 
 




function wptheme_showHelpWindow(wpsDocUrl){var newWindow = window.open(wpsDocUrl+'/help/index.html','PortalHelpWindow','resizable=yes,scrollbars=yes,menubar=no,toolbar=yes,status=no,width=800px,height=600px,screenX=10px,screenY=10px,top=10px,left=10px');newWindow.focus();return  false;}
/*
	Copyright (c) 2004-2009, The Dojo Foundation All Rights Reserved.
	Available via Academic Free License >= 2.1 OR the modified BSD license.
	see: http://dojotoolkit.org/license for details
*/

/*
	This is a compiled version of Dojo, built for deployment and not for
	development. To get an editable version, please visit:

		http://dojotoolkit.org

	for documentation and information on getting the source.
*/

(function(){var _1=null;if((_1||(typeof djConfig!="undefined"&&djConfig.scopeMap))&&(typeof window!="undefined")){var _2="",_3="",_4="",_5={},_6={};_1=_1||djConfig.scopeMap;for(var i=0;i<_1.length;i++){var _8=_1[i];_2+="var "+_8[0]+" = {}; "+_8[1]+" = "+_8[0]+";"+_8[1]+"._scopeName = '"+_8[1]+"';";_3+=(i==0?"":",")+_8[0];_4+=(i==0?"":",")+_8[1];_5[_8[0]]=_8[1];_6[_8[1]]=_8[0];}eval(_2+"dojo._scopeArgs = ["+_4+"];");dojo._scopePrefixArgs=_3;dojo._scopePrefix="(function("+_3+"){";dojo._scopeSuffix="})("+_4+")";dojo._scopeMap=_5;dojo._scopeMapRev=_6;}(function(){if(typeof this["loadFirebugConsole"]=="function"){this["loadFirebugConsole"]();}else{if(this["navigator"]){if(/3[\.0-9]+.*Safari/i.test(navigator.appVersion)&&this["console"]){this.console={_c:this.console,log:function(s){this._c.log(s);},info:function(s){this._c.info(s);},error:function(s){this._c.error(s);},warn:function(s){this._c.warn(s);}};}}this.console=this.console||{};var cn=["assert","count","debug","dir","dirxml","error","group","groupEnd","info","profile","profileEnd","time","timeEnd","trace","warn","log"];var i=0,tn;while((tn=cn[i++])){if(!console[tn]){(function(){var tcn=tn+"";console[tcn]=("log" in console)?function(){var a=Array.apply({},arguments);a.unshift(tcn+":");console["log"](a.join(" "));}:function(){};})();}}}if(typeof dojo=="undefined"){this.dojo={_scopeName:"dojo",_scopePrefix:"",_scopePrefixArgs:"",_scopeSuffix:"",_scopeMap:{},_scopeMapRev:{}};}var d=dojo;if(typeof dijit=="undefined"){this.dijit={_scopeName:"dijit"};}if(typeof dojox=="undefined"){this.dojox={_scopeName:"dojox"};}if(!d._scopeArgs){d._scopeArgs=[dojo,dijit,dojox];}d.global=this;d.config={isDebug:false,debugAtAllCosts:false};if(typeof djConfig!="undefined"){for(var opt in djConfig){d.config[opt]=djConfig[opt];}}dojo.locale=d.config.locale;var rev="$Rev: 18832 $".match(/\d+/);dojo.version={major:1,minor:3,patch:2,flag:"_IBM",revision:rev?+rev[0]:NaN,toString:function(){with(d.version){return major+"."+minor+"."+patch+flag+" ("+revision+")";}}};if(typeof OpenAjax!="undefined"){OpenAjax.hub.registerLibrary(dojo._scopeName,"http://dojotoolkit.org",d.version.toString());}var _15={};dojo._mixin=function(obj,_17){for(var x in _17){if(_15[x]===undefined||_15[x]!=_17[x]){obj[x]=_17[x];}}if(d.isIE&&_17){var p=_17.toString;if(typeof p=="function"&&p!=obj.toString&&p!=_15.toString&&p!="\nfunction toString() {\n    [native code]\n}\n"){obj.toString=_17.toString;}}return obj;};dojo.mixin=function(obj,_1b){if(!obj){obj={};}for(var i=1,l=arguments.length;i<l;i++){d._mixin(obj,arguments[i]);}return obj;};dojo._getProp=function(_1e,_1f,_20){var obj=_20||d.global;for(var i=0,p;obj&&(p=_1e[i]);i++){if(i==0&&this._scopeMap[p]){p=this._scopeMap[p];}obj=(p in obj?obj[p]:(_1f?obj[p]={}:undefined));}return obj;};dojo.setObject=function(_24,_25,_26){var _27=_24.split("."),p=_27.pop(),obj=d._getProp(_27,true,_26);return obj&&p?(obj[p]=_25):undefined;};dojo.getObject=function(_2a,_2b,_2c){return d._getProp(_2a.split("."),_2b,_2c);};dojo.exists=function(_2d,obj){return !!d.getObject(_2d,false,obj);};dojo["eval"]=function(_2f){return d.global.eval?d.global.eval(_2f):eval(_2f);};d.deprecated=d.experimental=function(){};})();(function(){var d=dojo;d.mixin(d,{_loadedModules:{},_inFlightCount:0,_hasResource:{},_modulePrefixes:{dojo:{name:"dojo",value:"."},doh:{name:"doh",value:"../util/doh"},tests:{name:"tests",value:"tests"}},_moduleHasPrefix:function(_31){var mp=this._modulePrefixes;return !!(mp[_31]&&mp[_31].value);},_getModulePrefix:function(_33){var mp=this._modulePrefixes;if(this._moduleHasPrefix(_33)){return mp[_33].value;}return _33;},_loadedUrls:[],_postLoad:false,_loaders:[],_unloaders:[],_loadNotifying:false});dojo._loadPath=function(_35,_36,cb){var uri=((_35.charAt(0)=="/"||_35.match(/^\w+:/))?"":this.baseUrl)+_35;try{return !_36?this._loadUri(uri,cb):this._loadUriAndCheck(uri,_36,cb);}catch(e){console.error(e);return false;}};dojo._loadUri=function(uri,cb){if(d._loadedUrls[uri]){return true;}d._inFlightCount++;var _3b=d._getText(uri,true);if(_3b){d._loadedUrls[uri]=true;d._loadedUrls.push(uri);if(cb){_3b="("+_3b+")";}else{_3b=d._scopePrefix+_3b+d._scopeSuffix;}if(d.isMoz){_3b+="\r\n//@ sourceURL="+uri;}var _3c=d["eval"](_3b);if(cb){cb(_3c);}}if(--d._inFlightCount==0&&d._postLoad&&d._loaders.length){setTimeout(function(){if(d._inFlightCount==0){d._callLoaded();}},0);}return !!_3b;};dojo._loadUriAndCheck=function(uri,_3e,cb){var ok=false;try{ok=this._loadUri(uri,cb);}catch(e){console.error("failed loading "+uri+" with error: "+e);}return !!(ok&&this._loadedModules[_3e]);};dojo.loaded=function(){this._loadNotifying=true;this._postLoad=true;var mll=d._loaders;this._loaders=[];for(var x=0;x<mll.length;x++){mll[x]();}this._loadNotifying=false;if(d._postLoad&&d._inFlightCount==0&&mll.length){d._callLoaded();}};dojo.unloaded=function(){var mll=d._unloaders;while(mll.length){(mll.pop())();}};d._onto=function(arr,obj,fn){if(!fn){arr.push(obj);}else{if(fn){var _47=(typeof fn=="string")?obj[fn]:fn;arr.push(function(){_47.call(obj);});}}};dojo.addOnLoad=function(obj,_49){d._onto(d._loaders,obj,_49);if(d._postLoad&&d._inFlightCount==0&&!d._loadNotifying){d._callLoaded();}};var dca=d.config.addOnLoad;if(dca){d.addOnLoad[(dca instanceof Array?"apply":"call")](d,dca);}dojo._modulesLoaded=function(){if(d._postLoad){return;}if(d._inFlightCount>0){console.warn("files still in flight!");return;}d._callLoaded();};dojo._callLoaded=function(){if(typeof setTimeout=="object"||(dojo.config.useXDomain&&d.isOpera)){if(dojo.isAIR){setTimeout(function(){dojo.loaded();},0);}else{setTimeout(dojo._scopeName+".loaded();",0);}}else{d.loaded();}};dojo._getModuleSymbols=function(_4b){var _4c=_4b.split(".");for(var i=_4c.length;i>0;i--){var _4e=_4c.slice(0,i).join(".");if((i==1)&&!this._moduleHasPrefix(_4e)){_4c[0]="../"+_4c[0];}else{var _4f=this._getModulePrefix(_4e);if(_4f!=_4e){_4c.splice(0,i,_4f);break;}}}return _4c;};dojo._global_omit_module_check=false;dojo.loadInit=function(_50){_50();};dojo._loadModule=dojo.require=function(_51,_52){_52=this._global_omit_module_check||_52;var _53=this._loadedModules[_51];if(_53){return _53;}var _54=this._getModuleSymbols(_51).join("/")+".js";var _55=(!_52)?_51:null;var ok=this._loadPath(_54,_55);if(!ok&&!_52){throw new Error("Could not load '"+_51+"'; last tried '"+_54+"'");}if(!_52&&!this._isXDomain){_53=this._loadedModules[_51];if(!_53){throw new Error("symbol '"+_51+"' is not defined after loading '"+_54+"'");}}return _53;};dojo.provide=function(_57){_57=_57+"";return (d._loadedModules[_57]=d.getObject(_57,true));};dojo.platformRequire=function(_58){var _59=_58.common||[];var _5a=_59.concat(_58[d._name]||_58["default"]||[]);for(var x=0;x<_5a.length;x++){var _5c=_5a[x];if(_5c.constructor==Array){d._loadModule.apply(d,_5c);}else{d._loadModule(_5c);}}};dojo.requireIf=function(_5d,_5e){if(_5d===true){var _5f=[];for(var i=1;i<arguments.length;i++){_5f.push(arguments[i]);}d.require.apply(d,_5f);}};dojo.requireAfterIf=d.requireIf;dojo.registerModulePath=function(_61,_62){d._modulePrefixes[_61]={name:_61,value:_62};};dojo.requireLocalization=function(_63,_64,_65,_66){d.require("dojo.i18n");d.i18n._requireLocalization.apply(d.hostenv,arguments);};var ore=new RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$");var ire=new RegExp("^((([^\\[:]+):)?([^@]+)@)?(\\[([^\\]]+)\\]|([^\\[:]*))(:([0-9]+))?$");dojo._Url=function(){var n=null;var _a=arguments;var uri=[_a[0]];for(var i=1;i<_a.length;i++){if(!_a[i]){continue;}var _6d=new d._Url(_a[i]+"");var _6e=new d._Url(uri[0]+"");if(_6d.path==""&&!_6d.scheme&&!_6d.authority&&!_6d.query){if(_6d.fragment!=n){_6e.fragment=_6d.fragment;}_6d=_6e;}else{if(!_6d.scheme){_6d.scheme=_6e.scheme;if(!_6d.authority){_6d.authority=_6e.authority;if(_6d.path.charAt(0)!="/"){var _6f=_6e.path.substring(0,_6e.path.lastIndexOf("/")+1)+_6d.path;var _70=_6f.split("/");for(var j=0;j<_70.length;j++){if(_70[j]=="."){if(j==_70.length-1){_70[j]="";}else{_70.splice(j,1);j--;}}else{if(j>0&&!(j==1&&_70[0]=="")&&_70[j]==".."&&_70[j-1]!=".."){if(j==(_70.length-1)){_70.splice(j,1);_70[j-1]="";}else{_70.splice(j-1,2);j-=2;}}}}_6d.path=_70.join("/");}}}}uri=[];if(_6d.scheme){uri.push(_6d.scheme,":");}if(_6d.authority){uri.push("//",_6d.authority);}uri.push(_6d.path);if(_6d.query){uri.push("?",_6d.query);}if(_6d.fragment){uri.push("#",_6d.fragment);}}this.uri=uri.join("");var r=this.uri.match(ore);this.scheme=r[2]||(r[1]?"":n);this.authority=r[4]||(r[3]?"":n);this.path=r[5];this.query=r[7]||(r[6]?"":n);this.fragment=r[9]||(r[8]?"":n);if(this.authority!=n){r=this.authority.match(ire);this.user=r[3]||n;this.password=r[4]||n;this.host=r[6]||r[7];this.port=r[9]||n;}};dojo._Url.prototype.toString=function(){return this.uri;};dojo.moduleUrl=function(_73,url){var loc=d._getModuleSymbols(_73).join("/");if(!loc){return null;}if(loc.lastIndexOf("/")!=loc.length-1){loc+="/";}var _76=loc.indexOf(":");if(loc.charAt(0)!="/"&&(_76==-1||_76>loc.indexOf("/"))){loc=d.baseUrl+loc;}return new d._Url(loc,url);};})();if(typeof window!="undefined"){dojo.isBrowser=true;dojo._name="browser";(function(){var d=dojo;if(document&&document.getElementsByTagName){var _78=document.getElementsByTagName("script");var _79=/dojo(\.xd)?\.js(\W|$)/i;for(var i=0;i<_78.length;i++){var src=_78[i].getAttribute("src");if(!src){continue;}var m=src.match(_79);if(m){if(!d.config.baseUrl){d.config.baseUrl=src.substring(0,m.index);}var cfg=_78[i].getAttribute("djConfig");if(cfg){var _7e=eval("({ "+cfg+" })");for(var x in _7e){dojo.config[x]=_7e[x];}}break;}}}d.baseUrl=d.config.baseUrl;var n=navigator;var dua=n.userAgent,dav=n.appVersion,tv=parseFloat(dav);if(dua.indexOf("Opera")>=0){d.isOpera=tv;}if(dua.indexOf("AdobeAIR")>=0){d.isAIR=1;}d.isKhtml=(dav.indexOf("Konqueror")>=0)?tv:0;d.isWebKit=parseFloat(dua.split("WebKit/")[1])||undefined;d.isChrome=parseFloat(dua.split("Chrome/")[1])||undefined;var _84=Math.max(dav.indexOf("WebKit"),dav.indexOf("Safari"),0);if(_84&&!dojo.isChrome){d.isSafari=parseFloat(dav.split("Version/")[1]);if(!d.isSafari||parseFloat(dav.substr(_84+7))<=419.3){d.isSafari=2;}}if(dua.indexOf("Gecko")>=0&&!d.isKhtml&&!d.isWebKit){d.isMozilla=d.isMoz=tv;}if(d.isMoz){d.isFF=parseFloat(dua.split("Firefox/")[1]||dua.split("Minefield/")[1]||dua.split("Shiretoko/")[1])||undefined;}if(document.all&&!d.isOpera){d.isIE=parseFloat(dav.split("MSIE ")[1])||undefined;if(d.isIE>=8&&document.documentMode!=5){d.isIE=document.documentMode;}}if(dojo.isIE&&window.location.protocol==="file:"){dojo.config.ieForceActiveXXhr=true;}var cm=document.compatMode;d.isQuirks=cm=="BackCompat"||cm=="QuirksMode"||d.isIE<6;d.locale=dojo.config.locale||(d.isIE?n.userLanguage:n.language).toLowerCase();d._XMLHTTP_PROGIDS=["Msxml2.XMLHTTP","Microsoft.XMLHTTP","Msxml2.XMLHTTP.4.0"];d._xhrObj=function(){var _86,_87;if(!dojo.isIE||!dojo.config.ieForceActiveXXhr){try{_86=new XMLHttpRequest();}catch(e){}}if(!_86){for(var i=0;i<3;++i){var _89=d._XMLHTTP_PROGIDS[i];try{_86=new ActiveXObject(_89);}catch(e){_87=e;}if(_86){d._XMLHTTP_PROGIDS=[_89];break;}}}if(!_86){throw new Error("XMLHTTP not available: "+_87);}return _86;};d._isDocumentOk=function(_8a){var _8b=_8a.status||0;return (_8b>=200&&_8b<300)||_8b==304||_8b==1223||(!_8b&&(location.protocol=="file:"||location.protocol=="chrome:"));};var _8c=window.location+"";var _8d=document.getElementsByTagName("base");var _8e=(_8d&&_8d.length>0);d._getText=function(uri,_90){var _91=this._xhrObj();if(!_8e&&dojo._Url){uri=(new dojo._Url(_8c,uri)).toString();}if(d.config.cacheBust){uri+="";uri+=(uri.indexOf("?")==-1?"?":"&")+String(d.config.cacheBust).replace(/\W+/g,"");}_91.open("GET",uri,false);try{_91.send(null);if(!d._isDocumentOk(_91)){var err=Error("Unable to load "+uri+" status:"+_91.status);err.status=_91.status;err.responseText=_91.responseText;throw err;}}catch(e){if(_90){return null;}throw e;}return _91.responseText;};var _w=window;var _94=function(_95,fp){var _97=_w[_95]||function(){};_w[_95]=function(){fp.apply(_w,arguments);_97.apply(_w,arguments);};};d._windowUnloaders=[];d.windowUnloaded=function(){var mll=d._windowUnloaders;while(mll.length){(mll.pop())();}};var _99=0;d.addOnWindowUnload=function(obj,_9b){d._onto(d._windowUnloaders,obj,_9b);if(!_99){_99=1;_94("onunload",d.windowUnloaded);}};var _9c=0;d.addOnUnload=function(obj,_9e){d._onto(d._unloaders,obj,_9e);if(!_9c){_9c=1;_94("onbeforeunload",dojo.unloaded);}};})();dojo._initFired=false;dojo._loadInit=function(e){dojo._initFired=true;var _a0=e&&e.type?e.type.toLowerCase():"load";if(arguments.callee.initialized||(_a0!="domcontentloaded"&&_a0!="load")){return;}arguments.callee.initialized=true;if("_khtmlTimer" in dojo){clearInterval(dojo._khtmlTimer);delete dojo._khtmlTimer;}if(dojo._inFlightCount==0){dojo._modulesLoaded();}};if(!dojo.config.afterOnLoad){if(document.addEventListener){if(dojo.isWebKit>525||dojo.isOpera||dojo.isFF>=3||(dojo.isMoz&&dojo.config.enableMozDomContentLoaded===true)){document.addEventListener("DOMContentLoaded",dojo._loadInit,null);}window.addEventListener("load",dojo._loadInit,null);}if(dojo.isAIR){window.addEventListener("load",dojo._loadInit,null);}else{if((dojo.isWebKit<525)||dojo.isKhtml){dojo._khtmlTimer=setInterval(function(){if(/loaded|complete/.test(document.readyState)){dojo._loadInit();}},10);}}}if(dojo.isIE){if(!dojo.config.afterOnLoad){document.write("<scr"+"ipt defer src=\"//:\" "+"onreadystatechange=\"if(this.readyState=='complete'){"+dojo._scopeName+"._loadInit();}\">"+"</scr"+"ipt>");}try{document.namespaces.add("v","urn:schemas-microsoft-com:vml");document.createStyleSheet().addRule("v\\:*","behavior:url(#default#VML);  display:inline-block");}catch(e){}}}(function(){var mp=dojo.config["modulePaths"];if(mp){for(var _a2 in mp){dojo.registerModulePath(_a2,mp[_a2]);}}})();if(dojo.config.isDebug){dojo.require("dojo._firebug.firebug");}if(dojo.config.debugAtAllCosts){dojo.config.useXDomain=true;dojo.require("dojo._base._loader.loader_xd");dojo.require("dojo._base._loader.loader_debug");}if(!dojo._hasResource["dojo._base.lang"]){dojo._hasResource["dojo._base.lang"]=true;dojo.provide("dojo._base.lang");dojo.isString=function(it){return !!arguments.length&&it!=null&&(typeof it=="string"||it instanceof String);};dojo.isArray=function(it){return it&&(it instanceof Array||typeof it=="array");};dojo.isFunction=(function(){var _a5=function(it){var t=typeof it;return it&&(t=="function"||it instanceof Function);};return dojo.isSafari?function(it){if(typeof it=="function"&&it=="[object NodeList]"){return false;}return _a5(it);}:_a5;})();dojo.isObject=function(it){return it!==undefined&&(it===null||typeof it=="object"||dojo.isArray(it)||dojo.isFunction(it));};dojo.isArrayLike=function(it){var d=dojo;return it&&it!==undefined&&!d.isString(it)&&!d.isFunction(it)&&!(it.tagName&&it.tagName.toLowerCase()=="form")&&(d.isArray(it)||isFinite(it.length));};dojo.isAlien=function(it){return it&&!dojo.isFunction(it)&&/\{\s*\[native code\]\s*\}/.test(String(it));};dojo.extend=function(_ad,_ae){for(var i=1,l=arguments.length;i<l;i++){dojo._mixin(_ad.prototype,arguments[i]);}return _ad;};dojo._hitchArgs=function(_b1,_b2){var pre=dojo._toArray(arguments,2);var _b4=dojo.isString(_b2);return function(){var _b5=dojo._toArray(arguments);var f=_b4?(_b1||dojo.global)[_b2]:_b2;return f&&f.apply(_b1||this,pre.concat(_b5));};};dojo.hitch=function(_b7,_b8){if(arguments.length>2){return dojo._hitchArgs.apply(dojo,arguments);}if(!_b8){_b8=_b7;_b7=null;}if(dojo.isString(_b8)){_b7=_b7||dojo.global;if(!_b7[_b8]){throw (["dojo.hitch: scope[\"",_b8,"\"] is null (scope=\"",_b7,"\")"].join(""));}return function(){return _b7[_b8].apply(_b7,arguments||[]);};}return !_b7?_b8:function(){return _b8.apply(_b7,arguments||[]);};};dojo.delegate=dojo._delegate=(function(){function TMP(){};return function(obj,_ba){TMP.prototype=obj;var tmp=new TMP();if(_ba){dojo._mixin(tmp,_ba);}return tmp;};})();(function(){var _bc=function(obj,_be,_bf){return (_bf||[]).concat(Array.prototype.slice.call(obj,_be||0));};var _c0=function(obj,_c2,_c3){var arr=_c3||[];for(var x=_c2||0;x<obj.length;x++){arr.push(obj[x]);}return arr;};dojo._toArray=dojo.isIE?function(obj){return ((obj.item)?_c0:_bc).apply(this,arguments);}:_bc;})();dojo.partial=function(_c7){var arr=[null];return dojo.hitch.apply(dojo,arr.concat(dojo._toArray(arguments)));};dojo.clone=function(o){if(!o){return o;}if(dojo.isArray(o)){var r=[];for(var i=0;i<o.length;++i){r.push(dojo.clone(o[i]));}return r;}if(!dojo.isObject(o)){return o;}if(o.nodeType&&o.cloneNode){return o.cloneNode(true);}if(o instanceof Date){return new Date(o.getTime());}r=new o.constructor();for(i in o){if(!(i in r)||r[i]!=o[i]){r[i]=dojo.clone(o[i]);}}return r;};dojo.trim=String.prototype.trim?function(str){return str.trim();}:function(str){return str.replace(/^\s\s*/,"").replace(/\s\s*$/,"");};}if(!dojo._hasResource["dojo._base.declare"]){dojo._hasResource["dojo._base.declare"]=true;dojo.provide("dojo._base.declare");dojo.declare=function(_ce,_cf,_d0){var dd=arguments.callee,_d2;if(dojo.isArray(_cf)){_d2=_cf;_cf=_d2.shift();}if(_d2){dojo.forEach(_d2,function(m,i){if(!m){throw (_ce+": mixin #"+i+" is null");}_cf=dd._delegate(_cf,m);});}var _d5=dd._delegate(_cf);_d0=_d0||{};_d5.extend(_d0);dojo.extend(_d5,{declaredClass:_ce,_constructor:_d0.constructor});_d5.prototype.constructor=_d5;return dojo.setObject(_ce,_d5);};dojo.mixin(dojo.declare,{_delegate:function(_d6,_d7){var bp=(_d6||0).prototype,mp=(_d7||0).prototype,dd=dojo.declare;var _db=dd._makeCtor();dojo.mixin(_db,{superclass:bp,mixin:mp,extend:dd._extend});if(_d6){_db.prototype=dojo._delegate(bp);}dojo.extend(_db,dd._core,mp||0,{_constructor:null,preamble:null});_db.prototype.constructor=_db;_db.prototype.declaredClass=(bp||0).declaredClass+"_"+(mp||0).declaredClass;return _db;},_extend:function(_dc){var i,fn;for(i in _dc){if(dojo.isFunction(fn=_dc[i])&&!0[i]){fn.nom=i;fn.ctor=this;}}dojo.extend(this,_dc);},_makeCtor:function(){return function(){this._construct(arguments);};},_core:{_construct:function(_df){var c=_df.callee,s=c.superclass,ct=s&&s.constructor,m=c.mixin,mct=m&&m.constructor,a=_df,ii,fn;if(a[0]){if(((fn=a[0].preamble))){a=fn.apply(this,a)||a;}}if((fn=c.prototype.preamble)){a=fn.apply(this,a)||a;}if(ct&&ct.apply){ct.apply(this,a);}if(mct&&mct.apply){mct.apply(this,a);}if((ii=c.prototype._constructor)){ii.apply(this,_df);}if(this.constructor.prototype==c.prototype&&(ct=this.postscript)){ct.apply(this,_df);}},_findMixin:function(_e8){var c=this.constructor,p,m;while(c){p=c.superclass;m=c.mixin;if(m==_e8||(m instanceof _e8.constructor)){return p;}if(m&&m._findMixin&&(m=m._findMixin(_e8))){return m;}c=p&&p.constructor;}},_findMethod:function(_ec,_ed,_ee,has){var p=_ee,c,m,f;do{c=p.constructor;m=c.mixin;if(m&&(m=this._findMethod(_ec,_ed,m,has))){return m;}if((f=p[_ec])&&(has==(f==_ed))){return p;}p=c.superclass;}while(p);return !has&&(p=this._findMixin(_ee))&&this._findMethod(_ec,_ed,p,has);},inherited:function(_f4,_f5,_f6){var a=arguments;if(!dojo.isString(a[0])){_f6=_f5;_f5=_f4;_f4=_f5.callee.nom;}a=_f6||_f5;var c=_f5.callee,p=this.constructor.prototype,fn,mp;if(this[_f4]!=c||p[_f4]==c){mp=(c.ctor||0).superclass||this._findMethod(_f4,c,p,true);if(!mp){throw (this.declaredClass+": inherited method \""+_f4+"\" mismatch");}p=this._findMethod(_f4,c,mp,false);}fn=p&&p[_f4];if(!fn){throw (mp.declaredClass+": inherited method \""+_f4+"\" not found");}return fn.apply(this,a);}}});}if(!dojo._hasResource["dojo._base.connect"]){dojo._hasResource["dojo._base.connect"]=true;dojo.provide("dojo._base.connect");dojo._listener={getDispatcher:function(){return function(){var ap=Array.prototype,c=arguments.callee,ls=c._listeners,t=c.target;var r=t&&t.apply(this,arguments);var lls;lls=[].concat(ls);for(var i in lls){if(!(i in ap)){lls[i].apply(this,arguments);}}return r;};},add:function(_103,_104,_105){_103=_103||dojo.global;var f=_103[_104];if(!f||!f._listeners){var d=dojo._listener.getDispatcher();d.target=f;d._listeners=[];f=_103[_104]=d;}return f._listeners.push(_105);},remove:function(_108,_109,_10a){var f=(_108||dojo.global)[_109];if(f&&f._listeners&&_10a--){delete f._listeners[_10a];}}};dojo.connect=function(obj,_10d,_10e,_10f,_110){var a=arguments,args=[],i=0;args.push(dojo.isString(a[0])?null:a[i++],a[i++]);var a1=a[i+1];args.push(dojo.isString(a1)||dojo.isFunction(a1)?a[i++]:null,a[i++]);for(var l=a.length;i<l;i++){args.push(a[i]);}return dojo._connect.apply(this,args);};dojo._connect=function(obj,_116,_117,_118){var l=dojo._listener,h=l.add(obj,_116,dojo.hitch(_117,_118));return [obj,_116,h,l];};dojo.disconnect=function(_11b){if(_11b&&_11b[0]!==undefined){dojo._disconnect.apply(this,_11b);delete _11b[0];}};dojo._disconnect=function(obj,_11d,_11e,_11f){_11f.remove(obj,_11d,_11e);};dojo._topics={};dojo.subscribe=function(_120,_121,_122){return [_120,dojo._listener.add(dojo._topics,_120,dojo.hitch(_121,_122))];};dojo.unsubscribe=function(_123){if(_123){dojo._listener.remove(dojo._topics,_123[0],_123[1]);}};dojo.publish=function(_124,args){var f=dojo._topics[_124];if(f){f.apply(this,args||[]);}};dojo.connectPublisher=function(_127,obj,_129){var pf=function(){dojo.publish(_127,arguments);};return (_129)?dojo.connect(obj,_129,pf):dojo.connect(obj,pf);};}if(!dojo._hasResource["dojo._base.Deferred"]){dojo._hasResource["dojo._base.Deferred"]=true;dojo.provide("dojo._base.Deferred");dojo.Deferred=function(_12b){this.chain=[];this.id=this._nextId();this.fired=-1;this.paused=0;this.results=[null,null];this.canceller=_12b;this.silentlyCancelled=false;};dojo.extend(dojo.Deferred,{_nextId:(function(){var n=1;return function(){return n++;};})(),cancel:function(){var err;if(this.fired==-1){if(this.canceller){err=this.canceller(this);}else{this.silentlyCancelled=true;}if(this.fired==-1){if(!(err instanceof Error)){var res=err;var msg="Deferred Cancelled";if(err&&err.toString){msg+=": "+err.toString();}err=new Error(msg);err.dojoType="cancel";err.cancelResult=res;}this.errback(err);}}else{if((this.fired==0)&&(this.results[0] instanceof dojo.Deferred)){this.results[0].cancel();}}},_resback:function(res){this.fired=((res instanceof Error)?1:0);this.results[this.fired]=res;this._fire();},_check:function(){if(this.fired!=-1){if(!this.silentlyCancelled){throw new Error("already called!");}this.silentlyCancelled=false;return;}},callback:function(res){this._check();this._resback(res);},errback:function(res){this._check();if(!(res instanceof Error)){res=new Error(res);}this._resback(res);},addBoth:function(cb,cbfn){var _135=dojo.hitch.apply(dojo,arguments);return this.addCallbacks(_135,_135);},addCallback:function(cb,cbfn){return this.addCallbacks(dojo.hitch.apply(dojo,arguments));},addErrback:function(cb,cbfn){return this.addCallbacks(null,dojo.hitch.apply(dojo,arguments));},addCallbacks:function(cb,eb){this.chain.push([cb,eb]);if(this.fired>=0){this._fire();}return this;},_fire:function(){var _13c=this.chain;var _13d=this.fired;var res=this.results[_13d];var self=this;var cb=null;while((_13c.length>0)&&(this.paused==0)){var f=_13c.shift()[_13d];if(!f){continue;}var func=function(){var ret=f(res);if(typeof ret!="undefined"){res=ret;}_13d=((res instanceof Error)?1:0);if(res instanceof dojo.Deferred){cb=function(res){self._resback(res);self.paused--;if((self.paused==0)&&(self.fired>=0)){self._fire();}};this.paused++;}};if(dojo.config.debugAtAllCosts){func.call(this);}else{try{func.call(this);}catch(err){_13d=1;res=err;}}}this.fired=_13d;this.results[_13d]=res;if((cb)&&(this.paused)){res.addBoth(cb);}}});}if(!dojo._hasResource["dojo._base.json"]){dojo._hasResource["dojo._base.json"]=true;dojo.provide("dojo._base.json");dojo.fromJson=function(json){return eval("("+json+")");};dojo._escapeString=function(str){return ("\""+str.replace(/(["\\])/g,"\\$1")+"\"").replace(/[\f]/g,"\\f").replace(/[\b]/g,"\\b").replace(/[\n]/g,"\\n").replace(/[\t]/g,"\\t").replace(/[\r]/g,"\\r");};dojo.toJsonIndentStr="\t";dojo.toJson=function(it,_148,_149){if(it===undefined){return "undefined";}var _14a=typeof it;if(_14a=="number"||_14a=="boolean"){return it+"";}if(it===null){return "null";}if(dojo.isString(it)){return dojo._escapeString(it);}var _14b=arguments.callee;var _14c;_149=_149||"";var _14d=_148?_149+dojo.toJsonIndentStr:"";var tf=it.__json__||it.json;if(dojo.isFunction(tf)){_14c=tf.call(it);if(it!==_14c){return _14b(_14c,_148,_14d);}}if(it.nodeType&&it.cloneNode){throw new Error("Can't serialize DOM nodes");}var sep=_148?" ":"";var _150=_148?"\n":"";if(dojo.isArray(it)){var res=dojo.map(it,function(obj){var val=_14b(obj,_148,_14d);if(typeof val!="string"){val="undefined";}return _150+_14d+val;});return "["+res.join(","+sep)+_150+_149+"]";}if(_14a=="function"){return null;}var _154=[],key;for(key in it){var _156,val;if(typeof key=="number"){_156="\""+key+"\"";}else{if(typeof key=="string"){_156=dojo._escapeString(key);}else{continue;}}val=_14b(it[key],_148,_14d);if(typeof val!="string"){continue;}_154.push(_150+_14d+_156+":"+sep+val);}return "{"+_154.join(","+sep)+_150+_149+"}";};}if(!dojo._hasResource["dojo._base.array"]){dojo._hasResource["dojo._base.array"]=true;dojo.provide("dojo._base.array");(function(){var _158=function(arr,obj,cb){return [dojo.isString(arr)?arr.split(""):arr,obj||dojo.global,dojo.isString(cb)?new Function("item","index","array",cb):cb];};dojo.mixin(dojo,{indexOf:function(_15c,_15d,_15e,_15f){var step=1,end=_15c.length||0,i=0;if(_15f){i=end-1;step=end=-1;}if(_15e!=undefined){i=_15e;}if((_15f&&i>end)||i<end){for(;i!=end;i+=step){if(_15c[i]==_15d){return i;}}}return -1;},lastIndexOf:function(_162,_163,_164){return dojo.indexOf(_162,_163,_164,true);},forEach:function(arr,_166,_167){if(!arr||!arr.length){return;}var _p=_158(arr,_167,_166);arr=_p[0];for(var i=0,l=arr.length;i<l;++i){_p[2].call(_p[1],arr[i],i,arr);}},_everyOrSome:function(_16b,arr,_16d,_16e){var _p=_158(arr,_16e,_16d);arr=_p[0];for(var i=0,l=arr.length;i<l;++i){var _172=!!_p[2].call(_p[1],arr[i],i,arr);if(_16b^_172){return _172;}}return _16b;},every:function(arr,_174,_175){return dojo._everyOrSome(true,arr,_174,_175);},some:function(arr,_177,_178){return dojo._everyOrSome(false,arr,_177,_178);},map:function(arr,_17a,_17b){var _p=_158(arr,_17b,_17a);arr=_p[0];var _17d=(arguments[3]?(new arguments[3]()):[]);for(var i=0,l=arr.length;i<l;++i){_17d.push(_p[2].call(_p[1],arr[i],i,arr));}return _17d;},filter:function(arr,_181,_182){var _p=_158(arr,_182,_181);arr=_p[0];var _184=[];for(var i=0,l=arr.length;i<l;++i){if(_p[2].call(_p[1],arr[i],i,arr)){_184.push(arr[i]);}}return _184;}});})();}if(!dojo._hasResource["dojo._base.Color"]){dojo._hasResource["dojo._base.Color"]=true;dojo.provide("dojo._base.Color");(function(){var d=dojo;dojo.Color=function(_188){if(_188){this.setColor(_188);}};dojo.Color.named={black:[0,0,0],silver:[192,192,192],gray:[128,128,128],white:[255,255,255],maroon:[128,0,0],red:[255,0,0],purple:[128,0,128],fuchsia:[255,0,255],green:[0,128,0],lime:[0,255,0],olive:[128,128,0],yellow:[255,255,0],navy:[0,0,128],blue:[0,0,255],teal:[0,128,128],aqua:[0,255,255]};dojo.extend(dojo.Color,{r:255,g:255,b:255,a:1,_set:function(r,g,b,a){var t=this;t.r=r;t.g=g;t.b=b;t.a=a;},setColor:function(_18e){if(d.isString(_18e)){d.colorFromString(_18e,this);}else{if(d.isArray(_18e)){d.colorFromArray(_18e,this);}else{this._set(_18e.r,_18e.g,_18e.b,_18e.a);if(!(_18e instanceof d.Color)){this.sanitize();}}}return this;},sanitize:function(){return this;},toRgb:function(){var t=this;return [t.r,t.g,t.b];},toRgba:function(){var t=this;return [t.r,t.g,t.b,t.a];},toHex:function(){var arr=d.map(["r","g","b"],function(x){var s=this[x].toString(16);return s.length<2?"0"+s:s;},this);return "#"+arr.join("");},toCss:function(_194){var t=this,rgb=t.r+", "+t.g+", "+t.b;return (_194?"rgba("+rgb+", "+t.a:"rgb("+rgb)+")";},toString:function(){return this.toCss(true);}});dojo.blendColors=function(_197,end,_199,obj){var t=obj||new d.Color();d.forEach(["r","g","b","a"],function(x){t[x]=_197[x]+(end[x]-_197[x])*_199;if(x!="a"){t[x]=Math.round(t[x]);}});return t.sanitize();};dojo.colorFromRgb=function(_19d,obj){var m=_19d.toLowerCase().match(/^rgba?\(([\s\.,0-9]+)\)/);return m&&dojo.colorFromArray(m[1].split(/\s*,\s*/),obj);};dojo.colorFromHex=function(_1a0,obj){var t=obj||new d.Color(),bits=(_1a0.length==4)?4:8,mask=(1<<bits)-1;_1a0=Number("0x"+_1a0.substr(1));if(isNaN(_1a0)){return null;}d.forEach(["b","g","r"],function(x){var c=_1a0&mask;_1a0>>=bits;t[x]=bits==4?17*c:c;});t.a=1;return t;};dojo.colorFromArray=function(a,obj){var t=obj||new d.Color();t._set(Number(a[0]),Number(a[1]),Number(a[2]),Number(a[3]));if(isNaN(t.a)){t.a=1;}return t.sanitize();};dojo.colorFromString=function(str,obj){var a=d.Color.named[str];return a&&d.colorFromArray(a,obj)||d.colorFromRgb(str,obj)||d.colorFromHex(str,obj);};})();}if(!dojo._hasResource["dojo._base"]){dojo._hasResource["dojo._base"]=true;dojo.provide("dojo._base");}if(!dojo._hasResource["dojo._base.window"]){dojo._hasResource["dojo._base.window"]=true;dojo.provide("dojo._base.window");dojo.doc=window["document"]||null;dojo.body=function(){return dojo.doc.body||dojo.doc.getElementsByTagName("body")[0];};dojo.setContext=function(_1ad,_1ae){dojo.global=_1ad;dojo.doc=_1ae;};dojo.withGlobal=function(_1af,_1b0,_1b1,_1b2){var _1b3=dojo.global;try{dojo.global=_1af;return dojo.withDoc.call(null,_1af.document,_1b0,_1b1,_1b2);}finally{dojo.global=_1b3;}};dojo.withDoc=function(_1b4,_1b5,_1b6,_1b7){var _1b8=dojo.doc,_1b9=dojo._bodyLtr;try{dojo.doc=_1b4;delete dojo._bodyLtr;if(_1b6&&dojo.isString(_1b5)){_1b5=_1b6[_1b5];}return _1b5.apply(_1b6,_1b7||[]);}finally{dojo.doc=_1b8;if(_1b9!==undefined){dojo._bodyLtr=_1b9;}}};}if(!dojo._hasResource["dojo._base.event"]){dojo._hasResource["dojo._base.event"]=true;dojo.provide("dojo._base.event");(function(){var del=(dojo._event_listener={add:function(node,name,fp){if(!node){return;}name=del._normalizeEventName(name);fp=del._fixCallback(name,fp);var _1be=name;if(!dojo.isIE&&(name=="mouseenter"||name=="mouseleave")){var ofp=fp;name=(name=="mouseenter")?"mouseover":"mouseout";fp=function(e){if(dojo.isFF<=2){try{e.relatedTarget.tagName;}catch(e2){return;}}if(!dojo.isDescendant(e.relatedTarget,node)){return ofp.call(this,e);}};}node.addEventListener(name,fp,false);return fp;},remove:function(node,_1c2,_1c3){if(node){_1c2=del._normalizeEventName(_1c2);if(!dojo.isIE&&(_1c2=="mouseenter"||_1c2=="mouseleave")){_1c2=(_1c2=="mouseenter")?"mouseover":"mouseout";}node.removeEventListener(_1c2,_1c3,false);}},_normalizeEventName:function(name){return name.slice(0,2)=="on"?name.slice(2):name;},_fixCallback:function(name,fp){return name!="keypress"?fp:function(e){return fp.call(this,del._fixEvent(e,this));};},_fixEvent:function(evt,_1c9){switch(evt.type){case "keypress":del._setKeyChar(evt);break;}return evt;},_setKeyChar:function(evt){evt.keyChar=evt.charCode?String.fromCharCode(evt.charCode):"";evt.charOrCode=evt.keyChar||evt.keyCode;},_punctMap:{106:42,111:47,186:59,187:43,188:44,189:45,190:46,191:47,192:96,219:91,220:92,221:93,222:39}});dojo.fixEvent=function(evt,_1cc){return del._fixEvent(evt,_1cc);};dojo.stopEvent=function(evt){evt.preventDefault();evt.stopPropagation();};var _1ce=dojo._listener;dojo._connect=function(obj,_1d0,_1d1,_1d2,_1d3){var _1d4=obj&&(obj.nodeType||obj.attachEvent||obj.addEventListener);var lid=_1d4?(_1d3?2:1):0,l=[dojo._listener,del,_1ce][lid];var h=l.add(obj,_1d0,dojo.hitch(_1d1,_1d2));return [obj,_1d0,h,lid];};dojo._disconnect=function(obj,_1d9,_1da,_1db){([dojo._listener,del,_1ce][_1db]).remove(obj,_1d9,_1da);};dojo.keys={BACKSPACE:8,TAB:9,CLEAR:12,ENTER:13,SHIFT:16,CTRL:17,ALT:18,PAUSE:19,CAPS_LOCK:20,ESCAPE:27,SPACE:32,PAGE_UP:33,PAGE_DOWN:34,END:35,HOME:36,LEFT_ARROW:37,UP_ARROW:38,RIGHT_ARROW:39,DOWN_ARROW:40,INSERT:45,DELETE:46,HELP:47,LEFT_WINDOW:91,RIGHT_WINDOW:92,SELECT:93,NUMPAD_0:96,NUMPAD_1:97,NUMPAD_2:98,NUMPAD_3:99,NUMPAD_4:100,NUMPAD_5:101,NUMPAD_6:102,NUMPAD_7:103,NUMPAD_8:104,NUMPAD_9:105,NUMPAD_MULTIPLY:106,NUMPAD_PLUS:107,NUMPAD_ENTER:108,NUMPAD_MINUS:109,NUMPAD_PERIOD:110,NUMPAD_DIVIDE:111,F1:112,F2:113,F3:114,F4:115,F5:116,F6:117,F7:118,F8:119,F9:120,F10:121,F11:122,F12:123,F13:124,F14:125,F15:126,NUM_LOCK:144,SCROLL_LOCK:145};if(dojo.isIE){var _1dc=function(e,code){try{return (e.keyCode=code);}catch(e){return 0;}};var iel=dojo._listener;var _1e0=(dojo._ieListenersName="_"+dojo._scopeName+"_listeners");if(!dojo.config._allow_leaks){_1ce=iel=dojo._ie_listener={handlers:[],add:function(_1e1,_1e2,_1e3){_1e1=_1e1||dojo.global;var f=_1e1[_1e2];if(!f||!f[_1e0]){var d=dojo._getIeDispatcher();d.target=f&&(ieh.push(f)-1);d[_1e0]=[];f=_1e1[_1e2]=d;}return f[_1e0].push(ieh.push(_1e3)-1);},remove:function(_1e7,_1e8,_1e9){var f=(_1e7||dojo.global)[_1e8],l=f&&f[_1e0];if(f&&l&&_1e9--){delete ieh[l[_1e9]];delete l[_1e9];}}};var ieh=iel.handlers;}dojo.mixin(del,{add:function(node,_1ed,fp){if(!node){return;}_1ed=del._normalizeEventName(_1ed);if(_1ed=="onkeypress"){var kd=node.onkeydown;if(!kd||!kd[_1e0]||!kd._stealthKeydownHandle){var h=del.add(node,"onkeydown",del._stealthKeyDown);kd=node.onkeydown;kd._stealthKeydownHandle=h;kd._stealthKeydownRefs=1;}else{kd._stealthKeydownRefs++;}}return iel.add(node,_1ed,del._fixCallback(fp));},remove:function(node,_1f2,_1f3){_1f2=del._normalizeEventName(_1f2);iel.remove(node,_1f2,_1f3);if(_1f2=="onkeypress"){var kd=node.onkeydown;if(--kd._stealthKeydownRefs<=0){iel.remove(node,"onkeydown",kd._stealthKeydownHandle);delete kd._stealthKeydownHandle;}}},_normalizeEventName:function(_1f5){return _1f5.slice(0,2)!="on"?"on"+_1f5:_1f5;},_nop:function(){},_fixEvent:function(evt,_1f7){if(!evt){var w=_1f7&&(_1f7.ownerDocument||_1f7.document||_1f7).parentWindow||window;evt=w.event;}if(!evt){return (evt);}evt.target=evt.srcElement;evt.currentTarget=(_1f7||evt.srcElement);evt.layerX=evt.offsetX;evt.layerY=evt.offsetY;var se=evt.srcElement,doc=(se&&se.ownerDocument)||document;var _1fb=((dojo.isIE<6)||(doc["compatMode"]=="BackCompat"))?doc.body:doc.documentElement;var _1fc=dojo._getIeDocumentElementOffset();evt.pageX=evt.clientX+dojo._fixIeBiDiScrollLeft(_1fb.scrollLeft||0)-_1fc.x;evt.pageY=evt.clientY+(_1fb.scrollTop||0)-_1fc.y;if(evt.type=="mouseover"){evt.relatedTarget=evt.fromElement;}if(evt.type=="mouseout"){evt.relatedTarget=evt.toElement;}evt.stopPropagation=del._stopPropagation;evt.preventDefault=del._preventDefault;return del._fixKeys(evt);},_fixKeys:function(evt){switch(evt.type){case "keypress":var c=("charCode" in evt?evt.charCode:evt.keyCode);if(c==10){c=0;evt.keyCode=13;}else{if(c==13||c==27){c=0;}else{if(c==3){c=99;}}}evt.charCode=c;del._setKeyChar(evt);break;}return evt;},_stealthKeyDown:function(evt){var kp=evt.currentTarget.onkeypress;if(!kp||!kp[_1e0]){return;}var k=evt.keyCode;var _202=k!=13&&k!=32&&k!=27&&(k<48||k>90)&&(k<96||k>111)&&(k<186||k>192)&&(k<219||k>222);if(_202||evt.ctrlKey){var c=_202?0:k;if(evt.ctrlKey){if(k==3||k==13){return;}else{if(c>95&&c<106){c-=48;}else{if((!evt.shiftKey)&&(c>=65&&c<=90)){c+=32;}else{c=del._punctMap[c]||c;}}}}var faux=del._synthesizeEvent(evt,{type:"keypress",faux:true,charCode:c});kp.call(evt.currentTarget,faux);evt.cancelBubble=faux.cancelBubble;evt.returnValue=faux.returnValue;_1dc(evt,faux.keyCode);}},_stopPropagation:function(){this.cancelBubble=true;},_preventDefault:function(){this.bubbledKeyCode=this.keyCode;if(this.ctrlKey){_1dc(this,0);}this.returnValue=false;}});dojo.stopEvent=function(evt){evt=evt||window.event;del._stopPropagation.call(evt);del._preventDefault.call(evt);};}del._synthesizeEvent=function(evt,_207){var faux=dojo.mixin({},evt,_207);del._setKeyChar(faux);faux.preventDefault=function(){evt.preventDefault();};faux.stopPropagation=function(){evt.stopPropagation();};return faux;};if(dojo.isOpera){dojo.mixin(del,{_fixEvent:function(evt,_20a){switch(evt.type){case "keypress":var c=evt.which;if(c==3){c=99;}c=c<41&&!evt.shiftKey?0:c;if(evt.ctrlKey&&!evt.shiftKey&&c>=65&&c<=90){c+=32;}return del._synthesizeEvent(evt,{charCode:c});}return evt;}});}if(dojo.isWebKit){del._add=del.add;del._remove=del.remove;dojo.mixin(del,{add:function(node,_20d,fp){if(!node){return;}var _20f=del._add(node,_20d,fp);if(del._normalizeEventName(_20d)=="keypress"){_20f._stealthKeyDownHandle=del._add(node,"keydown",function(evt){var k=evt.keyCode;var _212=k!=13&&k!=32&&k!=27&&(k<48||k>90)&&(k<96||k>111)&&(k<186||k>192)&&(k<219||k>222);if(_212||evt.ctrlKey){var c=_212?0:k;if(evt.ctrlKey){if(k==3||k==13){return;}else{if(c>95&&c<106){c-=48;}else{if(!evt.shiftKey&&c>=65&&c<=90){c+=32;}else{c=del._punctMap[c]||c;}}}}var faux=del._synthesizeEvent(evt,{type:"keypress",faux:true,charCode:c});fp.call(evt.currentTarget,faux);}});}return _20f;},remove:function(node,_216,_217){if(node){if(_217._stealthKeyDownHandle){del._remove(node,"keydown",_217._stealthKeyDownHandle);}del._remove(node,_216,_217);}},_fixEvent:function(evt,_219){switch(evt.type){case "keypress":if(evt.faux){return evt;}var c=evt.charCode;c=c>=32?c:0;return del._synthesizeEvent(evt,{charCode:c,faux:true});}return evt;}});}})();if(dojo.isIE){dojo._ieDispatcher=function(args,_21c){var ap=Array.prototype,h=dojo._ie_listener.handlers,c=args.callee,ls=c[dojo._ieListenersName],t=h[c.target];var r=t&&t.apply(_21c,args);var lls=[].concat(ls);for(var i in lls){var f=h[lls[i]];if(!(i in ap)&&f){f.apply(_21c,args);}}return r;};dojo._getIeDispatcher=function(){return new Function(dojo._scopeName+"._ieDispatcher(arguments, this)");};dojo._event_listener._fixCallback=function(fp){var f=dojo._event_listener._fixEvent;return function(e){return fp.call(this,f(e,this));};};}}if(!dojo._hasResource["dojo._base.html"]){dojo._hasResource["dojo._base.html"]=true;dojo.provide("dojo._base.html");try{document.execCommand("BackgroundImageCache",false,true);}catch(e){}if(dojo.isIE||dojo.isOpera){dojo.byId=function(id,doc){if(dojo.isString(id)){var _d=doc||dojo.doc;var te=_d.getElementById(id);if(te&&(te.attributes.id.value==id||te.id==id)){return te;}else{var eles=_d.all[id];if(!eles||eles.nodeName){eles=[eles];}var i=0;while((te=eles[i++])){if((te.attributes&&te.attributes.id&&te.attributes.id.value==id)||te.id==id){return te;}}}}else{return id;}};}else{dojo.byId=function(id,doc){return dojo.isString(id)?(doc||dojo.doc).getElementById(id):id;};}(function(){var d=dojo;var _232=null;d.addOnWindowUnload(function(){_232=null;});dojo._destroyElement=dojo.destroy=function(node){node=d.byId(node);try{if(!_232||_232.ownerDocument!=node.ownerDocument){_232=node.ownerDocument.createElement("div");}_232.appendChild(node.parentNode?node.parentNode.removeChild(node):node);_232.innerHTML="";}catch(e){}};dojo.isDescendant=function(node,_235){try{node=d.byId(node);_235=d.byId(_235);while(node){if(node===_235){return true;}node=node.parentNode;}}catch(e){}return false;};dojo.setSelectable=function(node,_237){node=d.byId(node);if(d.isMozilla){node.style.MozUserSelect=_237?"":"none";}else{if(d.isKhtml||d.isWebKit){node.style.KhtmlUserSelect=_237?"auto":"none";}else{if(d.isIE){var v=(node.unselectable=_237?"":"on");d.query("*",node).forEach("item.unselectable = '"+v+"'");}}}};var _239=function(node,ref){var _23c=ref.parentNode;if(_23c){_23c.insertBefore(node,ref);}};var _23d=function(node,ref){var _240=ref.parentNode;if(_240){if(_240.lastChild==ref){_240.appendChild(node);}else{_240.insertBefore(node,ref.nextSibling);}}};dojo.place=function(node,_242,_243){_242=d.byId(_242);if(d.isString(node)){node=node.charAt(0)=="<"?d._toDom(node,_242.ownerDocument):d.byId(node);}if(typeof _243=="number"){var cn=_242.childNodes;if(!cn.length||cn.length<=_243){_242.appendChild(node);}else{_239(node,cn[_243<0?0:_243]);}}else{switch(_243){case "before":_239(node,_242);break;case "after":_23d(node,_242);break;case "replace":_242.parentNode.replaceChild(node,_242);break;case "only":d.empty(_242);_242.appendChild(node);break;case "first":if(_242.firstChild){_239(node,_242.firstChild);break;}default:_242.appendChild(node);}}return node;};dojo.boxModel="content-box";if(d.isIE){var _dcm=document.compatMode;d.boxModel=_dcm=="BackCompat"||_dcm=="QuirksMode"||d.isIE<6?"border-box":"content-box";}var gcs;if(d.isWebKit){gcs=function(node){var s;if(node.nodeType==1){var dv=node.ownerDocument.defaultView;s=dv.getComputedStyle(node,null);if(!s&&node.style){node.style.display="";s=dv.getComputedStyle(node,null);}}return s||{};};}else{if(d.isIE){gcs=function(node){return node.nodeType==1?node.currentStyle:{};};}else{gcs=function(node){return node.nodeType==1?node.ownerDocument.defaultView.getComputedStyle(node,null):{};};}}dojo.getComputedStyle=gcs;if(!d.isIE){d._toPixelValue=function(_24c,_24d){return parseFloat(_24d)||0;};}else{d._toPixelValue=function(_24e,_24f){if(!_24f){return 0;}if(_24f=="medium"){return 4;}if(_24f.slice&&_24f.slice(-2)=="px"){return parseFloat(_24f);}with(_24e){var _250=style.left;var _251=runtimeStyle.left;runtimeStyle.left=currentStyle.left;try{style.left=_24f;_24f=style.pixelLeft;}catch(e){_24f=0;}style.left=_250;runtimeStyle.left=_251;}return _24f;};}var px=d._toPixelValue;var astr="DXImageTransform.Microsoft.Alpha";var af=function(n,f){try{return n.filters.item(astr);}catch(e){return f?{}:null;}};dojo._getOpacity=d.isIE?function(node){try{return af(node).Opacity/100;}catch(e){return 1;}}:function(node){return gcs(node).opacity;};dojo._setOpacity=d.isIE?function(node,_25a){var ov=_25a*100;node.style.zoom=1;af(node,1).Enabled=!(_25a==1);if(!af(node)){node.style.filter+=" progid:"+astr+"(Opacity="+ov+")";}else{af(node,1).Opacity=ov;}if(node.nodeName.toLowerCase()=="tr"){d.query("> td",node).forEach(function(i){d._setOpacity(i,_25a);});}return _25a;}:function(node,_25e){return node.style.opacity=_25e;};var _25f={left:true,top:true};var _260=/margin|padding|width|height|max|min|offset/;var _261=function(node,type,_264){type=type.toLowerCase();if(d.isIE){if(_264=="auto"){if(type=="height"){return node.offsetHeight;}if(type=="width"){return node.offsetWidth;}}if(type=="fontweight"){switch(_264){case 700:return "bold";case 400:default:return "normal";}}}if(!(type in _25f)){_25f[type]=_260.test(type);}return _25f[type]?px(node,_264):_264;};var _265=d.isIE?"styleFloat":"cssFloat",_266={"cssFloat":_265,"styleFloat":_265,"float":_265};dojo.style=function(node,_268,_269){var n=d.byId(node),args=arguments.length,op=(_268=="opacity");_268=_266[_268]||_268;if(args==3){return op?d._setOpacity(n,_269):n.style[_268]=_269;}if(args==2&&op){return d._getOpacity(n);}var s=gcs(n);if(args==2&&!d.isString(_268)){for(var x in _268){d.style(node,x,_268[x]);}return s;}return (args==1)?s:_261(n,_268,s[_268]||n.style[_268]);};dojo._getPadExtents=function(n,_270){var s=_270||gcs(n),l=px(n,s.paddingLeft),t=px(n,s.paddingTop);return {l:l,t:t,w:l+px(n,s.paddingRight),h:t+px(n,s.paddingBottom)};};dojo._getBorderExtents=function(n,_275){var ne="none",s=_275||gcs(n),bl=(s.borderLeftStyle!=ne?px(n,s.borderLeftWidth):0),bt=(s.borderTopStyle!=ne?px(n,s.borderTopWidth):0);return {l:bl,t:bt,w:bl+(s.borderRightStyle!=ne?px(n,s.borderRightWidth):0),h:bt+(s.borderBottomStyle!=ne?px(n,s.borderBottomWidth):0)};};dojo._getPadBorderExtents=function(n,_27b){var s=_27b||gcs(n),p=d._getPadExtents(n,s),b=d._getBorderExtents(n,s);return {l:p.l+b.l,t:p.t+b.t,w:p.w+b.w,h:p.h+b.h};};dojo._getMarginExtents=function(n,_280){var s=_280||gcs(n),l=px(n,s.marginLeft),t=px(n,s.marginTop),r=px(n,s.marginRight),b=px(n,s.marginBottom);if(d.isWebKit&&(s.position!="absolute")){r=l;}return {l:l,t:t,w:l+r,h:t+b};};dojo._getMarginBox=function(node,_287){var s=_287||gcs(node),me=d._getMarginExtents(node,s);var l=node.offsetLeft-me.l,t=node.offsetTop-me.t,p=node.parentNode;if(d.isMoz){var sl=parseFloat(s.left),st=parseFloat(s.top);if(!isNaN(sl)&&!isNaN(st)){l=sl,t=st;}else{if(p&&p.style){var pcs=gcs(p);if(pcs.overflow!="visible"){var be=d._getBorderExtents(p,pcs);l+=be.l,t+=be.t;}}}}else{if(d.isOpera||(d.isIE>7&&!d.isQuirks)){if(p){be=d._getBorderExtents(p);l-=be.l;t-=be.t;}}}return {l:l,t:t,w:node.offsetWidth+me.w,h:node.offsetHeight+me.h};};dojo._getContentBox=function(node,_292){var s=_292||gcs(node),pe=d._getPadExtents(node,s),be=d._getBorderExtents(node,s),w=node.clientWidth,h;if(!w){w=node.offsetWidth,h=node.offsetHeight;}else{h=node.clientHeight,be.w=be.h=0;}if(d.isOpera){pe.l+=be.l;pe.t+=be.t;}return {l:pe.l,t:pe.t,w:w-pe.w-be.w,h:h-pe.h-be.h};};dojo._getBorderBox=function(node,_299){var s=_299||gcs(node),pe=d._getPadExtents(node,s),cb=d._getContentBox(node,s);return {l:cb.l-pe.l,t:cb.t-pe.t,w:cb.w+pe.w,h:cb.h+pe.h};};dojo._setBox=function(node,l,t,w,h,u){u=u||"px";var s=node.style;if(!isNaN(l)){s.left=l+u;}if(!isNaN(t)){s.top=t+u;}if(w>=0){s.width=w+u;}if(h>=0){s.height=h+u;}};dojo._isButtonTag=function(node){return node.tagName=="BUTTON"||node.tagName=="INPUT"&&node.getAttribute("type").toUpperCase()=="BUTTON";};dojo._usesBorderBox=function(node){var n=node.tagName;return d.boxModel=="border-box"||n=="TABLE"||d._isButtonTag(node);};dojo._setContentSize=function(node,_2a8,_2a9,_2aa){if(d._usesBorderBox(node)){var pb=d._getPadBorderExtents(node,_2aa);if(_2a8>=0){_2a8+=pb.w;}if(_2a9>=0){_2a9+=pb.h;}}d._setBox(node,NaN,NaN,_2a8,_2a9);};dojo._setMarginBox=function(node,_2ad,_2ae,_2af,_2b0,_2b1){var s=_2b1||gcs(node),bb=d._usesBorderBox(node),pb=bb?_2b5:d._getPadBorderExtents(node,s);if(d.isWebKit){if(d._isButtonTag(node)){var ns=node.style;if(_2af>=0&&!ns.width){ns.width="4px";}if(_2b0>=0&&!ns.height){ns.height="4px";}}}var mb=d._getMarginExtents(node,s);if(_2af>=0){_2af=Math.max(_2af-pb.w-mb.w,0);}if(_2b0>=0){_2b0=Math.max(_2b0-pb.h-mb.h,0);}d._setBox(node,_2ad,_2ae,_2af,_2b0);};var _2b5={l:0,t:0,w:0,h:0};dojo.marginBox=function(node,box){var n=d.byId(node),s=gcs(n),b=box;return !b?d._getMarginBox(n,s):d._setMarginBox(n,b.l,b.t,b.w,b.h,s);};dojo.contentBox=function(node,box){var n=d.byId(node),s=gcs(n),b=box;return !b?d._getContentBox(n,s):d._setContentSize(n,b.w,b.h,s);};var _2c2=function(node,prop){if(!(node=(node||0).parentNode)){return 0;}var val,_2c6=0,_b=d.body();while(node&&node.style){if(gcs(node).position=="fixed"){return 0;}val=node[prop];if(val){_2c6+=val-0;if(node==_b){break;}}node=node.parentNode;}return _2c6;};dojo._docScroll=function(){var _b=d.body(),_w=d.global,de=d.doc.documentElement;return {y:(_w.pageYOffset||de.scrollTop||_b.scrollTop||0),x:(_w.pageXOffset||d._fixIeBiDiScrollLeft(de.scrollLeft)||_b.scrollLeft||0)};};dojo._isBodyLtr=function(){return "_bodyLtr" in d?d._bodyLtr:d._bodyLtr=(d.body().dir||d.doc.documentElement.dir||"ltr").toLowerCase()=="ltr";};dojo._getIeDocumentElementOffset=function(){var de=d.doc.documentElement;if(d.isIE<7){return {x:d._isBodyLtr()||window.parent==window?de.clientLeft:de.offsetWidth-de.clientWidth-de.clientLeft,y:de.clientTop};}else{if(d.isIE<8){return {x:de.getBoundingClientRect().left,y:de.getBoundingClientRect().top};}else{return {x:0,y:0};}}};dojo._fixIeBiDiScrollLeft=function(_2cc){var dd=d.doc;if(d.isIE<8&&!d._isBodyLtr()){var de=dd.compatMode=="BackCompat"?dd.body:dd.documentElement;return _2cc+de.clientWidth-de.scrollWidth;}return _2cc;};dojo._abs=function(node,_2d0){var db=d.body(),dh=d.body().parentNode,ret;if(node["getBoundingClientRect"]){var _2d4=node.getBoundingClientRect();ret={x:_2d4.left,y:_2d4.top};if(d.isFF>=3){var cs=gcs(dh);ret.x-=px(dh,cs.marginLeft)+px(dh,cs.borderLeftWidth);ret.y-=px(dh,cs.marginTop)+px(dh,cs.borderTopWidth);}if(d.isIE){var _2d6=d._getIeDocumentElementOffset();ret.x-=_2d6.x+(d.isQuirks?db.clientLeft:0);ret.y-=_2d6.y+(d.isQuirks?db.clientTop:0);}}else{ret={x:0,y:0};if(node["offsetParent"]){ret.x-=_2c2(node,"scrollLeft");ret.y-=_2c2(node,"scrollTop");var _2d7=node;do{var n=_2d7.offsetLeft,t=_2d7.offsetTop;ret.x+=isNaN(n)?0:n;ret.y+=isNaN(t)?0:t;cs=gcs(_2d7);if(_2d7!=node){if(d.isFF){ret.x+=2*px(_2d7,cs.borderLeftWidth);ret.y+=2*px(_2d7,cs.borderTopWidth);}else{ret.x+=px(_2d7,cs.borderLeftWidth);ret.y+=px(_2d7,cs.borderTopWidth);}}if(d.isFF&&cs.position=="static"){var _2da=_2d7.parentNode;while(_2da!=_2d7.offsetParent){var pcs=gcs(_2da);if(pcs.position=="static"){ret.x+=px(_2d7,pcs.borderLeftWidth);ret.y+=px(_2d7,pcs.borderTopWidth);}_2da=_2da.parentNode;}}_2d7=_2d7.offsetParent;}while((_2d7!=dh)&&_2d7);}else{if(node.x&&node.y){ret.x+=isNaN(node.x)?0:node.x;ret.y+=isNaN(node.y)?0:node.y;}}}if(_2d0){var _2dc=d._docScroll();ret.x+=_2dc.x;ret.y+=_2dc.y;}return ret;};dojo.coords=function(node,_2de){var n=d.byId(node),s=gcs(n),mb=d._getMarginBox(n,s);var abs=d._abs(n,_2de);mb.x=abs.x;mb.y=abs.y;return mb;};var _2e3=d.isIE<8;var _2e4=function(name){switch(name.toLowerCase()){case "tabindex":return _2e3?"tabIndex":"tabindex";case "readonly":return "readOnly";case "class":return "className";case "for":case "htmlfor":return _2e3?"htmlFor":"for";default:return name;}};var _2e6={colspan:"colSpan",enctype:"enctype",frameborder:"frameborder",method:"method",rowspan:"rowSpan",scrolling:"scrolling",shape:"shape",span:"span",type:"type",valuetype:"valueType",classname:"className",innerhtml:"innerHTML"};dojo.hasAttr=function(node,name){node=d.byId(node);var _2e9=_2e4(name);_2e9=_2e9=="htmlFor"?"for":_2e9;var attr=node.getAttributeNode&&node.getAttributeNode(_2e9);return attr?attr.specified:false;};var _2eb={},_ctr=0,_2ed=dojo._scopeName+"attrid",_2ee={col:1,colgroup:1,table:1,tbody:1,tfoot:1,thead:1,tr:1,title:1};dojo.attr=function(node,name,_2f1){node=d.byId(node);var args=arguments.length;if(args==2&&!d.isString(name)){for(var x in name){d.attr(node,x,name[x]);}return;}name=_2e4(name);if(args==3){if(d.isFunction(_2f1)){var _2f4=d.attr(node,_2ed);if(!_2f4){_2f4=_ctr++;d.attr(node,_2ed,_2f4);}if(!_2eb[_2f4]){_2eb[_2f4]={};}var h=_2eb[_2f4][name];if(h){d.disconnect(h);}else{try{delete node[name];}catch(e){}}_2eb[_2f4][name]=d.connect(node,name,_2f1);}else{if(typeof _2f1=="boolean"){node[name]=_2f1;}else{if(name==="style"&&!d.isString(_2f1)){d.style(node,_2f1);}else{if(name=="className"){node.className=_2f1;}else{if(name==="innerHTML"){if(d.isIE&&node.tagName.toLowerCase() in _2ee){d.empty(node);node.appendChild(d._toDom(_2f1,node.ownerDocument));}else{node[name]=_2f1;}}else{node.setAttribute(name,_2f1);}}}}}}else{var prop=_2e6[name.toLowerCase()];if(prop){return node[prop];}var _2f7=node[name];return (typeof _2f7=="boolean"||typeof _2f7=="function")?_2f7:(d.hasAttr(node,name)?node.getAttribute(name):null);}};dojo.removeAttr=function(node,name){d.byId(node).removeAttribute(_2e4(name));};dojo.create=function(tag,_2fb,_2fc,pos){var doc=d.doc;if(_2fc){_2fc=d.byId(_2fc);doc=_2fc.ownerDocument;}if(d.isString(tag)){tag=doc.createElement(tag);}if(_2fb){d.attr(tag,_2fb);}if(_2fc){d.place(tag,_2fc,pos);}return tag;};d.empty=d.isIE?function(node){node=d.byId(node);for(var c;c=node.lastChild;){d.destroy(c);}}:function(node){d.byId(node).innerHTML="";};var _302={option:["select"],tbody:["table"],thead:["table"],tfoot:["table"],tr:["table","tbody"],td:["table","tbody","tr"],th:["table","thead","tr"],legend:["fieldset"],caption:["table"],colgroup:["table"],col:["table","colgroup"],li:["ul"]},_303=/<\s*([\w\:]+)/,_304={},_305=0,_306="__"+d._scopeName+"ToDomId";for(var _307 in _302){var tw=_302[_307];tw.pre=_307=="option"?"<select multiple=\"multiple\">":"<"+tw.join("><")+">";tw.post="</"+tw.reverse().join("></")+">";}d._toDom=function(frag,doc){doc=doc||d.doc;var _30b=doc[_306];if(!_30b){doc[_306]=_30b=++_305+"";_304[_30b]=doc.createElement("div");}frag+="";var _30c=frag.match(_303),tag=_30c?_30c[1].toLowerCase():"",_30e=_304[_30b],wrap,i,fc,df;if(_30c&&_302[tag]){wrap=_302[tag];_30e.innerHTML=wrap.pre+frag+wrap.post;for(i=wrap.length;i;--i){_30e=_30e.firstChild;}}else{_30e.innerHTML=frag;}if(_30e.childNodes.length==1){return _30e.removeChild(_30e.firstChild);}df=doc.createDocumentFragment();while(fc=_30e.firstChild){df.appendChild(fc);}return df;};var _312="className";dojo.hasClass=function(node,_314){return ((" "+d.byId(node)[_312]+" ").indexOf(" "+_314+" ")>=0);};dojo.addClass=function(node,_316){node=d.byId(node);var cls=node[_312];if((" "+cls+" ").indexOf(" "+_316+" ")<0){node[_312]=cls+(cls?" ":"")+_316;}};dojo.removeClass=function(node,_319){node=d.byId(node);var t=d.trim((" "+node[_312]+" ").replace(" "+_319+" "," "));if(node[_312]!=t){node[_312]=t;}};dojo.toggleClass=function(node,_31c,_31d){if(_31d===undefined){_31d=!d.hasClass(node,_31c);}d[_31d?"addClass":"removeClass"](node,_31c);};})();}if(!dojo._hasResource["dojo._base.NodeList"]){dojo._hasResource["dojo._base.NodeList"]=true;dojo.provide("dojo._base.NodeList");(function(){var d=dojo;var ap=Array.prototype,aps=ap.slice,apc=ap.concat;var tnl=function(a){a.constructor=d.NodeList;dojo._mixin(a,d.NodeList.prototype);return a;};var _324=function(f,a,o){a=[0].concat(aps.call(a,0));if(!a.sort){a=aps.call(a,0);}o=o||d.global;return function(node){a[0]=node;return f.apply(o,a);};};var _329=function(f,o){return function(){this.forEach(_324(f,arguments,o));return this;};};var _32c=function(f,o){return function(){return this.map(_324(f,arguments,o));};};var _32f=function(f,o){return function(){return this.filter(_324(f,arguments,o));};};var _332=function(f,g,o){return function(){var a=arguments,body=_324(f,a,o);if(g.call(o||d.global,a)){return this.map(body);}this.forEach(body);return this;};};var _338=function(a){return a.length==1&&d.isString(a[0]);};var _33a=function(node){var p=node.parentNode;if(p){p.removeChild(node);}};dojo.NodeList=function(){return tnl(Array.apply(null,arguments));};var nl=d.NodeList,nlp=nl.prototype;nl._wrap=tnl;nl._adaptAsMap=_32c;nl._adaptAsForEach=_329;nl._adaptAsFilter=_32f;nl._adaptWithCondition=_332;d.forEach(["slice","splice"],function(name){var f=ap[name];nlp[name]=function(){return tnl(f.apply(this,arguments));};});d.forEach(["indexOf","lastIndexOf","every","some"],function(name){var f=d[name];nlp[name]=function(){return f.apply(d,[this].concat(aps.call(arguments,0)));};});d.forEach(["attr","style"],function(name){nlp[name]=_332(d[name],_338);});d.forEach(["connect","addClass","removeClass","toggleClass","empty"],function(name){nlp[name]=_329(d[name]);});dojo.extend(dojo.NodeList,{concat:function(item){var t=d.isArray(this)?this:aps.call(this,0),m=d.map(arguments,function(a){return a&&!d.isArray(a)&&(a.constructor===NodeList||a.constructor==nl)?aps.call(a,0):a;});return tnl(apc.apply(t,m));},map:function(func,obj){return tnl(d.map(this,func,obj));},forEach:function(_34b,_34c){d.forEach(this,_34b,_34c);return this;},coords:_32c(d.coords),place:function(_34d,_34e){var item=d.query(_34d)[0];return this.forEach(function(node){d.place(node,item,_34e);});},orphan:function(_351){return (_351?d._filterQueryResult(this,_351):this).forEach(_33a);},adopt:function(_352,_353){return d.query(_352).place(this[0],_353);},query:function(_354){if(!_354){return this;}var ret=this.map(function(node){return d.query(_354,node).filter(function(_357){return _357!==undefined;});});return tnl(apc.apply([],ret));},filter:function(_358){var a=arguments,_35a=this,_35b=0;if(d.isString(_358)){_35a=d._filterQueryResult(this,a[0]);if(a.length==1){return _35a;}_35b=1;}return tnl(d.filter(_35a,a[_35b],a[_35b+1]));},addContent:function(_35c,_35d){var c=d.isString(_35c)?d._toDom(_35c,this[0]&&this[0].ownerDocument):_35c,i,l=this.length-1;for(i=0;i<l;++i){d.place(c.cloneNode(true),this[i],_35d);}if(l>=0){d.place(c,this[l],_35d);}return this;},instantiate:function(_360,_361){var c=d.isFunction(_360)?_360:d.getObject(_360);_361=_361||{};return this.forEach(function(node){new c(_361,node);});},at:function(){var t=new dojo.NodeList();d.forEach(arguments,function(i){if(this[i]){t.push(this[i]);}},this);return t;}});d.forEach(["blur","focus","change","click","error","keydown","keypress","keyup","load","mousedown","mouseenter","mouseleave","mousemove","mouseout","mouseover","mouseup","submit"],function(evt){var _oe="on"+evt;nlp[_oe]=function(a,b){return this.connect(_oe,a,b);};});})();}if(!dojo._hasResource["dojo._base.query"]){dojo._hasResource["dojo._base.query"]=true;if(typeof dojo!="undefined"){dojo.provide("dojo._base.query");}(function(d){var trim=d.trim;var each=d.forEach;var qlc=d._queryListCtor=d.NodeList;var _36e=d.isString;var _36f=function(){return d.doc;};var _370=((d.isWebKit||d.isMozilla)&&((_36f().compatMode)=="BackCompat"));var _371=!!_36f().firstChild["children"]?"children":"childNodes";var _372=">~+";var _373=false;var _374=function(){return true;};var _375=function(_376){if(_372.indexOf(_376.slice(-1))>=0){_376+=" * ";}else{_376+=" ";}var ts=function(s,e){return trim(_376.slice(s,e));};var _37a=[];var _37b=-1,_37c=-1,_37d=-1,_37e=-1,_37f=-1,inId=-1,_381=-1,lc="",cc="",_384;var x=0,ql=_376.length,_387=null,_cp=null;var _389=function(){if(_381>=0){var tv=(_381==x)?null:ts(_381,x);_387[(_372.indexOf(tv)<0)?"tag":"oper"]=tv;_381=-1;}};var _38b=function(){if(inId>=0){_387.id=ts(inId,x).replace(/\\/g,"");inId=-1;}};var _38c=function(){if(_37f>=0){_387.classes.push(ts(_37f+1,x).replace(/\\/g,""));_37f=-1;}};var _38d=function(){_38b();_389();_38c();};var _38e=function(){_38d();if(_37e>=0){_387.pseudos.push({name:ts(_37e+1,x)});}_387.loops=(_387.pseudos.length||_387.attrs.length||_387.classes.length);_387.oquery=_387.query=ts(_384,x);_387.otag=_387.tag=(_387["oper"])?null:(_387.tag||"*");if(_387.tag){_387.tag=_387.tag.toUpperCase();}if(_37a.length&&(_37a[_37a.length-1].oper)){_387.infixOper=_37a.pop();_387.query=_387.infixOper.query+" "+_387.query;}_37a.push(_387);_387=null;};for(;lc=cc,cc=_376.charAt(x),x<ql;x++){if(lc=="\\"){continue;}if(!_387){_384=x;_387={query:null,pseudos:[],attrs:[],classes:[],tag:null,oper:null,id:null,getTag:function(){return (_373)?this.otag:this.tag;}};_381=x;}if(_37b>=0){if(cc=="]"){if(!_cp.attr){_cp.attr=ts(_37b+1,x);}else{_cp.matchFor=ts((_37d||_37b+1),x);}var cmf=_cp.matchFor;if(cmf){if((cmf.charAt(0)=="\"")||(cmf.charAt(0)=="'")){_cp.matchFor=cmf.slice(1,-1);}}_387.attrs.push(_cp);_cp=null;_37b=_37d=-1;}else{if(cc=="="){var _390=("|~^$*".indexOf(lc)>=0)?lc:"";_cp.type=_390+cc;_cp.attr=ts(_37b+1,x-_390.length);_37d=x+1;}}}else{if(_37c>=0){if(cc==")"){if(_37e>=0){_cp.value=ts(_37c+1,x);}_37e=_37c=-1;}}else{if(cc=="#"){_38d();inId=x+1;}else{if(cc=="."){_38d();_37f=x;}else{if(cc==":"){_38d();_37e=x;}else{if(cc=="["){_38d();_37b=x;_cp={};}else{if(cc=="("){if(_37e>=0){_cp={name:ts(_37e+1,x),value:null};_387.pseudos.push(_cp);}_37c=x;}else{if((cc==" ")&&(lc!=cc)){_38e();}}}}}}}}}return _37a;};var _391=function(_392,_393){if(!_392){return _393;}if(!_393){return _392;}return function(){return _392.apply(window,arguments)&&_393.apply(window,arguments);};};var _394=function(i,arr){var r=arr||[];if(i){r.push(i);}return r;};var _398=function(n){return (1==n.nodeType);};var _39a="";var _39b=function(elem,attr){if(!elem){return _39a;}if(attr=="class"){return elem.className||_39a;}if(attr=="for"){return elem.htmlFor||_39a;}if(attr=="style"){return elem.style.cssText||_39a;}return (_373?elem.getAttribute(attr):elem.getAttribute(attr,2))||_39a;};var _39e={"*=":function(attr,_3a0){return function(elem){return (_39b(elem,attr).indexOf(_3a0)>=0);};},"^=":function(attr,_3a3){return function(elem){return (_39b(elem,attr).indexOf(_3a3)==0);};},"$=":function(attr,_3a6){var tval=" "+_3a6;return function(elem){var ea=" "+_39b(elem,attr);return (ea.lastIndexOf(_3a6)==(ea.length-_3a6.length));};},"~=":function(attr,_3ab){var tval=" "+_3ab+" ";return function(elem){var ea=" "+_39b(elem,attr)+" ";return (ea.indexOf(tval)>=0);};},"|=":function(attr,_3b0){var _3b1=" "+_3b0+"-";return function(elem){var ea=" "+_39b(elem,attr);return ((ea==_3b0)||(ea.indexOf(_3b1)==0));};},"=":function(attr,_3b5){return function(elem){return (_39b(elem,attr)==_3b5);};}};var _3b7=(typeof _36f().firstChild.nextElementSibling=="undefined");var _ns=!_3b7?"nextElementSibling":"nextSibling";var _ps=!_3b7?"previousElementSibling":"previousSibling";var _3ba=(_3b7?_398:_374);var _3bb=function(node){while(node=node[_ps]){if(_3ba(node)){return false;}}return true;};var _3bd=function(node){while(node=node[_ns]){if(_3ba(node)){return false;}}return true;};var _3bf=function(node){var root=node.parentNode;var i=0,tret=root[_371],ci=(node["_i"]||-1),cl=(root["_l"]||-1);if(!tret){return -1;}var l=tret.length;if(cl==l&&ci>=0&&cl>=0){return ci;}root["_l"]=l;ci=-1;for(var te=root["firstElementChild"]||root["firstChild"];te;te=te[_ns]){if(_3ba(te)){te["_i"]=++i;if(node===te){ci=i;}}}return ci;};var _3c8=function(elem){return !((_3bf(elem))%2);};var _3ca=function(elem){return ((_3bf(elem))%2);};var _3cc={"checked":function(name,_3ce){return function(elem){return !!d.attr(elem,"checked");};},"first-child":function(){return _3bb;},"last-child":function(){return _3bd;},"only-child":function(name,_3d1){return function(node){if(!_3bb(node)){return false;}if(!_3bd(node)){return false;}return true;};},"empty":function(name,_3d4){return function(elem){var cn=elem.childNodes;var cnl=elem.childNodes.length;for(var x=cnl-1;x>=0;x--){var nt=cn[x].nodeType;if((nt===1)||(nt==3)){return false;}}return true;};},"contains":function(name,_3db){var cz=_3db.charAt(0);if(cz=="\""||cz=="'"){_3db=_3db.slice(1,-1);}return function(elem){return (elem.innerHTML.indexOf(_3db)>=0);};},"not":function(name,_3df){var p=_375(_3df)[0];var _3e1={el:1};if(p.tag!="*"){_3e1.tag=1;}if(!p.classes.length){_3e1.classes=1;}var ntf=_3e3(p,_3e1);return function(elem){return (!ntf(elem));};},"nth-child":function(name,_3e6){var pi=parseInt;if(_3e6=="odd"){return _3ca;}else{if(_3e6=="even"){return _3c8;}}if(_3e6.indexOf("n")!=-1){var _3e8=_3e6.split("n",2);var pred=_3e8[0]?((_3e8[0]=="-")?-1:pi(_3e8[0])):1;var idx=_3e8[1]?pi(_3e8[1]):0;var lb=0,ub=-1;if(pred>0){if(idx<0){idx=(idx%pred)&&(pred+(idx%pred));}else{if(idx>0){if(idx>=pred){lb=idx-idx%pred;}idx=idx%pred;}}}else{if(pred<0){pred*=-1;if(idx>0){ub=idx;idx=idx%pred;}}}if(pred>0){return function(elem){var i=_3bf(elem);return (i>=lb)&&(ub<0||i<=ub)&&((i%pred)==idx);};}else{_3e6=idx;}}var _3ef=pi(_3e6);return function(elem){return (_3bf(elem)==_3ef);};}};var _3f1=(d.isIE)?function(cond){var clc=cond.toLowerCase();if(clc=="class"){cond="className";}return function(elem){return (_373?elem.getAttribute(cond):elem[cond]||elem[clc]);};}:function(cond){return function(elem){return (elem&&elem.getAttribute&&elem.hasAttribute(cond));};};var _3e3=function(_3f7,_3f8){if(!_3f7){return _374;}_3f8=_3f8||{};var ff=null;if(!("el" in _3f8)){ff=_391(ff,_398);}if(!("tag" in _3f8)){if(_3f7.tag!="*"){ff=_391(ff,function(elem){return (elem&&(elem.tagName==_3f7.getTag()));});}}if(!("classes" in _3f8)){each(_3f7.classes,function(_3fb,idx,arr){var re=new RegExp("(?:^|\\s)"+_3fb+"(?:\\s|$)");ff=_391(ff,function(elem){return re.test(elem.className);});ff.count=idx;});}if(!("pseudos" in _3f8)){each(_3f7.pseudos,function(_400){var pn=_400.name;if(_3cc[pn]){ff=_391(ff,_3cc[pn](pn,_400.value));}});}if(!("attrs" in _3f8)){each(_3f7.attrs,function(attr){var _403;var a=attr.attr;if(attr.type&&_39e[attr.type]){_403=_39e[attr.type](a,attr.matchFor);}else{if(a.length){_403=_3f1(a);}}if(_403){ff=_391(ff,_403);}});}if(!("id" in _3f8)){if(_3f7.id){ff=_391(ff,function(elem){return (!!elem&&(elem.id==_3f7.id));});}}if(!ff){if(!("default" in _3f8)){ff=_374;}}return ff;};var _406=function(_407){return function(node,ret,bag){while(node=node[_ns]){if(_3b7&&(!_398(node))){continue;}if((!bag||_40b(node,bag))&&_407(node)){ret.push(node);}break;}return ret;};};var _40c=function(_40d){return function(root,ret,bag){var te=root[_ns];while(te){if(_3ba(te)){if(bag&&!_40b(te,bag)){break;}if(_40d(te)){ret.push(te);}}te=te[_ns];}return ret;};};var _412=function(_413){_413=_413||_374;return function(root,ret,bag){var te,x=0,tret=root[_371];while(te=tret[x++]){if(_3ba(te)&&(!bag||_40b(te,bag))&&(_413(te,x))){ret.push(te);}}return ret;};};var _41a=function(node,root){var pn=node.parentNode;while(pn){if(pn==root){break;}pn=pn.parentNode;}return !!pn;};var _41e={};var _41f=function(_420){var _421=_41e[_420.query];if(_421){return _421;}var io=_420.infixOper;var oper=(io?io.oper:"");var _424=_3e3(_420,{el:1});var qt=_420.tag;var _426=("*"==qt);var ecs=_36f()["getElementsByClassName"];if(!oper){if(_420.id){_424=(!_420.loops&&_426)?_374:_3e3(_420,{el:1,id:1});_421=function(root,arr){var te=d.byId(_420.id,(root.ownerDocument||root));if(!te||!_424(te)){return;}if(9==root.nodeType){return _394(te,arr);}else{if(_41a(te,root)){return _394(te,arr);}}};}else{if(ecs&&/\{\s*\[native code\]\s*\}/.test(String(ecs))&&_420.classes.length&&!_370){_424=_3e3(_420,{el:1,classes:1,id:1});var _42b=_420.classes.join(" ");_421=function(root,arr,bag){var ret=_394(0,arr),te,x=0;var tret=root.getElementsByClassName(_42b);while((te=tret[x++])){if(_424(te,root)&&_40b(te,bag)){ret.push(te);}}return ret;};}else{if(!_426&&!_420.loops){_421=function(root,arr,bag){var ret=_394(0,arr),te,x=0;var tret=root.getElementsByTagName(_420.getTag());while((te=tret[x++])){if(_40b(te,bag)){ret.push(te);}}return ret;};}else{_424=_3e3(_420,{el:1,tag:1,id:1});_421=function(root,arr,bag){var ret=_394(0,arr),te,x=0;var tret=root.getElementsByTagName(_420.getTag());while((te=tret[x++])){if(_424(te,root)&&_40b(te,bag)){ret.push(te);}}return ret;};}}}}else{var _441={el:1};if(_426){_441.tag=1;}_424=_3e3(_420,_441);if("+"==oper){_421=_406(_424);}else{if("~"==oper){_421=_40c(_424);}else{if(">"==oper){_421=_412(_424);}}}}return _41e[_420.query]=_421;};var _442=function(root,_444){var _445=_394(root),qp,x,te,qpl=_444.length,bag,ret;for(var i=0;i<qpl;i++){ret=[];qp=_444[i];x=_445.length-1;if(x>0){bag={};ret.nozip=true;}var gef=_41f(qp);while(te=_445[x--]){gef(te,ret,bag);}if(!ret.length){break;}_445=ret;}return ret;};var _44e={},_44f={};var _450=function(_451){var _452=_375(trim(_451));if(_452.length==1){var tef=_41f(_452[0]);return function(root){var r=tef(root,new qlc());if(r){r.nozip=true;}return r;};}return function(root){return _442(root,_452);};};var nua=navigator.userAgent;var wk="WebKit/";var _459=(d.isWebKit&&(nua.indexOf(wk)>0)&&(parseFloat(nua.split(wk)[1])>528));var _45a=d.isIE?"commentStrip":"nozip";var qsa="querySelectorAll";var _45c=(!!_36f()[qsa]&&(!d.isSafari||(d.isSafari>3.1)||_459));var _45d=function(_45e,_45f){if(_45c){var _460=_44f[_45e];if(_460&&!_45f){return _460;}}var _461=_44e[_45e];if(_461){return _461;}var qcz=_45e.charAt(0);var _463=(-1==_45e.indexOf(" "));if((_45e.indexOf("#")>=0)&&(_463)){_45f=true;}var _464=(_45c&&(!_45f)&&(_372.indexOf(qcz)==-1)&&(!d.isIE||(_45e.indexOf(":")==-1))&&(!(_370&&(_45e.indexOf(".")>=0)))&&(_45e.indexOf(":contains")==-1)&&(_45e.indexOf("|=")==-1));if(_464){var tq=(_372.indexOf(_45e.charAt(_45e.length-1))>=0)?(_45e+" *"):_45e;return _44f[_45e]=function(root){try{if(!((9==root.nodeType)||_463)){throw "";}var r=root[qsa](tq);r[_45a]=true;return r;}catch(e){return _45d(_45e,true)(root);}};}else{var _468=_45e.split(/\s*,\s*/);return _44e[_45e]=((_468.length<2)?_450(_45e):function(root){var _46a=0,ret=[],tp;while((tp=_468[_46a++])){ret=ret.concat(_450(tp)(root));}return ret;});}};var _46d=0;var _46e=d.isIE?function(node){if(_373){return (node.getAttribute("_uid")||node.setAttribute("_uid",++_46d)||_46d);}else{return node.uniqueID;}}:function(node){return (node._uid||(node._uid=++_46d));};var _40b=function(node,bag){if(!bag){return 1;}var id=_46e(node);if(!bag[id]){return bag[id]=1;}return 0;};var _474="_zipIdx";var _zip=function(arr){if(arr&&arr.nozip){return (qlc._wrap)?qlc._wrap(arr):arr;}var ret=new qlc();if(!arr||!arr.length){return ret;}if(arr[0]){ret.push(arr[0]);}if(arr.length<2){return ret;}_46d++;if(d.isIE&&_373){var _478=_46d+"";arr[0].setAttribute(_474,_478);for(var x=1,te;te=arr[x];x++){if(arr[x].getAttribute(_474)!=_478){ret.push(te);}te.setAttribute(_474,_478);}}else{if(d.isIE&&arr.commentStrip){try{for(var x=1,te;te=arr[x];x++){if(_398(te)){ret.push(te);}}}catch(e){}}else{if(arr[0]){arr[0][_474]=_46d;}for(var x=1,te;te=arr[x];x++){if(arr[x][_474]!=_46d){ret.push(te);}te[_474]=_46d;}}}return ret;};d.query=function(_47b,root){qlc=d._queryListCtor;if(!_47b){return new qlc();}if(_47b.constructor==qlc){return _47b;}if(!_36e(_47b)){return new qlc(_47b);}if(_36e(root)){root=d.byId(root);if(!root){return new qlc();}}root=root||_36f();var od=root.ownerDocument||root.documentElement;_373=(root.contentType&&root.contentType=="application/xml")||(d.isOpera&&(root.doctype||od.toString()=="[object XMLDocument]"))||(!!od)&&(d.isIE?od.xml:(root.xmlVersion||od.xmlVersion));var r=_45d(_47b)(root);if(r&&r.nozip&&!qlc._wrap){return r;}return _zip(r);};d.query.pseudos=_3cc;d._filterQueryResult=function(_47f,_480){var _481=new d._queryListCtor();var _482=_3e3(_375(_480)[0]);for(var x=0,te;te=_47f[x];x++){if(_482(te)){_481.push(te);}}return _481;};})(this["queryPortability"]||this["acme"]||dojo);}if(!dojo._hasResource["dojo._base.xhr"]){dojo._hasResource["dojo._base.xhr"]=true;dojo.provide("dojo._base.xhr");(function(){var _d=dojo;function setValue(obj,name,_488){var val=obj[name];if(_d.isString(val)){obj[name]=[val,_488];}else{if(_d.isArray(val)){val.push(_488);}else{obj[name]=_488;}}};dojo.formToObject=function(_48a){var ret={};var _48c="file|submit|image|reset|button|";_d.forEach(dojo.byId(_48a).elements,function(item){var _in=item.name;var type=(item.type||"").toLowerCase();if(_in&&type&&_48c.indexOf(type)==-1&&!item.disabled){if(type=="radio"||type=="checkbox"){if(item.checked){setValue(ret,_in,item.value);}}else{if(item.multiple){ret[_in]=[];_d.query("option",item).forEach(function(opt){if(opt.selected){setValue(ret,_in,opt.value);}});}else{setValue(ret,_in,item.value);if(type=="image"){ret[_in+".x"]=ret[_in+".y"]=ret[_in].x=ret[_in].y=0;}}}}});return ret;};dojo.objectToQuery=function(map){var enc=encodeURIComponent;var _493=[];var _494={};for(var name in map){var _496=map[name];if(_496!=_494[name]){var _497=enc(name)+"=";if(_d.isArray(_496)){for(var i=0;i<_496.length;i++){_493.push(_497+enc(_496[i]));}}else{_493.push(_497+enc(_496));}}}return _493.join("&");};dojo.formToQuery=function(_499){return _d.objectToQuery(_d.formToObject(_499));};dojo.formToJson=function(_49a,_49b){return _d.toJson(_d.formToObject(_49a),_49b);};dojo.queryToObject=function(str){var ret={};var qp=str.split("&");var dec=decodeURIComponent;_d.forEach(qp,function(item){if(item.length){var _4a1=item.split("=");var name=dec(_4a1.shift());var val=dec(_4a1.join("="));if(_d.isString(ret[name])){ret[name]=[ret[name]];}if(_d.isArray(ret[name])){ret[name].push(val);}else{ret[name]=val;}}});return ret;};dojo._blockAsync=false;dojo._contentHandlers={text:function(xhr){return xhr.responseText;},json:function(xhr){return _d.fromJson(xhr.responseText||null);},"json-comment-filtered":function(xhr){if(!dojo.config.useCommentedJson){console.warn("Consider using the standard mimetype:application/json."+" json-commenting can introduce security issues. To"+" decrease the chances of hijacking, use the standard the 'json' handler and"+" prefix your json with: {}&&\n"+"Use djConfig.useCommentedJson=true to turn off this message.");}var _4a7=xhr.responseText;var _4a8=_4a7.indexOf("/*");var _4a9=_4a7.lastIndexOf("*/");if(_4a8==-1||_4a9==-1){throw new Error("JSON was not comment filtered");}return _d.fromJson(_4a7.substring(_4a8+2,_4a9));},javascript:function(xhr){return _d.eval(xhr.responseText);},xml:function(xhr){var _4ac=xhr.responseXML;if(_d.isIE&&(!_4ac||!_4ac.documentElement)){var ms=function(n){return "MSXML"+n+".DOMDocument";};var dp=["Microsoft.XMLDOM",ms(6),ms(4),ms(3),ms(2)];_d.some(dp,function(p){try{var dom=new ActiveXObject(p);dom.async=false;dom.loadXML(xhr.responseText);_4ac=dom;}catch(e){return false;}return true;});}return _4ac;}};dojo._contentHandlers["json-comment-optional"]=function(xhr){var _4b3=_d._contentHandlers;if(xhr.responseText&&xhr.responseText.indexOf("/*")!=-1){return _4b3["json-comment-filtered"](xhr);}else{return _4b3["json"](xhr);}};dojo._ioSetArgs=function(args,_4b5,_4b6,_4b7){var _4b8={args:args,url:args.url};var _4b9=null;if(args.form){var form=_d.byId(args.form);var _4bb=form.getAttributeNode("action");_4b8.url=_4b8.url||(_4bb?_4bb.value:null);_4b9=_d.formToObject(form);}var _4bc=[{}];if(_4b9){_4bc.push(_4b9);}if(args.content){_4bc.push(args.content);}if(args.preventCache){_4bc.push({"dojo.preventCache":new Date().valueOf()});}_4b8.query=_d.objectToQuery(_d.mixin.apply(null,_4bc));_4b8.handleAs=args.handleAs||"text";var d=new _d.Deferred(_4b5);d.addCallbacks(_4b6,function(_4be){return _4b7(_4be,d);});var ld=args.load;if(ld&&_d.isFunction(ld)){d.addCallback(function(_4c0){return ld.call(args,_4c0,_4b8);});}var err=args.error;if(err&&_d.isFunction(err)){d.addErrback(function(_4c2){return err.call(args,_4c2,_4b8);});}var _4c3=args.handle;if(_4c3&&_d.isFunction(_4c3)){d.addBoth(function(_4c4){return _4c3.call(args,_4c4,_4b8);});}d.ioArgs=_4b8;return d;};var _4c5=function(dfd){dfd.canceled=true;var xhr=dfd.ioArgs.xhr;var _at=typeof xhr.abort;if(_at=="function"||_at=="object"||_at=="unknown"){xhr.abort();}var err=dfd.ioArgs.error;if(!err){err=new Error("xhr cancelled");err.dojoType="cancel";}return err;};var _4ca=function(dfd){var ret=_d._contentHandlers[dfd.ioArgs.handleAs](dfd.ioArgs.xhr);return ret===undefined?null:ret;};var _4cd=function(_4ce,dfd){console.error(_4ce);return _4ce;};var _4d0=null;var _4d1=[];var _4d2=function(){var now=(new Date()).getTime();if(!_d._blockAsync){for(var i=0,tif;i<_4d1.length&&(tif=_4d1[i]);i++){var dfd=tif.dfd;var func=function(){if(!dfd||dfd.canceled||!tif.validCheck(dfd)){_4d1.splice(i--,1);}else{if(tif.ioCheck(dfd)){_4d1.splice(i--,1);tif.resHandle(dfd);}else{if(dfd.startTime){if(dfd.startTime+(dfd.ioArgs.args.timeout||0)<now){_4d1.splice(i--,1);var err=new Error("timeout exceeded");err.dojoType="timeout";dfd.errback(err);dfd.cancel();}}}}};if(dojo.config.debugAtAllCosts){func.call(this);}else{try{func.call(this);}catch(e){dfd.errback(e);}}}}if(!_4d1.length){clearInterval(_4d0);_4d0=null;return;}};dojo._ioCancelAll=function(){try{_d.forEach(_4d1,function(i){try{i.dfd.cancel();}catch(e){}});}catch(e){}};if(_d.isIE){_d.addOnWindowUnload(_d._ioCancelAll);}_d._ioWatch=function(dfd,_4db,_4dc,_4dd){var args=dfd.ioArgs.args;if(args.timeout){dfd.startTime=(new Date()).getTime();}_4d1.push({dfd:dfd,validCheck:_4db,ioCheck:_4dc,resHandle:_4dd});if(!_4d0){_4d0=setInterval(_4d2,50);}if(args.sync){_4d2();}};var _4df="application/x-www-form-urlencoded";var _4e0=function(dfd){return dfd.ioArgs.xhr.readyState;};var _4e2=function(dfd){return 4==dfd.ioArgs.xhr.readyState;};var _4e4=function(dfd){var xhr=dfd.ioArgs.xhr;if(_d._isDocumentOk(xhr)){dfd.callback(dfd);}else{var err=new Error("Unable to load "+dfd.ioArgs.url+" status:"+xhr.status);err.status=xhr.status;err.responseText=xhr.responseText;dfd.errback(err);}};dojo._ioAddQueryToUrl=function(_4e8){if(_4e8.query.length){_4e8.url+=(_4e8.url.indexOf("?")==-1?"?":"&")+_4e8.query;_4e8.query=null;}};dojo.xhr=function(_4e9,args,_4eb){var dfd=_d._ioSetArgs(args,_4c5,_4ca,_4cd);dfd.ioArgs.xhr=_d._xhrObj(dfd.ioArgs.args);if(_4eb){if("postData" in args){dfd.ioArgs.query=args.postData;}else{if("putData" in args){dfd.ioArgs.query=args.putData;}}}else{_d._ioAddQueryToUrl(dfd.ioArgs);}var _4ed=dfd.ioArgs;var xhr=_4ed.xhr;xhr.open(_4e9,_4ed.url,args.sync!==true,args.user||undefined,args.password||undefined);if(args.headers){for(var hdr in args.headers){if(hdr.toLowerCase()==="content-type"&&!args.contentType){args.contentType=args.headers[hdr];}else{xhr.setRequestHeader(hdr,args.headers[hdr]);}}}xhr.setRequestHeader("Content-Type",args.contentType||_4df);if(!args.headers||!args.headers["X-Requested-With"]){xhr.setRequestHeader("X-Requested-With","XMLHttpRequest");}if(dojo.config.debugAtAllCosts){xhr.send(_4ed.query);}else{try{xhr.send(_4ed.query);}catch(e){dfd.ioArgs.error=e;dfd.cancel();}}_d._ioWatch(dfd,_4e0,_4e2,_4e4);xhr=null;return dfd;};dojo.xhrGet=function(args){return _d.xhr("GET",args);};dojo.rawXhrPost=dojo.xhrPost=function(args){return _d.xhr("POST",args,true);};dojo.rawXhrPut=dojo.xhrPut=function(args){return _d.xhr("PUT",args,true);};dojo.xhrDelete=function(args){return _d.xhr("DELETE",args);};})();}if(!dojo._hasResource["dojo._base.fx"]){dojo._hasResource["dojo._base.fx"]=true;dojo.provide("dojo._base.fx");(function(){var d=dojo;var _4f5=d.mixin;dojo._Line=function(_4f6,end){this.start=_4f6;this.end=end;};dojo._Line.prototype.getValue=function(n){return ((this.end-this.start)*n)+this.start;};d.declare("dojo._Animation",null,{constructor:function(args){_4f5(this,args);if(d.isArray(this.curve)){this.curve=new d._Line(this.curve[0],this.curve[1]);}},duration:350,repeat:0,rate:10,_percent:0,_startRepeatCount:0,_fire:function(evt,args){if(this[evt]){if(dojo.config.debugAtAllCosts){this[evt].apply(this,args||[]);}else{try{this[evt].apply(this,args||[]);}catch(e){console.error("exception in animation handler for:",evt);console.error(e);}}}return this;},play:function(_4fc,_4fd){var _t=this;if(_t._delayTimer){_t._clearTimer();}if(_4fd){_t._stopTimer();_t._active=_t._paused=false;_t._percent=0;}else{if(_t._active&&!_t._paused){return _t;}}_t._fire("beforeBegin");var de=_4fc||_t.delay,_p=dojo.hitch(_t,"_play",_4fd);if(de>0){_t._delayTimer=setTimeout(_p,de);return _t;}_p();return _t;},_play:function(_501){var _t=this;if(_t._delayTimer){_t._clearTimer();}_t._startTime=new Date().valueOf();if(_t._paused){_t._startTime-=_t.duration*_t._percent;}_t._endTime=_t._startTime+_t.duration;_t._active=true;_t._paused=false;var _503=_t.curve.getValue(_t._percent);if(!_t._percent){if(!_t._startRepeatCount){_t._startRepeatCount=_t.repeat;}_t._fire("onBegin",[_503]);}_t._fire("onPlay",[_503]);_t._cycle();return _t;},pause:function(){var _t=this;if(_t._delayTimer){_t._clearTimer();}_t._stopTimer();if(!_t._active){return _t;}_t._paused=true;_t._fire("onPause",[_t.curve.getValue(_t._percent)]);return _t;},gotoPercent:function(_505,_506){var _t=this;_t._stopTimer();_t._active=_t._paused=true;_t._percent=_505;if(_506){_t.play();}return _t;},stop:function(_508){var _t=this;if(_t._delayTimer){_t._clearTimer();}if(!_t._timer){return _t;}_t._stopTimer();if(_508){_t._percent=1;}_t._fire("onStop",[_t.curve.getValue(_t._percent)]);_t._active=_t._paused=false;return _t;},status:function(){if(this._active){return this._paused?"paused":"playing";}return "stopped";},_cycle:function(){var _t=this;if(_t._active){var curr=new Date().valueOf();var step=(curr-_t._startTime)/(_t._endTime-_t._startTime);if(step>=1){step=1;}_t._percent=step;if(_t.easing){step=_t.easing(step);}_t._fire("onAnimate",[_t.curve.getValue(step)]);if(_t._percent<1){_t._startTimer();}else{_t._active=false;if(_t.repeat>0){_t.repeat--;_t.play(null,true);}else{if(_t.repeat==-1){_t.play(null,true);}else{if(_t._startRepeatCount){_t.repeat=_t._startRepeatCount;_t._startRepeatCount=0;}}}_t._percent=0;_t._fire("onEnd");_t._stopTimer();}}return _t;},_clearTimer:function(){clearTimeout(this._delayTimer);delete this._delayTimer;}});var ctr=0,_50e=[],_50f=null,_510={run:function(){}};dojo._Animation.prototype._startTimer=function(){if(!this._timer){this._timer=d.connect(_510,"run",this,"_cycle");ctr++;}if(!_50f){_50f=setInterval(d.hitch(_510,"run"),this.rate);}};dojo._Animation.prototype._stopTimer=function(){if(this._timer){d.disconnect(this._timer);this._timer=null;ctr--;}if(ctr<=0){clearInterval(_50f);_50f=null;ctr=0;}};var _511=d.isIE?function(node){var ns=node.style;if(!ns.width.length&&d.style(node,"width")=="auto"){ns.width="auto";}}:function(){};dojo._fade=function(args){args.node=d.byId(args.node);var _515=_4f5({properties:{}},args),_516=(_515.properties.opacity={});_516.start=!("start" in _515)?function(){return +d.style(_515.node,"opacity")||0;}:_515.start;_516.end=_515.end;var anim=d.animateProperty(_515);d.connect(anim,"beforeBegin",d.partial(_511,_515.node));return anim;};dojo.fadeIn=function(args){return d._fade(_4f5({end:1},args));};dojo.fadeOut=function(args){return d._fade(_4f5({end:0},args));};dojo._defaultEasing=function(n){return 0.5+((Math.sin((n+1.5)*Math.PI))/2);};var _51b=function(_51c){this._properties=_51c;for(var p in _51c){var prop=_51c[p];if(prop.start instanceof d.Color){prop.tempColor=new d.Color();}}};_51b.prototype.getValue=function(r){var ret={};for(var p in this._properties){var prop=this._properties[p],_523=prop.start;if(_523 instanceof d.Color){ret[p]=d.blendColors(_523,prop.end,r,prop.tempColor).toCss();}else{if(!d.isArray(_523)){ret[p]=((prop.end-_523)*r)+_523+(p!="opacity"?prop.units||"px":0);}}}return ret;};dojo.animateProperty=function(args){args.node=d.byId(args.node);if(!args.easing){args.easing=d._defaultEasing;}var anim=new d._Animation(args);d.connect(anim,"beforeBegin",anim,function(){var pm={};for(var p in this.properties){if(p=="width"||p=="height"){this.node.display="block";}var prop=this.properties[p];prop=pm[p]=_4f5({},(d.isObject(prop)?prop:{end:prop}));if(d.isFunction(prop.start)){prop.start=prop.start();}if(d.isFunction(prop.end)){prop.end=prop.end();}var _529=(p.toLowerCase().indexOf("color")>=0);function getStyle(node,p){var v={height:node.offsetHeight,width:node.offsetWidth}[p];if(v!==undefined){return v;}v=d.style(node,p);return (p=="opacity")?+v:(_529?v:parseFloat(v));};if(!("end" in prop)){prop.end=getStyle(this.node,p);}else{if(!("start" in prop)){prop.start=getStyle(this.node,p);}}if(_529){prop.start=new d.Color(prop.start);prop.end=new d.Color(prop.end);}else{prop.start=(p=="opacity")?+prop.start:parseFloat(prop.start);}}this.curve=new _51b(pm);});d.connect(anim,"onAnimate",d.hitch(d,"style",anim.node));return anim;};dojo.anim=function(node,_52e,_52f,_530,_531,_532){return d.animateProperty({node:node,duration:_52f||d._Animation.prototype.duration,properties:_52e,easing:_530,onEnd:_531}).play(_532||0);};})();}if(!dojo._hasResource["dojo._base.browser"]){dojo._hasResource["dojo._base.browser"]=true;dojo.provide("dojo._base.browser");dojo.forEach(dojo.config.require,function(i){dojo["require"](i);});}if(!dojo._hasResource["dojo.date"]){dojo._hasResource["dojo.date"]=true;dojo.provide("dojo.date");dojo.date.getDaysInMonth=function(_534){var _535=_534.getMonth();var days=[31,28,31,30,31,30,31,31,30,31,30,31];if(_535==1&&dojo.date.isLeapYear(_534)){return 29;}return days[_535];};dojo.date.isLeapYear=function(_537){var year=_537.getFullYear();return !(year%400)||(!(year%4)&&!!(year%100));};dojo.date.getTimezoneName=function(_539){var str=_539.toString();var tz="";var _53c;var pos=str.indexOf("(");if(pos>-1){tz=str.substring(++pos,str.indexOf(")"));}else{var pat=/([A-Z\/]+) \d{4}$/;if((_53c=str.match(pat))){tz=_53c[1];}else{str=_539.toLocaleString();pat=/ ([A-Z\/]+)$/;if((_53c=str.match(pat))){tz=_53c[1];}}}return (tz=="AM"||tz=="PM")?"":tz;};dojo.date.compare=function(_53f,_540,_541){_53f=new Date(Number(_53f));_540=new Date(Number(_540||new Date()));if(_541!=="undefined"){if(_541=="date"){_53f.setHours(0,0,0,0);_540.setHours(0,0,0,0);}else{if(_541=="time"){_53f.setFullYear(0,0,0);_540.setFullYear(0,0,0);}}}if(_53f>_540){return 1;}if(_53f<_540){return -1;}return 0;};dojo.date.add=function(date,_543,_544){var sum=new Date(Number(date));var _546=false;var _547="Date";switch(_543){case "day":break;case "weekday":var days,_549;var mod=_544%5;if(!mod){days=(_544>0)?5:-5;_549=(_544>0)?((_544-5)/5):((_544+5)/5);}else{days=mod;_549=parseInt(_544/5);}var strt=date.getDay();var adj=0;if(strt==6&&_544>0){adj=1;}else{if(strt==0&&_544<0){adj=-1;}}var trgt=strt+days;if(trgt==0||trgt==6){adj=(_544>0)?2:-2;}_544=(7*_549)+days+adj;break;case "year":_547="FullYear";_546=true;break;case "week":_544*=7;break;case "quarter":_544*=3;case "month":_546=true;_547="Month";break;case "hour":case "minute":case "second":case "millisecond":_547="UTC"+_543.charAt(0).toUpperCase()+_543.substring(1)+"s";}if(_547){sum["set"+_547](sum["get"+_547]()+_544);}if(_546&&(sum.getDate()<date.getDate())){sum.setDate(0);}return sum;};dojo.date.difference=function(_54e,_54f,_550){_54f=_54f||new Date();_550=_550||"day";var _551=_54f.getFullYear()-_54e.getFullYear();var _552=1;switch(_550){case "quarter":var m1=_54e.getMonth();var m2=_54f.getMonth();var q1=Math.floor(m1/3)+1;var q2=Math.floor(m2/3)+1;q2+=(_551*4);_552=q2-q1;break;case "weekday":var days=Math.round(dojo.date.difference(_54e,_54f,"day"));var _558=parseInt(dojo.date.difference(_54e,_54f,"week"));var mod=days%7;if(mod==0){days=_558*5;}else{var adj=0;var aDay=_54e.getDay();var bDay=_54f.getDay();_558=parseInt(days/7);mod=days%7;var _55d=new Date(_54e);_55d.setDate(_55d.getDate()+(_558*7));var _55e=_55d.getDay();if(days>0){switch(true){case aDay==6:adj=-1;break;case aDay==0:adj=0;break;case bDay==6:adj=-1;break;case bDay==0:adj=-2;break;case (_55e+mod)>5:adj=-2;}}else{if(days<0){switch(true){case aDay==6:adj=0;break;case aDay==0:adj=1;break;case bDay==6:adj=2;break;case bDay==0:adj=1;break;case (_55e+mod)<0:adj=2;}}}days+=adj;days-=(_558*2);}_552=days;break;case "year":_552=_551;break;case "month":_552=(_54f.getMonth()-_54e.getMonth())+(_551*12);break;case "week":_552=parseInt(dojo.date.difference(_54e,_54f,"day")/7);break;case "day":_552/=24;case "hour":_552/=60;case "minute":_552/=60;case "second":_552/=1000;case "millisecond":_552*=_54f.getTime()-_54e.getTime();}return Math.round(_552);};}if(!dojo._hasResource["dojo.i18n"]){dojo._hasResource["dojo.i18n"]=true;dojo.provide("dojo.i18n");dojo.i18n.getLocalization=function(_55f,_560,_561){_561=dojo.i18n.normalizeLocale(_561);var _562=_561.split("-");var _563=[_55f,"nls",_560].join(".");var _564=dojo._loadedModules[_563];if(_564){var _565;for(var i=_562.length;i>0;i--){var loc=_562.slice(0,i).join("_");if(_564[loc]){_565=_564[loc];break;}}if(!_565){_565=_564.ROOT;}if(_565){var _568=function(){};_568.prototype=_565;return new _568();}}throw new Error("Bundle not found: "+_560+" in "+_55f+" , locale="+_561);};dojo.i18n.normalizeLocale=function(_569){var _56a=_569?_569.toLowerCase():dojo.locale;if(_56a=="root"){_56a="ROOT";}return _56a;};dojo.i18n._requireLocalization=function(_56b,_56c,_56d,_56e){var _56f=dojo.i18n.normalizeLocale(_56d);var _570=[_56b,"nls",_56c].join(".");var _571="";if(_56e){var _572=_56e.split(",");for(var i=0;i<_572.length;i++){if(_56f["indexOf"](_572[i])==0){if(_572[i].length>_571.length){_571=_572[i];}}}if(!_571){_571="ROOT";}}var _574=_56e?_571:_56f;var _575=dojo._loadedModules[_570];var _576=null;if(_575){if(dojo.config.localizationComplete&&_575._built){return;}var _577=_574.replace(/-/g,"_");var _578=_570+"."+_577;_576=dojo._loadedModules[_578];}if(!_576){_575=dojo["provide"](_570);var syms=dojo._getModuleSymbols(_56b);var _57a=syms.concat("nls").join("/");var _57b;dojo.i18n._searchLocalePath(_574,_56e,function(loc){var _57d=loc.replace(/-/g,"_");var _57e=_570+"."+_57d;var _57f=false;if(!dojo._loadedModules[_57e]){dojo["provide"](_57e);var _580=[_57a];if(loc!="ROOT"){_580.push(loc);}_580.push(_56c);var _581=_580.join("/")+".js";_57f=dojo._loadPath(_581,null,function(hash){var _583=function(){};_583.prototype=_57b;_575[_57d]=new _583();for(var j in hash){_575[_57d][j]=hash[j];}});}else{_57f=true;}if(_57f&&_575[_57d]){_57b=_575[_57d];}else{_575[_57d]=_57b;}if(_56e){return true;}});}if(_56e&&_56f!=_571){_575[_56f.replace(/-/g,"_")]=_575[_571.replace(/-/g,"_")];}};(function(){var _585=dojo.config.extraLocale;if(_585){if(!_585 instanceof Array){_585=[_585];}var req=dojo.i18n._requireLocalization;dojo.i18n._requireLocalization=function(m,b,_589,_58a){req(m,b,_589,_58a);if(_589){return;}for(var i=0;i<_585.length;i++){req(m,b,_585[i],_58a);}};}})();dojo.i18n._searchLocalePath=function(_58c,down,_58e){_58c=dojo.i18n.normalizeLocale(_58c);var _58f=_58c.split("-");var _590=[];for(var i=_58f.length;i>0;i--){_590.push(_58f.slice(0,i).join("-"));}_590.push(false);if(down){_590.reverse();}for(var j=_590.length-1;j>=0;j--){var loc=_590[j]||"ROOT";var stop=_58e(loc);if(stop){break;}}};dojo.i18n._preloadLocalizations=function(_595,_596){function preload(_597){_597=dojo.i18n.normalizeLocale(_597);dojo.i18n._searchLocalePath(_597,true,function(loc){for(var i=0;i<_596.length;i++){if(_596[i]==loc){dojo["require"](_595+"_"+loc);return true;}}return false;});};preload();var _59a=dojo.config.extraLocale||[];for(var i=0;i<_59a.length;i++){preload(_59a[i]);}};}if(!dojo._hasResource["dojo.cldr.supplemental"]){dojo._hasResource["dojo.cldr.supplemental"]=true;dojo.provide("dojo.cldr.supplemental");dojo.cldr.supplemental.getFirstDayOfWeek=function(_59c){var _59d={mv:5,ae:6,af:6,bh:6,dj:6,dz:6,eg:6,er:6,et:6,iq:6,ir:6,jo:6,ke:6,kw:6,lb:6,ly:6,ma:6,om:6,qa:6,sa:6,sd:6,so:6,tn:6,ye:6,as:0,au:0,az:0,bw:0,ca:0,cn:0,fo:0,ge:0,gl:0,gu:0,hk:0,ie:0,il:0,is:0,jm:0,jp:0,kg:0,kr:0,la:0,mh:0,mo:0,mp:0,mt:0,nz:0,ph:0,pk:0,sg:0,th:0,tt:0,tw:0,um:0,us:0,uz:0,vi:0,za:0,zw:0,et:0,mw:0,ng:0,tj:0,sy:4};var _59e=dojo.cldr.supplemental._region(_59c);var dow=_59d[_59e];return (dow===undefined)?1:dow;};dojo.cldr.supplemental._region=function(_5a0){_5a0=dojo.i18n.normalizeLocale(_5a0);var tags=_5a0.split("-");var _5a2=tags[1];if(!_5a2){_5a2={de:"de",en:"us",es:"es",fi:"fi",fr:"fr",he:"il",hu:"hu",it:"it",ja:"jp",ko:"kr",nl:"nl",pt:"br",sv:"se",zh:"cn"}[tags[0]];}else{if(_5a2.length==4){_5a2=tags[2];}}return _5a2;};dojo.cldr.supplemental.getWeekend=function(_5a3){var _5a4={eg:5,il:5,sy:5,"in":0,ae:4,bh:4,dz:4,iq:4,jo:4,kw:4,lb:4,ly:4,ma:4,om:4,qa:4,sa:4,sd:4,tn:4,ye:4};var _5a5={ae:5,bh:5,dz:5,iq:5,jo:5,kw:5,lb:5,ly:5,ma:5,om:5,qa:5,sa:5,sd:5,tn:5,ye:5,af:5,ir:5,eg:6,il:6,sy:6};var _5a6=dojo.cldr.supplemental._region(_5a3);var _5a7=_5a4[_5a6];var end=_5a5[_5a6];if(_5a7===undefined){_5a7=6;}if(end===undefined){end=0;}return {start:_5a7,end:end};};}if(!dojo._hasResource["dojo.regexp"]){dojo._hasResource["dojo.regexp"]=true;dojo.provide("dojo.regexp");dojo.regexp.escapeString=function(str,_5aa){return str.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g,function(ch){if(_5aa&&_5aa.indexOf(ch)!=-1){return ch;}return "\\"+ch;});};dojo.regexp.buildGroupRE=function(arr,re,_5ae){if(!(arr instanceof Array)){return re(arr);}var b=[];for(var i=0;i<arr.length;i++){b.push(re(arr[i]));}return dojo.regexp.group(b.join("|"),_5ae);};dojo.regexp.group=function(_5b1,_5b2){return "("+(_5b2?"?:":"")+_5b1+")";};}if(!dojo._hasResource["dojo.string"]){dojo._hasResource["dojo.string"]=true;dojo.provide("dojo.string");dojo.string.rep=function(str,num){if(num<=0||!str){return "";}var buf=[];for(;;){if(num&1){buf.push(str);}if(!(num>>=1)){break;}str+=str;}return buf.join("");};dojo.string.pad=function(text,size,ch,end){if(!ch){ch="0";}var out=String(text),pad=dojo.string.rep(ch,Math.ceil((size-out.length)/ch.length));return end?out+pad:pad+out;};dojo.string.substitute=function(_5bc,map,_5be,_5bf){_5bf=_5bf||dojo.global;_5be=(!_5be)?function(v){return v;}:dojo.hitch(_5bf,_5be);return _5bc.replace(/\$\{([^\s\:\}]+)(?:\:([^\s\:\}]+))?\}/g,function(_5c1,key,_5c3){var _5c4=dojo.getObject(key,false,map);if(_5c3){_5c4=dojo.getObject(_5c3,false,_5bf).call(_5bf,_5c4,key);}return _5be(_5c4,key).toString();});};dojo.string.trim=String.prototype.trim?dojo.trim:function(str){str=str.replace(/^\s+/,"");for(var i=str.length-1;i>=0;i--){if(/\S/.test(str.charAt(i))){str=str.substring(0,i+1);break;}}return str;};}if(!dojo._hasResource["dojo.date.locale"]){dojo._hasResource["dojo.date.locale"]=true;dojo.provide("dojo.date.locale");(function(){function formatPattern(_5c7,_5c8,_5c9,_5ca){return _5ca.replace(/([a-z])\1*/ig,function(_5cb){var s,pad;var c=_5cb.charAt(0);var l=_5cb.length;var _5d0=["abbr","wide","narrow"];switch(c){case "G":s=_5c8[(l<4)?"eraAbbr":"eraNames"][_5c7.getFullYear()<0?0:1];break;case "y":s=_5c7.getFullYear();switch(l){case 1:break;case 2:if(!_5c9){s=String(s);s=s.substr(s.length-2);break;}default:pad=true;}break;case "Q":case "q":s=Math.ceil((_5c7.getMonth()+1)/3);pad=true;break;case "M":var m=_5c7.getMonth();if(l<3){s=m+1;pad=true;}else{var _5d2=["months","format",_5d0[l-3]].join("-");s=_5c8[_5d2][m];}break;case "w":var _5d3=0;s=dojo.date.locale._getWeekOfYear(_5c7,_5d3);pad=true;break;case "d":s=_5c7.getDate();pad=true;break;case "D":s=dojo.date.locale._getDayOfYear(_5c7);pad=true;break;case "E":var d=_5c7.getDay();if(l<3){s=d+1;pad=true;}else{var _5d5=["days","format",_5d0[l-3]].join("-");s=_5c8[_5d5][d];}break;case "a":var _5d6=(_5c7.getHours()<12)?"am":"pm";s=_5c8[_5d6];break;case "h":case "H":case "K":case "k":var h=_5c7.getHours();switch(c){case "h":s=(h%12)||12;break;case "H":s=h;break;case "K":s=(h%12);break;case "k":s=h||24;break;}pad=true;break;case "m":s=_5c7.getMinutes();pad=true;break;case "s":s=_5c7.getSeconds();pad=true;break;case "S":s=Math.round(_5c7.getMilliseconds()*Math.pow(10,l-3));pad=true;break;case "v":case "z":s=dojo.date.getTimezoneName(_5c7);if(s){break;}l=4;case "Z":var _5d8=_5c7.getTimezoneOffset();var tz=[(_5d8<=0?"+":"-"),dojo.string.pad(Math.floor(Math.abs(_5d8)/60),2),dojo.string.pad(Math.abs(_5d8)%60,2)];if(l==4){tz.splice(0,0,"GMT");tz.splice(3,0,":");}s=tz.join("");break;default:throw new Error("dojo.date.locale.format: invalid pattern char: "+_5ca);}if(pad){s=dojo.string.pad(s,l);}return s;});};dojo.date.locale.format=function(_5da,_5db){_5db=_5db||{};var _5dc=dojo.i18n.normalizeLocale(_5db.locale);var _5dd=_5db.formatLength||"short";var _5de=dojo.date.locale._getGregorianBundle(_5dc);var str=[];var _5e0=dojo.hitch(this,formatPattern,_5da,_5de,_5db.fullYear);if(_5db.selector=="year"){var year=_5da.getFullYear();if(_5dc.match(/^zh|^ja/)){year+="";}return year;}if(_5db.selector!="time"){var _5e2=_5db.datePattern||_5de["dateFormat-"+_5dd];if(_5e2){str.push(_processPattern(_5e2,_5e0));}}if(_5db.selector!="date"){var _5e3=_5db.timePattern||_5de["timeFormat-"+_5dd];if(_5e3){str.push(_processPattern(_5e3,_5e0));}}var _5e4=str.join(" ");return _5e4;};dojo.date.locale.regexp=function(_5e5){return dojo.date.locale._parseInfo(_5e5).regexp;};dojo.date.locale._parseInfo=function(_5e6){_5e6=_5e6||{};var _5e7=dojo.i18n.normalizeLocale(_5e6.locale);var _5e8=dojo.date.locale._getGregorianBundle(_5e7);var _5e9=_5e6.formatLength||"short";var _5ea=_5e6.datePattern||_5e8["dateFormat-"+_5e9];var _5eb=_5e6.timePattern||_5e8["timeFormat-"+_5e9];var _5ec;if(_5e6.selector=="date"){_5ec=_5ea;}else{if(_5e6.selector=="time"){_5ec=_5eb;}else{_5ec=_5ea+" "+_5eb;}}var _5ed=[];var re=_processPattern(_5ec,dojo.hitch(this,_buildDateTimeRE,_5ed,_5e8,_5e6));return {regexp:re,tokens:_5ed,bundle:_5e8};};dojo.date.locale.parse=function(_5ef,_5f0){var info=dojo.date.locale._parseInfo(_5f0);var _5f2=info.tokens,_5f3=info.bundle;var re=new RegExp("^"+info.regexp+"$",info.strict?"":"i");var _5f5=re.exec(_5ef);if(!_5f5){return null;}var _5f6=["abbr","wide","narrow"];var _5f7=[1970,0,1,0,0,0,0];var amPm="";var _5f9=dojo.every(_5f5,function(v,i){if(!i){return true;}var _5fc=_5f2[i-1];var l=_5fc.length;switch(_5fc.charAt(0)){case "y":if(l!=2&&_5f0.strict){_5f7[0]=v;}else{if(v<100){v=Number(v);var year=""+new Date().getFullYear();var _5ff=year.substring(0,2)*100;var _600=Math.min(Number(year.substring(2,4))+20,99);var num=(v<_600)?_5ff+v:_5ff-100+v;_5f7[0]=num;}else{if(_5f0.strict){return false;}_5f7[0]=v;}}break;case "M":if(l>2){var _602=_5f3["months-format-"+_5f6[l-3]].concat();if(!_5f0.strict){v=v.replace(".","").toLowerCase();_602=dojo.map(_602,function(s){return s.replace(".","").toLowerCase();});}v=dojo.indexOf(_602,v);if(v==-1){return false;}}else{v--;}_5f7[1]=v;break;case "E":case "e":var days=_5f3["days-format-"+_5f6[l-3]].concat();if(!_5f0.strict){v=v.toLowerCase();days=dojo.map(days,function(d){return d.toLowerCase();});}v=dojo.indexOf(days,v);if(v==-1){return false;}break;case "D":_5f7[1]=0;case "d":_5f7[2]=v;break;case "a":var am=_5f0.am||_5f3.am;var pm=_5f0.pm||_5f3.pm;if(!_5f0.strict){var _608=/\./g;v=v.replace(_608,"").toLowerCase();am=am.replace(_608,"").toLowerCase();pm=pm.replace(_608,"").toLowerCase();}if(_5f0.strict&&v!=am&&v!=pm){return false;}amPm=(v==pm)?"p":(v==am)?"a":"";break;case "K":if(v==24){v=0;}case "h":case "H":case "k":if(v>23){return false;}_5f7[3]=v;break;case "m":_5f7[4]=v;break;case "s":_5f7[5]=v;break;case "S":_5f7[6]=v;}return true;});var _609=+_5f7[3];if(amPm==="p"&&_609<12){_5f7[3]=_609+12;}else{if(amPm==="a"&&_609==12){_5f7[3]=0;}}var _60a=new Date(_5f7[0],_5f7[1],_5f7[2],_5f7[3],_5f7[4],_5f7[5],_5f7[6]);if(_5f0.strict){_60a.setFullYear(_5f7[0]);}var _60b=_5f2.join(""),_60c=_60b.indexOf("d")!=-1,_60d=_60b.indexOf("M")!=-1;if(!_5f9||(_60d&&_60a.getMonth()>_5f7[1])||(_60c&&_60a.getDate()>_5f7[2])){return null;}if((_60d&&_60a.getMonth()<_5f7[1])||(_60c&&_60a.getDate()<_5f7[2])){_60a=dojo.date.add(_60a,"hour",1);}return _60a;};function _processPattern(_60e,_60f,_610,_611){var _612=function(x){return x;};_60f=_60f||_612;_610=_610||_612;_611=_611||_612;var _614=_60e.match(/(''|[^'])+/g);var _615=_60e.charAt(0)=="'";dojo.forEach(_614,function(_616,i){if(!_616){_614[i]="";}else{_614[i]=(_615?_610:_60f)(_616);_615=!_615;}});return _611(_614.join(""));};function _buildDateTimeRE(_618,_619,_61a,_61b){_61b=dojo.regexp.escapeString(_61b);if(!_61a.strict){_61b=_61b.replace(" a"," ?a");}return _61b.replace(/([a-z])\1*/ig,function(_61c){var s;var c=_61c.charAt(0);var l=_61c.length;var p2="",p3="";if(_61a.strict){if(l>1){p2="0"+"{"+(l-1)+"}";}if(l>2){p3="0"+"{"+(l-2)+"}";}}else{p2="0?";p3="0{0,2}";}switch(c){case "y":s="\\d{2,4}";break;case "M":s=(l>2)?"\\S+?":p2+"[1-9]|1[0-2]";break;case "D":s=p2+"[1-9]|"+p3+"[1-9][0-9]|[12][0-9][0-9]|3[0-5][0-9]|36[0-6]";break;case "d":s="[12]\\d|"+p2+"[1-9]|3[01]";break;case "w":s=p2+"[1-9]|[1-4][0-9]|5[0-3]";break;case "E":s="\\S+";break;case "h":s=p2+"[1-9]|1[0-2]";break;case "k":s=p2+"\\d|1[01]";break;case "H":s=p2+"\\d|1\\d|2[0-3]";break;case "K":s=p2+"[1-9]|1\\d|2[0-4]";break;case "m":case "s":s="[0-5]\\d";break;case "S":s="\\d{"+l+"}";break;case "a":var am=_61a.am||_619.am||"AM";var pm=_61a.pm||_619.pm||"PM";if(_61a.strict){s=am+"|"+pm;}else{s=am+"|"+pm;if(am!=am.toLowerCase()){s+="|"+am.toLowerCase();}if(pm!=pm.toLowerCase()){s+="|"+pm.toLowerCase();}if(s.indexOf(".")!=-1){s+="|"+s.replace(/\./g,"");}}s=s.replace(/\./g,"\\.");break;default:s=".*";}if(_618){_618.push(_61c);}return "("+s+")";}).replace(/[\xa0 ]/g,"[\\s\\xa0]");};})();(function(){var _624=[];dojo.date.locale.addCustomFormats=function(_625,_626){_624.push({pkg:_625,name:_626});};dojo.date.locale._getGregorianBundle=function(_627){var _628={};dojo.forEach(_624,function(desc){var _62a=dojo.i18n.getLocalization(desc.pkg,desc.name,_627);_628=dojo.mixin(_628,_62a);},this);return _628;};})();dojo.date.locale.addCustomFormats("dojo.cldr","gregorian");dojo.date.locale.getNames=function(item,type,_62d,_62e){var _62f;var _630=dojo.date.locale._getGregorianBundle(_62e);var _631=[item,_62d,type];if(_62d=="standAlone"){var key=_631.join("-");_62f=_630[key];if(_62f[0]==1){_62f=undefined;}}_631[1]="format";return (_62f||_630[_631.join("-")]).concat();};dojo.date.locale.isWeekend=function(_633,_634){var _635=dojo.cldr.supplemental.getWeekend(_634);var day=(_633||new Date()).getDay();if(_635.end<_635.start){_635.end+=7;if(day<_635.start){day+=7;}}return day>=_635.start&&day<=_635.end;};dojo.date.locale._getDayOfYear=function(_637){return dojo.date.difference(new Date(_637.getFullYear(),0,1,_637.getHours()),_637)+1;};dojo.date.locale._getWeekOfYear=function(_638,_639){if(arguments.length==1){_639=0;}var _63a=new Date(_638.getFullYear(),0,1).getDay();var adj=(_63a-_639+7)%7;var week=Math.floor((dojo.date.locale._getDayOfYear(_638)+adj-1)/7);if(_63a==_639){week++;}return week;};}if(!dojo._hasResource["dojo.date.stamp"]){dojo._hasResource["dojo.date.stamp"]=true;dojo.provide("dojo.date.stamp");dojo.date.stamp.fromISOString=function(_63d,_63e){if(!dojo.date.stamp._isoRegExp){dojo.date.stamp._isoRegExp=/^(?:(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?)?(?:T(\d{2}):(\d{2})(?::(\d{2})(.\d+)?)?((?:[+-](\d{2}):(\d{2}))|Z)?)?$/;}var _63f=dojo.date.stamp._isoRegExp.exec(_63d);var _640=null;if(_63f){_63f.shift();if(_63f[1]){_63f[1]--;}if(_63f[6]){_63f[6]*=1000;}if(_63e){_63e=new Date(_63e);dojo.map(["FullYear","Month","Date","Hours","Minutes","Seconds","Milliseconds"],function(prop){return _63e["get"+prop]();}).forEach(function(_642,_643){if(_63f[_643]===undefined){_63f[_643]=_642;}});}_640=new Date(_63f[0]||1970,_63f[1]||0,_63f[2]||1,_63f[3]||0,_63f[4]||0,_63f[5]||0,_63f[6]||0);var _644=0;var _645=_63f[7]&&_63f[7].charAt(0);if(_645!="Z"){_644=((_63f[8]||0)*60)+(Number(_63f[9])||0);if(_645!="-"){_644*=-1;}}if(_645){_644-=_640.getTimezoneOffset();}if(_644){_640.setTime(_640.getTime()+_644*60000);}}return _640;};dojo.date.stamp.toISOString=function(_646,_647){var _=function(n){return (n<10)?"0"+n:n;};_647=_647||{};var _64a=[];var _64b=_647.zulu?"getUTC":"get";var date="";if(_647.selector!="time"){var year=_646[_64b+"FullYear"]();date=["0000".substr((year+"").length)+year,_(_646[_64b+"Month"]()+1),_(_646[_64b+"Date"]())].join("-");}_64a.push(date);if(_647.selector!="date"){var time=[_(_646[_64b+"Hours"]()),_(_646[_64b+"Minutes"]()),_(_646[_64b+"Seconds"]())].join(":");var _64f=_646[_64b+"Milliseconds"]();if(_647.milliseconds){time+="."+(_64f<100?"0":"")+_(_64f);}if(_647.zulu){time+="Z";}else{if(_647.selector!="time"){var _650=_646.getTimezoneOffset();var _651=Math.abs(_650);time+=(_650>0?"-":"+")+_(Math.floor(_651/60))+":"+_(_651%60);}}_64a.push(time);}return _64a.join("T");};}if(!dojo._hasResource["dojo.parser"]){dojo._hasResource["dojo.parser"]=true;dojo.provide("dojo.parser");dojo.parser=new function(){var d=dojo;this._attrName=d._scopeName+"Type";this._query="["+this._attrName+"]";var _653=0,_654={};var _655=function(_656,_657){var nso=_657||_654;if(dojo.isIE){var cn=_656["__dojoNameCache"];if(cn&&nso[cn]===_656){return cn;}}var name;do{name="__"+_653++;}while(name in nso);nso[name]=_656;return name;};function val2type(_65b){if(d.isString(_65b)){return "string";}if(typeof _65b=="number"){return "number";}if(typeof _65b=="boolean"){return "boolean";}if(d.isFunction(_65b)){return "function";}if(d.isArray(_65b)){return "array";}if(_65b instanceof Date){return "date";}if(_65b instanceof d._Url){return "url";}return "object";};function str2obj(_65c,type){switch(type){case "string":return _65c;case "number":return _65c.length?Number(_65c):NaN;case "boolean":return typeof _65c=="boolean"?_65c:!(_65c.toLowerCase()=="false");case "function":if(d.isFunction(_65c)){_65c=_65c.toString();_65c=d.trim(_65c.substring(_65c.indexOf("{")+1,_65c.length-1));}try{if(_65c.search(/[^\w\.]+/i)!=-1){_65c=_655(new Function(_65c),this);}return d.getObject(_65c,false);}catch(e){return new Function();}case "array":return _65c?_65c.split(/\s*,\s*/):[];case "date":switch(_65c){case "":return new Date("");case "now":return new Date();default:return d.date.stamp.fromISOString(_65c);}case "url":return d.baseUrl+_65c;default:return d.fromJson(_65c);}};var _65e={};dojo.connect(dojo,"extend",function(){_65e={};});function getClassInfo(_65f){if(!_65e[_65f]){var cls=d.getObject(_65f);if(!d.isFunction(cls)){throw new Error("Could not load class '"+_65f+"'. Did you spell the name correctly and use a full path, like 'dijit.form.Button'?");}var _661=cls.prototype;var _662={},_663={};for(var name in _661){if(name.charAt(0)=="_"){continue;}if(name in _663){continue;}var _665=_661[name];_662[name]=val2type(_665);}_65e[_65f]={cls:cls,params:_662};}return _65e[_65f];};this._functionFromScript=function(_666){var _667="";var _668="";var _669=_666.getAttribute("args");if(_669){d.forEach(_669.split(/\s*,\s*/),function(part,idx){_667+="var "+part+" = arguments["+idx+"]; ";});}var _66c=_666.getAttribute("with");if(_66c&&_66c.length){d.forEach(_66c.split(/\s*,\s*/),function(part){_667+="with("+part+"){";_668+="}";});}return new Function(_667+_666.innerHTML+_668);};this.instantiate=function(_66e,_66f){var _670=[],dp=dojo.parser;_66f=_66f||{};d.forEach(_66e,function(node){if(!node){return;}var type=dp._attrName in _66f?_66f[dp._attrName]:node.getAttribute(dp._attrName);if(!type||!type.length){return;}var _674=getClassInfo(type),_675=_674.cls,ps=_675._noScript||_675.prototype._noScript;var _677={},_678=node.attributes;for(var name in _674.params){var item=name in _66f?{value:_66f[name],specified:true}:_678.getNamedItem(name);if(!item||(!item.specified&&(!dojo.isIE||name.toLowerCase()!="value"))){continue;}var _67b=item.value;switch(name){case "class":_67b="className" in _66f?_66f.className:node.className;break;case "style":_67b="style" in _66f?_66f.style:(node.style&&node.style.cssText);}var _67c=_674.params[name];if(typeof _67b=="string"){_677[name]=str2obj(_67b,_67c);}else{_677[name]=_67b;}}if(!ps){var _67d=[],_67e=[];d.query("> script[type^='dojo/']",node).orphan().forEach(function(_67f){var _680=_67f.getAttribute("event"),type=_67f.getAttribute("type"),nf=d.parser._functionFromScript(_67f);if(_680){if(type=="dojo/connect"){_67d.push({event:_680,func:nf});}else{_677[_680]=nf;}}else{_67e.push(nf);}});}var _682=_675["markupFactory"];if(!_682&&_675["prototype"]){_682=_675.prototype["markupFactory"];}var _683=_682?_682(_677,node,_675):new _675(_677,node);_670.push(_683);var _684=node.getAttribute("jsId");if(_684){d.setObject(_684,_683);}if(!ps){d.forEach(_67d,function(_685){d.connect(_683,_685.event,null,_685.func);});d.forEach(_67e,function(func){func.call(_683);});}});d.forEach(_670,function(_687){if(_687&&_687.startup&&!_687._started&&(!_687.getParent||!_687.getParent())){_687.startup();}});return _670;};this.parse=function(_688){var list=d.query(this._query,_688);var _68a=this.instantiate(list);return _68a;};}();(function(){var _68b=function(){if(dojo.config["parseOnLoad"]==true){dojo.parser.parse();}};if(dojo.exists("dijit.wai.onload")&&(dijit.wai.onload===dojo._loaders[0])){dojo._loaders.splice(1,0,_68b);}else{dojo._loaders.unshift(_68b);}})();}if(!dojo._hasResource["dojo.cookie"]){dojo._hasResource["dojo.cookie"]=true;dojo.provide("dojo.cookie");dojo.cookie=function(name,_68d,_68e){var c=document.cookie;if(arguments.length==1){var _690=c.match(new RegExp("(?:^|; )"+dojo.regexp.escapeString(name)+"=([^;]*)"));return _690?decodeURIComponent(_690[1]):undefined;}else{_68e=_68e||{};var exp=_68e.expires;if(typeof exp=="number"){var d=new Date();d.setTime(d.getTime()+exp*24*60*60*1000);exp=_68e.expires=d;}if(exp&&exp.toUTCString){_68e.expires=exp.toUTCString();}_68d=encodeURIComponent(_68d);var _693=name+"="+_68d,_694;for(_694 in _68e){_693+="; "+_694;var _695=_68e[_694];if(_695!==true){_693+="="+_695;}}document.cookie=_693;}};dojo.cookie.isSupported=function(){if(!("cookieEnabled" in navigator)){this("__djCookieTest__","CookiesAllowed");navigator.cookieEnabled=this("__djCookieTest__")=="CookiesAllowed";if(navigator.cookieEnabled){this("__djCookieTest__","",{expires:-1});}}return navigator.cookieEnabled;};}if(!dojo._hasResource["dojo.io.script"]){dojo._hasResource["dojo.io.script"]=true;dojo.provide("dojo.io.script");dojo.io.script={get:function(args){var dfd=this._makeScriptDeferred(args);var _698=dfd.ioArgs;dojo._ioAddQueryToUrl(_698);if(this._canAttach(_698)){this.attach(_698.id,_698.url,args.frameDoc);}dojo._ioWatch(dfd,this._validCheck,this._ioCheck,this._resHandle);return dfd;},attach:function(id,url,_69b){var doc=(_69b||dojo.doc);var _69d=doc.createElement("script");_69d.type="text/javascript";_69d.src=url;_69d.id=id;_69d.charset="utf-8";doc.getElementsByTagName("head")[0].appendChild(_69d);},remove:function(id,_69f){dojo.destroy(dojo.byId(id,_69f));if(this["jsonp_"+id]){delete this["jsonp_"+id];}},_makeScriptDeferred:function(args){var dfd=dojo._ioSetArgs(args,this._deferredCancel,this._deferredOk,this._deferredError);var _6a2=dfd.ioArgs;_6a2.id=dojo._scopeName+"IoScript"+(this._counter++);_6a2.canDelete=false;if(args.callbackParamName){_6a2.query=_6a2.query||"";if(_6a2.query.length>0){_6a2.query+="&";}_6a2.query+=args.callbackParamName+"="+(args.frameDoc?"parent.":"")+dojo._scopeName+".io.script.jsonp_"+_6a2.id+"._jsonpCallback";_6a2.frameDoc=args.frameDoc;_6a2.canDelete=true;dfd._jsonpCallback=this._jsonpCallback;this["jsonp_"+_6a2.id]=dfd;}return dfd;},_deferredCancel:function(dfd){dfd.canceled=true;if(dfd.ioArgs.canDelete){dojo.io.script._addDeadScript(dfd.ioArgs);}},_deferredOk:function(dfd){if(dfd.ioArgs.canDelete){dojo.io.script._addDeadScript(dfd.ioArgs);}if(dfd.ioArgs.json){return dfd.ioArgs.json;}else{return dfd.ioArgs;}},_deferredError:function(_6a5,dfd){if(dfd.ioArgs.canDelete){if(_6a5.dojoType=="timeout"){dojo.io.script.remove(dfd.ioArgs.id,dfd.ioArgs.frameDoc);}else{dojo.io.script._addDeadScript(dfd.ioArgs);}}console.log("dojo.io.script error",_6a5);return _6a5;},_deadScripts:[],_counter:1,_addDeadScript:function(_6a7){dojo.io.script._deadScripts.push({id:_6a7.id,frameDoc:_6a7.frameDoc});_6a7.frameDoc=null;},_validCheck:function(dfd){var _6a9=dojo.io.script;var _6aa=_6a9._deadScripts;if(_6aa&&_6aa.length>0){for(var i=0;i<_6aa.length;i++){_6a9.remove(_6aa[i].id,_6aa[i].frameDoc);_6aa[i].frameDoc=null;}dojo.io.script._deadScripts=[];}return true;},_ioCheck:function(dfd){if(dfd.ioArgs.json){return true;}var _6ad=dfd.ioArgs.args.checkString;if(_6ad&&eval("typeof("+_6ad+") != 'undefined'")){return true;}return false;},_resHandle:function(dfd){if(dojo.io.script._ioCheck(dfd)){dfd.callback(dfd);}else{dfd.errback(new Error("inconceivable dojo.io.script._resHandle error"));}},_canAttach:function(_6af){return true;},_jsonpCallback:function(json){this.ioArgs.json=json;}};}if(!dojo._hasResource["dojo.io.iframe"]){dojo._hasResource["dojo.io.iframe"]=true;dojo.provide("dojo.io.iframe");dojo.io.iframe={create:function(_6b1,_6b2,uri){if(window[_6b1]){return window[_6b1];}if(window.frames[_6b1]){return window.frames[_6b1];}var _6b4=null;var turi=uri;if(!turi){if(dojo.config["useXDomain"]&&!dojo.config["dojoBlankHtmlUrl"]){console.warn("dojo.io.iframe.create: When using cross-domain Dojo builds,"+" please save dojo/resources/blank.html to your domain and set djConfig.dojoBlankHtmlUrl"+" to the path on your domain to blank.html");}turi=(dojo.config["dojoBlankHtmlUrl"]||dojo.moduleUrl("dojo","resources/blank.html"));}var _6b6=dojo.isIE?"<iframe name=\""+_6b1+"\" src=\""+turi+"\" onload=\""+_6b2+"\">":"iframe";_6b4=dojo.doc.createElement(_6b6);with(_6b4){name=_6b1;setAttribute("name",_6b1);id=_6b1;}dojo.body().appendChild(_6b4);window[_6b1]=_6b4;with(_6b4.style){if(!(dojo.isSafari<3)){position="absolute";}left=top="1px";height=width="1px";visibility="hidden";}if(!dojo.isIE){this.setSrc(_6b4,turi,true);_6b4.onload=new Function(_6b2);}return _6b4;},setSrc:function(_6b7,src,_6b9){try{if(!_6b9){if(dojo.isWebKit){_6b7.location=src;}else{frames[_6b7.name].location=src;}}else{var idoc;if(dojo.isIE||dojo.isWebKit>521){idoc=_6b7.contentWindow.document;}else{if(dojo.isSafari){idoc=_6b7.document;}else{idoc=_6b7.contentWindow;}}if(!idoc){_6b7.location=src;return;}else{idoc.location.replace(src);}}}catch(e){console.log("dojo.io.iframe.setSrc: ",e);}},doc:function(_6bb){var doc=_6bb.contentDocument||(((_6bb.name)&&(_6bb.document)&&(document.getElementsByTagName("iframe")[_6bb.name].contentWindow)&&(document.getElementsByTagName("iframe")[_6bb.name].contentWindow.document)))||((_6bb.name)&&(document.frames[_6bb.name])&&(document.frames[_6bb.name].document))||null;return doc;},send:function(args){if(!this["_frame"]){this._frame=this.create(this._iframeName,dojo._scopeName+".io.iframe._iframeOnload();");}var dfd=dojo._ioSetArgs(args,function(dfd){dfd.canceled=true;dfd.ioArgs._callNext();},function(dfd){var _6c1=null;try{var _6c2=dfd.ioArgs;var dii=dojo.io.iframe;var ifd=dii.doc(dii._frame);var _6c5=_6c2.handleAs;_6c1=ifd;if(_6c5!="html"){if(_6c5=="xml"){if(dojo.isIE){dojo.query("a",dii._frame.contentWindow.document.documentElement).orphan();var _6c6=(dii._frame.contentWindow.document).documentElement.innerText;_6c6=_6c6.replace(/>\s+</g,"><");_6c6=dojo.trim(_6c6);var _6c7={responseText:_6c6};_6c1=dojo._contentHandlers["xml"](_6c7);}}else{_6c1=ifd.getElementsByTagName("textarea")[0].value;if(_6c5=="json"){_6c1=dojo.fromJson(_6c1);}else{if(_6c5=="javascript"){_6c1=dojo.eval(_6c1);}}}}}catch(e){_6c1=e;}finally{_6c2._callNext();}return _6c1;},function(_6c8,dfd){dfd.ioArgs._hasError=true;dfd.ioArgs._callNext();return _6c8;});dfd.ioArgs._callNext=function(){if(!this["_calledNext"]){this._calledNext=true;dojo.io.iframe._currentDfd=null;dojo.io.iframe._fireNextRequest();}};this._dfdQueue.push(dfd);this._fireNextRequest();dojo._ioWatch(dfd,function(dfd){return !dfd.ioArgs["_hasError"];},function(dfd){return (!!dfd.ioArgs["_finished"]);},function(dfd){if(dfd.ioArgs._finished){dfd.callback(dfd);}else{dfd.errback(new Error("Invalid dojo.io.iframe request state"));}});return dfd;},_currentDfd:null,_dfdQueue:[],_iframeName:dojo._scopeName+"IoIframe",_fireNextRequest:function(){try{if((this._currentDfd)||(this._dfdQueue.length==0)){return;}var dfd=this._currentDfd=this._dfdQueue.shift();var _6ce=dfd.ioArgs;var args=_6ce.args;_6ce._contentToClean=[];var fn=dojo.byId(args["form"]);var _6d1=args["content"]||{};if(fn){if(_6d1){var _6d2=function(name,_6d4){var tn;if(dojo.isIE){tn=dojo.doc.createElement("<input type='hidden' name='"+name+"'>");}else{tn=dojo.doc.createElement("input");tn.type="hidden";tn.name=name;}tn.value=_6d4;fn.appendChild(tn);_6ce._contentToClean.push(name);};for(var x in _6d1){var val=_6d1[x];if(dojo.isArray(val)&&val.length>1){var i;for(i=0;i<val.length;i++){_6d2(x,val[i]);}}else{if(!fn[x]){_6d2(x,val);}else{fn[x].value=val;}}}}var _6d9=fn.getAttributeNode("action");var _6da=fn.getAttributeNode("method");var _6db=fn.getAttributeNode("target");if(args["url"]){_6ce._originalAction=_6d9?_6d9.value:null;if(_6d9){_6d9.value=args.url;}else{fn.setAttribute("action",args.url);}}if(!_6da||!_6da.value){if(_6da){_6da.value=(args["method"])?args["method"]:"post";}else{fn.setAttribute("method",(args["method"])?args["method"]:"post");}}_6ce._originalTarget=_6db?_6db.value:null;if(_6db){_6db.value=this._iframeName;}else{fn.setAttribute("target",this._iframeName);}fn.target=this._iframeName;fn.submit();}else{var _6dc=args.url+(args.url.indexOf("?")>-1?"&":"?")+_6ce.query;this.setSrc(this._frame,_6dc,true);}}catch(e){dfd.errback(e);}},_iframeOnload:function(){var dfd=this._currentDfd;if(!dfd){this._fireNextRequest();return;}var _6de=dfd.ioArgs;var args=_6de.args;var _6e0=dojo.byId(args.form);if(_6e0){var _6e1=_6de._contentToClean;for(var i=0;i<_6e1.length;i++){var key=_6e1[i];for(var j=0;j<_6e0.childNodes.length;j++){var _6e5=_6e0.childNodes[j];if(_6e5.name==key){dojo.destroy(_6e5);break;}}}if(_6de["_originalAction"]){_6e0.setAttribute("action",_6de._originalAction);}if(_6de["_originalTarget"]){_6e0.setAttribute("target",_6de._originalTarget);_6e0.target=_6de._originalTarget;}}_6de._finished=true;}};}dojo.i18n._preloadLocalizations("dojo.nls.dojo",["ROOT","aa","aa-dj","aa-er","aa-et","af","af-za","am","am-et","ar","ar-dz","ar-jo","ar-lb","ar-ma","ar-qa","ar-sa","ar-sy","ar-tn","ar-ye","as","as-in","az","be","be-by","bg","bg-bg","bn","bn-bd","bn-in","bs","byn","byn-er","ca","ca-es","cs","cs-cz","cy","cy-gb","da","da-dk","de","de-at","de-be","de-ch","de-de","de-li","de-lu","dv","dz","dz-bt","el","el-cy","el-gr","el-polytoni","en","en-as","en-au","en-be","en-bw","en-ca","en-gb","en-gu","en-hk","en-ie","en-in","en-mh","en-mp","en-mt","en-nz","en-ph","en-pk","en-sg","en-um","en-us","en-us-posix","en-vi","en-za","en-zw","eo","es","es-ar","es-bo","es-cl","es-co","es-cr","es-do","es-ec","es-es","es-gt","es-hn","es-mx","es-ni","es-pa","es-pr","es-py","es-sv","es-us","es-uy","es-ve","et","et-ee","eu","eu-es","fa","fa-af","fi","fi-fi","fo","fo-fo","fr","fr-be","fr-ca","fr-ch","fr-lu","fur","ga","ga-ie","gez","gez-er","gez-et","gl","gl-es","gu","gu-in","gv","gv-gb","haw","haw-us","he","he-il","hi","hi-in","hr","hu","hu-hu","hy","hy-am","hy-am-revised","ia","id","id-id","is","is-is","it","it-ch","it-it","ja","ja-jp","ka","kk","kk-kz","kl","kl-gl","km","km-kh","kn","kn-in","ko","ko-kr","kok","kok-in","kw","kw-gb","ky","ln","lo","lo-la","lt","lt-lt","lv","lv-lv","mk","mk-mk","ml","ml-in","mn","mr","mr-in","ms","ms-bn","ms-my","mt","mt-mt","nb","nb-no","ne","nl","nl-be","nl-nl","nn","nn-no","om","om-et","om-ke","or","or-in","pa","pa-arab","pa-in","pl","pl-pl","ps","ps-af","pt","pt-br","pt-pt","ro","ro-ro","ru","ru-ua","rw","sa","se","sh","sh-ba","sid","sid-et","sk","sk-sk","sl","sl-si","so","so-dj","so-et","so-ke","so-so","sq","sq-al","sr","sr-ba","sr-cyrl","sr-cyrl-ba","sr-latn","sr-latn-ba","sv","sv-fi","sv-se","sw","sw-ke","sw-tz","syr","syr-sy","ta","ta-in","te","te-in","th","th-th","ti","ti-er","ti-et","tig","tig-er","tr","tt","tt-ru","uk","uk-ua","uz","uz-arab","vi","wal","wal-et","xh","xx","zh","zh-cn","zh-hans","zh-hans-cn","zh-hans-sg","zh-hant","zh-hant-hk","zh-hant-mo","zh-hant-tw","zh-hk","zh-mo","zh-sg","zh-tw","zu"]);if(dojo.config.afterOnLoad&&dojo.isBrowser){window.setTimeout(dojo._loadInit,1000);}})();

/*
	Copyright (c) 2004-2009, The Dojo Foundation All Rights Reserved.
	Available via Academic Free License >= 2.1 OR the modified BSD license.
	see: http://dojotoolkit.org/license for details
*/

/*
	This is a compiled version of Dojo, built for deployment and not for
	development. To get an editable version, please visit:

		http://dojotoolkit.org

	for documentation and information on getting the source.
*/

dojo.provide("dijit.dijit");if(!dojo._hasResource["dijit._base.focus"]){dojo._hasResource["dijit._base.focus"]=true;dojo.provide("dijit._base.focus");dojo.mixin(dijit,{_curFocus:null,_prevFocus:null,isCollapsed:function(){var _1=dojo.doc;if(_1.selection&&!dojo.isOpera){var s=_1.selection;if(s.type=="Text"){return !s.createRange().htmlText.length;}else{return !s.createRange().length;}}else{var _3=dojo.global;var _4=_3.getSelection();if(dojo.isString(_4)){return !_4;}else{return !_4||_4.isCollapsed||!_4.toString();}}},getBookmark:function(){var _5,_6=dojo.doc.selection;if(_6&&!dojo.isOpera){var _7=_6.createRange();if(_6.type.toUpperCase()=="CONTROL"){if(_7.length){_5=[];var i=0,_9=_7.length;while(i<_9){_5.push(_7.item(i++));}}else{_5=null;}}else{_5=_7.getBookmark();}}else{if(window.getSelection){_6=dojo.global.getSelection();if(_6){_7=_6.getRangeAt(0);_5=_7.cloneRange();}}else{console.warn("No idea how to store the current selection for this browser!");}}return _5;},moveToBookmark:function(_a){var _b=dojo.doc;if(_b.selection&&!dojo.isOpera){var _c;if(dojo.isArray(_a)){_c=_b.body.createControlRange();dojo.forEach(_a,function(n){_c.addElement(n);});}else{_c=_b.selection.createRange();_c.moveToBookmark(_a);}_c.select();}else{var _e=dojo.global.getSelection&&dojo.global.getSelection();if(_e&&_e.removeAllRanges){_e.removeAllRanges();_e.addRange(_a);}else{console.warn("No idea how to restore selection for this browser!");}}},getFocus:function(_f,_10){return {node:_f&&dojo.isDescendant(dijit._curFocus,_f.domNode)?dijit._prevFocus:dijit._curFocus,bookmark:!dojo.withGlobal(_10||dojo.global,dijit.isCollapsed)?dojo.withGlobal(_10||dojo.global,dijit.getBookmark):null,openedForWindow:_10};},focus:function(_11){if(!_11){return;}var _12="node" in _11?_11.node:_11,_13=_11.bookmark,_14=_11.openedForWindow;if(_12){var _15=(_12.tagName.toLowerCase()=="iframe")?_12.contentWindow:_12;if(_15&&_15.focus){try{_15.focus();}catch(e){}}dijit._onFocusNode(_12);}if(_13&&dojo.withGlobal(_14||dojo.global,dijit.isCollapsed)){if(_14){_14.focus();}try{dojo.withGlobal(_14||dojo.global,dijit.moveToBookmark,null,[_13]);}catch(e){}}},_activeStack:[],registerIframe:function(_16){dijit.registerWin(_16.contentWindow,_16);},registerWin:function(_17,_18){dojo.connect(_17.document,"onmousedown",function(evt){dijit._justMouseDowned=true;setTimeout(function(){dijit._justMouseDowned=false;},0);dijit._onTouchNode(_18||evt.target||evt.srcElement);});var doc=_17.document;if(doc){if(dojo.isIE){doc.attachEvent("onactivate",function(evt){if(evt.srcElement.tagName.toLowerCase()!="#document"){dijit._onFocusNode(_18||evt.srcElement);}});doc.attachEvent("ondeactivate",function(evt){dijit._onBlurNode(_18||evt.srcElement);});}else{doc.addEventListener("focus",function(evt){dijit._onFocusNode(_18||evt.target);},true);doc.addEventListener("blur",function(evt){dijit._onBlurNode(_18||evt.target);},true);}}doc=null;},_onBlurNode:function(_1f){dijit._prevFocus=dijit._curFocus;dijit._curFocus=null;if(dijit._justMouseDowned){return;}if(dijit._clearActiveWidgetsTimer){clearTimeout(dijit._clearActiveWidgetsTimer);}dijit._clearActiveWidgetsTimer=setTimeout(function(){delete dijit._clearActiveWidgetsTimer;dijit._setStack([]);dijit._prevFocus=null;},100);},_onTouchNode:function(_20){if(dijit._clearActiveWidgetsTimer){clearTimeout(dijit._clearActiveWidgetsTimer);delete dijit._clearActiveWidgetsTimer;}var _21=[];try{while(_20){if(_20.dijitPopupParent){_20=dijit.byId(_20.dijitPopupParent).domNode;}else{if(_20.tagName&&_20.tagName.toLowerCase()=="body"){if(_20===dojo.body()){break;}_20=dijit.getDocumentWindow(_20.ownerDocument).frameElement;}else{var id=_20.getAttribute&&_20.getAttribute("widgetId");if(id){_21.unshift(id);}_20=_20.parentNode;}}}}catch(e){}dijit._setStack(_21);},_onFocusNode:function(_23){if(!_23){return;}if(_23.nodeType==9){return;}dijit._onTouchNode(_23);if(_23==dijit._curFocus){return;}if(dijit._curFocus){dijit._prevFocus=dijit._curFocus;}dijit._curFocus=_23;dojo.publish("focusNode",[_23]);},_setStack:function(_24){var _25=dijit._activeStack;dijit._activeStack=_24;for(var _26=0;_26<Math.min(_25.length,_24.length);_26++){if(_25[_26]!=_24[_26]){break;}}for(var i=_25.length-1;i>=_26;i--){var _28=dijit.byId(_25[i]);if(_28){_28._focused=false;_28._hasBeenBlurred=true;if(_28._onBlur){_28._onBlur();}if(_28._setStateClass){_28._setStateClass();}dojo.publish("widgetBlur",[_28]);}}for(i=_26;i<_24.length;i++){_28=dijit.byId(_24[i]);if(_28){_28._focused=true;if(_28._onFocus){_28._onFocus();}if(_28._setStateClass){_28._setStateClass();}dojo.publish("widgetFocus",[_28]);}}}});dojo.addOnLoad(function(){dijit.registerWin(window);});}if(!dojo._hasResource["dijit._base.manager"]){dojo._hasResource["dijit._base.manager"]=true;dojo.provide("dijit._base.manager");dojo.declare("dijit.WidgetSet",null,{constructor:function(){this._hash={};},add:function(_29){if(this._hash[_29.id]){throw new Error("Tried to register widget with id=="+_29.id+" but that id is already registered");}this._hash[_29.id]=_29;},remove:function(id){delete this._hash[id];},forEach:function(_2b){for(var id in this._hash){_2b(this._hash[id]);}},filter:function(_2d){var res=new dijit.WidgetSet();this.forEach(function(_2f){if(_2d(_2f)){res.add(_2f);}});return res;},byId:function(id){return this._hash[id];},byClass:function(cls){return this.filter(function(_32){return _32.declaredClass==cls;});}});dijit.registry=new dijit.WidgetSet();dijit._widgetTypeCtr={};dijit.getUniqueId=function(_33){var id;do{id=_33+"_"+(_33 in dijit._widgetTypeCtr?++dijit._widgetTypeCtr[_33]:dijit._widgetTypeCtr[_33]=0);}while(dijit.byId(id));return id;};dijit.findWidgets=function(_35){var _36=[];function getChildrenHelper(_37){var _38=dojo.isIE?_37.children:_37.childNodes,i=0,_3a;while(_3a=_38[i++]){if(_3a.nodeType!=1){continue;}var _3b=_3a.getAttribute("widgetId");if(_3b){var _3c=dijit.byId(_3b);_36.push(_3c);}else{getChildrenHelper(_3a);}}};getChildrenHelper(_35);return _36;};if(dojo.isIE){dojo.addOnWindowUnload(function(){dojo.forEach(dijit.findWidgets(dojo.body()),function(_3d){if(_3d.destroyRecursive){_3d.destroyRecursive();}else{if(_3d.destroy){_3d.destroy();}}});});}dijit.byId=function(id){return (dojo.isString(id))?dijit.registry.byId(id):id;};dijit.byNode=function(_3f){return dijit.registry.byId(_3f.getAttribute("widgetId"));};dijit.getEnclosingWidget=function(_40){while(_40){if(_40.getAttribute&&_40.getAttribute("widgetId")){return dijit.registry.byId(_40.getAttribute("widgetId"));}_40=_40.parentNode;}return null;};dijit._tabElements={area:true,button:true,input:true,object:true,select:true,textarea:true};dijit._isElementShown=function(_41){var _42=dojo.style(_41);return (_42.visibility!="hidden")&&(_42.visibility!="collapsed")&&(_42.display!="none")&&(dojo.attr(_41,"type")!="hidden");};dijit.isTabNavigable=function(_43){if(dojo.hasAttr(_43,"disabled")){return false;}var _44=dojo.hasAttr(_43,"tabindex");var _45=dojo.attr(_43,"tabindex");if(_44&&_45>=0){return true;}var _46=_43.nodeName.toLowerCase();if(((_46=="a"&&dojo.hasAttr(_43,"href"))||dijit._tabElements[_46])&&(!_44||_45>=0)){return true;}return false;};dijit._getTabNavigable=function(_47){var _48,_49,_4a,_4b,_4c,_4d;var _4e=function(_4f){dojo.query("> *",_4f).forEach(function(_50){var _51=dijit._isElementShown(_50);if(_51&&dijit.isTabNavigable(_50)){var _52=dojo.attr(_50,"tabindex");if(!dojo.hasAttr(_50,"tabindex")||_52==0){if(!_48){_48=_50;}_49=_50;}else{if(_52>0){if(!_4a||_52<_4b){_4b=_52;_4a=_50;}if(!_4c||_52>=_4d){_4d=_52;_4c=_50;}}}}if(_51&&_50.nodeName.toUpperCase()!="SELECT"){_4e(_50);}});};if(dijit._isElementShown(_47)){_4e(_47);}return {first:_48,last:_49,lowest:_4a,highest:_4c};};dijit.getFirstInTabbingOrder=function(_53){var _54=dijit._getTabNavigable(dojo.byId(_53));return _54.lowest?_54.lowest:_54.first;};dijit.getLastInTabbingOrder=function(_55){var _56=dijit._getTabNavigable(dojo.byId(_55));return _56.last?_56.last:_56.highest;};dijit.defaultDuration=dojo.config["defaultDuration"]||200;}if(!dojo._hasResource["dojo.AdapterRegistry"]){dojo._hasResource["dojo.AdapterRegistry"]=true;dojo.provide("dojo.AdapterRegistry");dojo.AdapterRegistry=function(_57){this.pairs=[];this.returnWrappers=_57||false;};dojo.extend(dojo.AdapterRegistry,{register:function(_58,_59,_5a,_5b,_5c){this.pairs[((_5c)?"unshift":"push")]([_58,_59,_5a,_5b]);},match:function(){for(var i=0;i<this.pairs.length;i++){var _5e=this.pairs[i];if(_5e[1].apply(this,arguments)){if((_5e[3])||(this.returnWrappers)){return _5e[2];}else{return _5e[2].apply(this,arguments);}}}throw new Error("No match found");},unregister:function(_5f){for(var i=0;i<this.pairs.length;i++){var _61=this.pairs[i];if(_61[0]==_5f){this.pairs.splice(i,1);return true;}}return false;}});}if(!dojo._hasResource["dijit._base.place"]){dojo._hasResource["dijit._base.place"]=true;dojo.provide("dijit._base.place");dijit.getViewport=function(){var _62=(dojo.doc.compatMode=="BackCompat")?dojo.body():dojo.doc.documentElement;var _63=dojo._docScroll();return {w:_62.clientWidth,h:_62.clientHeight,l:_63.x,t:_63.y};};dijit.placeOnScreen=function(_64,pos,_66,_67){var _68=dojo.map(_66,function(_69){var c={corner:_69,pos:{x:pos.x,y:pos.y}};if(_67){c.pos.x+=_69.charAt(1)=="L"?_67.x:-_67.x;c.pos.y+=_69.charAt(0)=="T"?_67.y:-_67.y;}return c;});return dijit._place(_64,_68);};dijit._place=function(_6b,_6c,_6d){var _6e=dijit.getViewport();if(!_6b.parentNode||String(_6b.parentNode.tagName).toLowerCase()!="body"){dojo.body().appendChild(_6b);}var _6f=null;dojo.some(_6c,function(_70){var _71=_70.corner;var pos=_70.pos;if(_6d){_6d(_6b,_70.aroundCorner,_71);}var _73=_6b.style;var _74=_73.display;var _75=_73.visibility;_73.visibility="hidden";_73.display="";var mb=dojo.marginBox(_6b);_73.display=_74;_73.visibility=_75;var _77=(_71.charAt(1)=="L"?pos.x:Math.max(_6e.l,pos.x-mb.w)),_78=(_71.charAt(0)=="T"?pos.y:Math.max(_6e.t,pos.y-mb.h)),_79=(_71.charAt(1)=="L"?Math.min(_6e.l+_6e.w,_77+mb.w):pos.x),_7a=(_71.charAt(0)=="T"?Math.min(_6e.t+_6e.h,_78+mb.h):pos.y),_7b=_79-_77,_7c=_7a-_78,_7d=(mb.w-_7b)+(mb.h-_7c);if(_6f==null||_7d<_6f.overflow){_6f={corner:_71,aroundCorner:_70.aroundCorner,x:_77,y:_78,w:_7b,h:_7c,overflow:_7d};}return !_7d;});_6b.style.left=_6f.x+"px";_6b.style.top=_6f.y+"px";if(_6f.overflow&&_6d){_6d(_6b,_6f.aroundCorner,_6f.corner);}return _6f;};dijit.placeOnScreenAroundNode=function(_7e,_7f,_80,_81){_7f=dojo.byId(_7f);var _82=_7f.style.display;_7f.style.display="";var _83=_7f.offsetWidth;var _84=_7f.offsetHeight;var _85=dojo.coords(_7f,true);_7f.style.display=_82;return dijit._placeOnScreenAroundRect(_7e,_85.x,_85.y,_83,_84,_80,_81);};dijit.placeOnScreenAroundRectangle=function(_86,_87,_88,_89){return dijit._placeOnScreenAroundRect(_86,_87.x,_87.y,_87.width,_87.height,_88,_89);};dijit._placeOnScreenAroundRect=function(_8a,x,y,_8d,_8e,_8f,_90){var _91=[];for(var _92 in _8f){_91.push({aroundCorner:_92,corner:_8f[_92],pos:{x:x+(_92.charAt(1)=="L"?0:_8d),y:y+(_92.charAt(0)=="T"?0:_8e)}});}return dijit._place(_8a,_91,_90);};dijit.placementRegistry=new dojo.AdapterRegistry();dijit.placementRegistry.register("node",function(n,x){return typeof x=="object"&&typeof x.offsetWidth!="undefined"&&typeof x.offsetHeight!="undefined";},dijit.placeOnScreenAroundNode);dijit.placementRegistry.register("rect",function(n,x){return typeof x=="object"&&"x" in x&&"y" in x&&"width" in x&&"height" in x;},dijit.placeOnScreenAroundRectangle);dijit.placeOnScreenAroundElement=function(_97,_98,_99,_9a){return dijit.placementRegistry.match.apply(dijit.placementRegistry,arguments);};}if(!dojo._hasResource["dijit._base.window"]){dojo._hasResource["dijit._base.window"]=true;dojo.provide("dijit._base.window");dijit.getDocumentWindow=function(doc){if(dojo.isIE&&window!==document.parentWindow&&!doc._parentWindow){doc.parentWindow.execScript("document._parentWindow = window;","Javascript");var win=doc._parentWindow;doc._parentWindow=null;return win;}return doc._parentWindow||doc.parentWindow||doc.defaultView;};}if(!dojo._hasResource["dijit._base.popup"]){dojo._hasResource["dijit._base.popup"]=true;dojo.provide("dijit._base.popup");dijit.popup=new function(){var _9d=[],_9e=1000,_9f=1;this.prepare=function(_a0){var s=_a0.style;s.visibility="hidden";s.position="absolute";s.top="-9999px";if(s.display=="none"){s.display="";}dojo.body().appendChild(_a0);};this.open=function(_a2){var _a3=_a2.popup,_a4=_a2.orient||{"BL":"TL","TL":"BL"},_a5=_a2.around,id=(_a2.around&&_a2.around.id)?(_a2.around.id+"_dropdown"):("popup_"+_9f++);var _a7=dojo.create("div",{id:id,"class":"dijitPopup",style:{zIndex:_9e+_9d.length,visibility:"hidden"}},dojo.body());dijit.setWaiRole(_a7,"presentation");_a7.style.left=_a7.style.top="0px";if(_a2.parent){_a7.dijitPopupParent=_a2.parent.id;}var s=_a3.domNode.style;s.display="";s.visibility="";s.position="";s.top="0px";_a7.appendChild(_a3.domNode);var _a9=new dijit.BackgroundIframe(_a7);var _aa=_a5?dijit.placeOnScreenAroundElement(_a7,_a5,_a4,_a3.orient?dojo.hitch(_a3,"orient"):null):dijit.placeOnScreen(_a7,_a2,_a4=="R"?["TR","BR","TL","BL"]:["TL","BL","TR","BR"],_a2.padding);_a7.style.visibility="visible";var _ab=[];var _ac=function(){for(var pi=_9d.length-1;pi>0&&_9d[pi].parent===_9d[pi-1].widget;pi--){}return _9d[pi];};_ab.push(dojo.connect(_a7,"onkeypress",this,function(evt){if(evt.charOrCode==dojo.keys.ESCAPE&&_a2.onCancel){dojo.stopEvent(evt);_a2.onCancel();}else{if(evt.charOrCode===dojo.keys.TAB){dojo.stopEvent(evt);var _af=_ac();if(_af&&_af.onCancel){_af.onCancel();}}}}));if(_a3.onCancel){_ab.push(dojo.connect(_a3,"onCancel",null,_a2.onCancel));}_ab.push(dojo.connect(_a3,_a3.onExecute?"onExecute":"onChange",null,function(){var _b0=_ac();if(_b0&&_b0.onExecute){_b0.onExecute();}}));_9d.push({wrapper:_a7,iframe:_a9,widget:_a3,parent:_a2.parent,onExecute:_a2.onExecute,onCancel:_a2.onCancel,onClose:_a2.onClose,handlers:_ab});if(_a3.onOpen){_a3.onOpen(_aa);}return _aa;};this.close=function(_b1){while(dojo.some(_9d,function(_b2){return _b2.widget==_b1;})){var top=_9d.pop(),_b4=top.wrapper,_b5=top.iframe,_b6=top.widget,_b7=top.onClose;if(_b6.onClose){_b6.onClose();}dojo.forEach(top.handlers,dojo.disconnect);if(!_b6||!_b6.domNode){return;}this.prepare(_b6.domNode);_b5.destroy();dojo.destroy(_b4);if(_b7){_b7();}}};}();dijit._frames=new function(){var _b8=[];this.pop=function(){var _b9;if(_b8.length){_b9=_b8.pop();_b9.style.display="";}else{if(dojo.isIE){var _ba=dojo.config["dojoBlankHtmlUrl"]||(dojo.moduleUrl("dojo","resources/blank.html")+"")||"javascript:\"\"";var _bb="<iframe src='"+_ba+"'"+" style='position: absolute; left: 0px; top: 0px;"+"z-index: -1; filter:Alpha(Opacity=\"0\");'>";_b9=dojo.doc.createElement(_bb);}else{_b9=dojo.create("iframe");_b9.src="javascript:\"\"";_b9.className="dijitBackgroundIframe";}_b9.tabIndex=-1;dojo.body().appendChild(_b9);}return _b9;};this.push=function(_bc){_bc.style.display="none";if(dojo.isIE){_bc.style.removeExpression("width");_bc.style.removeExpression("height");}_b8.push(_bc);};}();dijit.BackgroundIframe=function(_bd){if(!_bd.id){throw new Error("no id");}if(dojo.isIE<7||(dojo.isFF<3&&dojo.hasClass(dojo.body(),"dijit_a11y"))){var _be=dijit._frames.pop();_bd.appendChild(_be);if(dojo.isIE){_be.style.setExpression("width",dojo._scopeName+".doc.getElementById('"+_bd.id+"').offsetWidth");_be.style.setExpression("height",dojo._scopeName+".doc.getElementById('"+_bd.id+"').offsetHeight");}this.iframe=_be;}};dojo.extend(dijit.BackgroundIframe,{destroy:function(){if(this.iframe){dijit._frames.push(this.iframe);delete this.iframe;}}});}if(!dojo._hasResource["dijit._base.scroll"]){dojo._hasResource["dijit._base.scroll"]=true;dojo.provide("dijit._base.scroll");dijit.scrollIntoView=function(_bf){try{_bf=dojo.byId(_bf);var doc=_bf.ownerDocument||dojo.doc;var _c1=doc.body||dojo.body();var _c2=doc.documentElement||_c1.parentNode;if((!(dojo.isFF>=3||dojo.isIE||dojo.isWebKit)||_bf==_c1||_bf==_c2)&&(typeof _bf.scrollIntoView=="function")){_bf.scrollIntoView(false);return;}var ltr=dojo._isBodyLtr();var _c4=dojo.isIE>=8&&!_c5;var rtl=!ltr&&!_c4;var _c7=_c1;var _c5=doc.compatMode=="BackCompat";if(_c5){_c2._offsetWidth=_c2._clientWidth=_c1._offsetWidth=_c1.clientWidth;_c2._offsetHeight=_c2._clientHeight=_c1._offsetHeight=_c1.clientHeight;}else{if(dojo.isWebKit){_c1._offsetWidth=_c1._clientWidth=_c2.clientWidth;_c1._offsetHeight=_c1._clientHeight=_c2.clientHeight;}else{_c7=_c2;}_c2._offsetHeight=_c2.clientHeight;_c2._offsetWidth=_c2.clientWidth;}function isFixedPosition(_c8){var ie=dojo.isIE;return ((ie<=6||(ie>=7&&_c5))?false:(dojo.style(_c8,"position").toLowerCase()=="fixed"));};function addPseudoAttrs(_ca){var _cb=_ca.parentNode;var _cc=_ca.offsetParent;if(_cc==null||isFixedPosition(_ca)){_cc=_c2;_cb=(_ca==_c1)?_c2:null;}_ca._offsetParent=_cc;_ca._parent=_cb;var bp=dojo._getBorderExtents(_ca);_ca._borderStart={H:(_c4&&!ltr)?(bp.w-bp.l):bp.l,V:bp.t};_ca._borderSize={H:bp.w,V:bp.h};_ca._scrolledAmount={H:_ca.scrollLeft,V:_ca.scrollTop};_ca._offsetSize={H:_ca._offsetWidth||_ca.offsetWidth,V:_ca._offsetHeight||_ca.offsetHeight};_ca._offsetStart={H:(_c4&&!ltr)?_cc.clientWidth-_ca.offsetLeft-_ca._offsetSize.H:_ca.offsetLeft,V:_ca.offsetTop};_ca._clientSize={H:_ca._clientWidth||_ca.clientWidth,V:_ca._clientHeight||_ca.clientHeight};if(_ca!=_c1&&_ca!=_c2&&_ca!=_bf){for(var dir in _ca._offsetSize){var _cf=_ca._offsetSize[dir]-_ca._clientSize[dir]-_ca._borderSize[dir];var _d0=_ca._clientSize[dir]>0&&_cf>0;if(_d0){_ca._offsetSize[dir]-=_cf;if(dojo.isIE&&rtl&&dir=="H"){_ca._offsetStart[dir]+=_cf;}}}}};var _d1=_bf;while(_d1!=null){if(isFixedPosition(_d1)){_bf.scrollIntoView(false);return;}addPseudoAttrs(_d1);_d1=_d1._parent;}if(dojo.isIE&&_bf._parent){var _d2=_bf._offsetParent;_bf._offsetStart.H+=_d2._borderStart.H;_bf._offsetStart.V+=_d2._borderStart.V;}if(dojo.isIE>=7&&_c7==_c2&&rtl&&_c1._offsetStart&&_c1._offsetStart.H==0){var _d3=_c2.scrollWidth-_c2._offsetSize.H;if(_d3>0){_c1._offsetStart.H=-_d3;}}if(dojo.isIE<=6&&!_c5){_c2._offsetSize.H+=_c2._borderSize.H;_c2._offsetSize.V+=_c2._borderSize.V;}if(rtl&&_c1._offsetStart&&_c7==_c2&&_c2._scrolledAmount){var ofs=_c1._offsetStart.H;if(ofs<0){_c2._scrolledAmount.H+=ofs;_c1._offsetStart.H=0;}}_d1=_bf;while(_d1){var _d5=_d1._parent;if(!_d5){break;}if(_d5.tagName=="TD"){var _d6=_d5._parent._parent._parent;if(_d5!=_d1._offsetParent&&_d5._offsetParent!=_d1._offsetParent){_d5=_d6;}}var _d7=_d1._offsetParent==_d5;for(var dir in _d1._offsetStart){var _d9=dir=="H"?"V":"H";if(rtl&&dir=="H"&&(_d5!=_c2)&&(_d5!=_c1)&&(dojo.isIE||dojo.isWebKit)&&_d5._clientSize.H>0&&_d5.scrollWidth>_d5._clientSize.H){var _da=_d5.scrollWidth-_d5._clientSize.H;if(_da>0){_d5._scrolledAmount.H-=_da;}}if(_d5._offsetParent.tagName=="TABLE"){if(dojo.isIE){_d5._offsetStart[dir]-=_d5._offsetParent._borderStart[dir];_d5._borderStart[dir]=_d5._borderSize[dir]=0;}else{_d5._offsetStart[dir]+=_d5._offsetParent._borderStart[dir];}}if(dojo.isIE){_d5._offsetStart[dir]+=_d5._offsetParent._borderStart[dir];}var _db=_d1._offsetStart[dir]-_d5._scrolledAmount[dir]-(_d7?0:_d5._offsetStart[dir])-_d5._borderStart[dir];var _dc=_db+_d1._offsetSize[dir]-_d5._offsetSize[dir]+_d5._borderSize[dir];var _dd=(dir=="H")?"scrollLeft":"scrollTop";var _de=dir=="H"&&rtl;var _df=_de?-_dc:_db;var _e0=_de?-_db:_dc;var _e1=(_df*_e0<=0)?0:Math[(_df<0)?"max":"min"](_df,_e0);if(_e1!=0){var _e2=_d5[_dd];_d5[_dd]+=(_de)?-_e1:_e1;var _e3=_d5[_dd]-_e2;}if(_d7){_d1._offsetStart[dir]+=_d5._offsetStart[dir];}_d1._offsetStart[dir]-=_d5[_dd];}_d1._parent=_d5._parent;_d1._offsetParent=_d5._offsetParent;}_d5=_bf;var _e4;while(_d5&&_d5.removeAttribute){_e4=_d5.parentNode;_d5.removeAttribute("_offsetParent");_d5.removeAttribute("_parent");_d5=_e4;}}catch(error){console.error("scrollIntoView: "+error);_bf.scrollIntoView(false);}};}if(!dojo._hasResource["dijit._base.sniff"]){dojo._hasResource["dijit._base.sniff"]=true;dojo.provide("dijit._base.sniff");(function(){var d=dojo,_e6=d.doc.documentElement,ie=d.isIE,_e8=d.isOpera,maj=Math.floor,ff=d.isFF,_eb=d.boxModel.replace(/-/,""),_ec={dj_ie:ie,dj_ie6:maj(ie)==6,dj_ie7:maj(ie)==7,dj_iequirks:ie&&d.isQuirks,dj_opera:_e8,dj_opera8:maj(_e8)==8,dj_opera9:maj(_e8)==9,dj_khtml:d.isKhtml,dj_webkit:d.isWebKit,dj_safari:d.isSafari,dj_gecko:d.isMozilla,dj_ff2:maj(ff)==2,dj_ff3:maj(ff)==3};_ec["dj_"+_eb]=true;for(var p in _ec){if(_ec[p]){if(_e6.className){_e6.className+=" "+p;}else{_e6.className=p;}}}dojo._loaders.unshift(function(){if(!dojo._isBodyLtr()){_e6.className+=" dijitRtl";for(var p in _ec){if(_ec[p]){_e6.className+=" "+p+"-rtl";}}}});})();}if(!dojo._hasResource["dijit._base.typematic"]){dojo._hasResource["dijit._base.typematic"]=true;dojo.provide("dijit._base.typematic");dijit.typematic={_fireEventAndReload:function(){this._timer=null;this._callback(++this._count,this._node,this._evt);this._currentTimeout=(this._currentTimeout<0)?this._initialDelay:((this._subsequentDelay>1)?this._subsequentDelay:Math.round(this._currentTimeout*this._subsequentDelay));this._timer=setTimeout(dojo.hitch(this,"_fireEventAndReload"),this._currentTimeout);},trigger:function(evt,_f0,_f1,_f2,obj,_f4,_f5){if(obj!=this._obj){this.stop();this._initialDelay=_f5||500;this._subsequentDelay=_f4||0.9;this._obj=obj;this._evt=evt;this._node=_f1;this._currentTimeout=-1;this._count=-1;this._callback=dojo.hitch(_f0,_f2);this._fireEventAndReload();}},stop:function(){if(this._timer){clearTimeout(this._timer);this._timer=null;}if(this._obj){this._callback(-1,this._node,this._evt);this._obj=null;}},addKeyListener:function(_f6,_f7,_f8,_f9,_fa,_fb){if(_f7.keyCode){_f7.charOrCode=_f7.keyCode;dojo.deprecated("keyCode attribute parameter for dijit.typematic.addKeyListener is deprecated. Use charOrCode instead.","","2.0");}else{if(_f7.charCode){_f7.charOrCode=String.fromCharCode(_f7.charCode);dojo.deprecated("charCode attribute parameter for dijit.typematic.addKeyListener is deprecated. Use charOrCode instead.","","2.0");}}return [dojo.connect(_f6,"onkeypress",this,function(evt){if(evt.charOrCode==_f7.charOrCode&&(_f7.ctrlKey===undefined||_f7.ctrlKey==evt.ctrlKey)&&(_f7.altKey===undefined||_f7.altKey==evt.ctrlKey)&&(_f7.shiftKey===undefined||_f7.shiftKey==evt.ctrlKey)){dojo.stopEvent(evt);dijit.typematic.trigger(_f7,_f8,_f6,_f9,_f7,_fa,_fb);}else{if(dijit.typematic._obj==_f7){dijit.typematic.stop();}}}),dojo.connect(_f6,"onkeyup",this,function(evt){if(dijit.typematic._obj==_f7){dijit.typematic.stop();}})];},addMouseListener:function(_fe,_ff,_100,_101,_102){var dc=dojo.connect;return [dc(_fe,"mousedown",this,function(evt){dojo.stopEvent(evt);dijit.typematic.trigger(evt,_ff,_fe,_100,_fe,_101,_102);}),dc(_fe,"mouseup",this,function(evt){dojo.stopEvent(evt);dijit.typematic.stop();}),dc(_fe,"mouseout",this,function(evt){dojo.stopEvent(evt);dijit.typematic.stop();}),dc(_fe,"mousemove",this,function(evt){dojo.stopEvent(evt);}),dc(_fe,"dblclick",this,function(evt){dojo.stopEvent(evt);if(dojo.isIE){dijit.typematic.trigger(evt,_ff,_fe,_100,_fe,_101,_102);setTimeout(dojo.hitch(this,dijit.typematic.stop),50);}})];},addListener:function(_109,_10a,_10b,_10c,_10d,_10e,_10f){return this.addKeyListener(_10a,_10b,_10c,_10d,_10e,_10f).concat(this.addMouseListener(_109,_10c,_10d,_10e,_10f));}};}if(!dojo._hasResource["dijit._base.wai"]){dojo._hasResource["dijit._base.wai"]=true;dojo.provide("dijit._base.wai");dijit.wai={onload:function(){var div=dojo.create("div",{id:"a11yTestNode",style:{cssText:"border: 1px solid;"+"border-color:red green;"+"position: absolute;"+"height: 5px;"+"top: -999px;"+"background-image: url(\""+(dojo.config.blankGif||dojo.moduleUrl("dojo","resources/blank.gif"))+"\");"}},dojo.body());var cs=dojo.getComputedStyle(div);if(cs){var _112=cs.backgroundImage;var _113=(cs.borderTopColor==cs.borderRightColor)||(_112!=null&&(_112=="none"||_112=="url(invalid-url:)"));dojo[_113?"addClass":"removeClass"](dojo.body(),"dijit_a11y");if(dojo.isIE){div.outerHTML="";}else{dojo.body().removeChild(div);}}}};if(dojo.isIE||dojo.isMoz){dojo._loaders.unshift(dijit.wai.onload);}dojo.mixin(dijit,{_XhtmlRoles:/banner|contentinfo|definition|main|navigation|search|note|secondary|seealso/,hasWaiRole:function(elem,role){var _116=this.getWaiRole(elem);return role?(_116.indexOf(role)>-1):(_116.length>0);},getWaiRole:function(elem){return dojo.trim((dojo.attr(elem,"role")||"").replace(this._XhtmlRoles,"").replace("wairole:",""));},setWaiRole:function(elem,role){var _11a=dojo.attr(elem,"role")||"";if(dojo.isFF<3||!this._XhtmlRoles.test(_11a)){dojo.attr(elem,"role",dojo.isFF<3?"wairole:"+role:role);}else{if((" "+_11a+" ").indexOf(" "+role+" ")<0){var _11b=dojo.trim(_11a.replace(this._XhtmlRoles,""));var _11c=dojo.trim(_11a.replace(_11b,""));dojo.attr(elem,"role",_11c+(_11c?" ":"")+role);}}},removeWaiRole:function(elem,role){var _11f=dojo.attr(elem,"role");if(!_11f){return;}if(role){var _120=dojo.isFF<3?"wairole:"+role:role;var t=dojo.trim((" "+_11f+" ").replace(" "+_120+" "," "));dojo.attr(elem,"role",t);}else{elem.removeAttribute("role");}},hasWaiState:function(elem,_123){if(dojo.isFF<3){return elem.hasAttributeNS("http://www.w3.org/2005/07/aaa",_123);}return elem.hasAttribute?elem.hasAttribute("aria-"+_123):!!elem.getAttribute("aria-"+_123);},getWaiState:function(elem,_125){if(dojo.isFF<3){return elem.getAttributeNS("http://www.w3.org/2005/07/aaa",_125);}return elem.getAttribute("aria-"+_125)||"";},setWaiState:function(elem,_127,_128){if(dojo.isFF<3){elem.setAttributeNS("http://www.w3.org/2005/07/aaa","aaa:"+_127,_128);}else{elem.setAttribute("aria-"+_127,_128);}},removeWaiState:function(elem,_12a){if(dojo.isFF<3){elem.removeAttributeNS("http://www.w3.org/2005/07/aaa",_12a);}else{elem.removeAttribute("aria-"+_12a);}}});}if(!dojo._hasResource["dijit._base"]){dojo._hasResource["dijit._base"]=true;dojo.provide("dijit._base");}if(!dojo._hasResource["dijit._Widget"]){dojo._hasResource["dijit._Widget"]=true;dojo.provide("dijit._Widget");dojo.require("dijit._base");dojo.connect(dojo,"connect",function(_12b,_12c){if(_12b&&dojo.isFunction(_12b._onConnect)){_12b._onConnect(_12c);}});dijit._connectOnUseEventHandler=function(_12d){};dijit._lastKeyDownNode=null;if(dojo.isIE){dojo.doc.attachEvent("onkeydown",function(evt){dijit._lastKeyDownNode=evt.srcElement;});}else{dojo.doc.addEventListener("keydown",function(evt){dijit._lastKeyDownNode=evt.target;},true);}(function(){var _130={};var _131=function(dc){if(!_130[dc]){var r=[];var _134;var _135=dojo.getObject(dc).prototype;for(var _136 in _135){if(dojo.isFunction(_135[_136])&&(_134=_136.match(/^_set([a-zA-Z]*)Attr$/))&&_134[1]){r.push(_134[1].charAt(0).toLowerCase()+_134[1].substr(1));}}_130[dc]=r;}return _130[dc]||[];};dojo.declare("dijit._Widget",null,{id:"",lang:"",dir:"","class":"",style:"",title:"",srcNodeRef:null,domNode:null,containerNode:null,attributeMap:{id:"",dir:"",lang:"","class":"",style:"",title:""},_deferredConnects:{onClick:"",onDblClick:"",onKeyDown:"",onKeyPress:"",onKeyUp:"",onMouseMove:"",onMouseDown:"",onMouseOut:"",onMouseOver:"",onMouseLeave:"",onMouseEnter:"",onMouseUp:""},onClick:dijit._connectOnUseEventHandler,onDblClick:dijit._connectOnUseEventHandler,onKeyDown:dijit._connectOnUseEventHandler,onKeyPress:dijit._connectOnUseEventHandler,onKeyUp:dijit._connectOnUseEventHandler,onMouseDown:dijit._connectOnUseEventHandler,onMouseMove:dijit._connectOnUseEventHandler,onMouseOut:dijit._connectOnUseEventHandler,onMouseOver:dijit._connectOnUseEventHandler,onMouseLeave:dijit._connectOnUseEventHandler,onMouseEnter:dijit._connectOnUseEventHandler,onMouseUp:dijit._connectOnUseEventHandler,_blankGif:(dojo.config.blankGif||dojo.moduleUrl("dojo","resources/blank.gif")),postscript:function(_137,_138){this.create(_137,_138);},create:function(_139,_13a){this.srcNodeRef=dojo.byId(_13a);this._connects=[];this._deferredConnects=dojo.clone(this._deferredConnects);for(var attr in this.attributeMap){delete this._deferredConnects[attr];}for(attr in this._deferredConnects){if(this[attr]!==dijit._connectOnUseEventHandler){delete this._deferredConnects[attr];}}if(this.srcNodeRef&&(typeof this.srcNodeRef.id=="string")){this.id=this.srcNodeRef.id;}if(_139){this.params=_139;dojo.mixin(this,_139);}this.postMixInProperties();if(!this.id){this.id=dijit.getUniqueId(this.declaredClass.replace(/\./g,"_"));}dijit.registry.add(this);this.buildRendering();if(this.domNode){this._applyAttributes();var _13c=this.srcNodeRef;if(_13c&&_13c.parentNode){_13c.parentNode.replaceChild(this.domNode,_13c);}for(attr in this.params){this._onConnect(attr);}}if(this.domNode){this.domNode.setAttribute("widgetId",this.id);}this.postCreate();if(this.srcNodeRef&&!this.srcNodeRef.parentNode){delete this.srcNodeRef;}this._created=true;},_applyAttributes:function(){var _13d=function(attr,_13f){if((_13f.params&&attr in _13f.params)||_13f[attr]){_13f.attr(attr,_13f[attr]);}};for(var attr in this.attributeMap){_13d(attr,this);}dojo.forEach(_131(this.declaredClass),function(a){if(!(a in this.attributeMap)){_13d(a,this);}},this);},postMixInProperties:function(){},buildRendering:function(){this.domNode=this.srcNodeRef||dojo.create("div");},postCreate:function(){},startup:function(){this._started=true;},destroyRecursive:function(_142){this.destroyDescendants(_142);this.destroy(_142);},destroy:function(_143){this.uninitialize();dojo.forEach(this._connects,function(_144){dojo.forEach(_144,dojo.disconnect);});dojo.forEach(this._supportingWidgets||[],function(w){if(w.destroy){w.destroy();}});this.destroyRendering(_143);dijit.registry.remove(this.id);},destroyRendering:function(_146){if(this.bgIframe){this.bgIframe.destroy(_146);delete this.bgIframe;}if(this.domNode){if(_146){dojo.removeAttr(this.domNode,"widgetId");}else{dojo.destroy(this.domNode);}delete this.domNode;}if(this.srcNodeRef){if(!_146){dojo.destroy(this.srcNodeRef);}delete this.srcNodeRef;}},destroyDescendants:function(_147){dojo.forEach(this.getChildren(),function(_148){if(_148.destroyRecursive){_148.destroyRecursive(_147);}});},uninitialize:function(){return false;},onFocus:function(){},onBlur:function(){},_onFocus:function(e){this.onFocus();},_onBlur:function(){this.onBlur();},_onConnect:function(_14a){if(_14a in this._deferredConnects){var _14b=this[this._deferredConnects[_14a]||"domNode"];this.connect(_14b,_14a.toLowerCase(),_14a);delete this._deferredConnects[_14a];}},_setClassAttr:function(_14c){var _14d=this[this.attributeMap["class"]||"domNode"];dojo.removeClass(_14d,this["class"]);this["class"]=_14c;dojo.addClass(_14d,_14c);},_setStyleAttr:function(_14e){var _14f=this[this.attributeMap["style"]||"domNode"];if(dojo.isObject(_14e)){dojo.style(_14f,_14e);}else{if(_14f.style.cssText){_14f.style.cssText+="; "+_14e;}else{_14f.style.cssText=_14e;}}this["style"]=_14e;},setAttribute:function(attr,_151){dojo.deprecated(this.declaredClass+"::setAttribute() is deprecated. Use attr() instead.","","2.0");this.attr(attr,_151);},_attrToDom:function(attr,_153){var _154=this.attributeMap[attr];dojo.forEach(dojo.isArray(_154)?_154:[_154],function(_155){var _156=this[_155.node||_155||"domNode"];var type=_155.type||"attribute";switch(type){case "attribute":if(dojo.isFunction(_153)){_153=dojo.hitch(this,_153);}if(/^on[A-Z][a-zA-Z]*$/.test(attr)){attr=attr.toLowerCase();}dojo.attr(_156,attr,_153);break;case "innerHTML":_156.innerHTML=_153;break;case "class":dojo.removeClass(_156,this[attr]);dojo.addClass(_156,_153);break;}},this);this[attr]=_153;},attr:function(name,_159){var args=arguments.length;if(args==1&&!dojo.isString(name)){for(var x in name){this.attr(x,name[x]);}return this;}var _15c=this._getAttrNames(name);if(args==2){if(this[_15c.s]){return this[_15c.s](_159)||this;}else{if(name in this.attributeMap){this._attrToDom(name,_159);}this[name]=_159;}return this;}else{if(this[_15c.g]){return this[_15c.g]();}else{return this[name];}}},_attrPairNames:{},_getAttrNames:function(name){var apn=this._attrPairNames;if(apn[name]){return apn[name];}var uc=name.charAt(0).toUpperCase()+name.substr(1);return apn[name]={n:name+"Node",s:"_set"+uc+"Attr",g:"_get"+uc+"Attr"};},toString:function(){return "[Widget "+this.declaredClass+", "+(this.id||"NO ID")+"]";},getDescendants:function(){if(this.containerNode){var list=dojo.query("[widgetId]",this.containerNode);return list.map(dijit.byNode);}else{return [];}},getChildren:function(){if(this.containerNode){return dijit.findWidgets(this.containerNode);}else{return [];}},nodesWithKeyClick:["input","button"],connect:function(obj,_162,_163){var d=dojo;var dc=dojo.connect;var _166=[];if(_162=="ondijitclick"){if(!this.nodesWithKeyClick[obj.tagName.toLowerCase()]){var m=d.hitch(this,_163);_166.push(dc(obj,"onkeydown",this,function(e){if((e.keyCode==d.keys.ENTER||e.keyCode==d.keys.SPACE)&&!e.ctrlKey&&!e.shiftKey&&!e.altKey&&!e.metaKey){dijit._lastKeyDownNode=e.target;d.stopEvent(e);}}),dc(obj,"onkeyup",this,function(e){if((e.keyCode==d.keys.ENTER||e.keyCode==d.keys.SPACE)&&e.target===dijit._lastKeyDownNode&&!e.ctrlKey&&!e.shiftKey&&!e.altKey&&!e.metaKey){dijit._lastKeyDownNode=null;return m(e);}}));}_162="onclick";}_166.push(dc(obj,_162,this,_163));this._connects.push(_166);return _166;},disconnect:function(_16a){for(var i=0;i<this._connects.length;i++){if(this._connects[i]==_16a){dojo.forEach(_16a,dojo.disconnect);this._connects.splice(i,1);return;}}},isLeftToRight:function(){return dojo._isBodyLtr();},isFocusable:function(){return this.focus&&(dojo.style(this.domNode,"display")!="none");},placeAt:function(_16c,_16d){if(_16c["declaredClass"]&&_16c["addChild"]){_16c.addChild(this,_16d);}else{dojo.place(this.domNode,_16c,_16d);}return this;}});})();}if(!dojo._hasResource["dijit._Templated"]){dojo._hasResource["dijit._Templated"]=true;dojo.provide("dijit._Templated");dojo.declare("dijit._Templated",null,{templateString:null,templatePath:null,widgetsInTemplate:false,_skipNodeCache:false,_stringRepl:function(tmpl){var _16f=this.declaredClass,_170=this;return dojo.string.substitute(tmpl,this,function(_171,key){if(key.charAt(0)=="!"){_171=dojo.getObject(key.substr(1),false,_170);}if(typeof _171=="undefined"){throw new Error(_16f+" template:"+key);}if(_171==null){return "";}return key.charAt(0)=="!"?_171:_171.toString().replace(/"/g,"&quot;");},this);},buildRendering:function(){var _173=dijit._Templated.getCachedTemplate(this.templatePath,this.templateString,this._skipNodeCache);var node;if(dojo.isString(_173)){node=dojo._toDom(this._stringRepl(_173));}else{node=_173.cloneNode(true);}this.domNode=node;this._attachTemplateNodes(node);if(this.widgetsInTemplate){var _175=dojo.parser,qry,attr;if(_175._query!="[dojoType]"){qry=_175._query;attr=_175._attrName;_175._query="[dojoType]";_175._attrName="dojoType";}var cw=(this._supportingWidgets=dojo.parser.parse(node));if(qry){_175._query=qry;_175._attrName=attr;}this._attachTemplateNodes(cw,function(n,p){return n[p];});}this._fillContent(this.srcNodeRef);},_fillContent:function(_17b){var dest=this.containerNode;if(_17b&&dest){while(_17b.hasChildNodes()){dest.appendChild(_17b.firstChild);}}},_attachTemplateNodes:function(_17d,_17e){_17e=_17e||function(n,p){return n.getAttribute(p);};var _181=dojo.isArray(_17d)?_17d:(_17d.all||_17d.getElementsByTagName("*"));var x=dojo.isArray(_17d)?0:-1;for(;x<_181.length;x++){var _183=(x==-1)?_17d:_181[x];if(this.widgetsInTemplate&&_17e(_183,"dojoType")){continue;}var _184=_17e(_183,"dojoAttachPoint");if(_184){var _185,_186=_184.split(/\s*,\s*/);while((_185=_186.shift())){if(dojo.isArray(this[_185])){this[_185].push(_183);}else{this[_185]=_183;}}}var _187=_17e(_183,"dojoAttachEvent");if(_187){var _188,_189=_187.split(/\s*,\s*/);var trim=dojo.trim;while((_188=_189.shift())){if(_188){var _18b=null;if(_188.indexOf(":")!=-1){var _18c=_188.split(":");_188=trim(_18c[0]);_18b=trim(_18c[1]);}else{_188=trim(_188);}if(!_18b){_18b=_188;}this.connect(_183,_188,_18b);}}}var role=_17e(_183,"waiRole");if(role){dijit.setWaiRole(_183,role);}var _18e=_17e(_183,"waiState");if(_18e){dojo.forEach(_18e.split(/\s*,\s*/),function(_18f){if(_18f.indexOf("-")!=-1){var pair=_18f.split("-");dijit.setWaiState(_183,pair[0],pair[1]);}});}}}});dijit._Templated._templateCache={};dijit._Templated.getCachedTemplate=function(_191,_192,_193){var _194=dijit._Templated._templateCache;var key=_192||_191;var _196=_194[key];if(_196){if(!_196.ownerDocument||_196.ownerDocument==dojo.doc){return _196;}dojo.destroy(_196);}if(!_192){_192=dijit._Templated._sanitizeTemplateString(dojo.trim(dojo._getText(_191)));}_192=dojo.string.trim(_192);if(_193||_192.match(/\$\{([^\}]+)\}/g)){return (_194[key]=_192);}else{return (_194[key]=dojo._toDom(_192));}};dijit._Templated._sanitizeTemplateString=function(_197){if(_197){_197=_197.replace(/^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im,"");var _198=_197.match(/<body[^>]*>\s*([\s\S]+)\s*<\/body>/im);if(_198){_197=_198[1];}}else{_197="";}return _197;};if(dojo.isIE){dojo.addOnWindowUnload(function(){var _199=dijit._Templated._templateCache;for(var key in _199){var _19b=_199[key];if(!isNaN(_19b.nodeType)){dojo.destroy(_19b);}delete _199[key];}});}dojo.extend(dijit._Widget,{dojoAttachEvent:"",dojoAttachPoint:"",waiRole:"",waiState:""});}if(!dojo._hasResource["com.ibm.widgets.TemplateCleaner"]){dojo._hasResource["com.ibm.widgets.TemplateCleaner"]=true;dojo.provide("com.ibm.widgets.TemplateCleaner");dojo.extend(dijit._Templated,{destroyRecursive:function(_19c){if(this._destroyed){return;}this.inherited("destroyRecursive",arguments);},destroy:function(_19d,_19e){if(this._destroyed){return;}this._destroyed=true;this.inherited("destroy",arguments);dojo.forEach(this._attachPoints,function(_19f){this[_19f]=null;},this);this._attachPoints=[];},_oldAttachTemplateNodes:dijit._Templated.prototype._attachTemplateNodes,_attachTemplateNodes:function(_1a0,func){var res=this._oldAttachTemplateNodes.apply(this,arguments);func=func?func:function(node,attr){return node.getAttribute(attr);};var _1a5=dojo.isArray(_1a0)?_1a0:[_1a0];if(!this._attachPoints){this._attachPoints=[];}dojo.forEach(_1a5,function(node){var _1a7=null;if(node.domNode){_1a7=[node];}else{_1a7=dojo.query("[dojoAttachPoint]",node);}dojo.forEach(_1a7,function(_1a8){var _1a9=func(_1a8,"dojoAttachPoint"),_1aa=_1a9.split(/\s*,\s*/mg);dojo.forEach(_1aa,function(_1ab){this._attachPoints.push(_1ab);},this);},this);},this);return res;}});}if(!dojo._hasResource["dijit._Container"]){dojo._hasResource["dijit._Container"]=true;dojo.provide("dijit._Container");dojo.declare("dijit._Container",null,{isContainer:true,buildRendering:function(){this.inherited(arguments);if(!this.containerNode){this.containerNode=this.domNode;}},addChild:function(_1ac,_1ad){var _1ae=this.containerNode;if(_1ad&&typeof _1ad=="number"){var _1af=this.getChildren();if(_1af&&_1af.length>=_1ad){_1ae=_1af[_1ad-1].domNode;_1ad="after";}}dojo.place(_1ac.domNode,_1ae,_1ad);if(this._started&&!_1ac._started){_1ac.startup();}},removeChild:function(_1b0){if(typeof _1b0=="number"&&_1b0>0){_1b0=this.getChildren()[_1b0];}if(!_1b0||!_1b0.domNode){return;}var node=_1b0.domNode;node.parentNode.removeChild(node);},_nextElement:function(node){do{node=node.nextSibling;}while(node&&node.nodeType!=1);return node;},_firstElement:function(node){node=node.firstChild;if(node&&node.nodeType!=1){node=this._nextElement(node);}return node;},getChildren:function(){return dojo.query("> [widgetId]",this.containerNode).map(dijit.byNode);},hasChildren:function(){return !!this._firstElement(this.containerNode);},destroyDescendants:function(_1b4){dojo.forEach(this.getChildren(),function(_1b5){_1b5.destroyRecursive(_1b4);});},_getSiblingOfChild:function(_1b6,dir){var node=_1b6.domNode;var _1b9=(dir>0?"nextSibling":"previousSibling");do{node=node[_1b9];}while(node&&(node.nodeType!=1||!dijit.byNode(node)));return node?dijit.byNode(node):null;},getIndexOfChild:function(_1ba){var _1bb=this.getChildren();for(var i=0,c;c=_1bb[i];i++){if(c==_1ba){return i;}}return -1;}});}if(!dojo._hasResource["dijit._Contained"]){dojo._hasResource["dijit._Contained"]=true;dojo.provide("dijit._Contained");dojo.declare("dijit._Contained",null,{getParent:function(){for(var p=this.domNode.parentNode;p;p=p.parentNode){var id=p.getAttribute&&p.getAttribute("widgetId");if(id){var _1c0=dijit.byId(id);return _1c0.isContainer?_1c0:null;}}return null;},_getSibling:function(_1c1){var node=this.domNode;do{node=node[_1c1+"Sibling"];}while(node&&node.nodeType!=1);if(!node){return null;}var id=node.getAttribute("widgetId");return dijit.byId(id);},getPreviousSibling:function(){return this._getSibling("previous");},getNextSibling:function(){return this._getSibling("next");},getIndexInParent:function(){var p=this.getParent();if(!p||!p.getIndexOfChild){return -1;}return p.getIndexOfChild(this);}});}if(!dojo._hasResource["dijit.layout._LayoutWidget"]){dojo._hasResource["dijit.layout._LayoutWidget"]=true;dojo.provide("dijit.layout._LayoutWidget");dojo.declare("dijit.layout._LayoutWidget",[dijit._Widget,dijit._Container,dijit._Contained],{baseClass:"dijitLayoutContainer",isLayoutContainer:true,postCreate:function(){dojo.addClass(this.domNode,"dijitContainer");dojo.addClass(this.domNode,this.baseClass);},startup:function(){if(this._started){return;}dojo.forEach(this.getChildren(),function(_1c5){_1c5.startup();});if(!this.getParent||!this.getParent()){this.resize();this._viewport=dijit.getViewport();this.connect(dojo.global,"onresize",function(){var _1c6=dijit.getViewport();if(_1c6.w!=this._viewport.w||_1c6.h!=this._viewport.h){this._viewport=_1c6;this.resize();}});}this.inherited(arguments);},resize:function(_1c7,_1c8){var node=this.domNode;if(_1c7){dojo.marginBox(node,_1c7);if(_1c7.t){node.style.top=_1c7.t+"px";}if(_1c7.l){node.style.left=_1c7.l+"px";}}var mb=_1c8||{};dojo.mixin(mb,_1c7||{});if(!("h" in mb)||!("w" in mb)){mb=dojo.mixin(dojo.marginBox(node),mb);}var cs=dojo.getComputedStyle(node);var me=dojo._getMarginExtents(node,cs);var be=dojo._getBorderExtents(node,cs);var bb=(this._borderBox={w:mb.w-(me.w+be.w),h:mb.h-(me.h+be.h)});var pe=dojo._getPadExtents(node,cs);this._contentBox={l:dojo._toPixelValue(node,cs.paddingLeft),t:dojo._toPixelValue(node,cs.paddingTop),w:bb.w-pe.w,h:bb.h-pe.h};this.layout();},layout:function(){},_setupChild:function(_1d0){dojo.addClass(_1d0.domNode,this.baseClass+"-child");if(_1d0.baseClass){dojo.addClass(_1d0.domNode,this.baseClass+"-"+_1d0.baseClass);}},addChild:function(_1d1,_1d2){this.inherited(arguments);if(this._started){this._setupChild(_1d1);}},removeChild:function(_1d3){dojo.removeClass(_1d3.domNode,this.baseClass+"-child");if(_1d3.baseClass){dojo.removeClass(_1d3.domNode,this.baseClass+"-"+_1d3.baseClass);}this.inherited(arguments);}});dijit.layout.marginBox2contentBox=function(node,mb){var cs=dojo.getComputedStyle(node);var me=dojo._getMarginExtents(node,cs);var pb=dojo._getPadBorderExtents(node,cs);return {l:dojo._toPixelValue(node,cs.paddingLeft),t:dojo._toPixelValue(node,cs.paddingTop),w:mb.w-(me.w+pb.w),h:mb.h-(me.h+pb.h)};};(function(){var _1d9=function(word){return word.substring(0,1).toUpperCase()+word.substring(1);};var size=function(_1dc,dim){_1dc.resize?_1dc.resize(dim):dojo.marginBox(_1dc.domNode,dim);dojo.mixin(_1dc,dojo.marginBox(_1dc.domNode));dojo.mixin(_1dc,dim);};dijit.layout.layoutChildren=function(_1de,dim,_1e0){dim=dojo.mixin({},dim);dojo.addClass(_1de,"dijitLayoutContainer");_1e0=dojo.filter(_1e0,function(item){return item.layoutAlign!="client";}).concat(dojo.filter(_1e0,function(item){return item.layoutAlign=="client";}));dojo.forEach(_1e0,function(_1e3){var elm=_1e3.domNode,pos=_1e3.layoutAlign;var _1e6=elm.style;_1e6.left=dim.l+"px";_1e6.top=dim.t+"px";_1e6.bottom=_1e6.right="auto";dojo.addClass(elm,"dijitAlign"+_1d9(pos));if(pos=="top"||pos=="bottom"){size(_1e3,{w:dim.w});dim.h-=_1e3.h;if(pos=="top"){dim.t+=_1e3.h;}else{_1e6.top=dim.t+dim.h+"px";}}else{if(pos=="left"||pos=="right"){size(_1e3,{h:dim.h});dim.w-=_1e3.w;if(pos=="left"){dim.l+=_1e3.w;}else{_1e6.left=dim.l+dim.w+"px";}}else{if(pos=="client"){size(_1e3,dim);}}}});};})();}if(!dojo._hasResource["dijit.form._FormWidget"]){dojo._hasResource["dijit.form._FormWidget"]=true;dojo.provide("dijit.form._FormWidget");dojo.declare("dijit.form._FormWidget",[dijit._Widget,dijit._Templated],{baseClass:"",name:"",alt:"",value:"",type:"text",tabIndex:"0",disabled:false,readOnly:false,intermediateChanges:false,scrollOnFocus:true,attributeMap:dojo.delegate(dijit._Widget.prototype.attributeMap,{value:"focusNode",disabled:"focusNode",readOnly:"focusNode",id:"focusNode",tabIndex:"focusNode",alt:"focusNode"}),postMixInProperties:function(){this.nameAttrSetting=this.name?("name='"+this.name+"'"):"";this.inherited(arguments);},_setDisabledAttr:function(_1e7){this.disabled=_1e7;dojo.attr(this.focusNode,"disabled",_1e7);dijit.setWaiState(this.focusNode,"disabled",_1e7);if(_1e7){this._hovering=false;this._active=false;this.focusNode.removeAttribute("tabIndex");}else{this.focusNode.setAttribute("tabIndex",this.tabIndex);}this._setStateClass();},setDisabled:function(_1e8){dojo.deprecated("setDisabled("+_1e8+") is deprecated. Use attr('disabled',"+_1e8+") instead.","","2.0");this.attr("disabled",_1e8);},_onFocus:function(e){if(this.scrollOnFocus){dijit.scrollIntoView(this.domNode);}this.inherited(arguments);},_onMouse:function(_1ea){var _1eb=_1ea.currentTarget;if(_1eb&&_1eb.getAttribute){this.stateModifier=_1eb.getAttribute("stateModifier")||"";}if(!this.disabled){switch(_1ea.type){case "mouseenter":case "mouseover":this._hovering=true;this._active=this._mouseDown;break;case "mouseout":case "mouseleave":this._hovering=false;this._active=false;break;case "mousedown":this._active=true;this._mouseDown=true;var _1ec=this.connect(dojo.body(),"onmouseup",function(){if(this._mouseDown&&this.isFocusable()){this.focus();}this._active=false;this._mouseDown=false;this._setStateClass();this.disconnect(_1ec);});break;}this._setStateClass();}},isFocusable:function(){return !this.disabled&&!this.readOnly&&this.focusNode&&(dojo.style(this.domNode,"display")!="none");},focus:function(){dijit.focus(this.focusNode);},_setStateClass:function(){var _1ed=this.baseClass.split(" ");function multiply(_1ee){_1ed=_1ed.concat(dojo.map(_1ed,function(c){return c+_1ee;}),"dijit"+_1ee);};if(this.checked){multiply("Checked");}if(this.state){multiply(this.state);}if(this.selected){multiply("Selected");}if(this.disabled){multiply("Disabled");}else{if(this.readOnly){multiply("ReadOnly");}else{if(this._active){multiply(this.stateModifier+"Active");}else{if(this._focused){multiply("Focused");}if(this._hovering){multiply(this.stateModifier+"Hover");}}}}var tn=this.stateNode||this.domNode,_1f1={};dojo.forEach(tn.className.split(" "),function(c){_1f1[c]=true;});if("_stateClasses" in this){dojo.forEach(this._stateClasses,function(c){delete _1f1[c];});}dojo.forEach(_1ed,function(c){_1f1[c]=true;});var _1f5=[];for(var c in _1f1){_1f5.push(c);}tn.className=_1f5.join(" ");this._stateClasses=_1ed;},compare:function(val1,val2){if((typeof val1=="number")&&(typeof val2=="number")){return (isNaN(val1)&&isNaN(val2))?0:(val1-val2);}else{if(val1>val2){return 1;}else{if(val1<val2){return -1;}else{return 0;}}}},onChange:function(_1f9){},_onChangeActive:false,_handleOnChange:function(_1fa,_1fb){this._lastValue=_1fa;if(this._lastValueReported==undefined&&(_1fb===null||!this._onChangeActive)){this._resetValue=this._lastValueReported=_1fa;}if((this.intermediateChanges||_1fb||_1fb===undefined)&&((typeof _1fa!=typeof this._lastValueReported)||this.compare(_1fa,this._lastValueReported)!=0)){this._lastValueReported=_1fa;if(this._onChangeActive){this.onChange(_1fa);}}},create:function(){this.inherited(arguments);this._onChangeActive=true;this._setStateClass();},destroy:function(){if(this._layoutHackHandle){clearTimeout(this._layoutHackHandle);}this.inherited(arguments);},setValue:function(_1fc){dojo.deprecated("dijit.form._FormWidget:setValue("+_1fc+") is deprecated.  Use attr('value',"+_1fc+") instead.","","2.0");this.attr("value",_1fc);},getValue:function(){dojo.deprecated(this.declaredClass+"::getValue() is deprecated. Use attr('value') instead.","","2.0");return this.attr("value");},_layoutHack:function(){if(dojo.isFF==2&&!this._layoutHackHandle){var node=this.domNode;var old=node.style.opacity;node.style.opacity="0.999";this._layoutHackHandle=setTimeout(dojo.hitch(this,function(){this._layoutHackHandle=null;node.style.opacity=old;}),0);}}});dojo.declare("dijit.form._FormValueWidget",dijit.form._FormWidget,{attributeMap:dojo.delegate(dijit.form._FormWidget.prototype.attributeMap,{value:""}),postCreate:function(){if(dojo.isIE||dojo.isWebKit){this.connect(this.focusNode||this.domNode,"onkeydown",this._onKeyDown);}if(this._resetValue===undefined){this._resetValue=this.value;}},_setValueAttr:function(_1ff,_200){this.value=_1ff;this._handleOnChange(_1ff,_200);},_getValueAttr:function(_201){return this._lastValue;},undo:function(){this._setValueAttr(this._lastValueReported,false);},reset:function(){this._hasBeenBlurred=false;this._setValueAttr(this._resetValue,true);},_onKeyDown:function(e){if(e.keyCode==dojo.keys.ESCAPE&&!e.ctrlKey&&!e.altKey){var te;if(dojo.isIE){e.preventDefault();te=document.createEventObject();te.keyCode=dojo.keys.ESCAPE;te.shiftKey=e.shiftKey;e.srcElement.fireEvent("onkeypress",te);}else{if(dojo.isWebKit){te=document.createEvent("Events");te.initEvent("keypress",true,true);te.keyCode=dojo.keys.ESCAPE;te.shiftKey=e.shiftKey;e.target.dispatchEvent(te);}}}}});}if(!dojo._hasResource["dijit.dijit"]){dojo._hasResource["dijit.dijit"]=true;dojo.provide("dijit.dijit");}

/** Licensed Materials - Property of IBM, 5724-E76 and 5724-E77, (C) Copyright IBM Corp. 2009 - All Rights reserved.  **/
dojo.provide("com.ibmPortalEnhancedTheme");
if(!dojo._hasResource["com.ibm.portal.debug"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.portal.debug"] = true;
dojo.provide( "com.ibm.portal.debug" );

//To satisfy dojo.require
//TODO: convert all ibm.portal.debug statements to com.ibm.portal.debug stmts
dojo.provide( "ibm.portal.debug" );

ibm.portal.debug.setTrace = function ( /*String*/functionName ) {
	ibm.portal.debug._traceString = functionName;
}

ibm.portal.debug._isDebugEnabled = function () {
	var retVal = false;
	
	if ( typeof ( ibmPortalConfig ) != "undefined" ) {
		if ( ibmPortalConfig && ibmPortalConfig.isDebug ) {
			retVal = true;
		}
	}
	
	return retVal;	
}

ibm.portal.debug.text = function( str, functionName ) {
	//First check that ibmPortalConfig is defined. Next check to see if the
	//isDebug flag is enabled. We don't want to actually print the statement
	//if we can avoid it since it can be expensive performance-wise. If a trace
	//string is defined, we only want to print debug statements that match that trace string.
	//otherwise, we print everything. This way the debug output can be filtered down. The 
	//one caveat is that not all functions specify a function name.
	if ( typeof ( ibmPortalConfig ) != "undefined" ) {
		if ( ibmPortalConfig && ibmPortalConfig.isDebug ) {
			var traceStr = ibm.portal.debug._traceString;
			if ( traceStr ) {
				if ( functionName ) {
					if ( functionName.indexOf( traceStr ) >= 0 ) {
						window.console.log(str);
					}
				}
			}
			else {
				window.console.log(str);
			}		
		}
	}	
} 

ibm.portal.debug.entry = function ( functionName, args ) {
	if ( ibm.portal.debug._isDebugEnabled() ) {
	
		var debugStr = functionName + " --> entry; { ";
		
		if ( args && args.length > 0 )
		{
			for ( arg in args ) {
				debugStr = debugStr + args[arg] + " ";
			}
		} 
		
		debugStr = debugStr + " } ";
		
		ibm.portal.debug.text( debugStr, functionName );
	}	
}

ibm.portal.debug.exit = function( functionName, retValue ) {
	if ( ibm.portal.debug._isDebugEnabled() ) {
		var debugStr = functionName + " --> exit;"
		if ( typeof( retValue ) != "undefined" )
		{
			debugStr = debugStr +" { " + retValue + " } ";
		}		
		ibm.portal.debug.text( debugStr, functionName );
	}			
}

ibm.portal.debug.escapeXmlForHTMLDisplay = function( string ) {
	string = string.replace( /</g, "&lt;" );
	string = string.replace( />/g, "&gt;" );
	
	return string;
}

}

if(!dojo._hasResource["dojox.lang.aspect"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.lang.aspect"] = true;
dojo.provide("dojox.lang.aspect");

(function(){
	var d = dojo, aop = dojox.lang.aspect, ap = Array.prototype,
		contextStack = [], context;
		
	// this class implements a topic-based double-linked list
	var Advice = function(){
		this.next_before = this.prev_before =
		this.next_around = this.prev_around =
		this.next_afterReturning = this.prev_afterReturning =
		this.next_afterThrowing = this.prev_afterThrowing =
			this;
		this.counter = 0;
	};
	d.extend(Advice, {
		add: function(advice){
			var dyn = d.isFunction(advice),
				node = {advice: advice, dynamic: dyn};
			this._add(node, "before", "", dyn, advice);
			this._add(node, "around", "", dyn, advice);
			this._add(node, "after", "Returning", dyn, advice);
			this._add(node, "after", "Throwing", dyn, advice);
			++this.counter;
			return node;
		},
		_add: function(node, topic, subtopic, dyn, advice){
			var full = topic + subtopic;
			if(dyn || advice[topic] || (subtopic && advice[full])){
				var next = "next_" + full, prev = "prev_" + full;
				(node[prev] = this[prev])[next] = node;
				(node[next] = this)[prev] = node;
			}
		},
		remove: function(node){
			this._remove(node, "before");
			this._remove(node, "around");
			this._remove(node, "afterReturning");
			this._remove(node, "afterThrowing");
			--this.counter;
		},
		_remove: function(node, topic){
			var next = "next_" + topic, prev = "prev_" + topic;
			if(node[next]){
				node[next][prev] = node[prev];
				node[prev][next] = node[next];
			}
		},
		isEmpty: function(){
			return !this.counter;
		}
	});

	var getDispatcher = function(){
	
		return function(){
			
			var self = arguments.callee,	// the join point
				advices = self.advices,		// list of advices for this joinpoint
				ret, i, a, e, t;

			// push context
			if(context){ contextStack.push(context); }
			context = {
				instance: this,					// object instance
				joinPoint: self,				// join point
				depth: contextStack.length,		// current level of depth starting from 0
				around: advices.prev_around,	// pointer to the current around advice
				dynAdvices: [],					// array of dynamic advices if any
				dynIndex: 0						// index of a dynamic advice
			};

			try{
				// process before events
				for(i = advices.prev_before; i != advices; i = i.prev_before){
					if(i.dynamic){
						// instantiate a dynamic advice
						context.dynAdvices.push(a = new i.advice(context));
						if(t = a.before){ // intentional assignment
							t.apply(a, arguments);
						}
					}else{
						t = i.advice;
						t.before.apply(t, arguments);
					}
				}

				// process around and after events
				try{
					// call the around advice or the original method
					ret = (advices.prev_around == advices ? self.target : aop.proceed).apply(this, arguments);
				}catch(e){
					// process after throwing and after events
					context.dynIndex = context.dynAdvices.length;
					for(i = advices.next_afterThrowing; i != advices; i = i.next_afterThrowing){
						a = i.dynamic ? context.dynAdvices[--context.dynIndex] : i.advice;
						if(t = a.afterThrowing){ // intentional assignment
							t.call(a, e);
						}
						if(t = a.after){ // intentional assignment
							t.call(a);
						}
					}
					// continue the exception processing
					throw e;
				}
				// process after returning and after events
				context.dynIndex = context.dynAdvices.length;
				for(i = advices.next_afterReturning; i != advices; i = i.next_afterReturning){
					a = i.dynamic ? context.dynAdvices[--context.dynIndex] : i.advice;
					if(t = a.afterReturning){ // intentional assignment
						t.call(a, ret);
					}
					if(t = a.after){ // intentional assignment
						t.call(a);
					}
				}
				// process dojo.connect() listeners
				var ls = self._listeners;
				for(i in ls){
					if(!(i in ap)){
						ls[i].apply(this, arguments);
					}
				}
			}finally{
				// destroy dynamic advices
				for(i = 0; i < context.dynAdvices.length; ++i){
					a = context.dynAdvices[i];
					if(a.destroy){
						a.destroy();
					}
				}
				// pop context
				context = contextStack.length ? contextStack.pop() : null;
			}
			
			return ret;
		};
	};

	aop.advise = function(/*Object*/ obj,
						/*String|RegExp|Array*/ method,
						/*Object|Function|Array*/ advice
						){
		// summary:
		//		Attach AOP-style advices to a method.
		//
		// description:
		//		Attaches AOP-style advices to a method. Can attach several
		//		advices at once and operate on several methods of an object.
		//		The latter is achieved when a RegExp is specified as
		//		a method name, or an array of strings and regular expressions
		//		is used. In this case all functional methods that
		//		satisfy the RegExp condition are processed. This function
		//		returns a handle, which can be used to unadvise, or null,
		//		if advising has failed.
		//		
		//		This function is a convenience wrapper for
		//		dojox.lang.aspect.adviseRaw().
		//
		// obj:
		//		A source object for the advised function. Cannot be a DOM node.
		//		If this object is a constructor, its prototype is advised.
		//
		// method:
		//		A string name of the function in obj. In case of RegExp all
		//		methods of obj matching the regular expression are advised.
		//
		// advice:
		//		An object, which defines advises, or a function, which
		//		returns such object, or an array of previous items.
		//		The advice object can define following member functions:
		//		before, around, afterReturning, afterThrowing, after.
		//		If the function is supplied, it is called with a context
		//		object once per call to create a temporary advice object, which
		//		is destroyed after the processing. The temporary advice object
		//		can implement a destroy() method, if it wants to be called when
		//		not needed.
		
		if(typeof obj != "object"){
			obj = obj.prototype;
		}

		var methods = [];
		if(!(method instanceof Array)){
			method = [method];
		}
		
		// identify advised methods
		for(var j = 0; j < method.length; ++j){
			var t = method[j];
			if(t instanceof RegExp){
				for(var i in obj){
					if(d.isFunction(obj[i]) && t.test(i)){
						methods.push(i);
					}
				}
			}else{
				if(d.isFunction(obj[t])){
					methods.push(t);
				}
			}
		}

		if(!d.isArray(advice)){ advice = [advice]; }

		return aop.adviseRaw(obj, methods, advice);	// Object
	};
	
	aop.adviseRaw = function(/*Object*/ obj,
						/*Array*/ methods,
						/*Array*/ advices
						){
		// summary:
		//		Attach AOP-style advices to methods.
		//
		// description:
		//		Attaches AOP-style advices to object's methods. Can attach several
		//		advices at once and operate on several methods of the object.
		//		The latter is achieved when a RegExp is specified as
		//		a method name. In this case all functional methods that
		//		satisfy the RegExp condition are processed. This function
		//		returns a handle, which can be used to unadvise, or null,
		//		if advising has failed.
		//
		// obj:
		//		A source object for the advised function.
		//		Cannot be a DOM node.
		//
		// methods:
		//		An array of method names (strings) to be advised.
		//
		// advices:
		//		An array of advices represented by objects or functions that
		//		return such objects on demand during the event processing.
		//		The advice object can define following member functions:
		//		before, around, afterReturning, afterThrowing, after.
		//		If the function is supplied, it is called with a context
		//		object once per call to create a temporary advice object, which
		//		is destroyed after the processing. The temporary advice object
		//		can implement a destroy() method, if it wants to be called when
		//		not needed.

		if(!methods.length || !advices.length){ return null; }
		
		// attach advices
		var m = {}, al = advices.length;
		for(var i = methods.length - 1; i >= 0; --i){
			var name = methods[i], o = obj[name], ao = new Array(al), t = o.advices;
			// create a stub, if needed
			if(!t){
				var x = obj[name] = getDispatcher();
				x.target = o.target || o;
				x.targetName = name;
				x._listeners = o._listeners || [];
				x.advices = new Advice;
				t = x.advices;
			}
			// attach advices
			for(var j = 0; j < al; ++j){
				ao[j] = t.add(advices[j]);
			}
			m[name] = ao;
		}
		
		return [obj, m];	// Object
	};

	aop.unadvise = function(/*Object*/ handle){
		// summary:
		//		Detach previously attached AOP-style advices.
		//
		// handle:
		//		The object returned by dojox.lang.aspect.advise().
		
		if(!handle){ return; }
		var obj = handle[0], methods = handle[1];
		for(var name in methods){
			var o = obj[name], t = o.advices, ao = methods[name];
			for(var i = ao.length - 1; i >= 0; --i){
				t.remove(ao[i]);
			}
			if(t.isEmpty()){
				// check if we can remove all stubs
				var empty = true, ls = o._listeners;
				if(ls.length){
					for(i in ls){
						if(!(i in ap)){
							empty = false;
							break;
						}
					}
				}
				if(empty){
					// revert to the original method
					obj[name] = o.target;
				}else{
					// replace with the dojo.connect() stub
					var x = obj[name] = d._listener.getDispatcher();
					x.target = o.target;
					x._listeners = ls;
				}
			}
		}
	};
	
	aop.getContext = function(){
		// summary:
		//		Returns the context information for the advice in effect.
		
		return context;	// Object
	};
	
	aop.getContextStack = function(){
		// summary:
		//		Returns the context stack, which reflects executing advices
		//		up to this point. The array is ordered from oldest to newest.
		//		In order to get the active context use dojox.lang.aspect.getContext().
		
		return contextStack;	// Array
	};
	
	aop.proceed = function(){
		// summary:
		//		Call the original function (or the next level around advice) in an around advice code.
		//
		// description:
		//		Calls the original function (or the next level around advice).
		//		Accepts and passes on any number of arguments, and returns a value.
		//		This function is valid only in the content of around calls.
		
		var joinPoint = context.joinPoint, advices = joinPoint.advices;
		for(var c = context.around; c != advices; c = context.around){
			context.around = c.prev_around;	// advance the pointer
			if(c.dynamic){
				var a = context.dynAdvices[context.dynIndex++], t = a.around;
				if(t){
					return t.apply(a, arguments);
				}
			}else{
				return c.advice.around.apply(c.advice, arguments);
			}
		}
		return joinPoint.target.apply(context.instance, arguments);
	};
})();

/*
Aspect = {
	before: function(arguments){...},
	around: function(arguments){...returns value...},
	afterReturning: function(ret){...},
	afterThrowing: function(excp){...},
	after: function(){...}
};

Context = {
	instance:  ..., // the instance we operate on
	joinPoint: ...,	// Object (see below)
	depth:     ...	// current depth of the context stack
};

JoinPoint = {
	target:     ...,	// the original function being wrapped
	targetName: ...		// name of the method
};
*/

}

if(!dojo._hasResource["com.ibm.debug.Tracer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.debug.Tracer"] = true;
dojo.provide("com.ibm.debug.Tracer");



(function(){
	var argsExtractor = function(prefix, args) {
		var msg = (prefix ? prefix + " " : "") + (args[0] ? args[0] : "");
		return [msg].concat([args[1]]).concat([args[2]]).concat(args[3]);
	}
	
	var asp = dojox.lang.aspect;
	
	if(!console.log) {
		console.log = function(){};
	}
	if(!console.info) {
		console.info = console.log;
	}
	if(!console.warn) {
		console.warn = console.log;
	}
	if(!console.error) {
		console.error = console.log;
	}
	
	var TraceAdvice = function(context) {
		this.name = context.joinPoint.targetName;
		this.instance = context.instance;
		this.prefix = dojo.string.pad("", context.depth * 2, "--", true);
	}
	
	dojo.extend(TraceAdvice, {
		/* Logging helpers */
		log: function() {
			console.log.apply(console, argsExtractor(this.prefix, arguments)); 
		},
		info: function() {
			console.info.apply(console, argsExtractor(this.prefix, arguments));
		},
		warn: function() {
			console.warn.apply(console, argsExtractor(this.prefix, arguments));
		},
		error: function() {
			console.error.apply(console, argsExtractor(this.prefix, arguments));
		},
		
		/* Advice providers */
		/*
		before: function() {
			this.log("Before -> " + this.name + "(%o)", arguments);
		},
		*/
		around: function() {
			this.log("Before -> %o.%o(%o)", this.instance, this.name, arguments);
			var ret = asp.proceed.apply(null, arguments);
			this.log("After -> %o.%o -> Returned %o", this.instance, this.name, [ret]);
			return ret;
		},
		afterThrowing: function(err) {
			this.error("Exception in -> %o.%o: %o", this.instance, this.name, [err]);
		}
	});
	
	com.ibm.debug.Tracer = {
		advise: asp.advise,
		unadvise: asp.unadvise,
		trace: function(obj, methods) {
			if(!methods) methods = /^\S/;
			return asp.advise(obj, methods, TraceAdvice);
		},
		untrace: function(handle) {
			asp.unadvise(handle);
		}
	}
})();

}

if(!dojo._hasResource["com.ibm.ajax.auth"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.ajax.auth"] = true;
//dojo.require( "ibm.portal.debug" );
dojo.provide("com.ibm.ajax.auth");
com.ibm.ajax.auth = {
   /**
    * This method will wrap ioArgs normally sent to the dojo xhr methods with a special handler function that will check for form 
    * authentication redirection on a request.  This method supports dojo.xhrGet, dojo.xhrPost, dojo.xhrDelete, dojo.xhrPut,
    * dojo.io.iframe.send, and dojo.io.script.send.
    *
    * The testForValidOutput function will be invoked (if specified) with the response and the ioArgs arguments that are normally 
    * passed to the dojo.xhr methods.
    *
    * The onauthenticated method is optional, and will be invoked when the provider 
    * determines the user is successfully authenticated.  
    *
    * The handler method added to the ioArgs would check that the response status code is >= 200 && < 300, and that the mime-type is
    * text/html.
    *
    * @return A version of args suitable to be passed to dojo.xhrGet/xhrPost/xhrDelete/xhrPut/xhrRawPost/io.iframe.send()
    */
   prepareSecure: function( /* object */ args, /* function(response,ioArgs) optional */ isExpectedResponse, /* function() optional */ onauthenticated ) {
      args._handle = args.handle;
      args.handle = dojo.partial(this.testAuthenticationHandler, this, isExpectedResponse, onauthenticated);

      return args;
   },
   
   /**
    * When a request is determined to require authentication, the authenticationRequired function passed to this function will 
    * be invoked with the following arguments:
    *   - the response object from dojo
    *   - the ioArgs object that was passed to dojo
    *   - the onauthenticated function provided to the checkRequest/checkHtmlRequest methods (may be null)
    */
   setAuthenticationHandler: function( /* function(response,ioArgs,onauthenticated) */ authenticationRequired) {
      this.authenticationHandler = authenticationRequired;
   },
   
   /**
    * Callers of the API may choose to override the authentication test mechanism for this class wholesale by calling this
    * this method with an override.  The function will be invoked with the following arguments whenever an xhrGet that was
    * invoked with prepareSecure() returns.  Generally this is provided only as a last resort if a specific product's 
    * authentication test needs are not satisfied, or if the default behavior is not sufficient.
    */
   setTestAuthenticationHandler: function( /* function(auth, isExpected, onauthenticated, response, ioArgs) */handler) {
      this.testAuthenticationHandler = handler;
   },
   
   /**
    * By default there are three authentication tests performed when a request is returned from dojo.xhrGet/Post/Delete/Put.
    *    1) If the caller provides a test themselves (they know that their particular response may be confused for a
    *       login redirect)
    *    2) If the handleAs type is 'xml', 'json', or 'json-comment-optional' and the server returned 'text/html' or
    *       one of the other common HTML mime types, we assume that a redirect was sent from the server and the browser
    *       silently redirected the user (if the status code was >= 200 and < 300).
    *    3) If the status code is 302 in the response, which typically only occurs when multiple redirects are sent by the 
    *       server and the browser decides not to handle all of them, we assume a login redirect was the cause.
    *
    * The three booleans passed to this function will set whether the specific check is enabled.  By default all three
    * are true.
    */
   setDefaultAuthenticationTests: function(checkFromCaller,checkByContentType,checkByStatusCode) {
      this.checkFromCaller = checkFromCaller;
      this.checkByContentType = checkByContentType;
      this.checkByStatusCode = checkByStatusCode;
   },
   
   /**
    * This method allows users to add their own,custom login checks via a handler function.  The function takes three
    * arguments:
    *   - a reference to the auth object
    *   - the response object from dojo
    *   - the ioArgs object that was passed to dojo
    *
    * and returns true if the request requires authentication.
    *
    * See setDefaultAuthenticationTests(3) for more information about the default checks that are performed.
    */
   addAuthenticationCheck: function( /* function(auth, response, ioArgs) */handler ) {
      if (handler)
         this.authenticationChecks.push(handler);
   },
   
   /** 
    * Use this method to check whether a specific request requires authentication after a request has already
    * been received.  Should only be used when the default authentication test and handling behavior is not desired (for 
    * instance, when an application is initializing itself and needs to check whether it is authenticated).
    */
   isAuthenticationRequired: function(response, ioArgs) {
      var handleAs = ioArgs.args.handleAs;
      var unauthenticated = false;
      
      if (!response || dojo.indexOf(["cancel","timeout"],response.dojoType) == -1) {
         if (this.checkByContentType && dojo.indexOf(["xml","json","json-comment-optional","text"],handleAs) != -1 && ioArgs.xhr && /^text\/html/.exec(ioArgs.xhr.getResponseHeader("Content-Type")) && ioArgs.xhr.status >= 200 && ioArgs.xhr.status < 300) {
            ibm.portal.debug.text("auth::isAuthenticationRequired DEBUG content type does not match request, assume logged out");
            return true;
         }
         else if (this.checkByStatusCode && dojo.indexOf(["xml","json","json-comment-optional","text"],handleAs) != -1 && ioArgs.xhr && ioArgs.xhr.status == 302) {
            ibm.portal.debug.text("auth::isAuthenticationRequired DEBUG redirect received, assume login request");
            return true;
         }
         else if (this.checkByStatusCode && ioArgs.xhr && (ioArgs.xhr.status == 401|| ioArgs.xhr.status==0) && ioArgs.xhr.getResponseHeader("WWW-Authenticate") && ioArgs.xhr.getResponseHeader("WWW-Authenticate").indexOf("IBMXHR")!=-1) {
            ibm.portal.debug.text("auth::isAuthenticationRequired DEBUG Portal 401 received, assume login required");
            return true;
         }

      }
      if (!unauthenticated) {
         for (var i=0; i<this.authenticationChecks.length; i++)
            if (this.authenticationChecks[i](this, response, ioArgs))
               return true;
      }
      return false;   
   },
   
   testAuthenticationHandler: function(auth, isExpectedResponse, onauthenticated, response, ioArgs) {
      var args = dojo._toArray(arguments).slice(3);

      var unauthenticated = false;
      if (!response || dojo.indexOf(["cancel","timeout"],response.dojoType) == -1) {
         if (auth.checkFromCaller && typeof isExpectedResponse == "function" && isExpectedResponse(response, ioArgs)) {
            //console.log("auth::_testAuthentication DEBUG caller provided detection logic that indicated form login, assume logged out");
            unauthenticated = true;
         }
         else
            unauthenticated = auth.isAuthenticationRequired(response,ioArgs,isExpectedResponse)
      }
      
      if (unauthenticated) {
         //assume that WAS has set its redirect cookies and clear them
         var path = auth._parseUri(ioArgs.args.url).path;
         dojo.cookie("WASPostParam",null,{expires:-1,path:path});
         dojo.cookie("WASReqURL",null,{expires:-1,path:"/"});

         auth.authenticationHandler(response, ioArgs, onauthenticated);

         args[0] = new Error("xhr unauthenticated");
         args[0].dojoType = "unauthenticated";
      }
      if (ioArgs.args._handle)
         return ioArgs.args._handle.apply(this, args);
      else
      	 return(response);
   },
   
   /** Private methods */

   _parseUri: function(uri) {
      if (!uri)
         return null;
      uri = new dojo._Url(uri);
      var params = this._splitQuery(uri.query);
      uri.queryParameters = params;
      return uri;
   },
   
   _splitQuery: function(query) {
      var params = {};
      if (!query)
         return params;
      if (query.charAt(0) == "?")
         query = query.substring(1);
   
      var args = query.split("&");
      for (var i=0; i<args.length; i++)
         if (args[i].length > 0) {
            var separator = args[i].indexOf("=");
            if (separator == -1) {
               var key = decodeURIComponent(args[i]);
               var existing = params[key];
               if (dojo.isArray(existing))
                  existing.push("");
               else if (existing)
                  params[key] = [existing,""];
               else
                  params[key] = "";
            } else if (separator > 0) {
               var key = decodeURIComponent(args[i].substring(0, separator));
               var value = decodeURIComponent(args[i].substring(separator+1));
               var existing = params[key];
               if (dojo.isArray(existing))
                  existing.push(value);
               else if (existing)
                  params[key] = [existing,value];
               else
                  params[key] = value;
            }
         }
      return params;
   },
   
   checkFromCaller: true,
   checkByContentType: true,
   checkByStatusCode: true,
   authenticationChecks: [],
   authenticationHandler: function() {
      ibm.portal.debug.text("auth::authenticationHandler DEBUG authentication was required");
   }
};

}

if(!dojo._hasResource["dojox.xml.parser"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.xml.parser"] = true;
dojo.provide("dojox.xml.parser");

//DOM type to int value for reference.
//Ints make for more compact code than full constant names.
//ELEMENT_NODE                  = 1;
//ATTRIBUTE_NODE                = 2;
//TEXT_NODE                     = 3;
//CDATA_SECTION_NODE            = 4;
//ENTITY_REFERENCE_NODE         = 5;
//ENTITY_NODE                   = 6;
//PROCESSING_INSTRUCTION_NODE   = 7;
//COMMENT_NODE                  = 8;
//DOCUMENT_NODE                 = 9;
//DOCUMENT_TYPE_NODE            = 10;
//DOCUMENT_FRAGMENT_NODE        = 11;
//NOTATION_NODE                 = 12;

dojox.xml.parser.parse = function(/*String?*/ str, /*String?*/ mimetype){
	//	summary:
	//		cross-browser implementation of creating an XML document object from null, empty string, and XML text..
	//
	//	str:
	//		Optional text to create the document from.  If not provided, an empty XML document will be created.  
	//		If str is empty string "", then a new empty document will be created.
	//	mimetype:
	//		Optional mimetype of the text.  Typically, this is text/xml.  Will be defaulted to text/xml if not provided.
	var _document = dojo.doc;
	var doc;

	mimetype = mimetype || "text/xml";
	if(str && dojo.trim(str) && "DOMParser" in dojo.global){
		//Handle parsing the text on Mozilla based browsers etc..
		var parser = new DOMParser();
		doc = parser.parseFromString(str, mimetype);
		var de = doc.documentElement;
		var errorNS = "http://www.mozilla.org/newlayout/xml/parsererror.xml";
		if(de.nodeName == "parsererror" && de.namespaceURI == errorNS){
			var sourceText = de.getElementsByTagNameNS(errorNS, 'sourcetext')[0];
			if(!sourceText){
				sourceText = sourceText.firstChild.data;
			}
        	throw new Error("Error parsing text " + nativeDoc.documentElement.firstChild.data + " \n" + sourceText);
		}
		return doc;

	}else if("ActiveXObject" in dojo.global){
		//Handle IE.
		var ms = function(n){ return "MSXML" + n + ".DOMDocument"; };
		var dp = ["Microsoft.XMLDOM", ms(6), ms(4), ms(3), ms(2)];
		dojo.some(dp, function(p){
			try{
				doc = new ActiveXObject(p);
			}catch(e){ return false; }
			return true;
		});
		if(str && doc){
			doc.async = false;
			doc.loadXML(str);
			var pe = doc.parseError;
			if(pe.errorCode !== 0){
				throw new Error("Line: " + pe.line + "\n" +
					"Col: " + pe.linepos + "\n" +
					"Reason: " + pe.reason + "\n" + 
					"Error Code: " + pe.errorCode + "\n" +
					"Source: " + pe.srcText);
			}
		}
		if(doc){
			return doc; //DOMDocument
		}
	}else if(_document.implementation && _document.implementation.createDocument){
		if(str && dojo.trim(str) && _document.createElement){
			//Everyone else that we couldn't get to work.  Fallback case.
			// FIXME: this may change all tags to uppercase!
			var tmp = _document.createElement("xml");
			tmp.innerHTML = str;
			var xmlDoc = _document.implementation.createDocument("foo", "", null);
			dojo.forEach(tmp.childNodes, function(child){
				xmlDoc.importNode(child, true);
			});
			return xmlDoc;	//	DOMDocument
		}else{
			return _document.implementation.createDocument("", "", null); // DOMDocument
		}
	}
	return null;	//	null
}

dojox.xml.parser.textContent = function(/*Node*/node, /*String?*/text){
	//	summary:
	//		Implementation of the DOM Level 3 attribute; scan node for text
	//	description:
	//		Implementation of the DOM Level 3 attribute; scan node for text
	//		This function can also update the text of a node by replacing all child 
	//		content of the node.
	//	node:
	//		The node to get the text off of or set the text on.
	//	text:
	//		Optional argument of the text to apply to the node.
	if(arguments.length>1){
		var _document = node.ownerDocument || dojo.doc;  //Preference is to get the node owning doc first or it may fail
		dojox.xml.parser.replaceChildren(node, _document.createTextNode(text));
		return text;	//	String
	}else{
		if(node.textContent !== undefined){ //FF 1.5 -- remove?
			return node.textContent;	//	String
		}
		var _result = "";
		if(node){
			dojo.forEach(node.childNodes, function(child){
				switch(child.nodeType){
					case 1: // ELEMENT_NODE
					case 5: // ENTITY_REFERENCE_NODE
						_result += dojox.xml.parser.textContent(child);
						break;
					case 3: // TEXT_NODE
					case 2: // ATTRIBUTE_NODE
					case 4: // CDATA_SECTION_NODE
						_result += child.nodeValue;
				}
			});
		}
		return _result;	//	String
	}
}

dojox.xml.parser.replaceChildren = function(/*Element*/node, /*Node || Array*/ newChildren){
	//	summary:
	//		Removes all children of node and appends newChild. All the existing
	//		children will be destroyed.
	//	description:
	//		Removes all children of node and appends newChild. All the existing
	//		children will be destroyed.
	// 	node:
	//		The node to modify the children on
	//	newChildren:
	//		The children to add to the node.  It can either be a single Node or an
	//		array of Nodes.
	var nodes = [];

	if(dojo.isIE){
		dojo.forEach(node.childNodes, function(child){
			nodes.push(child);
		});
	}

	dojox.xml.parser.removeChildren(node);
	dojo.forEach(nodes, dojo.destroy);

	if(!dojo.isArray(newChildren)){
		node.appendChild(newChildren);
	}else{
		dojo.forEach(newChildren, function(child){
			node.appendChild(child);
		});
	}
}

dojox.xml.parser.removeChildren = function(/*Element*/node){
	//	summary:
	//		removes all children from node and returns the count of children removed.
	//		The children nodes are not destroyed. Be sure to call dojo.destroy on them
	//		after they are not used anymore.
	//	node:
	//		The node to remove all the children from.
	var count = node.childNodes.length;
	while(node.hasChildNodes()){
		node.removeChild(node.firstChild);
	}
	return count; // int
}


dojox.xml.parser.innerXML = function(/*Node*/node){
	//	summary:
	//		Implementation of MS's innerXML function.
	//	node:
	//		The node from which to generate the XML text representation.
	if(node.innerXML){
		return node.innerXML;	//	String
	}else if(node.xml){
		return node.xml;		//	String
	}else if(typeof XMLSerializer != "undefined"){
		return (new XMLSerializer()).serializeToString(node);	//	String
	}
	return null;
}

}

if(!dojo._hasResource["dojox.data.dom"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.data.dom"] = true;
dojo.provide("dojox.data.dom");


//DOM type to int value for reference.
//Ints make for more compact code than full constant names.
//ELEMENT_NODE                  = 1;
//ATTRIBUTE_NODE                = 2;
//TEXT_NODE                     = 3;
//CDATA_SECTION_NODE            = 4;
//ENTITY_REFERENCE_NODE         = 5;
//ENTITY_NODE                   = 6;
//PROCESSING_INSTRUCTION_NODE   = 7;
//COMMENT_NODE                  = 8;
//DOCUMENT_NODE                 = 9;
//DOCUMENT_TYPE_NODE            = 10;
//DOCUMENT_FRAGMENT_NODE        = 11;
//NOTATION_NODE                 = 12;

//This file contains internal/helper APIs as holders for people who used them.  They have been migrated to
//a better project, dojox.xml and experimental has been removed there.  Please update usage to the new package.
dojo.deprecated("dojox.data.dom", "Use dojox.xml.parser instead.", "2.0");

dojox.data.dom.createDocument = function(/*string?*/ str, /*string?*/ mimetype){
	//	summary:
	//		cross-browser implementation of creating an XML document object.
	//
	//	str:
	//		Optional text to create the document from.  If not provided, an empty XML document will be created.  
	//		If str is empty string "", then a new empty document will be created.
	//	mimetype:
	//		Optional mimetype of the text.  Typically, this is text/xml.  Will be defaulted to text/xml if not provided.
	dojo.deprecated("dojox.data.dom.createDocument()", "Use dojox.xml.parser.parse() instead.", "2.0");
	try{
		return dojox.xml.parser.parse(str,mimetype); //DOMDocument.
	}catch(e){
		/*Squeltch errors like the old parser did.*/
		return null;
	}
};

dojox.data.dom.textContent = function(/*Node*/node, /*string?*/text){
	//	summary:
	//		Implementation of the DOM Level 3 attribute; scan node for text
	//	description:
	//		Implementation of the DOM Level 3 attribute; scan node for text
	//		This function can also update the text of a node by replacing all child 
	//		content of the node.
	//	node:
	//		The node to get the text off of or set the text on.
	//	text:
	//		Optional argument of the text to apply to the node.
	dojo.deprecated("dojox.data.dom.textContent()", "Use dojox.xml.parser.textContent() instead.", "2.0");
	if(arguments.length> 1){
		return dojox.xml.parser.textContent(node, text); //string
	}else{
		return dojox.xml.parser.textContent(node); //string
	}
};

dojox.data.dom.replaceChildren = function(/*Element*/node, /*Node || array*/ newChildren){
	//	summary:
	//		Removes all children of node and appends newChild. All the existing
	//		children will be destroyed.
	//	description:
	//		Removes all children of node and appends newChild. All the existing
	//		children will be destroyed.
	// 	node:
	//		The node to modify the children on
	//	newChildren:
	//		The children to add to the node.  It can either be a single Node or an
	//		array of Nodes.
	dojo.deprecated("dojox.data.dom.replaceChildren()", "Use dojox.xml.parser.replaceChildren() instead.", "2.0");
	dojox.xml.parser.replaceChildren(node, newChildren);
};

dojox.data.dom.removeChildren = function(/*Element*/node){
	//	summary:
	//		removes all children from node and returns the count of children removed.
	//		The children nodes are not destroyed. Be sure to call dojo._destroyElement on them
	//		after they are not used anymore.
	//	node:
	//		The node to remove all the children from.
	dojo.deprecated("dojox.data.dom.removeChildren()", "Use dojox.xml.parser.removeChildren() instead.", "2.0");
	return dojox.xml.parser.removeChildren(node); //int
};

dojox.data.dom.innerXML = function(/*Node*/node){
	//	summary:
	//		Implementation of MS's innerXML function.
	//	node:
	//		The node from which to generate the XML text representation.
	dojo.deprecated("dojox.data.dom.innerXML()", "Use dojox.xml.parser.innerXML() instead.", "2.0");
	return dojox.xml.parser.innerXML(node); //string||null
};


}

if(!dojo._hasResource["com.ibm.portal.xpath"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.portal.xpath"] = true;
/* Confidential                                                                                                         */
/*                                                                                                                                    */
/* OCO Source Materials                                                                                                */
/*                                                                                                                                    */
/* (C) Copyright IBM Corp. 2006,2007                                                                          */
/*                                                                                                                                    */
/* The source code for this program is not published or otherwise                               */
/* divested of its trade secrets, irrespective of what has been                                    */
/* deposited with the U.S. Copyright Office.                                                                 */
/*                                                                                                                                    */
/* ***************************************************************** */

dojo.provide( "com.ibm.portal.xpath" );

// generic impl

com.ibm.portal.xpath.evaluateXPath = function(/*String*/xpathExpr, /*DOMDocument*/ doc, /*Object{prefix:ns,prefix2:ns2,...}*/namespaces) {
    if (typeof ActiveXObject != "undefined") {
        return com.ibm.portal.xpath.ie.evaluateXPath(xpathExpr, doc, namespaces);
    }
    else {
        return com.ibm.portal.xpath.gecko.evaluateXPath(xpathExpr, doc, namespaces);
    }
}

// IE Implementation

dojo.provide( "com.ibm.portal.xpath.ie" );

com.ibm.portal.xpath.ie.evaluateXPath = function(/*String*/xpathExpr, /*DOMDocument*/ doc, /*Object{prefix:ns,prefix2:ns2,...}*/namespaces) {
        if (namespaces) {        
            var ns = "";
            for (var prop in namespaces) {
                ns += "xmlns:"+prop+"='"+namespaces[prop]+"' ";
            }
            if (doc.ownerDocument) {
                doc.ownerDocument.setProperty("SelectionNamespaces", ns);
            } else {
                doc.setProperty("SelectionNamespaces", ns);
            }
        }
        var result = doc.selectNodes(xpathExpr);

        var thisResult;
        var resultSet = new Array();
        var len = 0;
        for (var i=0; i<result.length; i++) {
            thisResult = result[i];
            if (thisResult) {
                resultSet[len] = thisResult;
                len++;
            }
        }
        return resultSet;
}


// GECKO Implementation

dojo.provide( "com.ibm.portal.xpath.gecko" );

com.ibm.portal.xpath.gecko.evaluateXPath = function(/*String*/xpathExpr, /*DOMDocument*/ doc, /*Object{prefix:ns,prefix2:ns2,...}*/namespaces) {
        var result;
        try {
        	var rootDoc = doc;
        	if(!rootDoc.evaluate) rootDoc = doc.ownerDocument;
            result = rootDoc.evaluate( xpathExpr, doc, function(prefix) { return namespaces[prefix] || null;}, XPathResult.ANY_TYPE, null );
        } 
        catch (exc)
        {
            //Callers should catch this and can substitute their own error message
            throw new Error("Error with xpath expression" + exc);
        }
    
        //alert(result.resultType);
        var thisResult;
        var resultSet = new Array();
        var len = 0;
        do {
            thisResult = result.iterateNext();
            if (thisResult) {
                resultSet[len] = thisResult;
                len++;
            }
        } while ( thisResult );
        return resultSet;
}


}

if(!dojo._hasResource["ibm.portal.xml.xpath"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["ibm.portal.xml.xpath"] = true;
/* Confidential                                                                                                         */
/*                                                                                                                                    */
/* OCO Source Materials                                                                                                */
/*                                                                                                                                    */
/* (C) Copyright IBM Corp. 2006,2007                                                                          */
/*                                                                                                                                    */
/* The source code for this program is not published or otherwise                               */
/* divested of its trade secrets, irrespective of what has been                                    */
/* deposited with the U.S. Copyright Office.                                                                 */
/*                                                                                                                                    */
/* ***************************************************************** */

dojo.provide( "ibm.portal.xml.xpath" );
dojo.require( "com.ibm.portal.xpath" );

// generic impl

ibm.portal.xml.xpath.evaluateXPath = function(/*String*/xpathExpr, /*DOMDocument*/ doc, /*Object{prefix:ns,prefix2:ns2,...}*/namespaces) {
    return com.ibm.portal.xpath.evaluateXPath(xpathExpr, doc, namespaces);
}

// IE Implementation

dojo.provide( "ibm.portal.xml.xpath.ie" );

ibm.portal.xml.xpath.ie.evaluateXPath = function(/*String*/xpathExpr, /*DOMDocument*/ doc, /*Object{prefix:ns,prefix2:ns2,...}*/namespaces) {
        return com.ibm.portal.xpath.ie.evaluateXPath(xpathExpr, doc, namespaces);
}


// GECKO Implementation

dojo.provide( "ibm.portal.xml.xpath.gecko" );

ibm.portal.xml.xpath.gecko.evaluateXPath = function(/*String*/xpathExpr, /*DOMDocument*/ doc, /*Object{prefix:ns,prefix2:ns2,...}*/namespaces) {
        return com.ibm.portal.xpath.gecko.evaluateXPath(xpathExpr, doc, namespaces);
}


}

if(!dojo._hasResource["com.ibm.portal.xslt"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.portal.xslt"] = true;
/* ***************************************************************** */
/*                                                                                                                                    */
/* IBM Confidential                                                                                                         */
/*                                                                                                                                    */
/* OCO Source Materials                                                                                                */
/*                                                                                                                                    */
/* (C) Copyright IBM Corp. 2006,2007                                                                          */
/*                                                                                                                                    */
/* The source code for this program is not published or otherwise                               */
/* divested of its trade secrets, irrespective of what has been                                    */
/* deposited with the U.S. Copyright Office.                                                                 */
/*                                                                                                                                    */
/* ***************************************************************** */
dojo.provide( "com.ibm.portal.xslt" );

// TODO: Not needed anymore here, test before removing
dojo.require( "dojox.data.dom" );

dojo.declare( "com.ibm.portal.xslt.TransformerFactory",
    null,
    {
        constructor: function() {
            // create our internal XSL cache
            this._xsltMap = new Array();
        },
        /**
         * summary:
         *		Creates a new com.ibm.portal.xslt.Transformer object.
         */
        newTransformer: function(/*String*/ xsltUrl) {
             ibm.portal.debug.entry( "newTransformer", [ xsltUrl ] );
             var trf = this._getCached(xsltUrl);
             if(trf == null) {
             	trf = new com.ibm.portal.xslt.Transformer(xsltUrl);
             	this._xsltMap.push({url: xsltUrl, transformer: trf});
             }
             return trf;
        },
        _getCached: function(xsltUrl) {
        	var xslt = null;
             // try to get the XSL object from our internal cache
             for (i=0; i<this._xsltMap.length; i++) {
                 var entry = this._xsltMap[i];
                 if (xsltUrl == entry.url) {
                     // alert("cache hit");
                     xslt = entry.transformer;
                     break;
                 }
             }
             return xslt;
        }
    }
);

dojo.declare( "com.ibm.portal.xslt.Transformer",
    null,
    {
        /**
         * summary:
         *		Creates a new transformer for cross-browser XSLT operations
         */
        constructor: function(/* String */ xsltUrl) {
            this._xslt = com.ibm.portal.xslt.loadXsl(xsltUrl);
        },
        /**
         * summary:
         *		Transforms the given xmlDoc and puts the result into the passed
         *		DOM node
         *
         * xmlDoc:
         * 		XML Document to transform
         * xsltParams:
         *		Set of configuration parameters to pass to the transformation
         *		engine.  Object map in this format: {param1Name: "param1Value", param2Name: "param2Value"}
         * node:
         * 		DOM node to put the transform results in
         * doc:
         * 		HTML document to update
         */ 
        transformToRegion: function(xmlDoc, xsltParams, node, doc) {
			if (dojo.isIE) {
				var resultStr = com.ibm.portal.xslt.transform(xmlDoc, this._xslt, null, xsltParams, true);
				node.innerHTML = dojo.string.trim(resultStr);
			} else {
				/*
				var resultsDoc = this.transformToDocument( xmlDoc, xsltParams);
				dojox.data.dom.replaceChildren(node, resultsDoc.documentElement);
				*/
				var frag = com.ibm.portal.xslt.gecko._transformToFragment(xmlDoc, this._xslt, null, xsltParams, doc);
				node.innerHTML = "";
				node.appendChild(frag);
			}
        },
        /** 
         * summary:
         *		Transforms the given xmlDoc and returns a new XML document or String containing
         *		the result
         * xmlDoc:
         * 		XML Document to transform
         * xsltParams:
         *		Set of configuration parameters to pass to the transformation
         *		engine.  Object map in this format: {param1Name: "param1Value", param2Name: "param2Value"}
         * bReturnAsString:
         * 		Boolean indicating whether a XML document or String should be returned.
         */
        transformToDocument: function(xmlDoc, xsltParams, bReturnAsString) {
             var results = com.ibm.portal.xslt.transform(xmlDoc, this._xslt, null, xsltParams, bReturnAsString);
             return results;
        }
    }
);

// global transformer factory
com.ibm.portal.xslt.TRANSFORMER_FACTORY = new com.ibm.portal.xslt.TransformerFactory();



//---------------------------------------------------------------------- xml related utility methods
/*
 * loadXml(sUrl) - returns oDomDoc. parses xml from the url into DOM document object.
 * loadXmlString() - returns oDomDoc. parses xml from the contents of the string into DOM document object.
 * loadXsl()
 * transform()
 */
com.ibm.portal.xslt.ie = {};
com.ibm.portal.xslt.gecko = {};

com.ibm.portal.xslt.getXmlHttpRequest = function() {
	var oXml = null;
	if (typeof ActiveXObject != "undefined") {
		oXml = new ActiveXObject("Microsoft.XMLHTTP");
	} else {
		oXml = new XMLHttpRequest();
	}
  return oXml;
}

com.ibm.portal.xslt.loadXml = function(sUrl) {
	if (typeof ActiveXObject != "undefined") 
		return com.ibm.portal.xslt.ie.loadXml(sUrl);
	else 
		return com.ibm.portal.xslt.gecko.loadXml(sUrl);
}

com.ibm.portal.xslt.loadXmlString = function(sXml) {
	if (typeof ActiveXObject != "undefined") 
		return com.ibm.portal.xslt.ie.loadXmlString(sXml);
	else 
		return com.ibm.portal.xslt.gecko.loadXmlString(sXml);
}

com.ibm.portal.xslt.loadXsl = function(sUrl) {
	if (typeof ActiveXObject != "undefined") 
		return com.ibm.portal.xslt.ie.loadXsl(sUrl);
	else 
		return com.ibm.portal.xslt.gecko.loadXsl(sUrl);
}

com.ibm.portal.xslt.transform = function (xml, xsl, sXslMode, aXslParams, bReturnString)
{
   ibm.portal.debug.entry( "transform", [xml,xsl,sXslMode,aXslParams,bReturnString] );  
   if (typeof ActiveXObject != "undefined") {
    return com.ibm.portal.xslt.ie.transform(xml, xsl, sXslMode, aXslParams,bReturnString);
  }
  else 
    return com.ibm.portal.xslt.gecko.transform(xml, xsl, sXslMode, aXslParams,bReturnString);
}

com.ibm.portal.xslt.transformAndUpdate = function (/*HTMLElement*/nodeToUpdate, /*XMLDocument*/xml, /*XMLDocument*/xsl, /*String?*/sXslMode, /*Map*/aXslParams) {
	ibm.portal.debug.entry( "transformAndUpdate", [ nodeToUpdate, xml, xsl, sXslMode, aXslParams ]);
	
	if ( typeof ActiveXObject != "undefined" ) {
		var resultStr = com.ibm.portal.xslt.transform(xml, xsl, sXslMode, aXslParams, true);
		nodeToUpdate.innerHTML = dojo.string.trim(resultStr);
	} else {
		var doc = nodeToUpdate.ownerDocument ? nodeToUpdate.ownerDocument : document;
		var frag = com.ibm.portal.xslt.gecko._transformToFragment(xml, xsl, sXslMode, aXslParams, doc);
		nodeToUpdate.innerHTML = "";
		nodeToUpdate.appendChild(frag);
	}
	
	ibm.portal.debug.exit( "transformAndUpdate" );
}

//---------------------------------------------------------------------- IE xml related utility methods

com.ibm.portal.xslt.ie.XSLT_PROG_IDS = [
		"Msxml2.XSLTemplate.6.0",
		"Msxml2.XSLTemplate.4.0",
		"MSXML2.XSLTemplate.3.0",
		"MSXML2.XSLTemplate"
	];
	
com.ibm.portal.xslt.ie.DOM_PROG_IDS = [
		"Msxml2.DOMDocument.6.0",
		"Msxml2.DOMDocument.4.0",
		"MSXML2.DOMDocument",
		"MSXML.DOMDocument",
		"Microsoft.XMLDOM"
	];
	
com.ibm.portal.xslt.ie.FTDOM_PROG_IDS = [
		"Msxml2.FreeThreadedDOMDocument.6.0",
		"Msxml2.FreeThreadedDOMDocument.4.0",
		"MSXML2.FreeThreadedDOMDocument",
		"MSXML.FreeThreadedDOMDocument",
		"Microsoft.FreeThreadedXMLDOM"
	];
	
com.ibm.portal.xslt.ie._getMSXMLImpl = function(array) {
	// This iterates through the passed in array of Strings which represent ProgIDs for
	// MSXML objects, and attempts to find the first available one and returns an instance
	// to the caller
	while(array.length > 0) {
		try {
			var impl = new ActiveXObject(array[0]);
			if(impl) {
				return impl;
			}
		}
		catch(err){}
		array.splice(0,1);
	}
	throw new Error("No MSXML implementation exists");
}

com.ibm.portal.xslt.ie.loadXml = function(sUrl) {
	//var oXmlDoc = new ActiveXObject("MSXML2.DOMDocument");
	var oXmlDoc = this._getMSXMLImpl(this.DOM_PROG_IDS);
	oXmlDoc.async=0;
	oXmlDoc.resolveExternals = 0;
  	if(!oXmlDoc.load(sUrl))
  	{
  		//Callers should catch this and can substitute their own error message
  		throw new Error("Error loading xml file " + sUrl);
  	}
	return oXmlDoc;

}

com.ibm.portal.xslt.ie.loadXmlString = function(sXml) {
	var oXmlDoc = this._getMSXMLImpl(this.DOM_PROG_IDS);
	oXmlDoc.async=0;
	oXmlDoc.resolveExternals = 0;
  	if(!oXmlDoc.loadXML(sXml))
  	{
  	    //Callers should catch this and can substitute their own error message
  		throw new Error("Error loading xml string " + sXml); 
  	}
	return oXmlDoc;
}

com.ibm.portal.xslt.ie.loadXsl = function(sUrl) {
	//we need to use MSXML2.FreeThreadedDOMDocument interface in order to support 
	//mode and parameters in XSL transformation.
	var oXslDoc = this._getMSXMLImpl(this.FTDOM_PROG_IDS);
	oXslDoc.async=0;
	oXslDoc.resolveExternals = 0;
  	if(!oXslDoc.load(sUrl))
  	{
  		//Callers should catch this and can substitute their own error message
  		throw new Error("Error loading xsl file " + sUrl);
  	}	
	return oXslDoc;
}

com.ibm.portal.xslt.ie.transform = function(xmlDoc, xsl, sXslMode, aXslParams,bReturnString) {
	var oXml = xmlDoc;
	var oXsl = xsl;

     try {		
		if(!oXsl.documentElement) oXsl = this.loadXsl(xsl);
	 }
	 catch(e) {
		var sMsg = e.message;
		throw new Error(""+sMsg, ""+sMsg);
	 }
	//create the xsl processor and apply the transformation
	var oXslt = this._getMSXMLImpl(this.XSLT_PROG_IDS);
	oXslt.stylesheet = oXsl;
	var oXslProc = oXslt.createProcessor();
	oXslProc.input = oXml;
	
	//set paramaters if any
	if(aXslParams) {
		for(var p in aXslParams) {
			oXslProc.addParameter(p, aXslParams[p]);
		}
	}
	if (sXslMode) oXslProc.addParameter("mode", sXslMode);
	
	if (bReturnString) {
		if(!oXslProc.transform()) {
			//Callers should catch this and can substitute their own error message
  			throw new Error("Error transforming xml doc " + oXml); 
  		}
  		return oXslProc.output;
	} else {
		var oHtmlDoc = this._getMSXMLImpl(this.DOM_PROG_IDS);
		oHtmlDoc.async = false;
		oHtmlDoc.validateOnParse = false;
		oXml.transformNodeToObject(oXsl,oHtmlDoc);
		return oHtmlDoc;	
	}
}

//---------------------------------------------------------------------- GECKO xml related utility methods

com.ibm.portal.xslt.gecko.loadXml = function(sUrl) {
    //var oXmlResponse = NG.ServerRequest.postRequest(sUrl);
//    if (oXmlResponse) return xmlLoadString(oXmlResponse.responseText);
//    else return null;
	var oDomDoc = null;
	if(dojo.isSafari) {
		var xhr = new XMLHttpRequest();
		xhr.open( "GET", sUrl, false );
		xhr.send( null );
		  
		if ( xhr.status == 200 ) {
			oDomDoc = xhr.responseXML;
		}
	}
	else {
		oDomDoc = document.implementation.createDocument('','',null);
		oDomDoc.async = 0; // this is the important part
		oDomDoc.load(sUrl);
	} 
	return oDomDoc;
}

com.ibm.portal.xslt.gecko.loadXmlString = function(sXml) {
    var parser = new DOMParser();
    try { oXmlDoc = parser.parseFromString(sXml, "text/xml"); }
    catch (exc) {
	    //Callers should catch this and can substitute their own error message
  		throw new Error("Error loading xml string " + sXml); 
    }
	return oXmlDoc;
}

com.ibm.portal.xslt.gecko.loadXsl = function(sUrl) {
	//This is done through createDocument because of anchor(#) we have in portal url. 
	//Do not change the code without testing the case.
	var oDomDoc = null;
	if(dojo.isSafari) {
		var xhr = new XMLHttpRequest();
		xhr.open( "GET", sUrl, false );
		xhr.send( null );
		  
		if ( xhr.status == 200 ) {
			oDomDoc = xhr.responseXML;
		}
	}
	else {
		oDomDoc = document.implementation.createDocument('','',null); 
		oDomDoc.async = 0; // this is the important part
		oDomDoc.load(sUrl);
	}
	
	return oDomDoc;
}

com.ibm.portal.xslt.gecko._getXSLTProc = function(xmlDoc, xsl, sXslMode, aXslParams) {
	var xslDoc = xsl;
	if(!xslDoc.documentElement) 
	{
		xslDoc = this.loadXsl(xsl);
	}        
    var proc = new XSLTProcessor();
    proc.importStylesheet(xslDoc); 

	
	//set parameters if any
	if(aXslParams) {
		for(var p in aXslParams)  {
			proc.setParameter(null, p, aXslParams[p]);
		}
	}
	
	if (sXslMode) proc.setParameter(null, "mode", sXslMode);
	
	return proc;
}

com.ibm.portal.xslt.gecko._transformToFragment = function(xmlDoc, xsl, sXslMode, aXslParams, doc) {
	var proc = com.ibm.portal.xslt.gecko._getXSLTProc(xmlDoc, xsl, sXslMode, aXslParams);
	
	var resultDoc = null;
	resultDoc = proc.transformToFragment(xmlDoc, doc);
	proc.clearParameters();
	return resultDoc;
}

com.ibm.portal.xslt.gecko.transform = function(xmlDoc, xsl, sXslMode, aXslParams,bReturnString) {
	try {
		var resultDoc = null;
		if (!bReturnString) {
			var proc = com.ibm.portal.xslt.gecko._getXSLTProc(xmlDoc, xsl, sXslMode, aXslParams);
			resultDoc = proc.transformToDocument(xmlDoc);
			return resultDoc;
		}
		else {
			resultDoc = com.ibm.portal.xslt.gecko._transformToFragment(xmlDoc, xsl, sXslMode, aXslParams, document);
		}

		var serializer = new XMLSerializer();
		// need to trim newlines and spaces from beginning and end so that the root node always has the same
		// number of child nodes regardless of the browser implementation
		// this should be lossless of real expected content
		var resultStr = dojo.string.trim(serializer.serializeToString(resultDoc));
		if(dojo.isOpera && resultDoc.firstChild && resultDoc.firstChild.nodeName == 'result') {
			var start = resultStr.indexOf("<result>") + 8;
			var end = resultStr.lastIndexOf("</result>");
			resultStr = dojo.string.trim(resultStr.substring(start, end));
		}
		return resultStr;    
    }
    catch (exc)
    {
        //alert("error transforming document: "+exc)
		//Callers should catch this and can substitute their own error message
  		throw new Error("Error transforming xml doc " + exc);
	}
}

/* This method sets the content of a layer within the HTML page
 * to the result of transforming the xml parameter by the xsl
 * parameter. The xml and xsl parameters may be of any form
 * supported by the transformXml() method. The layer parameter
 * may be either a DOM object or the name of a DOM object that
 * can be found using the findObject() method.
 */

com.ibm.portal.xslt.setLayerContentByXml = function (layer, xml, xsl, xslparam,bReturnString) {
    var result = com.ibm.portal.xslt.transform(xml,xsl,null,xslparam,bReturnString);
    if (layer.innerHTML) layer.innerHTML = result;
    else {
        var obj = document.getElementById(layer);
        obj.innerHTML=result;
    }
}

}

if(!dojo._hasResource["ibm.portal.xml.xslt"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["ibm.portal.xml.xslt"] = true;
/* ***************************************************************** */
/*                                                                                                                                    */
/* IBM Confidential                                                                                                         */
/*                                                                                                                                    */
/* OCO Source Materials                                                                                                */
/*                                                                                                                                    */
/* (C) Copyright IBM Corp. 2006,2007                                                                          */
/*                                                                                                                                    */
/* The source code for this program is not published or otherwise                               */
/* divested of its trade secrets, irrespective of what has been                                    */
/* deposited with the U.S. Copyright Office.                                                                 */
/*                                                                                                                                    */
/* ***************************************************************** */
dojo.provide( "ibm.portal.xml.xslt" );
dojo.require( "com.ibm.portal.xslt" );

//---------------------------------------------------------------------- xml related utility methods
/*
 * loadXml(sUrl) - returns oDomDoc. parses xml from the url into DOM document object.
 * loadXmlString() - returns oDomDoc. parses xml from the contents of the string into DOM document object.
 * loadXsl()
 * transform()
 */
ibm.portal.xml.xslt.ie = {};
ibm.portal.xml.xslt.gecko = {};

ibm.portal.xml.xslt.getXmlHttpRequest = function() {
	return com.ibm.portal.xslt.getXmlHttpRequest();
}

ibm.portal.xml.xslt.loadXml = function(sUrl) {
	return com.ibm.portal.xslt.loadXml(sUrl);
}

ibm.portal.xml.xslt.loadXmlString = function(sXml) {
	return com.ibm.portal.xslt.loadXmlString(sXml);
}

ibm.portal.xml.xslt.loadXsl = function(sUrl) {
	return com.ibm.portal.xslt.loadXsl(sUrl);
}

ibm.portal.xml.xslt.transform = function (xml, xsl, sXslMode, aXslParams, bReturnString)
{
   ibm.portal.debug.entry( "transform", [xml,xsl,sXslMode,aXslParams,bReturnString] );  
   return com.ibm.portal.xslt.transform(xml, xsl, sXslMode, aXslParams, bReturnString );
}

ibm.portal.xml.xslt.transformAndUpdate = function (/*HTMLElement*/nodeToUpdate, /*XMLDocument*/xml, /*XMLDocument*/xsl, /*String?*/sXslMode, /*Map*/aXslParams) {
	ibm.portal.debug.entry( "transformAndUpdate", [ nodeToUpdate, xml, xsl, sXslMode, aXslParams ]);
	com.ibm.portal.xslt.transformAndUpdate(nodeToUpdate, xml, xsl, sXslMode, aXslParams);	
	ibm.portal.debug.exit( "transformAndUpdate" );
}

//---------------------------------------------------------------------- IE xml related utility methods

ibm.portal.xml.xslt.ie.loadXml = function(sUrl) {
	return com.ibm.portal.xslt.ie.loadXml(sUrl);
}

ibm.portal.xml.xslt.ie.loadXmlString = function(sXml) {
	return com.ibm.portal.xslt.ie.loadXmlString(sXml);
}

ibm.portal.xml.xslt.ie.loadXsl = function(sUrl) {
	return com.ibm.portal.xslt.ie.loadXsl(sUrl);
}

ibm.portal.xml.xslt.ie.transform = function(xmlDoc, xsl, sXslMode, aXslParams,bReturnString) {
	return com.ibm.portal.xslt.ie.transform(xmlDoc, xsl, sXslMode, aXslParams,bReturnString);
}

//---------------------------------------------------------------------- GECKO xml related utility methods

ibm.portal.xml.xslt.gecko.loadXml = function(sUrl) {
    return com.ibm.portal.xslt.gecko.loadXml(sUrl);
}

ibm.portal.xml.xslt.gecko.loadXmlString = function(sXml) {
    return com.ibm.portal.xslt.gecko.loadXmlString(sXml);
}

ibm.portal.xml.xslt.gecko.loadXsl = function(sUrl) {
	return com.ibm.portal.xslt.gecko.loadXsl(sUrl);
}

ibm.portal.xml.xslt.gecko.transform = function(xmlDoc, xsl, sXslMode, aXslParams,bReturnString) {
	return com.ibm.portal.xslt.gecko.transform(xmlDoc, xsl, sXslMode, aXslParams,bReturnString);
}

/* This method sets the content of a layer within the HTML page
 * to the result of transforming the xml parameter by the xsl
 * parameter. The xml and xsl parameters may be of any form
 * supported by the transformXml() method. The layer parameter
 * may be either a DOM object or the name of a DOM object that
 * can be found using the findObject() method.
 */

ibm.portal.xml.xslt.setLayerContentByXml = function (layer, xml, xsl, xslparam,bReturnString) {
    com.ibm.portal.xslt.setLayerContentByXml(layer, xml, xsl, xslparam,bReturnString);
}

}

if(!dojo._hasResource["com.ibm.portal.state"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.portal.state"] = true;
dojo.provide("com.ibm.portal.state");








dojo.declare("com.ibm.portal.state.StateManager", null, {

    /**
     * summary:
     *     Constructor which initializes our internal properties.
     */
    constructor: function(/*String*/ contentHandlerURL) {
        this.stateDOM = null;
        this.stateNode = null;
        this.ns = { "state" : "http://www.ibm.com/xmlns/prod/websphere/portal/v6.1/portal-state" };
        this.serializationManager = new com.ibm.portal.state.SerializationManager(contentHandlerURL);
    },

    /**
     * summary:
     *     Gets the current navigational state that can be read or modified
     *     using the offered state accessors.
     */
    getState: function() {
        return this.stateDOM; // dojo.dom.DOMDocument - DOM representing the navigational state
    },
	
    /**
     * summary:
     *     Creates a new state DOM. If a state is provided, this method will create a
     *     deep copy of the given state. Otherwise a new empty state DOM is created.
     *     
     * state: dojo.dom.DOMDocument - State that should be cloned. May be NULL.
     * xslDoc: dojo.dom.DOMDocument - XSL transformation which should be applied to the state copy. May be NULL.
     * xslParams: Map - Map of XSL parameters. May be NULL.
     */
    newState: function(/*dojo.dom.DOMDocument*/ state, /*dojo.dom.DOMDocument*/ xslDoc, /*Map*/ xslParams) {
        var resultState = null;
        // just create a new document if state is null
        if (state == null) {
            resultState = dojox.data.dom.createDocument();
        } else {
            // just clone the given state if no XSL transformation has been passed in
            if (xslDoc == null) {
                resultState = dojox.data.dom.createDocument(dojox.data.dom.innerXML(state));
            } else {
                // apply transformation; pass in XSL parameters
                var xslt = com.ibm.portal.xslt;
                var results = xslt.transform(state, xslDoc, null, xslParams, true);
                resultState = dojox.data.dom.createDocument(results);
            }
        }
        return resultState; /*dojo.dom.DOMDocument*/
    },
    
    /**
     * summary:
     *     Sets the current navigational state that can be read or modified
     *     using the offered state accessors.
     *     
     * state: dojo.dom.DOMDocument - the navigational state represented as a DOM.
     */
    reset: function(/*dojo.dom.DOMDocument*/ stateDOM) {        
        // remember the state
        this.stateDOM = stateDOM;
        // make sure that at least the "<state type='navigational'>" element exists
        this.stateNode = this._getStateNode(stateDOM);         
    },
	
    /**
     * summary:
     *     Returns a SerializationManager which cam be used to serialize /deserialize
     *     state. 
     */
    getSerializationManager: function() {
        return this.serializationManager;
    },
    
    /**
     * summary:
     *     Gets a state accessor that allows for reading and writing navigational
     *     state of a portlet. This includes portlet mode, window state, and render
     *     parameters.
     *     
     * portletWindowID: String - Unique identifier of the portlet window. Must not
     *     be NULL. 
     * state: dojo.dom.DOMDocument - the navigational state the requested portlet
     *     accessor should operate on. Pass in NULL to indicate that the internal state
     *     of the state manager should be used.  
     */
    newPortletAccessor: function(/*String*/ portletWindowID, /*dojo.dom.DOMDocument*/ state) {
        var stNode;
        var stDOM;
        if (state == null || this.stateDOM == state) {
            stNode = this.stateNode;
            stDOM = this.stateDOM;
        } else {
            stNode = this._getStateNode(state);
            stDOM = state;
        }
        
        // get the portlet node
        var expr = "state:portlet[@id='" + portletWindowID + "']";
        var portletNode = this._getSpecificStateNode("portlet", expr, stNode, stDOM);
        portletNode.setAttribute("id", portletWindowID);
        
        return new com.ibm.portal.state.PortletAccessor(portletNode, stDOM);
        // com.ibm.portal.state.PortletAccessor - Accessor to read and write portlet-specific state.
    },
	
    /**
     * summary:
     *     Gets a state accessor that allows for reading the set of portlet IDs that are
     *     part of the state DOM.
     *     
     * state: dojo.dom.DOMDocument - the navigational state the requested portlet
     *     accessor should operate on. Pass in NULL to indicate that the internal state
     *     of the state manager should be used.  
     */
    newPortletListAccessor: function(/*dojo.dom.DOMDocument*/ state) {
        var stNode;
        var stDOM;
        if (state == null || this.stateDOM == state) {
            stNode = this.stateNode;
            stDOM = this.stateDOM;
        } else {
            stNode = this._getStateNode(state);
            stDOM = state;
        }

        return new com.ibm.portal.state.PortletListAccessor(stNode, stDOM);
        // com.ibm.portal.state.PortletListAccessor - Accessor to read portlet IDs.
    },    
    
    /**
     * summary:
     *     Gets a state accessor that allows for reading and writing page selection
     *     state information. This includes the currently selected page as well as label
     *     mappings.
     *     
     * state: dojo.dom.DOMDocument - the navigational state the requested selection
     *     accessor should operate on. Pass in NULL to indicate that the internal state
     *     of the state manager should be used. 
     */
    newSelectionAccessor: function(/*dojo.dom.DOMDocument*/ state) {

        var stNode;
        var stDOM;
        if (state == null || this.stateDOM == state) {
            stNode = this.stateNode;
            stDOM = this.stateDOM;
        } else {
            stNode = this._getStateNode(state);
            stDOM = state;
        }

        // get the selection node
        var selectionNode = this._getSpecificStateNode("selection", "state:selection", stNode, stDOM);

        return new com.ibm.portal.state.SelectionAccessor(selectionNode, stDOM);
        // com.ibm.portal.state.SelectionAccessor - Accessor to read and write page selection state.
    },
    
    /**
     * summary:
     *     Gets a state accessor that allows to check whether or not a portlet window
     *     is in solo state or to set a portlet window to solo state.
     *     
     * state: dojo.dom.DOMDocument - the navigational state the requested solo state
     *     accessor should operate on. Pass in NULL to indicate that the internal state
     *     of the state manager should be used. 
     */
    newSoloStateAccessor: function(/*dojo.dom.DOMDocument*/ state) {

        var stNode;
        var stDOM;
        if (state == null || this.stateDOM == state) {
            stNode = this.stateNode;
            stDOM = this.stateDOM;
        } else {
            stNode = this._getStateNode(state);
            stDOM = state;
        }

        // get the node keeping the solo state information
        var soloNode = this._getSpecificStateNode("solo", "state:solo", stNode, stDOM);

        return new com.ibm.portal.state.SoloStateAccessor(soloNode, stDOM);
        // com.ibm.portal.state.SoloStateAccessor - Accessor to read and write solo state.
    },
    /**
     * summary:
     *     Gets a state accessor that allows to check whether or not a theme-template
     * 	   has been specified and, if not, set one.
     *     
     * state: dojo.dom.DOMDocument - the navigational state the requested theme-template
     *     accessor should operate on. Pass in NULL to indicate that the internal state
     *     of the state manager should be used. 
     */
    newThemeTemplateAccessor: function(/*dojo.dom.DOMDocument*/ state) {

        var stNode;
        var stDOM;
        if (state == null || this.stateDOM == state) {
            stNode = this.stateNode;
            stDOM = this.stateDOM;
        } else {
            stNode = this._getStateNode(state);
            stDOM = state;
        }

        // get the node keeping the theme-template information
        var templateNode = this._getSpecificStateNode("theme-template", "state:theme-template", stNode, stDOM);

        return new com.ibm.portal.state.ThemeTemplateAccessor(templateNode, stDOM);
        // com.ibm.portal.state.ThemeTemplateAccessor - Accessor to read and write theme-template state.
    },
    
    /**
     * summary:
     *     Gets a state accessor that allows to check whether or not a locale
     * 	   has been specified and, if not, set one.
     *     
     * state: dojo.dom.DOMDocument - the navigational state the requested locale
     *     accessor should operate on. Pass in NULL to indicate that the internal state
     *     of the state manager should be used. 
     */
    newLocaleAccessor: function(/*dojo.dom.DOMDocument*/ state) {

        var stNode;
        var stDOM;
        if (state == null || this.stateDOM == state) {
            stNode = this.stateNode;
            stDOM = this.stateDOM;
        } else {
            stNode = this._getStateNode(state);
            stDOM = state;
        }

        // get the node keeping the locale information
        var localeNode = this._getSpecificStateNode("locale", "state:locale", stNode, stDOM);

        return new com.ibm.portal.state.LocaleAccessor(localeNode, stDOM);
        // com.ibm.portal.state.LocaleAccessor - Accessor to read and write locale information.
    },

    /**
     * summary:
     *     Returns a state accessor that allows to include a state partition id into the state.
     *     
     * state: dojo.dom.DOMDocument - the navigational state the requested state partition
     *     accessor should operate on. Pass in NULL to indicate that the internal state
     *     of the state manager should be used. 
     */
    newStatePartitionAccessor: function(/*dojo.dom.DOMDocument*/ state) {

        var stNode;
        var stDOM;
        if (state == null || this.stateDOM == state) {
            stNode = this.stateNode;
            stDOM = this.stateDOM;
        } else {
            stNode = this._getStateNode(state);
            stDOM = state;
        }

        // get the node keeping the state partition information
        var partitionNode = this._getSpecificStateNode("statepartition", "state:statepartition", stNode, stDOM);

        return new com.ibm.portal.state.StatePartitionAccessor(partitionNode, stDOM);
        // com.ibm.portal.state.StatePartitionAccessor - Accessor to set a state partition.
    },    

    /**
     * summary:
     *     Internal method that resolves the <state type='navigational' /> node which is
     *     the root node of navigational state information. If not already present, this
     *     method will create the state node.
     *     
     * aStateDOM: dojo.dom.DOMDocument - the navigational state document that should be inspected.
     *    Must not be NULL. 
     */
    _getStateNode: function(aStateDOM) {
        var expr = "state:root/state:state[@type='navigational']";
        var nodes = com.ibm.portal.xpath.evaluateXPath(expr, aStateDOM, this.ns);
        var stateNode = null;         
        if (nodes == null || nodes.length <= 0) {
            var rootNode = aStateDOM.firstChild;
            
            //make sure we really have the root node and not any processing instructions
            while ( rootNode && rootNode.nodeType == 7 ) {
            	rootNode = rootNode.nextSibling;
            }
            
			if (rootNode == null) {
                // create the root element
                rootNode = this._createElement(aStateDOM, "root");
                this._prependChild(rootNode, aStateDOM);
			} 
            stateNode = rootNode.firstChild;
			if (stateNode == null) {
                // create the state element
                stateNode = this._createElement(aStateDOM, "state");
                this._prependChild(stateNode, rootNode);
            }
            // add the 'type' attribute
            stateNode.setAttribute("type", "navigational");
        } else {
            // in most cases we will end up here
            stateNode = nodes[0];
        }
        return stateNode; 
    },
   
    /**
     * summary:
     *     Internal method that resolves a specific state node with the given node name
     *     which is located as a child of the given <state type='navigational'> node.
     *     If the node does not exist, this method will create a new node. 
     *     
     * aNodeName: String - the name of the node that should be resolved. Must not be NULL.
     * aPathExpression: String - XPath expression that addresses the node to be resolved
     *     relative to the given state node.
     * aStateNode: Element - DOM element representing the <state type='navigational'> node.
     * aStateDOM: dojo.dom.DOMDocument - the navigational state document that should be
     *     inspected. Must not be NULL. 
     */
    _getSpecificStateNode: function(aNodeName, aPathExpression, aStateNode, aStateDOM) {
        // evaluate the expression starting from the state node
        var nodes = com.ibm.portal.xpath.evaluateXPath(aPathExpression, aStateNode, this.ns);
        var node;
        if (nodes == null || nodes.length <= 0) {
            // create the state element
            node = this._createElement(aStateDOM, aNodeName);
            this._prependChild(node, aStateNode);
        } else {
            node = nodes[0];
        }
        return node;
    },
	_prependChild: function(/*DOMElement*/node, /*DOMElement*/parent){
		parent.firstChild ?	parent.insertBefore(node, parent.firstChild): parent.appendChild(node);
	},	    
    _createElement: function(dom, name) {
        var newElem;
        if (dojo.isIE) {
            newElem = dom.createNode(1, name, this.ns.state); // 1 = NODE_ELEMENT
        } else {
            newElem = dom.createElementNS(this.ns.state, name);
        }
        return newElem;
    }
    
});


dojo.declare("com.ibm.portal.state.PortletAccessor", null, {
    
    /**
     * summary:
     *     Constructor which initializes this acccessor with the
     *     state DOM and the DOM node that keeps the state information
     *     of the respective portlet window in its subtree.
     */
    constructor: function (/*Element*/ portletNode, 
                           /*dojo.dom.DOMDocument*/ stateDOM) {

        this.portletNode = portletNode;
        this.stateDOM = stateDOM;
        this.parameters = new com.ibm.portal.state.Parameters(portletNode, stateDOM);
        this.ns = { "state" : "http://www.ibm.com/xmlns/prod/websphere/portal/v6.1/portal-state" };

        this.xsltURL = dojo.moduleUrl( "com", "ibm/portal/state/");
    },

    /**
     * summary:
     *     Gets the current portlet mode of the portlet window this accessor
     *     operates on.
     */
    getPortletMode: function() {
        
        var expr = "state:portlet-mode";
        var nodes = com.ibm.portal.xpath.evaluateXPath(expr, this.portletNode, this.ns);
        var portletMode = ibm.portal.portlet.PortletMode.VIEW; 
        if (nodes != null && nodes.length > 0) {
            var txtNode = nodes[0].firstChild;
            if (txtNode != null) {
                portletMode = txtNode.nodeValue;
            }
        }
        return portletMode; // ibm.portal.portlet.PortletMode - The current portlet mode.
    },
	
    /**
     * summary:
     *     Gets the current window state of the portlet window this accessor
     *     operates on.
     */
    getWindowState: function() {
        var expr = "state:window-state";
        var nodes = com.ibm.portal.xpath.evaluateXPath(expr, this.portletNode, this.ns);
        var windowState = ibm.portal.portlet.WindowState.NORMAL; 
        if (nodes != null && nodes.length > 0) {
            var txtNode = nodes[0].firstChild;
            if (txtNode != null) {
                windowState = txtNode.nodeValue;
            }
        }
        return windowState; // ibm.portal.portlet.WindowState - The current window state.
    },

    /**
     * summary:
     *     Gets the current render parameters of the portlet window this accessor
     *     operates on. The returned Parameters object allows for querying, adding,
     *     modifying and removing parameters.
     */
    getRenderParameters: function() {
        return this.parameters; // com.ibm.portal.state.Parameters - The current render parameters. 
    },

    /**
     * summary:
     *     Sets the portlet mode of the portlet window this accessor operates on
     *     by changing the navigational state DOM accordingly.
     *     
     * portletMode: ibm.portal.portlet.PortletMode - the portlet mode to be set.
     *     Must not be NULL. 
     */
    setPortletMode: function(/*ibm.portal.portlet.PortletMode*/ portletMode) {
        var expr = "state:portlet-mode";
        var nodes = com.ibm.portal.xpath.evaluateXPath(expr, this.portletNode, this.ns);
        if (nodes == null || nodes.length <= 0) {
            var portletModeNode = this._createElement(this.stateDOM, "portlet-mode");
            this._prependChild(portletModeNode, this.portletNode);
			var txtNode = this.stateDOM.createTextNode(portletMode);
            this._prependChild(txtNode, portletModeNode);
        } else {
            nodes[0].firstChild.nodeValue = portletMode;
        }
    },

    /**
     * summary:
     *     Sets the window state of the portlet window this accessor operates on
     *     by changing the navigational state DOM accordingly.
     *     
     * windowState: ibm.portal.portlet.WindowState - the window state to be set.
     *     Must not be NULL. 
     */
    setWindowState: function(/*ibm.portal.portlet.WindowState*/ windowState) {
        var expr = "state:window-state";
        var nodes = com.ibm.portal.xpath.evaluateXPath(expr, this.portletNode, this.ns);
        if (nodes == null || nodes.length <= 0) {
            var windowStateNode = this._createElement(this.stateDOM, "window-state");
            this._prependChild(windowStateNode, this.portletNode);
            var txtNode = this.stateDOM.createTextNode(windowState)
            this._prependChild(txtNode, windowStateNode);
        } else {
            nodes[0].firstChild.nodeValue = windowState;
        }
    },
    
    /**
     * summary:
     *     Gets a dojo.dom.DOMDocument which contains only the state of the portlet
     *     this accessor operates on. The returned DOMDocument still complies with the
     *     state.DTD i.e. it contains the complete path to the portlet node that
     *     contains the portlet's state information. 
     */
    getPortletState: function() {
        // TODO implement this function using XSLT
        
        /*var xslt = com.ibm.portal.xslt;
        // load the xsl file
        var uri = this.xsltURL + "SelectPortletState.xsl";
        var xslDoc = xslt.loadXsl(uri);
	    // apply the transformation
	    if (xslDoc.documentElement == null) { alert("xslDoc is null"); }
    	var results = xslt.transform(this.stateDOM, xslDoc, null, {"id" : this.portletNode.getAttribute("id")}, true);
        return dojo.dom.createDocumentFromText(results);*/
        
        // get a new portlet accessor operating on a new empty state
        var newDOM = dojox.data.dom.createDocument();
        var portletAcc = com.ibm.portal.state.STATE_MANAGER.newPortletAccessor(this.portletNode.getAttribute("id"), newDOM);
        portletAcc.setPortletMode(this.getPortletMode());
        portletAcc.setWindowState(this.getWindowState());
        var paramMap = this.getRenderParameters().getMap();
        if (paramMap.length > 0) {
            portletAcc.getRenderParameters().putAll(paramMap);
        }
        return newDOM; /* dojo.dom.DOMDocument */
    },

    /**
     * summary:
     *     Sets the complete state of the portlet this accessor operates on.
     *     Ignores all state information in the given state that is not
     *     related to the portlet this accessor operates on. 
     *     
     *  state: dojo.dom.DOMDocument - The state DOM that contains state for the
     *      portlet this accessor operates on. Must not be NULL.
     *  merge: boolean - Flag that indicates whether the given state of the portlet
     *      should be merged into the state of the accessor or if it should be replaced.
     *      May be NULL which defaults to false, i.e. the current state of the portlet
     *      is replaced with the state retrieved from the given DOM. 
     */
    setPortletState: function(/* dojo.dom.DOMDocument */ state, /* boolean */ merge) {
        // TODO implement this function using XSLT
        
        // get a new portlet accessor operating on a new empty state
        var portletAcc = com.ibm.portal.state.STATE_MANAGER.newPortletAccessor(this.portletNode.getAttribute("id"), state);
        this.setPortletMode(portletAcc.getPortletMode());
        this.setWindowState(portletAcc.getWindowState());
        var paramMap = portletAcc.getRenderParameters().getMap();
        // clear parameters only if we should replace them
        if (merge == null || merge == false) {
            this.getRenderParameters().clear();
        }
        if (paramMap.length > 0) {
            this.getRenderParameters().putAll(paramMap);
        }
    },
	_prependChild: function(/*DOMElement*/node, /*DOMElement*/parent){
		parent.firstChild ?	parent.insertBefore(node, parent.firstChild): parent.appendChild(node);
	},	
    _createElement: function(dom, name) {
        var newElem;
        if (dojo.isIE) {
            newElem = dom.createNode(1, name, this.ns.state); // 1 = NODE_ELEMENT
        } else {
            newElem = dom.createElementNS(this.ns.state, name);
        }
        return newElem;
    }
    
});	



dojo.declare("com.ibm.portal.state.Parameters", null, {

    /**
     * summary:
     *     Constructor which initializes this Parameters object with the
     *     state DOM and the DOM node that keeps the parameters information.
     */
    constructor: function(/*Element*/ baseNode, /*dojo.dom.DOMDocument*/ stateDOM) {
        this.baseNode = baseNode;
        this.stateDOM = stateDOM;
        this.ns = { "state" : "http://www.ibm.com/xmlns/prod/websphere/portal/v6.1/portal-state" };
    },

    /**
     * summary: 
     *     Returns a read-only parameter map represented as a Object[].
     *     Returns an empty map if no parameters are available.
     */
    getMap: function() {
        var names = this.getNames();
        var map = new Array(names.length);
        for (var i = 0; i < names.length; i++) {
            var name = names[i];
            map[i] = {name: name, values : this.getValues(name)};
        }
        return map; // Object[] {name: String, values: String[]}
    },

    /**
     * summary:
     *     Returns a String[] containing the names of all parameters that have an
     *     associated value. Returns an empty array if no parameters are available.
     */
    getNames: function() {
        var expr = "state:parameters/state:param";
        var nodes = com.ibm.portal.xpath.evaluateXPath(expr, this.baseNode, this.ns);
        var names = new Array();
        if (nodes != null && nodes.length > 0) {
            var nodeCount = nodes.length;
            for (var i = 0; i < nodeCount; i++) {
                names[i] = nodes[i].getAttribute("name");
            }
        }
        return names;
    },

    /**
     * summary:
     *     Returns the String value associated with the parameter with the given name.
     *     
     * description:
     *     If there are one or more parameter values associated with the given name 
     * 	   it returns the first associated value.
     *
     * name: String - Name of the parameter for which the associated value is to
     *     be returned. Must not be NULL.
     */
    getValue: function(/*String*/ name) {
        var values = this.getValues(name);
        var firstValue = null;
        if (values != null && values.length > 0) {
            firstValue = values[0];
        }
		return firstValue;
    },

    /**
     * summary:
     *     Returns the String[] representing the values that are associated with
     *     the parameter with the given name.
     *
     * name: String - Name of the parameter for which the associated values are to
     *     be returned. Must not be NULL.
     */
    getValues: function(/*String*/ name) {
        var expr = "state:parameters/state:param[@name='" + name + "']/state:value";
        var nodes = com.ibm.portal.xpath.evaluateXPath(expr, this.baseNode, this.ns);
        var values = null;
        if (nodes != null && nodes.length > 0) {
            values = new Array(nodes.length);
            var nodeCount = nodes.length;
            for (var i = 0; i < nodeCount; i++) {
                // get the text value
                var txtNode = nodes[i].firstChild;
                if (txtNode != null) {
                    values[i] = txtNode.nodeValue;
                }
            }
        }
        return values;
    },

    /**
     * summary:
     *     Removes the parameter with the given name.
     *
     * name: String - Name of the parameter that should be removed. Must not be NULL.
     */
    remove: function (/*String*/ name) {
        var expr = "state:parameters/state:param[@name='" + name + "']";
        var nodes = com.ibm.portal.xpath.evaluateXPath(expr, this.baseNode, this.ns);
        if (nodes != null) {
			var toRemove = nodes[0];
			if(toRemove && toRemove.parentNode){
				toRemove.parentNode.removeChild(toRemove);
			}
		} 
    },

    /**
     * summary:
     *     Adds all parameters that are contained in the given map. Overrides the values
     *     of parameters that already exist.
     *
     * map: Object[] {name: String, values: String[]} - Two dimensional object array
     *     representing the map of parameters that should be added. Must not be NULL.
     */
    putAll: function(/*Object[] {name: String, values: String[]}*/ map) {
        if (map != null && map.length > 0) {
            for (var i = map.length - 1; i >= 0; i--) {
                var paramName = map[i].name;
                var paramValues = map[i].values;
                this.setValues(paramName, paramValues);
            }
        }
    },

    /**
     * summary:
     *     Sets a simple String value for the parameter with the given name. Overrides
     *     the value of the parameter if it already exists.
     *
     * name: String - The name of the parameter. Must not be NULL.
     * value: String - The value of the parameter that should be set. Must not be NULL. 
     */
    setValue: function (/*String*/ name, /*String*/ value) {
        this.setValues(name, new Array(value));
    },

    /**
     * summary:
     *     Sets a String[] representing the value of the parameter with the given name.
     *     Overrides the value of the parameter if it already exists.
     *
     * name: String - The name of the parameter. Must not be NULL.
     * value: String[] - The value of the parameter that should be set. Must not be NULL. 
     */
    setValues: function(/*String*/ name, /*String[]*/ values) {
        var expr = "state:parameters/state:param[@name='" + name + "']";
        var nodes = com.ibm.portal.xpath.evaluateXPath(expr, this.baseNode, this.ns);
        var paramNode;
        if (nodes == null || nodes.length == 0) {
            // create the parameters node
            var paramsNode = null;// this._getFirstChildWithTag(this.baseNode, "state:parameters"); // do we really need to use the NS prefix here? bug??
            if (paramsNode == null) {
                paramsNode = this._createElement(this.stateDOM, "parameters");
                this._prependChild(paramsNode, this.baseNode);
            }
            // create the param node
            paramNode = this._createElement(this.stateDOM, "param");
            paramNode.setAttribute("name", name);
            this._prependChild(paramNode, paramsNode);
        } else {
            paramNode = nodes[0];
			// remove all children of paramNode
			dojox.data.dom.removeChildren(paramNode);
        }
        // putAll sometimes passes in null for values
        if (values != null) {
            for (var i = values.length - 1; i >= 0; i--) {
                var valueNode = this._createElement(this.stateDOM, "value");
                this._prependChild(valueNode, paramNode);
                var value = values[i];
                // make sure that we do not encode something like "undefined" into a value node 
                if (value != null) {
                    var txtNode = this.stateDOM.createTextNode(value);
                    this._prependChild(txtNode, valueNode);
                }
            }
        }
    },

    /**
     * summary:
     *     Removes all existing parameters.
     */
    clear: function() {
        var expr = "state:parameters";
        var nodes = com.ibm.portal.xpath.evaluateXPath(expr, this.baseNode, this.ns);
        if (nodes != null) {
			var toRemove = nodes[0];
			if(toRemove && toRemove.parentNode){
				toRemove.parentNode.removeChild(toRemove);
			}
        } 
    },
	_getFirstChildWithTag: function(parentNode, tagName){
		// validate arguments
		if(!parentNode || !tagName) return null;
		var node = parentNode.firstChild;
		// iterate over all children
		while(node){
			// if an element node has a tag equal to tagname, return it
			if( node.nodeType == 1 && node.tagName && node.tagName.toLowerCase() == tagName.toLowerCase()){
				return node;
			}
			// otherwise, move on to the next sibling
			node = node.nextSibling;
		}
		// if we got here, we didn't find a match
		return null;
	},	
	_prependChild: function(/*DOMElement*/node, /*DOMElement*/parent){
		parent.firstChild ?	parent.insertBefore(node, parent.firstChild): parent.appendChild(node);
	},	    
    _createElement: function(dom, name) {
        var newElem;
        if (dojo.isIE) {
            newElem = dom.createNode(1, name, this.ns.state); // 1 = NODE_ELEMENT
        } else {
            newElem = dom.createElementNS(this.ns.state, name);
        }
        return newElem;
    }
	
});	


dojo.declare("com.ibm.portal.state.PortletListAccessor", null, {
   
    /**
     * summary:
     *     Constructor which initializes this accessor with the state DOM
     *     and the DOM node representing the root of navigational state
     *     information in the state DOM.
     */
    constructor: function(/*Element*/stateNode, /*dojo.dom.DOMDocument*/ stateDOM) {
        this.stateNode = stateNode;
        this.stateDOM = stateDOM;
        this.ns = { "state" : "http://www.ibm.com/xmlns/prod/websphere/portal/v6.1/portal-state" };
    },

    /**
     * summary:
     *     Returns an array of Strings representing the IDs of the portlet windows
     *     that are part of the state DOM this accessor operates on. Returns null
     *     the state DOM does not contain any portlet-related state information.
     */
    getPortlets: function() {
        // get all portlet nodes
        var expr = "state:portlet";
        var nodes = com.ibm.portal.xpath.evaluateXPath(expr, this.stateNode, this.ns);
        var portletIDs = null;
        if (nodes != null && nodes.length > 0) {
            portletIDs = new Array(nodes.length);
            for (var i=0; i < nodes.length; i++) {
               var node = nodes[i];
               portletIDs[i] = node.getAttribute("id");  
            }
        }
        return portletIDs; /*String[]*/
    }
    
});


dojo.declare("com.ibm.portal.state.SelectionAccessor", null, {
    
    /**
     * summary:
     *     Constructor which initializes this accessor with the state DOM
     *     and the DOM node that keeps the selection information.
     */
    constructor: function(/*Element*/selectionNode, /*dojo.dom.DOMDocument*/ stateDOM) {
        this.selectionNode = selectionNode;
        this.stateDOM = stateDOM;
        this.parameters = new com.ibm.portal.state.Parameters(this.selectionNode, stateDOM);
        this.ns = { "state" : "http://www.ibm.com/xmlns/prod/websphere/portal/v6.1/portal-state" };
    },

    /**
     * summary:
     *     Returns a String representing the unique identifier of the
     *     navigation node that represents the currently selected page.
     */
    getPageSelection: function() {
        return this.selectionNode.getAttribute("selection-node"); // String
    },
	
    /**
     * summary:
     *     Returns a String representing the unique identifier of the
     *     selected fragment. Typically the fragment is a layout node
     *     that is part of the layout model of the currently selected page.
     */
    getFragmentSelection: function() {
        var params = this.getParameters();
        var fragmentParams = params.getValues("frg");
        var fragmentID = null;
        if (fragmentParams != null && fragmentParams.length > 0) {
            fragmentID = fragmentParams[0];
            if (fragmentParams.length > 1) {
                if (fragmentID == "pw") {
                    fragmentID = fragmentParams[1];
                }
            }    
        }
        return fragmentID; // String
    },
    
    /**
     * summary:
     *     Returns a String representing the unique ID of the navigation node
     *     that represents the page that should be selected instead of the
     *     label with the given identifier. Returns null if there is no
     *     mapping available for the given label ID.
     *     
     * srcID:
     *     String representing the ID of the label that should be resolved.
     *     Must not be NULL.
     */
    getMapping: function(/*String*/ srcID) {
        var expr = "state:mapping[@src='" + srcID + "']";
        var nodes = com.ibm.portal.xpath.evaluateXPath(expr, this.selectionNode, this.ns);
        var targetID = null;
        if (nodes != null && nodes.length > 0) {
            var mappingNode = nodes[0];
            targetID = mappingNode.getAttribute("dst");
        }
        return targetID; // String or null
    },

    /**
     * summary:
     *     Returns a com.ibm.portal.state.Parameters object which contains
     *     selection parameters. Does not return NULL.
     * 
     */
    getParameters: function() {
        return this.parameters; // com.ibm.portal.state.Parameters
    },
    
    /**
     * summary:
     *     Changes the selection according to the given navigation node ID.
     *     
     * navigationNodeID:
     *     String representing the identifier of the page or label that should
     *     be selected. Must not be NULL.
     */
    setPageSelection: function(/*String*/ navigationNodeID) {
        this.selectionNode.setAttribute("selection-node", navigationNodeID);
    },

    /**
     * summary:
     *     Changes the fragment selection according to the given layout node ID.
     *     
     * layoutNodeID:
     *     String representing the identifier of the layout node that represents
     *     the oage fragment that should be selected. Must not be NULL.
     * isPortletWindow:
     *     Flag which indicates whether or not the layout node represents a
     *     portlet window. May be NULL to indicate that the layout node is a
     *     portlet window.
     */
    setFragmentSelection: function(/*String*/ layoutNodeID, /*boolean*/ isPortletWindow) {
        var params = this.getParameters();
        if (isPortletWindow == null || isPortletWindow == true) {
            var values = new Array(2);
            values[0] = layoutNodeID;
            values[1] = "pw";
            params.setValues("frg", values);
        } else {
            params.setValue("frg", layoutNodeID);
        }
    },

    /**
     * summary:
     *     Sets a label mapping that specifies the page that should be
     *     selected instead of the label. The label is identified via the
     *     given source ID, the page via the target ID. If the given targetID
     *     is null, the method will completely remove the mapping from the state.
     *     
     * srcID:
     *     ID of the label that should be mapped to a page. Must not be NULL.
     * targetID:
     *     ID of the page the label should be mapped to. May be NULL..
     */
    setMapping: function(/*String*/ srcID, /*String*/ targetID ) {
        if (targetID != null) {
            var expr = "state:mapping[@src='" + srcID + "']";
            var nodes = com.ibm.portal.xpath.evaluateXPath(expr, this.selectionNode, this.ns);
            var mappingNode;
            if (nodes != null && nodes.length > 0) {
                mappingNode = nodes[0];
            } else {
                mappingNode = this._createElement(this.stateDOM, "mapping");
                this._prependChild(mappingNode, this.selectionNode);
                mappingNode.setAttribute("src", srcID);
            }
            mappingNode.setAttribute("dst", targetID);
        } else {
            // this is equivalent with removing the mapping
            this.removeMapping(srcID);
        }
    },

    /**
     * summary:
     *     Removes the label mapping with the given source ID.
     *     
     * srcID:
     *     ID of the label that should be removed. Must not be NULL.
     */
    removeMapping: function(/*String*/ srcID) {
        var expr = "state:mapping[@src='" + srcID + "']";
        var nodes = com.ibm.portal.xpath.evaluateXPath(expr, this.selectionNode, this.ns);
        var removed = false;
        if (nodes != null && nodes.length > 0) {
            // actually there should be only one such node
            // but clean up if we ran into an inconsistent state 
            for (var i=0; i < nodes.length; i++) {
	   			var toRemove = nodes[i];
				if(toRemove && toRemove.parentNode){
					toRemove.parentNode.removeChild(toRemove);
				}

            }
            removed = true;
        }
        return removed;
    },
	_prependChild: function(/*DOMElement*/node, /*DOMElement*/parent){
		parent.firstChild ?	parent.insertBefore(node, parent.firstChild): parent.appendChild(node);
	},	    
    _createElement: function(dom, name) {
        var newElem;
        if (dojo.isIE) {
            newElem = dom.createNode(1, name, this.ns.state); // 1 = NODE_ELEMENT
        } else {
            newElem = dom.createElementNS(this.ns.state, name);
        }
        return newElem;
    },
    
    /**
     * @deprecated: use getPageSelection instead
     */
    getSelection: function() {
        return this.getPageSelection(); // String
    },

    /**
     * @deprecated: use setPageSelection instead
     */
    setSelection: function(/*String*/ navigationNodeID) {
        this.setPageSelection(navigationNodeID);
    }
    
});	


dojo.declare("com.ibm.portal.state.SoloStateAccessor", null, {
    
    /**
     * summary:
     *     Constructor which initializes this accessor with the state DOM
     *     and the DOM node that keeps the solo state information.
     */
    constructor: function(/*Element*/soloNode, /*dojo.dom.DOMDocument*/ stateDOM) {
        this.soloNode = soloNode;
        this.stateDOM = stateDOM;
        this.ns = { "state" : "http://www.ibm.com/xmlns/prod/websphere/portal/v6.1/portal-state" };
    },

    /**
     * summary:
     *     Sets the portlet window with the given ID into solo state.
     *     
     * portletWindowID:
     *     String representing the identifier of the portlet window which should
     *     be set to solo state. To entirely delete the solo state information from
     *     the state DOM, pass in NULL.
     */
    setSoloPortlet: function(/*String*/ portletWindowID) {
         // first remove child nodes
         dojox.data.dom.removeChildren(this.soloNode);
         if (portletWindowID != null) {
             // create a new text node and append it
             var txtNode = this.stateDOM.createTextNode(portletWindowID)
             this._prependChild(txtNode, this.soloNode);
         }
    },

    /**
     * summary:
     *     Returns the ID of the portlet window which is currently in solo state.
     *     Returns NULL if no such portlet window exists.
     */
    getSoloPortlet: function() {
        var txtNode = this.soloNode.firstChild;
        if (txtNode != null) {
            return txtNode.nodeValue;
        } else {
            return null;
        }
    },

    /**
     * summary:
     *     Sets the page the portal should navigate to after leaving
     *     Solo state.
     * 
     * pageID:
     *     ID of the return page. Must not be NULL.
     */ 
    setReturnSelection: function(/*String*/ pageID) {
        this.soloNode.setAttribute("return-selection", pageID);
    },

    /**
     * summary:
     *     Returns the ID of the page the portal navigates to
     *     after leaving Solo state.
     */
    getReturnSelection: function() {
        return this.soloNode.getAttribute("return-selection");
    },
	_prependChild: function(/*DOMElement*/node, /*DOMElement*/parent){
		parent.firstChild ?	parent.insertBefore(node, parent.firstChild): parent.appendChild(node);
	}   


});

dojo.declare("com.ibm.portal.state.ThemeTemplateAccessor", null, {
    
    /**
     * summary:
     *     Constructor which initializes this accessor with the state DOM
     *     and the DOM node that keeps the theme-template state information.
     */
    constructor: function(/*Element*/themeTemplateNode, /*dojo.dom.DOMDocument*/ stateDOM) {
        this.themeTemplateNode = themeTemplateNode;
        this.stateDOM = stateDOM;
        this.ns = { "state" : "http://www.ibm.com/xmlns/prod/websphere/portal/v6.1/portal-state" };
    },
    
    /**
     * summary:
     *     Sets the theme-template to the given value.
     *     
     * themeTemplate:
     *     String representing the theme-template which should be set. To entirely delete the theme-template
     *     information from the state DOM, pass in NULL.
     */
    setThemeTemplate: function(/*String*/ themeTemplate) {
         // first remove child nodes
         dojox.data.dom.removeChildren(this.themeTemplateNode);
         if (themeTemplate != null) {
             // create a new text node and append it
             var txtNode = this.stateDOM.createTextNode(themeTemplate)
             this._prependChild(txtNode, this.themeTemplateNode);
         }
    },

    /**
     * summary:
     *     Returns the name of the current theme-template.
     *     Returns NULL if no such value exists.
     */
    getThemeTemplate: function() {
        var txtNode = this.themeTemplateNode.firstChild;
        if (txtNode != null) {
            return txtNode.nodeValue;
        } else {
            return null;
        }
    },
	_prependChild: function(/*DOMElement*/node, /*DOMElement*/parent){
		parent.firstChild ?	parent.insertBefore(node, parent.firstChild): parent.appendChild(node);
	}
	
});

dojo.declare("com.ibm.portal.state.LocaleAccessor", null, {
    
    /**
     * summary:
     *     Constructor which initializes this accessor with the state DOM
     *     and the DOM node that keeps the locale information.
     */
    constructor: function(/*Element*/localeNode, /*dojo.dom.DOMDocument*/ stateDOM) {
        this.localeNode = localeNode;
        this.stateDOM = stateDOM;
        this.ns = { "state" : "http://www.ibm.com/xmlns/prod/websphere/portal/v6.1/portal-state" };
    },
    
    /**
     * summary:
     *     Sets the locale to the given value.
     *     
     * themeTemplate:
     *     String representing the locale which should be set. To entirely delete the locale
     *     information from the state DOM, pass in NULL.
     */
    setLocale: function(/*String*/ locale) {
         // first remove child nodes
         dojox.data.dom.removeChildren(this.localeNode);
         if (locale != null) {
             // create a new text node and append it
             var txtNode = this.stateDOM.createTextNode(locale)
             this._prependChild(txtNode, this.localeNode);
         }
    },

    /**
     * summary:
     *     Returns the name of the current locale in the state.
     *     Returns NULL if no such value exists.
     */
    getLocale: function() {
        var txtNode = this.localeNode.firstChild;
        if (txtNode != null) {
            return txtNode.nodeValue;
        } else {
            return null;
        }
    },

    _prependChild: function(/*DOMElement*/node, /*DOMElement*/parent){
        parent.firstChild ?	parent.insertBefore(node, parent.firstChild): parent.appendChild(node);
    }
	
});


dojo.declare("com.ibm.portal.state.StatePartitionAccessor", null, {
    
    /**
     * summary:
     *     Constructor which initializes this accessor with the state DOM
     *     and the DOM node that keeps the state partition information.
     */
    constructor: function(/*Element*/statePartitionNode, /*dojo.dom.DOMDocument*/ stateDOM) {
        this.statePartitionNode = statePartitionNode;
        this.stateDOM = stateDOM;
        this.ns = { "state" : "http://www.ibm.com/xmlns/prod/websphere/portal/v6.1/portal-state" };
    },
    
    /**
     * summary:
     *     Includes a state partition into the state.
     */
    includeStatePartition: function() {
         // first remove the exisiting partition ID
         dojox.data.dom.removeChildren(this.statePartitionNode);
         var txtNode = this.stateDOM.createTextNode(this._generateID());
         this._prependChild(txtNode, this.statePartitionNode);
    },
	
    _prependChild: function(/*DOMElement*/node, /*DOMElement*/parent){
		parent.firstChild ?	parent.insertBefore(node, parent.firstChild): parent.appendChild(node);
	},

    _generateID: function() {
        return Math.floor(Math.random()*100);
    }
	
});


/**
 * The serialization manager is able to serialize /deserialize state documents. 
 */
dojo.declare("com.ibm.portal.state.SerializationManager", null, {
    
    /**
     * Scheme of the uri that addresses the state REST service.
     */
    STATE_URI_SCHEME: "state",
    STATE_URI_POST: "state:encode",
    
    /**
     * The download mode
     */
    DOWNLOAD_MODE: "download",
    
    STATUS_UNDEFINED: 0,
    STATUS_OK: 1,
    STATUS_ERROR: 2,
    
    STATE_NS_URI: "http://www.ibm.com/xmlns/prod/websphere/portal/v6.1/portal-state",

    /**
     * Maximum length the serialized state must not exceed.
     * The actual URL length limit is 2048 but we need to take into account the base URL incl. query params.
     */
    STATE_THRESHOLD: 1024,
    
    /**
     * summary:
     *     Constructor which initializes the serialization manager with a URL that
     *     can be used to access the state REST service of portal.
     */
    constructor: function(/*String*/ stateServiceURL) {
        this.serviceURL = stateServiceURL;
    },
    
    /**
     * summary:
     *     Serializes the given state DOM into a form that can be included into URLs.
     *     If a callback function is provided, the method will execute asynchronously.
     *     Otherwise it will execute synchronously and return a
     *     {status: STATUS_OK /STATUS_ERROR /STATUS_UNDEFINED, state: dojo.dom.DOMDocument, url: String} object. 
     *     
     * state: dojo.dom.DOMDocument - The state DOM that should be serialized. Must not
     *     be NULL.
     * validate: boolean - Optional flag specifying whether the server should validate the state or not.
     *     Defaults to false. 
     * callbackfn: function - The callback function which should be called in case of
     *     internal status changes. May be NULL to indcate that the method should execute
     *     synchronously.
     */
    serialize: function(/*dojo.dom.DOMDocument*/ state, /*boolean*/ validate, /*Function*/ callbackfn) {
         ibm.portal.debug.entry( "SerializationManager.serialize", [ dojox.data.dom.innerXML( state ), validate, callbackfn ] );
         
         // get the serialized state
         var stateXML = dojox.data.dom.innerXML(state).replace(/[\r\n]/mg, "");
         // apply ASCII encoding to state XML
         // because we want to use it as a scheme-specific part in a URI or as part of a POST body
		 //RES: this used to call dojo.string.encodeAscii(), which also included special handling for unicode characters
		 // if escape() is not sufficient, see the _encodeAscii function defined in this object (though it doesn't work yet :)
         var encodedStateXML = escape(stateXML);
         //var encodedStateXML = dojo.string.encodeAscii(stateXML);
         //var encodedStateXML = this._encodeAscii(stateXML);
         var mType = this._getMimeType();
         var result = null;
         var me = this;
         ibm.portal.debug.text( "Mime type for response: " + mType );
         ibm.portal.debug.text( "Length of encoded state XML is: " + encodedStateXML.length );
         ibm.portal.debug.text( "Encoded state XML is: " + encodedStateXML );
         var digest = com.ibm.portal.services.PortalRestServiceConfig.digest;
         ibm.portal.debug.text( "Digest: " + digest );
         // check if we need to send a GET or a POST based on the length of the serialized state
         if (encodedStateXML.length <= this.STATE_THRESHOLD) {
             // GET
             // create the uri
             var payload = this.STATE_URI_SCHEME + ":" + encodedStateXML;
             var params;
             validate = (validate != null && validate == true);
             if (validate == true) {
                 if (digest != null) {
                     params = { "uri" : payload, "mode" : this.DOWNLOAD_MODE, "xmlns" : this.STATE_NS_URI, "sessionDependencyAllowed": "true", "preprocessors": "true", "digest": digest};
                 } else {
                     params = { "uri" : payload, "mode" : this.DOWNLOAD_MODE, "xmlns" : this.STATE_NS_URI, "sessionDependencyAllowed": "true", "preprocessors": "true"};
                 }
             } else {
                 if (digest != null) {
                     params = { "uri" : payload, "mode" : this.DOWNLOAD_MODE, "xmlns" : this.STATE_NS_URI, "sessionDependencyAllowed": "true", "digest": digest};
                 } else {
                     params = { "uri" : payload, "mode" : this.DOWNLOAD_MODE, "xmlns" : this.STATE_NS_URI, "sessionDependencyAllowed": "true"};
                 }
             }
             
             ibm.portal.debug.text( "Doing a GET request: { url: \"" + this.serviceURL + "\", sync: " + ((callbackfn)?false:true) + ", content: " + params + ", handleAs: " + mType + ", transport: XMLHTTPRequest" );
             ibm.portal.debug.text( "Parameters: uri=\"" + params.uri + "\" mode=\"" + params.mode + "\" xmlns=\"" + params.xmlns + "\"" );
              
             dojo.xhrGet({
                 url: this.serviceURL,
                 sync: (callbackfn)?false:true,
                 content: params,
                 headers: {"X-IBM-XHR":"true"},
                 handleAs: mType,
                 handle: function(response, ioArgs) {
                      ibm.portal.debug.text( "Response: " + response );
                      if(com.ibm.ajax.auth && (ioArgs.xhr.status==401 || ioArgs.xhr.status==0 )) {
                         ibm.portal.debug.text( " 401 found, re-auth");
                         com.ibm.ajax.auth.authenticationHandler();
                         return;
                      } else {
                          result = me._handleSerializationResponse.call(me, response, callbackfn, state, validate);
                          return response;
                      }
                 },
                 transport: "XMLHTTPTransport"
             });
         } else {
             ibm.portal.debug.text( "Doing a POST request." );
             // tentative fix: content handler framework cannot deal with UTF-16 at the moment
             if (dojo.isIE) {
                 var idx = stateXML.indexOf("UTF-16");
                 if (idx >= 0) {
                     stateXML = stateXML.replace(/UTF-16/, "UTF-8");
                 }
             }
             var url = this.serviceURL + "?uri=" + this.STATE_URI_POST + "&xmlns=" + this.STATE_NS_URI + "&sessionDependencyAllowed=true";
             if (digest != null) {
                 url += "&digest=" + digest;
             }
             // POST
             dojo.rawXhrPost({
                 url: url,
                 sync: (callbackfn)?false:true,
                 postData: stateXML,
                 handleAs: mType,
                 headers: {"Content-Type":"text/xml", "X-IBM-XHR":"true"},
                 handle: function(response, ioArgs) {
                      if(com.ibm.ajax.auth && (ioArgs.xhr.status==401 || ioArgs.xhr.status==0 )) {
                         ibm.portal.debug.text( "401 found, re-auth");
                         com.ibm.ajax.auth.authenticationHandler();
                         return;
                      } else {
                         result = me._handleSerializationResponse.call(me, response, callbackfn, state, validate);
                         return response;
                      }
                 },
                 transport: "XMLHTTPTransport"
             });
         }
         
         ibm.portal.debug.exit( "SerializationManager.serialize", result );
         return result;
    },
    
    /**
     * summary:
     *     Deserializes the state from the given URL. If a callback function is provided,
     *     the method will execute asynchronously. Otherwise it will execute synchronously
     *     and return a
     *     {status: STATUS_OK /STATUS_ERROR /STATE_UNDEFINED, url: String, state: dojo.dom.DOMDocument}
     *     object. 
     *     
     * url: String - String representing the URL the state DOM should be retrieved from.
     *     Must not be NULL.
     * callbackfn: function - The callback function which should be called in case of
     *     internal status changes. May be NULL to indcate that the method should execute
     *     synchronously.
     */
    deserialize: function(/*String*/ url, /*Function*/ callbackfn) {
        var payload = this.STATE_URI_SCHEME + ":" + url;
        var result = null;
        var mType = this._getMimeType();
        var me = this;
        var digest = com.ibm.portal.services.PortalRestServiceConfig.digest;
        ibm.portal.debug.text( "Digest: " + digest );
        var params;
        if (digest != null) {
            params = { "uri" : payload, "mode" : this.DOWNLOAD_MODE, "xmlns" : this.STATE_NS_URI, "digest" : digest};
        } else {
            params = { "uri" : payload, "mode" : this.DOWNLOAD_MODE, "xmlns" : this.STATE_NS_URI};
        }
        dojo.xhrGet({
             url: this.serviceURL,
             sync: (callbackfn)?false:true,
             content: params,
             headers: {"X-IBM-XHR":"true"},
             handleAs: mType,
             handle: function(response, ioArgs){
                  var type = ( response instanceof Error ) ? "error" : "load";
                  if (type == "load") {
                      var stateDOM = me._getResponseXML(response);
                      //If we get a parser error, then valid XML was not returned by 
                      //the serialization service and we want to return an empty xml
                      //document in this case.
                      if ( stateDOM.documentElement.nodeName == "parsererror" ) {
                          stateDOM = dojox.data.dom.createDocument();
                      }
                      if (callbackfn) {
                          // TODO use this.STATUS_OK here
                          callbackfn(1, url, stateDOM);
                      } else {
                          // TODO use this.STATUS_OK here
                          result = {"status" : 1, "input" : me.serviceURL, "url" : me.serviceURL, "returnObject" : stateDOM, "state" : stateDOM};
                      }
                  } else if (type == "error") {
                      if(com.ibm.ajax.auth && (ioArgs.xhr.status==401 || ioArgs.xhr.status==0 )) {
                          ibm.portal.debug.text( " 401 found, reauth");
                          com.ibm.ajax.auth.authenticationHandler();
                          return;
                      }


                      if (callbackfn) {
                          // TODO use this.STATUS_ERROR here
                          callbackfn(2, url, null);
                      } else {
                          // TODO use this.STATUS_ERROR here
                          result = {"status" : 2, "input" : me.serviceURL, "url" : me.serviceURL, "returnObject" : null, "state" : null};
                      }
                  }
             },
             transport: "XMLHTTPTransport"
         });
         return result;
    },
    

    _handleSerializationResponse: function(response, callbackfn, state, validate) {
        var result = null;
        var type = ( response instanceof Error ) ? "error" : "load";
        if (type == "load") {
            var responseXML = this._getResponseXML(response);
            // get the serialized state from response XML
            var linkExpr = "atom:entry/atom:link";
            var ns = {"atom" : "http://www.w3.org/2005/Atom", "state" : "http://www.ibm.com/xmlns/prod/websphere/portal/v6.1/portal-state"};
            var serializedState = null;
            var linkNodes = com.ibm.portal.xpath.evaluateXPath(linkExpr, responseXML, ns);
            if (linkNodes != null && linkNodes.length > 0) {
                // take the fist node found and read its href attribute
                serializedState = linkNodes[0].getAttribute("href");
            }
            var resultState = state;
            // check if the state potentially changed
            if (validate == true) {
                // get the new state from the response XML
                var stateExpr = "atom:entry/atom:content/state:root";
                var stateNodes = com.ibm.portal.xpath.evaluateXPath(stateExpr, responseXML, ns);
                if (stateNodes != null && stateNodes.length > 0) {
                    var newState = dojox.data.dom.innerXML(stateNodes[0]); 
                    resultState = dojox.data.dom.createDocument(newState);
                }
            }
            if (callbackfn) {
                // TODO use this.STATUS_OK here
                callbackfn(1, resultState, serializedState);
            } else {
                // TODO use this.STATUS_OK here
                result = {"status" : 1, "input" : resultState, "state" : resultState, "returnObject" : serializedState, "url" : serializedState};
            }
        } else if (type == "error") {                      
            if (callbackfn) {
                // TODO use this.STATUS_ERROR here
                callbackfn(this.STATUS_ERROR, state, null);
            } else {
                // TODO use this.STATUS_ERROR here
                result = {"status" : this.STATUS_ERROR, "input" : state, "state" : state, "returnObject" : null, "url" : null};
            }
        }
        return result;
    },


    _getMimeType: function() {
        var mtype = "xml";
        // IE does not work with "text/xml"
        if (dojo.isIE) {
             mtype = "text";
        }
        return mtype;
    },
    
    _getResponseXML: function(data) {
        var responseDOM = data;
        if (dojo.isIE) {
            responseDOM = dojox.data.dom.createDocument(data);
        }
        return responseDOM;
    },
	_encodeAscii: function(str) {
		var ret = str;
		if(dojo.isString(ret)) {
			var escapedStr = escape(ret);
			// \u#### patterns will be replaced with %u#### patterns by the escape() function
			var unicodeRegx = /%u([A-F0-9][A-F0-9][A-F0-9][A-F0-9])/i;
			var unicodeVal = null;
			// now find all %u#### patterns and replace them with an 
			while((unicodeVal = escapedStr.match(unicodeRegx))) {
				ret += escapedStr.substring(0, unicodeVal.index) + escape(Number("0x"+unicodeVal[1]));
				escapedStr = escapedStr.substring(unicodeVal.index + unicodeVal[0].length);
			}
			ret += escapedStr;
			ret = ret.replace(/\+/g, "%2B");
		}
		return ret;
	}	
    
    
});

/**
 * Component that manages state vary expressions on an ID basis.
 */
dojo.declare("com.ibm.portal.navigation.controller.StateVaryManager", null, {
    
				/**
				 * summary:
				 *     Constructor which initializes the state vary manager with a URL
				 */
				constructor: function() {
					this._expr = new Array();
				},

				setExpressions: function (/*String*/ id, /*Array*/ expressions) {
					var bucket = this._findBucket(id);
					if (bucket == null) {
						// create a new empty bucket
						bucket = { "id": id, "expr": null };
						// update the cache
						this._expr.push(bucket);
					}
					// add /replace the expressions
					bucket.expr = expressions;
				},

				getExpressions: function(/*String*/ id) {
					var result = null;
					var bucket = this._findBucket(id);
					if (bucket != null) {
						result = bucket.expr;
					}
					return result;
				},

				_findBucket: function(/*String*/ id) {
					var bucket = null;
					for (i=0; i<this._expr.length; i++) {
						var temp = this._expr[i];
						if (temp.id == id) {
							bucket = temp;
							break;
						}
					}
			      	return bucket;
				}
    
});

com.ibm.portal.state.STATE_MANAGER = new com.ibm.portal.state.StateManager(); 	
com.ibm.portal.state.STATE_MANAGER.reset(dojox.data.dom.createDocument()); // workaround


}

if(!dojo._hasResource["com.ibm.portal.EventBroker"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.portal.EventBroker"] = true;
dojo.provide( "com.ibm.portal.EventBroker" );

dojo.require( "com.ibm.portal.debug" );

dojo.declare( "com.ibm.portal.Event",
			  null,
			  {
			  	constructor: function ( /*String*/uniqueEventId ) {
				  	this.eventName = uniqueEventId;
				  	this._listeners = new Array();
				},
			  	fire: function ( /*Object?*/ parameters ) {
					// summary: Fires the event to the listeners.
					// parameters: any parameters that are to be passed to the listeners
					ibm.portal.debug.text( "Firing event: " + this.eventName + " with parameters: " );
					////dojo.debugShallow( parameters );
					//dojo.event.topic.publish( this.eventName, parameters );
					dojo.publish( this.eventName, [parameters] );
				},
				register: function ( /*Function or Object*/listener, /*Function or String*/listenerFunc ) {
					// summary: Registers a listener with an event.
					// listener: the listener function to be called when an event is fired.
					
					if ( !listenerFunc ) {
						//dojo.event.topic.subscribe( this.eventName, listener );
						return dojo.subscribe( this.eventName, null, listener ); // Handle
					}
					else {
						//dojo.event.topic.subscribe( this.eventName, listener, listenerFunc );
						return dojo.subscribe( this.eventName, listener, listenerFunc ); // Handle
					}	
				},
				unregister: function( /*Handle*/handle ) { 
					// summary: Unregisters a listener from an event. The parameters must match
					//		exactly.
					//dojo.event.topic.unsubscribe( this.eventName, listener, listenerFunc );
					dojo.unsubscribe( handle );
				},
				cancel: function ( /*Object?*/ parameters ) { 
					// summary: Cancels an event.
					// parameters: any parameters to be passed to the listeners
					dojo.publish( this.id + "/cancel" );	
				} 
			  }
);

dojo.declare( "com.ibm.portal.EventBroker",
			  null,
			  {
			  	// summary: All events should be instance variables of an Event.	
				
				//required events
				startPage: new com.ibm.portal.Event( "portal/StartPage" ),
				endPage: new com.ibm.portal.Event( "portal/EndPage" ),
				startFragment: new com.ibm.portal.Event( "portal/StartFragment" ),
				endFragment: new com.ibm.portal.Event( "portal/EndFragment" ),
				fragmentUpdated: new com.ibm.portal.Event( "portal/FragmentUpdated" ),
				startRequest: new com.ibm.portal.Event( "portal/StartRequest" ),
				endRequest: new com.ibm.portal.Event( "portal/EndRequest" ),
				cancelAll: new com.ibm.portal.Event( "portal/CancelAll" ),
				stateChanged: new com.ibm.portal.Event( "portal/StateChanged" ),
				startScriptHandling: new com.ibm.portal.Event( "portal/StartScriptHandling" ),
				endScriptHandling: new com.ibm.portal.Event( "portal/EndScriptHandling" ),
				startScriptExecution: new com.ibm.portal.Event( "portal/StartScriptExecution" ),
				endScriptExecution: new com.ibm.portal.Event( "portal/EndScriptExecution" ),
                javascriptCleanup: new com.ibm.portal.Event( "portal/JavascriptCleanup" ),
                //The events below this comment need to be removed. They are deprecated. We may have to leave them in for compatibility.
                //startScriptExecution and endScriptExecution should be used instead. There will be no replacement for restorePointUpdated
                //and clearRestorePoint as these should never have been introduced.
                beforeSnapShot: new com.ibm.portal.Event( "portal/BeforeSnapShot" ),
                afterSnapShot: new com.ibm.portal.Event( "portal/AfterSnapShot" ),
                restorePointUpdated: new com.ibm.portal.Event( "portal/RestorePointUpdated" ),
                clearRestorePoint: new com.ibm.portal.Event( "portal/ClearRestorePoint" ),
				//The events above this comment need to be removed. They are deprecated.
                stopEvent: new com.ibm.portal.Event( "portal/StopEvent" ),
				redirect: new com.ibm.portal.Event( "portal/Redirect" )
			  }
);

com.ibm.portal.EVENT_BROKER = new com.ibm.portal.EventBroker();

}

if(!dojo._hasResource["dojo.dnd.common"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.common"] = true;
dojo.provide("dojo.dnd.common");

dojo.dnd._isMac = navigator.appVersion.indexOf("Macintosh") >= 0;
dojo.dnd._copyKey = dojo.dnd._isMac ? "metaKey" : "ctrlKey";

dojo.dnd.getCopyKeyState = function(e) {
	// summary: abstracts away the difference between selection on Mac and PC,
	//	and returns the state of the "copy" key to be pressed.
	// e: Event: mouse event
	return e[dojo.dnd._copyKey];	// Boolean
};

dojo.dnd._uniqueId = 0;
dojo.dnd.getUniqueId = function(){
	// summary: returns a unique string for use with any DOM element
	var id;
	do{
		id = dojo._scopeName + "Unique" + (++dojo.dnd._uniqueId);
	}while(dojo.byId(id));
	return id;
};

dojo.dnd._empty = {};

dojo.dnd.isFormElement = function(/*Event*/ e){
	// summary: returns true, if user clicked on a form element
	var t = e.target;
	if(t.nodeType == 3 /*TEXT_NODE*/){
		t = t.parentNode;
	}
	return " button textarea input select option ".indexOf(" " + t.tagName.toLowerCase() + " ") >= 0;	// Boolean
};

// doesn't take into account when multiple buttons are pressed
dojo.dnd._lmb = dojo.isIE ? 1 : 0;	// left mouse button

dojo.dnd._isLmbPressed = dojo.isIE ?
	function(e){ return e.button & 1; } : // intentional bit-and
	function(e){ return e.button === 0; };

}

if(!dojo._hasResource["com.ibm.portal.services.PortalRestServiceRequestQueue"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.portal.services.PortalRestServiceRequestQueue"] = true;
dojo.provide( "com.ibm.portal.services.PortalRestServiceRequestQueue" );

dojo.declare( "com.ibm.portal.services.PortalRestServiceRequestQueue",
			  null,
			  {
			  	maxNumberOfActiveRequests: 4,
			  	constructor: function () {
			  		// summary: Constructs a new queue to limit the number of active requests at any given time.
			  		var _method = "PortalRestServiceRequestQueue.constructor"
			  		ibm.portal.debug.entry( _method );
			  		
			  		this._activeRequests = 0;
			  		this._requestQueue = [];
			  		
			  		ibm.portal.debug.exit( _method );
			  	},
			  	add: function ( /*Request*/req ) {
			  		// summary: Adds a new request to the queue. 
			  		// description: The request object should have a single method called "execute" that takes a function object
			  		//		as a parameter. The function should be called when the request is complete to let the queue know it can
			  		//		move on to the next request. 
			  		var _method = "PortalRestServiceRequestQueue.add";
			  		ibm.portal.debug.entry( _method, [ req ] );
			  		
			  		this._requestQueue.push( req );
			  		var me = this;
			  		setTimeout( function () { me._executeNextRequest(); }, 5 );
			  		
			  		ibm.portal.debug.exit( _method );
			  	},
			  	_executeNextRequest: function () {
			  		// summary: Execute the next request in the queue, if necessary.
			  		var _method = "PortalRestServiceRequestQueue._executeNextRequest";
			  		ibm.portal.debug.entry( _method );
			  		
			  		ibm.portal.debug.text( this._requestQueue.length + " request(s) in the queue. " + this._activeRequests + " active request(s) currently.", _method );
			  		if ( this._requestQueue.length > 0 && this._activeRequests < this.maxNumberOfActiveRequests ) {
				  		var reqToExec = this._requestQueue.shift();
			  			
			  			ibm.portal.debug.text( "Executing request: " + reqToExec, _method );
			  			
			  			var me = this;
			  			setTimeout( function () { reqToExec.execute( function () { me._notifyComplete(); } ); me.activeRequests = me._activeRequests+1; }, 1 );
			  		}
			  		else {
			  			ibm.portal.debug.text( "No request(s) pending or maximum number of requests already currently active.", _method );
			  		}
			  		
			  		ibm.portal.debug.exit( _method );	
			  	},
			  	_notifyComplete: function () {
			  		// summary: Called to notify the queue that an active request has completed and the next waiting request
			  		//		can now be executed.
			  		var _method = "PortalRestServiceRequestQueue._notifyComplete";
			  		ibm.portal.debug.entry( _method );
			  		
			  		this._activeRequests = this._activeRequests-1;
			  		if ( this._activeRequests < 0 ) {
			  			this._activeRequests = 0;
			  		}
			  		var me = this;
			  		setTimeout( function () { me._executeNextRequest(); }, 5 );
			  		
			  		ibm.portal.debug.exit( _method );
			  	}
			  }
);

}

if(!dojo._hasResource["com.ibm.portal.utilities"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.portal.utilities"] = true;
dojo.provide( "com.ibm.portal.utilities" );

com.ibm.portal.utilities = {
	findPortletIdByElement: function ( /*DOMElement*/ element ) {
		// summary: Finds the portlet ID which the given element belongs to
		// description: Finds the portlet ID to which the give DOM element belongs
		//		by walking up the parents of the given element until the ancestor is 
		//		found with one of the defined class names.
		// element: the DOM element to find the portlet ID of
		
		ibm.portal.debug.entry( "findPortletID", [ element ] );
		var id = "";
		var current = element.parentNode;
		while ( current && id.length == 0 ) {
			ibm.portal.debug.text( "examining element " + current.tagName + "; class=" + current.className,"findPortletID" );
		
			if ( current.className && (current.className.match(/\bwpsPortletBody\b/) || current.className.match(/\bwpsPortletBodyInlineMode\b/)) ) {
				id = current.id;
				var indexOf = id.indexOf( "_mode" );
				if ( indexOf >= 0 )  {
					id = id.substring( 0, indexOf );
				}
			}
			current = current.parentNode;	
		}
		
		if ( id.indexOf( "portletActions_" ) >= 0 ) {
			id = id.substring( "portletActions_".length );
		}
		
		ibm.portal.debug.exit( "findPortletID", [ id ] );
		
		return id;
	},
	findFormByElement: function ( /*DOMElement*/ element) {
		var current = element;
		while(current) {
			if(current.tagName && current.tagName.toLowerCase() == "form") break;
			current = current.parentNode;
		}
		return current;
	},
	encodeURI: function ( /*String*/uri ) {
		// summary: Encodes a model uri for use in an URL.
		// uri: the unencoded model uri to encode
		// returns: the encoded uri ready for use in an URL
		ibm.portal.debug.entry( "encodeURI", [ uri ] );
		
		var encodedURI = uri;
		var index = uri.lastIndexOf( ":" );
		
		while ( index >= 0 ) {
			var scheme = encodedURI.substring(0, index );
			var part = encodedURI.substring( index + 1  );
			
			encodedURI = scheme + ":" + encodeURIComponent( part );
			index = scheme.lastIndexOf( ":" );
		}
		
		encodedURI = encodeURIComponent( encodedURI );
		
		ibm.portal.debug.exit( "encodeURI", [ encodedURI ] );
		return encodedURI; // String
	},
	decodeURI: function ( /*String*/uri ) { 
		// summary: Decodes a model uri.
		// uri: the encode model uri
		// returns: the decoded model uri
		ibm.portal.debug.entry( "decodeURI", [ uri ] );
		
		var decodedURI = decodeURIComponent( uri );
		var index = decodedURI.indexOf( ":" );
		
		while ( index >= 0 ) {
			var scheme = decodedURI.substring(0, index );
			var part = decodedURI.substring( index + 1 );
			
			decodedURI = scheme + ":" + decodeURIComponent( part );
			index = decodedURI.indexOf( ":", index+1 );
		}
		
		ibm.portal.debug.exit( "decodeURI", [ decodedURI ] );
		return decodedURI;	//String
	},
	getSelectionNodeId: function ( /*String*/fullPortletId ) {
		// summary: Extracts the selection node object id from the full portlet id returned
		//		by the layout model feed.
		ibm.portal.debug.entry( "getSelectionNodeId", [ fullPortletId ] );
		
		// this split will break the full portlet id into the control with prefixes at index [0]
		// and the selected node will be at index [1]
		var selNodeId = fullPortletId.split('@oid:');
				
		ibm.portal.debug.exit( "getSelectionNodeId", [ selNodeId[1] ] );
		return selNodeId[1];
	},
	getControlId: function ( /*String*/fullPortletId ) {
		// summary: Extracts the control object id from the full portlet id returned
		//		by the feed.
		ibm.portal.debug.entry( "_getControlId", [ fullPortletId ] );
		
		// this first split will get rid of the page oid
		var controlParts = fullPortletId.split('@oid:');
		
		// this second split will leave the feed prefix (i.e. lm) at index [0]
		// and index [1] will have the control oid
		var controlId = controlParts[0].split("oid:");
		
		ibm.portal.debug.exit( "getControlId", [ controlId[1] ] );
		return controlId[1];
	},
	overwriteProperty: function ( /*Object*/obj, /*String*/propertyName, /*Object*/newValue, /*Boolean?*/onlyOnce ) {
		// summary: Overwrites the given property.
		ibm.portal.debug.entry( "overwriteProperty", [ obj, propertyName, newValue, onlyOnce ] );
		
		if ( !obj["_overwritten_"] ) {
			obj["_overwritten_"] = new Object();
		}
		
		//In case onlyOnce is undefined.
		if ( !onlyOnce ) { onlyOnce = false; }
		
		var skipOverwrite = (onlyOnce &&  (obj["_overwritten_"][propertyName] != null) );
		if ( !skipOverwrite ) {
			if ( obj["_overwritten_"][propertyName] == null ) {
                obj["_overwritten_"][propertyName] = obj[propertyName];
            }
            else {
                obj["_overwritten_"][propertyName] = null;
            }    
			obj[propertyName] = newValue;
			ibm.portal.debug.text( "Property overwrite successful!" );
		}
		
		ibm.portal.debug.exit( "overwriteProperty");	
	},
	restoreProperty: function ( /*Object*/obj, /*String*/propertyName ) {
		// summary: Restores an overwritten property.
        // returns: the overwritten value for the property
		ibm.portal.debug.entry( "utilities.restoreProperty", [ obj, propertyName ] );
		var retVal = obj[propertyName];

        if ( obj["_overwritten_"] != null ) {
            ibm.portal.debug.text( "overwritten property value: " + obj["_overwritten_"] ); 
            obj[propertyName] = obj["_overwritten_"][propertyName];
            obj["_overwritten_"][propertyName] = null;
        }
        else {
            obj[propertyName] = null;
        }
        
        ibm.portal.debug.exit( "utilities.restoreProperty", retVal );    
        return retVal;
	},
	getOverwrittenProperty: function ( /*Object*/obj, /*String*/propertyName ) {
		// summary: Access an overwritten property.
		if ( obj["_overwritten_"] ) {
			return obj["_overwritten_"][propertyName];
		}
		else {
			return null;
		}	
	},
	setOverwrittenProperty: function ( /*Object*/obj, /*String*/propertyName, /*Object*/value ) {
		// summary: Sets the overwritten property directly; bypassing the overwriting process.
		ibm.portal.debug.entry( "utilities.setOverwrittenProperty", [ obj, propertyName, value ] ); 
		
		if ( !obj["_overwritten_"] ) {
			obj["_overwritten_"] = new Object();
		}
		
		obj["_overwritten_"][propertyName] = value;
		
		ibm.portal.debug.exit( "utilities.setOverwrittenProperty" );
	},
	callOverwrittenFunction: function ( /*Object*/thisObj, /*String*/propertyName, /*Object[]?*/args ) {
		ibm.portal.debug.entry( "utilities.callOverwrittenFunction", [ thisObj, propertyName, args ]);
		//IE doesn't like it if we pass in an undefined args object to apply.
		var retVal = null;
		var oldProp = this.getOverwrittenProperty( thisObj, propertyName );
		ibm.portal.debug.text( "Overwritten property: " + oldProp );
		ibm.portal.debug.text( "old property's apply function: " + oldProp.apply );
		
		if ( args ) {
			retVal = oldProp.apply( thisObj, args );
		}
		else {
			retVal = oldProp.apply( thisObj );
		}
		
		ibm.portal.debug.exit( "utilities.callOverwrittenFunction", retVal );
		return retVal;
	},
	isExternalUrl: function ( /*String*/urlString ) {
		// summary: Determines if the given url points to an external server.
		// urlString: the url in string form
		// returns: true if the url points to an external server
		ibm.portal.debug.entry( "isExternalUrl", [ urlString ] );
		
		var host = window.location.host;
		var protocol = window.location.protocol;
		var urlStringNoQuery = urlString.split( "?" )[0];
		var retVal = !(urlStringNoQuery.indexOf("://") < 0 || (urlStringNoQuery.indexOf(protocol) == 0 && urlStringNoQuery.indexOf(host) == protocol.length+2) );
		
		ibm.portal.debug.text( "urlStringNoQuery.indexOf(\"://\") = " + urlStringNoQuery.indexOf("://") );
		ibm.portal.debug.text( "urlStringNoQuery.indexOf(protocol) = " + urlStringNoQuery.indexOf(protocol) );
		
		ibm.portal.debug.exit( "isExternalUrl", retVal );
		return retVal;
	},
	isJavascriptUrl: function ( /*String*/urlString ) {
		// summary: Determines if the given url is a javascript url.
		// description: Checks to see if the url begins with the javascript: protocol
		// urlString: the url in string form
		// returns: true if the url is actually a javascript call.
		ibm.portal.debug.entry( "isJavascriptUrl", [ urlString ] );
		var url = com.ibm.portal.utilities.string.trim( urlString.toLowerCase() );
		var retVal = ( url.indexOf( "javascript:" ) == 0 );
		ibm.portal.debug.exit( "isJavascriptUrl", retVal );
		return retVal;
	},
	isPortalUrl: function ( /*String*/urlString ) {
		// summary: Determines if a given url is a url to the portal servlet.
		// description: Checks to see if the url begins with the path to the portal servlet.
		// urlString: the url to check in string form
		// returns: true if the url is a portal url
		ibm.portal.debug.entry( "utilities.isPortalUrl", [ urlString ] );
		
		var retVal = ( urlString.indexOf( ibmPortalConfig["portalURI"] ) >= 0 );
		
		ibm.portal.debug.exit( "utilities.isPortalUrl", retVal );
		return retVal;
	},	

	addExternalNode: function ( /*DOMDocument*/ doc, /*Element*/ node ) {
		var newNode = null;
		if(doc.importNode) newNode = doc.importNode(node, true);
		else newNode = node;
		doc.appendChild( newNode );
	},
    decodeXML: function ( /*String*/xmlText ) {
		// summary: decodes xml sent by multi-part form 
		ibm.portal.debug.entry( "decodeXML", [ xmlText ] );

		var newXmlText1 = xmlText.replace(/&amp;/g, "&");
		var newXmlText2 = newXmlText1.replace(/&amp;/g, "&");
		newXmlText1 = newXmlText2.replace(/&#039;/g, "\'");
		newXmlText2 = newXmlText1.replace(/&#034;/g, '\"');
		
		newXmlText2 = newXmlText2.replace( /&lt;/g, "<" );
		newXmlText2 = newXmlText2.replace( /&gt;/g, ">" );

		ibm.portal.debug.exit( "decodeXML", [ newXmlText2 ] );
		return newXmlText2;
	},
	eventHandlerToString: function ( eventHandler ) {
		var eventHandlerStr = eventHandler.toString();
		var startIndex = eventHandlerStr.indexOf("{");
		var endIndex = eventHandlerStr.lastIndexOf("}");
		onclickStr = eventHandlerStr.substring(startIndex+1, endIndex);
		
		return onclickStr;
	},
	_waitingForScript: false,
	_isWaitingForScript: function() { return com.ibm.portal.utilities._waitingForScript; },
	stopWaitingForScript: function() { com.ibm.portal.utilities._waitingForScript = false; },

	waitFor: function(testFunction, pollInterval, callback, args) {
		var interval = setInterval(function() {
			if (testFunction())
			{
				clearInterval(interval);
				
				if ( !args ) {
					callback();
				}
				else {
					callback(args);
				}
			}
		},
		pollInterval);
	},

	waitForScript: function( callback, args ) {
		com.ibm.portal.utilities._waitingForScript = true;
		com.ibm.portal.utilities.waitFor(function()
		{
			return (!com.ibm.portal.utilities._isWaitingForScript());
		},
		500,
		callback,
		args);
	}
}

com.ibm.portal.utilities.string = {
	findNext: function ( /*String*/ string, /*Array*/searchStrings, /*int?*/from ) {
		// summary: Finds the next index of any of the given search strings.
		// description: Looks for each search string in the given string and returns the index 
		//		of the first one encountered. If none of the search strings are discovered, 
		//		-1 is returned. 
		// string: the string to search
		// searchStrings: the array of strings to look for in the string
		// from: the index to start looking from - the length of the search string is always added 
		//		from index before searching for the next instance
		ibm.portal.debug.entry( "string.findNext", [ string, searchStrings ] );
		
		var lowValueNotZero = -1;
		
		for ( var i = 0; i < searchStrings.length; i++ ) {
			var fromIndex = null;
			if ( from ) {
				fromIndex = from + searchStrings[i].length;
			}
			var index = string.indexOf( searchStrings[i], fromIndex );
				
			if ( index > -1 && ( index < lowValueNotZero || lowValueNotZero == -1 ) ) {
				lowValueNotZero = index;
			}
		}
		
		ibm.portal.debug.exit( "string.findNext", [ lowValueNotZero ] );
		return lowValueNotZero;		
	},
	contains: function ( /*String*/ stringToSearch, /*String*/stringToLookFor ) {
		// summary: Determines if the stringToSearch contains the stringToLookFor
		ibm.portal.debug.entry( "string.contains", [ stringToSearch, stringToLookFor ] );
		
		var retVal = false;
		
		if ( stringToSearch != null && stringToLookFor != null ) {
			retVal = ( stringToSearch.indexOf( stringToLookFor ) != -1 );		
		}
		
		ibm.portal.debug.exit( "string.contains", [ retVal ] );
		return retVal;
	},
	strip: function ( /*String*/string, /*String*/stringToStrip ) {
		// summary: Strips out the given string from the original string if it contains
		//		the stringToStrip.
		// string: the original string
		// stringToStrip: the string to remove from the original string
		// returns: the original string without any instances of the stringToStrip
		ibm.portal.debug.entry( "string.strip", [ string, stringToStrip ] );
		
		var retVal = string.replace( new RegExp( stringToStrip, "g" ), "" );
				
		ibm.portal.debug.exit ( "string.strip", [ retVal ]);
		return retVal;
	},
	properCase: function ( /*String*/string ) {
		// summary: Changes the first character of the string to Upper Case and all remaining characters
		//		to Lower Case.  Note that this does not split the string into words and capitalize
		//		each word, but only acts on the entire string as a whole.
		// string: The original string to change
		// returns: The original string with the first character in Upper Case and all other characters
		//		in Lower Case.
		if(string == null || string.length < 1) return "";
		ibm.portal.debug.entry("string.properCase", [string] );
		var retVal = string.charAt(0).toUpperCase();
		if(string.length > 1) {
			retVal += string.substring(1).toLowerCase();
		}
		ibm.portal.debug.exit("string.properCase", [retVal] );
		return retVal;
	},
	trim: function ( /*String*/ string ) {
		// summary: Removes leading and trailing spaces from a string.
		// string: the string to trim
		// returns: the original string minus any leading or trailing spaces
		ibm.portal.debug.entry( "string.trim", [ string ] );
		var retVal = string;
		
		retVal = retVal.replace( /^\s+/, '' );
		retVal = retVal.replace( /\s+$/, '' );
		
		ibm.portal.debug.exit( "string.trim", retVal );
		return retVal;
	}
}

dojo.declare( "com.ibm.portal.utilities.HttpUrl", 
			  null,
			  {
			  	constructor: function ( /*String*/urlString ) {
					this.scheme = "http://";
				  	this.server = this._extractServer( urlString );
					this.port = this._extractPort( urlString );
					this.path = this._extractPath( urlString );
					this.query = this._extractQuery( urlString );
					this.anchor = "";
				},
			  	addParameter: function ( /*String*/name, /*String*/value ) {
					this.query += "&" + name + "=" + value;
				},
				toString: function () {
					var str = "";
					if ( this.server != "" ) {
						str += this.scheme + this.server;
					} 
					if ( this.port != "" ) {
						str += ":" + this.port;
					}
					
					str += "/" + this.path;
					
					if ( this.query != "" ) {
						str += "?" + this.query;
					}
					if ( this.anchor != "" ) {
						str += "#" + this.anchor;
					}
					
					return str;
				},
				_extractServer: function (/*String*/urlString ) {
					var indexOfScheme = urlString.indexOf( this.scheme );
					var retVal = "";
					if ( indexOfScheme == 0 ) {
						var indexOfSlash = urlString.indexOf( "/", indexOfScheme + this.scheme.length );
						var serverAndPort = urlString.substring( indexOfScheme+ this.scheme.length, indexOfSlash );
						retVal = serverAndPort.split( ":" )[0];
					}	
					
					return retVal; 
				},
				_extractPort: function (/*String*/urlString ) {
					var indexOfServer = urlString.indexOf( this.server );
					var retVal = "";
					if ( indexOfServer >= 0 ) {
						var indexOfSlash = urlString.indexOf( "/", indexOfServer );
						var serverAndPort = urlString.substring( indexOfServer, indexOfSlash );
						var serverAndPortParts = serverAndPort.split( ":" );
						if ( serverAndPortParts.length > 1 ) {
							retVal = serverAndPortParts[1];
						}
					}	
					
					return retVal; 
				},
				_extractPath: function ( /*String*/urlString ) {
					var indexOfServer = urlString.indexOf( this.server );
					var retVal = "";
					if ( indexOfServer >= 0 ) {
						var indexOfSlash = urlString.indexOf( "/", indexOfServer );
						var indexOfQuery = urlString.indexOf( "?" );
						var indexOfHash = urlString.lastIndexOf( "#" );
						if ( indexOfQuery >= 0 ) {
							retVal = urlString.substring( indexOfSlash + 1, indexOfQuery );
						}
						else {
							if ( indexOfHash >= 0 ) {
								retVal = urlString.substring( indexOfSlash + 1, indexOfHash );
							}
							else {
								retVal = urlString.substring( indexOfSlash + 1 );
							}		
						}
					}	
					
					return retVal;
				},
				_extractQuery: function ( /*String*/urlString ) {
					var retVal = "";
					var urlParts = urlString.split( "?" );
					
					if ( urlParts.length > 1 ) {
						retVal = urlParts[1].split( "#" )[0];
					}	
					
					return retVal;
				},
				_extractAnchor: function ( /*String*/urlString ) {
					var retVal = "";
					var urlParts = urlString.split( "#" );
					
					if ( urlParts.length > 1 ) {
						retVal = urlParts[urlParts.length - 1];
					}	
					
					return retVal;
				}
					
			  }
);

}

if(!dojo._hasResource["dojo.fx.Toggler"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.fx.Toggler"] = true;
dojo.provide("dojo.fx.Toggler");

dojo.declare("dojo.fx.Toggler", null, {
	// summary:
	//		class constructor for an animation toggler. It accepts a packed
	//		set of arguments about what type of animation to use in each
	//		direction, duration, etc.
	//
	// example:
	//	|	var t = new dojo.fx.Toggler({
	//	|		node: "nodeId",
	//	|		showDuration: 500,
	//	|		// hideDuration will default to "200"
	//	|		showFunc: dojo.wipeIn, 
	//	|		// hideFunc will default to "fadeOut"
	//	|	});
	//	|	t.show(100); // delay showing for 100ms
	//	|	// ...time passes...
	//	|	t.hide();

	// FIXME: need a policy for where the toggler should "be" the next
	// time show/hide are called if we're stopped somewhere in the
	// middle.

	constructor: function(args){
		var _t = this;

		dojo.mixin(_t, args);
		_t.node = args.node;
		_t._showArgs = dojo.mixin({}, args);
		_t._showArgs.node = _t.node;
		_t._showArgs.duration = _t.showDuration;
		_t.showAnim = _t.showFunc(_t._showArgs);

		_t._hideArgs = dojo.mixin({}, args);
		_t._hideArgs.node = _t.node;
		_t._hideArgs.duration = _t.hideDuration;
		_t.hideAnim = _t.hideFunc(_t._hideArgs);

		dojo.connect(_t.showAnim, "beforeBegin", dojo.hitch(_t.hideAnim, "stop", true));
		dojo.connect(_t.hideAnim, "beforeBegin", dojo.hitch(_t.showAnim, "stop", true));
	},

	// node: DomNode
	//	the node to toggle
	node: null,

	// showFunc: Function
	//	The function that returns the dojo._Animation to show the node
	showFunc: dojo.fadeIn,

	// hideFunc: Function	
	//	The function that returns the dojo._Animation to hide the node
	hideFunc: dojo.fadeOut,

	// showDuration:
	//	Time in milliseconds to run the show Animation
	showDuration: 200,

	// hideDuration:
	//	Time in milliseconds to run the hide Animation
	hideDuration: 200,

	/*=====
	_showArgs: null,
	_showAnim: null,

	_hideArgs: null,
	_hideAnim: null,

	_isShowing: false,
	_isHiding: false,
	=====*/

	show: function(delay){
		// summary: Toggle the node to showing
		return this.showAnim.play(delay || 0);
	},

	hide: function(delay){
		// summary: Toggle the node to hidden
		return this.hideAnim.play(delay || 0);
	}
});

}

if(!dojo._hasResource["dojo.fx"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.fx"] = true;
dojo.provide("dojo.fx");

/*=====
dojo.fx = {
	// summary: Effects library on top of Base animations
};
=====*/
(function(){
	
	var d = dojo, 
		_baseObj = {
			_fire: function(evt, args){
				if(this[evt]){
					this[evt].apply(this, args||[]);
				}
				return this;
			}
		};

	var _chain = function(animations){
		this._index = -1;
		this._animations = animations||[];
		this._current = this._onAnimateCtx = this._onEndCtx = null;

		this.duration = 0;
		d.forEach(this._animations, function(a){
			this.duration += a.duration;
			if(a.delay){ this.duration += a.delay; }
		}, this);
	};
	d.extend(_chain, {
		_onAnimate: function(){
			this._fire("onAnimate", arguments);
		},
		_onEnd: function(){
			d.disconnect(this._onAnimateCtx);
			d.disconnect(this._onEndCtx);
			this._onAnimateCtx = this._onEndCtx = null;
			if(this._index + 1 == this._animations.length){
				this._fire("onEnd");
			}else{
				// switch animations
				this._current = this._animations[++this._index];
				this._onAnimateCtx = d.connect(this._current, "onAnimate", this, "_onAnimate");
				this._onEndCtx = d.connect(this._current, "onEnd", this, "_onEnd");
				this._current.play(0, true);
			}
		},
		play: function(/*int?*/ delay, /*Boolean?*/ gotoStart){
			if(!this._current){ this._current = this._animations[this._index = 0]; }
			if(!gotoStart && this._current.status() == "playing"){ return this; }
			var beforeBegin = d.connect(this._current, "beforeBegin", this, function(){
					this._fire("beforeBegin");
				}),
				onBegin = d.connect(this._current, "onBegin", this, function(arg){
					this._fire("onBegin", arguments);
				}),
				onPlay = d.connect(this._current, "onPlay", this, function(arg){
					this._fire("onPlay", arguments);
					d.disconnect(beforeBegin);
					d.disconnect(onBegin);
					d.disconnect(onPlay);
				});
			if(this._onAnimateCtx){
				d.disconnect(this._onAnimateCtx);
			}
			this._onAnimateCtx = d.connect(this._current, "onAnimate", this, "_onAnimate");
			if(this._onEndCtx){
				d.disconnect(this._onEndCtx);
			}
			this._onEndCtx = d.connect(this._current, "onEnd", this, "_onEnd");
			this._current.play.apply(this._current, arguments);
			return this;
		},
		pause: function(){
			if(this._current){
				var e = d.connect(this._current, "onPause", this, function(arg){
						this._fire("onPause", arguments);
						d.disconnect(e);
					});
				this._current.pause();
			}
			return this;
		},
		gotoPercent: function(/*Decimal*/percent, /*Boolean?*/ andPlay){
			this.pause();
			var offset = this.duration * percent;
			this._current = null;
			d.some(this._animations, function(a){
				if(a.duration <= offset){
					this._current = a;
					return true;
				}
				offset -= a.duration;
				return false;
			});
			if(this._current){
				this._current.gotoPercent(offset / this._current.duration, andPlay);
			}
			return this;
		},
		stop: function(/*boolean?*/ gotoEnd){
			if(this._current){
				if(gotoEnd){
					for(; this._index + 1 < this._animations.length; ++this._index){
						this._animations[this._index].stop(true);
					}
					this._current = this._animations[this._index];
				}
				var e = d.connect(this._current, "onStop", this, function(arg){
						this._fire("onStop", arguments);
						d.disconnect(e);
					});
				this._current.stop();
			}
			return this;
		},
		status: function(){
			return this._current ? this._current.status() : "stopped";
		},
		destroy: function(){
			if(this._onAnimateCtx){ d.disconnect(this._onAnimateCtx); }
			if(this._onEndCtx){ d.disconnect(this._onEndCtx); }
		}
	});
	d.extend(_chain, _baseObj);

	dojo.fx.chain = function(/*dojo._Animation[]*/ animations){
		// summary: Chain a list of dojo._Animation s to run in sequence
		// example:
		//	|	dojo.fx.chain([
		//	|		dojo.fadeIn({ node:node }),
		//	|		dojo.fadeOut({ node:otherNode })
		//	|	]).play();
		//
		return new _chain(animations) // dojo._Animation
	};

	var _combine = function(animations){
		this._animations = animations||[];
		this._connects = [];
		this._finished = 0;

		this.duration = 0;
		d.forEach(animations, function(a){
			var duration = a.duration;
			if(a.delay){ duration += a.delay; }
			if(this.duration < duration){ this.duration = duration; }
			this._connects.push(d.connect(a, "onEnd", this, "_onEnd"));
		}, this);
		
		this._pseudoAnimation = new d._Animation({curve: [0, 1], duration: this.duration});
		var self = this;
		d.forEach(["beforeBegin", "onBegin", "onPlay", "onAnimate", "onPause", "onStop"], 
			function(evt){
				self._connects.push(d.connect(self._pseudoAnimation, evt,
					function(){ self._fire(evt, arguments); }
				));
			}
		);
	};
	d.extend(_combine, {
		_doAction: function(action, args){
			d.forEach(this._animations, function(a){
				a[action].apply(a, args);
			});
			return this;
		},
		_onEnd: function(){
			if(++this._finished == this._animations.length){
				this._fire("onEnd");
			}
		},
		_call: function(action, args){
			var t = this._pseudoAnimation;
			t[action].apply(t, args);
		},
		play: function(/*int?*/ delay, /*Boolean?*/ gotoStart){
			this._finished = 0;
			this._doAction("play", arguments);
			this._call("play", arguments);
			return this;
		},
		pause: function(){
			this._doAction("pause", arguments);
			this._call("pause", arguments);
			return this;
		},
		gotoPercent: function(/*Decimal*/percent, /*Boolean?*/ andPlay){
			var ms = this.duration * percent;
			d.forEach(this._animations, function(a){
				a.gotoPercent(a.duration < ms ? 1 : (ms / a.duration), andPlay);
			});
			this._call("gotoPercent", arguments);
			return this;
		},
		stop: function(/*boolean?*/ gotoEnd){
			this._doAction("stop", arguments);
			this._call("stop", arguments);
			return this;
		},
		status: function(){
			return this._pseudoAnimation.status();
		},
		destroy: function(){
			d.forEach(this._connects, dojo.disconnect);
		}
	});
	d.extend(_combine, _baseObj);

	dojo.fx.combine = function(/*dojo._Animation[]*/ animations){
		// summary: Combine an array of `dojo._Animation`s to run in parallel
		//
		// description:
		//		Combine an array of `dojo._Animation`s to run in parallel, 
		//		providing a new `dojo._Animation` instance encompasing each
		//		animation, firing standard animation events.
		//
		// example:
		//	|	dojo.fx.combine([
		//	|		dojo.fadeIn({ node:node }),
		//	|		dojo.fadeOut({ node:otherNode })
		//	|	]).play();
		//
		// example:
		//	When the longest animation ends, execute a function:
		//	| 	var anim = dojo.fx.combine([
		//	|		dojo.fadeIn({ node: n, duration:700 }),
		//	|		dojo.fadeOut({ node: otherNode, duration: 300 })
		//	|	]);
		//	|	dojo.connect(anim, "onEnd", function(){
		//	|		// overall animation is done.
		//	|	});
		//	|	anim.play(); // play the animation
		//
		return new _combine(animations); // dojo._Animation
	};

	dojo.fx.wipeIn = function(/*Object*/ args){
		// summary:
		//		Returns an animation that will expand the
		//		node defined in 'args' object from it's current height to
		//		it's natural height (with no scrollbar).
		//		Node must have no margin/border/padding.
		args.node = d.byId(args.node);
		var node = args.node, s = node.style, o;

		var anim = d.animateProperty(d.mixin({
			properties: {
				height: {
					// wrapped in functions so we wait till the last second to query (in case value has changed)
					start: function(){
						// start at current [computed] height, but use 1px rather than 0
						// because 0 causes IE to display the whole panel
						o = s.overflow;
						s.overflow="hidden";
						if(s.visibility=="hidden"||s.display=="none"){
							s.height="1px";
							s.display="";
							s.visibility="";
							return 1;
						}else{
							var height = d.style(node, "height");
							return Math.max(height, 1);
						}
					},
					end: function(){
						return node.scrollHeight;
					}
				}
			}
		}, args));

		d.connect(anim, "onEnd", function(){ 
			s.height = "auto";
			s.overflow = o;
		});

		return anim; // dojo._Animation
	}

	dojo.fx.wipeOut = function(/*Object*/ args){
		// summary:
		//		Returns an animation that will shrink node defined in "args"
		//		from it's current height to 1px, and then hide it.
		var node = args.node = d.byId(args.node), s = node.style, o;
		
		var anim = d.animateProperty(d.mixin({
			properties: {
				height: {
					end: 1 // 0 causes IE to display the whole panel
				}
			}
		}, args));

		d.connect(anim, "beforeBegin", function(){
			o = s.overflow;
			s.overflow = "hidden";
			s.display = "";
		});
		d.connect(anim, "onEnd", function(){
			s.overflow = o;
			s.height = "auto";
			s.display = "none";
		});

		return anim; // dojo._Animation
	}

	dojo.fx.slideTo = function(/*Object?*/ args){
		// summary:
		//		Returns an animation that will slide "node" 
		//		defined in args Object from its current position to
		//		the position defined by (args.left, args.top).
		// example:
		//	|	dojo.fx.slideTo({ node: node, left:"40", top:"50", unit:"px" }).play()

		var node = args.node = d.byId(args.node), 
			top = null, left = null;

		var init = (function(n){
			return function(){
				var cs = d.getComputedStyle(n);
				var pos = cs.position;
				top = (pos == 'absolute' ? n.offsetTop : parseInt(cs.top) || 0);
				left = (pos == 'absolute' ? n.offsetLeft : parseInt(cs.left) || 0);
				if(pos != 'absolute' && pos != 'relative'){
					var ret = d.coords(n, true);
					top = ret.y;
					left = ret.x;
					n.style.position="absolute";
					n.style.top=top+"px";
					n.style.left=left+"px";
				}
			};
		})(node);
		init();

		var anim = d.animateProperty(d.mixin({
			properties: {
				top: args.top || 0,
				left: args.left || 0
			}
		}, args));
		d.connect(anim, "beforeBegin", anim, init);

		return anim; // dojo._Animation
	}

})();

}

if(!dojo._hasResource["com.ibm.portal.utilities.html"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.portal.utilities.html"] = true;
dojo.provide( "com.ibm.portal.utilities.html" );

dojo.require( "com.ibm.portal.utilities" );
dojo.require( "dojo.fx" );

com.ibm.portal.utilities.html = {
	createAnchor: function ( /*HTMLElement*/parent, /*String*/href, 
									     /*String*/id, /*String*/displayText, 
										 /*String*/className ) {
					
		// summary: Creates an anchor element using the given attributes and appends it to the parent.
		// parent: the parent element that will contain the created anchor
		// href: the value of the href attribute
		// id: the id of the anchor element
		// displayText: the inner text of the anchor
		// className: the CSS style name to apply
		// returns: the created anchor object
		ibm.portal.debug.entry( "SkinRenderer.createAnchor", [ parent, href, id, displayText, className ] );
		
		//Create and set the attributes for the anchor.
		var anchor = document.createElement( "A" );
		anchor.href = href;
		if ( id ) { anchor.id = id; }
		if ( className ) { anchor.className = className; }
		if ( displayText ) { anchor.appendChild( document.createTextNode( displayText ) ); }
												 	
		//Append the anchor to the parent.
		parent.appendChild( anchor );
		
		ibm.portal.debug.exit( "SkinRenderer.createAnchor", [ anchor ]);
		return anchor; //HTMLElement																
	},
	createButton: function ( /*HTMLElement*/parent, /*String*/href, 
						     /*String*/id, /*String?*/displayText, 
							 /*String*/className ) {
		
		// summary: Creates a button element using the given attributes and appends it to the parent.
		// parent: the parent element that will contain the created anchor
		// href: the value of the href attribute
		// id: the id of the anchor element
		// displayText: the inner text of the anchor
		// className: the CSS style name to apply
		// returns: the created anchor object
		ibm.portal.debug.entry( "SkinRenderer.createButton", [ parent, href, id, displayText, className ] );
		
		//Create and set the attributes for the anchor.
		var button = document.createElement( "BUTTON" );
		if ( href ) { button.href = href; }
		if ( id ) { button.id = id; }
		if ( className ) { button.className = className; }
		if ( displayText ) {
			button.appendChild( document.createTextNode( displayText ) );
		}	
												 	
		//Append the anchor to the parent.
		parent.appendChild( button );
		
		ibm.portal.debug.exit( "SkinRenderer.createButton", [ button ]);
		return button; //HTMLElement																
	},
	createImage: function ( /*HTMLElement*/parent, /*String*/src,
							/*String*/id, /*String*/altText,
							/*String*/className ) {
								
		// summary: Creates an img element using the given attributes and appends it to the parent.
		// parent: the parent element that will contain the created image
		// src: the url to the image
		// id: the id of the created image element
		// altText: the alternate text for the image
		// className: the CSS style name to apply.
		ibm.portal.debug.entry( "SkinRenderer.createImage", [ parent, src, id, altText, className ] );
		
		//Create and set attributes for our image.
		var img = document.createElement( "IMG" );
		img.src = src;
		if ( id ) { img.id = id; }
		if ( altText ) { 
			img.alt = altText; img.setAttribute("title", altText); 
			//set the title for the button ("tooltip")
			if( parent.nodeName == "BUTTON") {
				parent.setAttribute("title", altText);
			}
		}
		if ( className ) { img.className = className; }
		
		//Append the image to the parent.
		parent.appendChild( img );
		
		ibm.portal.debug.exit( "SkinRenderer.createImage", [ img ] );
		return img; //HTMLElement	
	},
	createImageAnchor: function ( /*HTMLElement*/parent, /*String*/src,
							/*String*/id, /*String*/altText,
							/*String*/className ) {
								
		// summary: Creates an img element using the given attributes and appends it to the parent.
		// parent: the parent element that will contain the created image
		// src: the url to the image
		// id: the id of the created image element
		// altText: the alternate text for the image
		// className: the CSS style name to apply.
		ibm.portal.debug.entry( "SkinRenderer.createImageAnchor", [ parent, src, id, altText, className ] );
		
		var anchor = com.ibm.portal.utilities.html.createAnchor( parent, "javascript:void(0);" );
		
		//Create and set attributes for our image.
		var img = document.createElement( "IMG" );
		img.src = src;
		if ( id ) { img.id = id; }
		if ( altText ) { img.alt = altText; img.title = altText; }
		if ( className ) { img.className = className; }
		
		//Append the image to the parent.
		anchor.appendChild( img );
		
		ibm.portal.debug.exit( "SkinRenderer.createImageAnchor", [ img ] );
		return anchor; //HTMLElement	
	},
	createTemporaryMarkupDiv: function ( /*String*/ markupStr ) {
		// summary: Creates a div for putting our markup into.  Returns a map with these properties:
		//		{ 	
		// 			node: the new div node,
		//			objects: a map of the extracted OBJECTS keyed by the unique id of the placeholder node in the div node
		//		}
		// description: Necessary because IE doesn't like it when you set innerHTML on a div and the first
		//		element is a script element. For some reason, any script elements up until the first actual
		//		markup element will not be inserted into the DOM. Our workaround is to create a hidden <p>
		//		element which will always be the first element in the markup string.  In IE, this will also
		//		extract all OBJECT elements and put them into the objects property map on the return object
		//		to later be put back into the DOM once the div in the node property of the return object
		//		has been placed into the DOM.  The works around an issue where using innerHTML or outerHTML
		//		of OBJECT elements doesn't retrieve their children in IE.
		// markupStr: the markup string.
		ibm.portal.debug.entry( "html.createTemporaryMarkupDiv" );
		
		var markupMap = {markup: markupStr, objects: {}};
		// fix for inserting OBJECT elements with contents in IE
		if(dojo.isIE) {
			markupMap = com.ibm.portal.utilities.html.extractObjectElementsFromString(markupStr);
		}
		
		var div = document.createElement( "DIV" );
		div.innerHTML = "<p style='display: none;'>&nbsp;</p>" + markupMap.markup;
		
		ibm.portal.debug.exit( "html.createTemporaryMarkupDiv", [ div ] );
		return {node: div, objects: markupMap.objects};
	},
	extractObjectElementsFromString: function ( /*String*/ markupStr ) {
		// summary: Extracts all OBJECT elements from the markupStr and returns an object with the following
		//		properties -
		//		{
		//			markup: the modified markup with uniquely identifiable placeholder nodes in place of the removed
		//				OBJECT elements,
		//			objects: a map of the extracted OBJECTS keyed by the unique id of the placeholder node in the new
		//				markup string
		//		}
		// markupStr: the markup string
		var objElems = {};
		var openRegExp = /<object/gi;
		var closeRegExp = /<\/object>/gi;
		var markup = markupStr;
		var match = null;
		try {
			match = openRegExp.exec(markup);
			if(match && match.index > -1) {
				var start = match.index;
				var buf;
				var end;
				var middle;
				var id;
				while(start > -1) {
					buf = markup.substring(0, start);
					end = markup.indexOf(">", start);
					if(markup.charAt(end - 1) == "/") {
						// we encountered an <OBJECT .... /> tag, so just leave it since it has no contents
						openRegExp.lastIndex = end;
						match = openRegExp.exec(markup);
						if(match) {
							start = match.index;
							continue;
						}
						else break;	// we didn't find anything after the last match
					}
					closeRegExp.lastIndex = start;
					match = closeRegExp.exec(markup);
					if(match) end = match.index;
					else break; // bad markup, OBJECT not closed, just let it go
					
					middle = markup.substring(start, end + 9);
					id = dojo.dnd.getUniqueId();
					markup = buf + "<div id='" + id + "'></div>" + markup.substring(end + 9);
					objElems[id] = middle;
					openRegExp.lastIndex = 0;	// start at the beginning since the markup string has changed
					match = openRegExp.exec(markup);
					
					if(match) start = match.index;
					else break;	// no more matches
				}
			}
			markupStr = markup;
		}
		catch(e) {
			// if we get a failure during the processing of the markup, then the markupStr will still be the same
			// that means we should clear out the objElems and just let the markup pass through as-is
			objElems = {};
		}
		return {markup: markupStr, objects: objElems};
	},
	replaceObjectElementsInMarkup: function ( /*Map*/ objects ) {
		// summary: For every key in the objects argument map, this function looks up a node in the DOM whose id
		// 		equals the key and replaces the outerHTML of that node with the string contents of the property
		//		value of the objects map with that key.  It's useful for putting markup from various nodes back 
		// 		into the DOM that was extracted earlier for some purpose.
		for(var id in objects) {
    		var objContainer = dojo.byId(id);
    		if(objContainer) {
    			objContainer.outerHTML = objects[id];
    		}
    	}
	},
	removeNodesOnCondition: function ( /*DOMElement*/node, /*Function*/condition ) {
		// summary: Walks down this node's descendants and removes all nodes that cause the given
		// condition function to return true, effectively satisfying the condition for removal.
		// Useful for delinting XSL transformations that have created unwanted nodes in the markup.
		if(!condition) condition = function(){return false;};
		if(node && node.childNodes) {
			for(var i = 0; i < node.childNodes.length; i++) {
				if(condition(node.childNodes[i])) {
					var nonNode = node.childNodes[i];
					node.removeChild(nonNode);
					delete nonNode;
					i--; // going back because the childNodes array has been updated
				}
				else {
					this.removeNodesOnCondition(node.childNodes[i], condition);
				}
			}
		}
	},
    getElementsByTagNames: function ( /*HTMLElement*/baseElem /*String 1...N*/ ) {
        // summary: Retrieves elements by tag name for 1 to N tag names.
        // description: Builds a single array with all elements of any tag name specified. A base element
        //        must be specified event if it's just the document object. Any number of tag names can be
        //        searched for, just simply keep appending parameters to the function call.
        // baseElem: the base element to search from
        // tagName1: a tag name
        // tagName2: a tag name
        // ...
        // tagNameN: a tag name
        ibm.portal.debug.entry( "html.getElementsByTagNames", [ baseElem ] );
        
        var retVal = new Array();
        
        for ( var i=1; i < arguments.length; i++ ) {
            var elements = baseElem.getElementsByTagName( arguments[i] );
            ibm.portal.debug.text( 'found ' + elements.length + ' ' + arguments[i] + ' tags.');
            for ( var j=0; j < elements.length; j++ ) {
                retVal.push( elements[j] );
            }    
        }
        
        ibm.portal.debug.exit( "html.getElementsByTagNames", [ retVal ] );
        return retVal;
    },
    getX: function ( /*HTMLElement*/elem ) {
    	// summary: Calculates the X coordinate of the top left corner of the given element. This
    	//		function was stolen from WCL and included here so that we have no dependency on 
    	//		WCL.
    	// elem: the html element to calculate the position of.
    	// returns: an integer with the X position.
    	ibm.portal.debug.entry( "html.getX", [ elem ] );
    	
    	var size = 0;
	    
	    if ( elem != null ) {
	       if ( elem.offsetParent != null ) {
	          size += com.ibm.portal.utilities.html.getX( elem.offsetParent );
	       }
	       if ( elem != null ) {
	          size += elem.offsetLeft;
	       }
	
	    }
	    
	    ibm.portal.debug.exit( "html.getX", [ size ] );
	    return size; // int
    },
    getY: function ( /*HTMLElement*/elem ) {
    	// summary: Calculates the Y coordinate of the top left corner of the given element. This
    	//		function was stolen from WCL and included here so that we have no dependency on 
    	//		WCL.
    	// elem: the html element to calculate the position of.
    	// returns: an integer with the Y position
    	ibm.portal.debug.entry( "html.getY" [ elem ] );
    	
    	var size = 0;

	    if ( elem != null ) {

	       if ( elem.offsetParent != null ) {
	          size += com.ibm.portal.utilities.html.getY( elem.offsetParent );
	       }
	       if ( elem != null ) {
	          size += elem.offsetTop;
	       }
	
 	    }
 	    
 	    ibm.portal.debug.exit( "html.getY", [ size ] );
 	    return size; // int
    },
    convertFormToQuery: function ( /*HTMLElement*/formObj, /*{name:, value:}*/submitTrigger ) {
    	// summary: Converts a given form object to a query string.
    	// description: Iterates through the given form object's "elements" and attempts to
    	//		a name/value pair to the query string. All parameters are encoded using the native
    	//		javascript function "encodeURIComponent". Since a form may contain multiple submit
    	//		inputs, the submit input name which triggered the current submission may be passed 
    	// 		to this function so that the submit input which triggered the submission may be properly
    	//		encoded into the query string. 
    	// formObj: the form object to decode
    	// submitTrigger: the name and value of the input which triggered the submission.
    	// returns: the query string with all name/value pairs that were successfully decoded
		ibm.portal.debug.entry( "html.convertFormToQuery", [ formObj, submitTrigger ] );
		
		//For some reason, formObj.elements didn't seem to always return ALL input elements.
		var elements = this.getElementsByTagNames( formObj, "input", "select", "textarea", "button" );
    	var queryStr = "";
    	var querySep = "&";
    	var queryNameValueSep = "=";
		var processed = 0;
    	for ( var i = 0; i < elements.length; i++ ) {
    		var inputNV = this.convertInputToNameValuePairs( elements[i], submitTrigger );
    		for ( var k = 0; k < inputNV.length; k++ ) {
				var pair = inputNV[k];
				if ( pair.name != "" ) {
					if ( processed != 0 ) {
						queryStr += querySep;
					}	
					queryStr += encodeURIComponent( pair.name );
		    		
					for ( var j = 0; j < pair.values.length; j++ ) {
		    			if ( j == 0 ) {
		    				queryStr += ( queryNameValueSep + encodeURIComponent( pair.values[j] ) ); 
		    			}
		    			else {
		    				queryStr += ( querySep + encodeURIComponent(pair.name) + queryNameValueSep + encodeURIComponent( pair.values[j] ) );
		    			}	
		    		}
					
					processed = processed+1;
				}
			}	
   		
    	}
		
    	ibm.portal.debug.exit( "html.convertFormToQuery", queryStr );
    	return queryStr;
    },
    convertInputToNameValuePairs: function ( /*HTMLElement*/input, /*{name:,value:}*/submitTrigger ) {
    	// summary: Converts a given form element to a name value pair.
    	// description: Given an HTML INPUT element, produces an object representation of the following format:
    	//		{ name: <input name>, values: [ <input value1>, <input value2, ..., <input valueN> ] } where values is likely
    	//		an array with one value. The array is used to cover the case where a single input has multiple values. Submit
    	//		inputs are only included if no submitTrigger is specified OR the submitTrigger variable value matches the 
    	//		submit input's "name" attribute.
    	// input: the HTML INPUT element to convert
    	// submitTrigger: the input which triggered the form submission
    	// returns: a name/value pair { name: "", values: [] }, guaranteed to be not NULL
    	ibm.portal.debug.entry( "html.convertInputToNameValuePairs", [ input, submitTrigger ]);
    	
    	var type = input.type;
    	ibm.portal.debug.text( "Input type is: " + type );
		ibm.portal.debug.text( "Input name is: " + input.name );
    	var name = "";
    	var values = [];
		var retPairs = [];
    	
    	if ( !input.disabled ) {
    		    		
			switch ( type.toLowerCase() ) {
				case "text":
				case "password":
				case "hidden":
					name = input.name; values.push( input.value );
					retPairs.push( { name: name, values: values } );
					break;
				case "reset":
				case "button": 
					if ( !submitTrigger || ( input.name == submitTrigger.name && input.value == submitTrigger.value ) ) {
						name = input.name; values.push( input.value );
						retPairs.push( { name: name, values: values } );				
					}
					break;		
				case "radio":
				case "checkbox": if ( input.checked ) {
						name = input.name;
						values.push( input.value );
					}
					retPairs.push( { name: name, values: values } );
					break;
				case "image": if ( !submitTrigger || input.name == submitTrigger ) {
						name = input.name;
						if ( input.value ) {
							values.push( input.value );
							retPairs.push( { name: name, values: values } );
						}
						
						retPairs.push( { name: name + ".x", values: [ this.getX( input ) ] } );
						retPairs.push( { name: name + ".y", values: [ this.getY( input ) ] } );
					}
					break;
				case "submit": if ( !submitTrigger || ( input.name == submitTrigger.name && input.value == submitTrigger.value ) ) {
						name = input.name;
						if ( input.value ) {
							values.push( input.value );
						}
						retPairs.push( { name: name, values: values } );
					}
					break;
				case "select-one": 
				case "select-multiple": name = input.name;
					for ( var i = 0; i < input.options.length; i++ ) {
						if ( input.options[i].selected ) {
							var value = input.options[i].value ? input.options[i].value : input.options[i].text;
							values.push( value );
						}
					}
					if ( values.length != 0 ) { 
						retPairs.push( { name: name, values: values } );
					}	
					
					break;
				case "file": break;
				default: name = input.name; values.push( input.value ); retPairs.push( { name: name, values: values } );
			}
    	}	
		
		ibm.portal.debug.exit( "html.convertInputToNameValuePairs", retPairs );
		return retPairs;	
    },
		isHidden: function(node) {
    	// summary: determines whether the specified node is hidden or shown.
    	// description: this is a lightweight replacement for the obsolete dojo.html.isHidden function. It checks the element
    	//		only, not its parents, for display:none being set.
    	// input: the dom node
    	// returns: true if the node has display:none style set, false otherwise	
			return dojo.style(node, 'display') == 'none';
		},
		hide: function(node) {
    	// summary:  hides the specified node from the rendered page.
    	// description: this is a replacement for the obsolete dojo.html.hide() function. 
    	// input: the dom node to hide
			dojo.fx.wipeOut({node: node, duration: 5}).play();
		},
		show: function(node) {
    	// summary:  shows the specified node from the rendered page.
    	// description: this is a replacement for the obsolete dojo.html.show) function. 
    	// input: the dom node to show
			dojo.fx.wipeIn({node: node, duration: 5}).play();
		},
		isDescendantOf: function(node, ref) {
			//summary: Checks to see if the given node descends from the reference node.
			//node: node to check
			//ref: the reference node
			// returns: true if the node is a descendant of the given reference node
			var node = node.parentNode;
			var found = false;
			
			while ( node && !found ) {
				if ( node == ref ) {
					found = true;
				}
				node = node.parentNode;
			}
			
			return found;
		}
	
};

}

if(!dojo._hasResource["com.ibm.portal.services.PortalRestServiceRequest"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.portal.services.PortalRestServiceRequest"] = true;
dojo.provide( "com.ibm.portal.services.PortalRestServiceRequest" );

dojo.require( "com.ibm.ajax.auth" );
dojo.require( "com.ibm.portal.EventBroker" );

dojo.require( "com.ibm.portal.services.PortalRestServiceRequestQueue" );

dojo.declare( "com.ibm.portal.services.ContentHandlerURL",
			  null,
			  {
		  		// summary: Provides convenience methods to construct URLs to the 
				// 		content handler servlet which serves most of the Portal 
				//		REST services.
				
				constructor: function ( /*String*/uri, /*String or int*/levels, /*String*/verb, /*String?*/params ) {
				  	ibm.portal.debug.entry( "ContentHandlerURL.constructor", [ uri, levels, verb, params ]);
				  	//If no URI is passed in, just return null.
					if ( uri == null ) {
						return null;
					}	
					
					if ( !levels ) { 
						levels = 2;
					}

					// check if we need to enforce a specific locale
					var state = com.ibm.portal.navigation.controller.NAVIGATION_CONTROLLER.getState();
					var locale = state.getLocale();
					if (locale) {
						if (params) {
							params += "&locale=" + locale;
						} else {
							params = "&locale=" + locale;
						}
					}
				  
				  	this.url = "";
					if ( uri.charAt(0) == "?" ) {
						this.url = this._fromQueryString( uri, params );	
					}
					else {
						this.url = this._fromURI( uri, levels, "download", params );
					}
					ibm.portal.debug.exit( "ContentHandlerURL.constructor" );
			    },
				_fromQueryString: function ( /*String*/queryString, /*String?*/params  ) {
					// summary: Constructs an url from a given query string.
					// description: Constructs the URL to the content handler servlet using
					//		the given query string. Replaces any '&amp;' characters with '&' 		
					//		since Firefox thinks the 'amp;' is part of the parameter name.
					// queryString: the query string to construct the URL from
					// returns: String - the constructed URL
					ibm.portal.debug.entry( "fromQueryString", [ queryString ] );
				
					var str = ibmPortalConfig["contentHandlerURI"] + queryString;
					str = str.replace(/&amp;/g,"&" );
					if ( params ) {
						str = str + params;
					}
					
					if ( str.indexOf( "rep=compact" ) < 0 && str.indexOf( "rep=full" ) < 0 ) {
						str = str + "&rep=compact";
					}	
				
					ibm.portal.debug.exit( "fromQueryString", [ str ] );
					
					return str; //String	
				},
				_fromURI: function ( /*String*/uri, /*int?*/levels, /*String?*/verb, /*String?*/params ) {
					// summary: Constructs an URL using the given parameters.
					// description: Constructs the URL to the content handler servlet for
					//		the given URI, number of levels to traverse, and the action verb
					//		for the REST service to execute. It is not generally recommended
					//		to request more than 2 levels at a time since this will cause an
					//		expensive tree traversal server-side. The verb is generally expected
					//		to be set to "download".
					// uri: the uri for the resource to request
					// levels: the number of levels to include in the response
					// verb: the action to take (e.g. "view" or "download")
					// returns: String - the constructed URL
					ibm.portal.debug.entry( "ContentHandlerURL._fromURI", [ uri, levels, verb, params ] );
					
					uri = com.ibm.portal.utilities.encodeURI( uri );
					
					var qStr = "?uri=" + uri;
					
					if ( levels ) {
						qStr = qStr + "&levels=" + encodeURIComponent( levels );
					}
					
					if ( verb ) {
						qStr = qStr + "&mode=" + encodeURIComponent( verb );
					}
					if ( params ) {
						qStr = qStr + params;
					}
					
					if ( qStr.indexOf( "rep=compact" ) < 0 && qStr.indexOf( "rep=full" ) < 0 ) {
						qStr = qStr + "&rep=compact";
					}	
					
					return this._fromQueryString( qStr ); //String
				},
				getURI: function() {
					ibm.portal.debug.entry( "ContentHandlerURL.getURI" );
					return com.ibm.portal.utilities.decodeURI( this._extractParamValue( "uri" ) ); //String
				},
				getLevels: function () {
					return this._extractParamValue( "levels" );
				},
				getVerb: function () {
					return this._extractParamValue( "verb" );
				},
				_extractParamValue: function ( /*String*/ paramName ) {
					ibm.portal.debug.entry( "ContentHandlerURL._extractParamValue", [ paramName ] );
					
					var startIndex = this.url.indexOf( paramName );
					var endIndex = this.url.indexOf( "&", startIndex );
					var uriParamStr = this.url.slice( startIndex + paramName.length + 1, endIndex );
					
					ibm.portal.debug.exit( "ContentHandlerURL._extractParamValue", [ uriParamStr ]);
					
					return uriParamStr;
				}
			  }
);

dojo.require( "com.ibm.portal.utilities.html" );

dojo.declare( "com.ibm.portal.services.PortalRestServiceForm",
			  null,
			  {
			  	// summary: Object representation of a form that will be submitted to one of the Portal
			  	//		REST services. Encapsulates all the information about the form necessary to get
			  	//		the form info to the server.
			  	// method: the METHOD of the form (usually GET or POST)
			  	// isMultipart: indicates whether this is a multipart encoded form or not
			  	// encoding: the encoding used to submit the form
			  	// DomId: the ID of the DOM element corresponding to the form
			  	method: "GET",
			  	isMultipart: false,
			  	encoding: "application/x-www-form-urlencoded",
			  	DomId: null,
			  	constructor: function ( /*HTMLElement*/formElem ) {
			  		if ( formElem.getAttributeNode("method" ) ) {
			  			this.method = formElem.getAttributeNode( "method" ).value;	
			  		}
			  		if ( formElem.getAttributeNode( "encType" ) ) {
			  			this.encoding = formElem.getAttributeNode( "encType" ).value;
			  		}
			  		if ( formElem.getAttributeNode( "id" ) ) {	
			  			this.DomId = formElem.getAttributeNode( "id" ).value;
			  		}
			  		else {
			  			DomId = formElem;
			  		}	
			  		this.isMultipart = ( this.encoding == "multipart/form-data");
			  	},
			  	getDOMElement: function () {
			  		// summary: Returns the DOM element for this form.
			  		// returns: the DOM element corresponding to this form
			  		return dojo.byId( this.DomId );
			  	},
			  	submit: function () {
			  		// summary: Submits the form. This is necessary because the native submit function
			  		//		may have been overridden to ensure the form submission was intercepted.
			  		this.getDOMElement().submit();
			  	},
			  	toQuery: function () {
			  		// summary: Translates the form into a query string. Only elements which make sense
			  		//		for a query string are translated (i.e. NOT inputs of type "file").
			  		// returns: a string of name/value pairs suitable for being included as part of a url's
			  		//		query string.
			  		return com.ibm.portal.utilities.html.convertFormToQuery( this.getDOMElement() );
			  	}			  	
			  }
);

com.ibm.portal.services.REQUEST_QUEUE = new com.ibm.portal.services.PortalRestServiceRequestQueue();

dojo.declare( "com.ibm.portal.services.PortalRestServiceRequest",
			  null,
			  {
			  	// summary: Sends a request to one of the Portal REST Services and handles the response.
				// description: Create a new instance of this object for every REST service request that is
				//		sent. The URL is passed in to the constructor. If a form node and form filter is 
				// 		passed into the constructor, the REST service request is handled as a form submit.
				// 		The request can also be executed synchronously if TRUE is passed into the constructor.
				// 		In general, only the model implementations should send these requests.
				
				constructor: function( /*ContentHandlerURL*/feedlocation, /*PortalRestServiceForm?*/form, /*boolean?*/textOnly, /*boolean?*/sync ) {
				  	ibm.portal.debug.entry( "PortalRestServiceRequest.constructor", [ feedlocation, form, textOnly, sync ] );
					this._feedURI = feedlocation.url;
					this._textOnly = textOnly;
					this._sync = sync;
					this._form = form;
					this._customResponseValidator = null;
					this._onauthenticated = null;
					
					//Make sure this isn't undefined.
					if ( !this._sync ) {
							this._sync = false;
					}
					ibm.portal.debug.exit( "PortalRestServiceRequest.constructor" );
			    },
			    setAuthenticationValidator: function ( /*Function*/checkFn ) {
			    	// summary: Sets a function that will be used to check whether the response is valid (i.e. does not require  authentication).
			    	//		The function will take two parameters: one will be the response object (xml, json, string, etc);
			    	//		the second will be the dojo._ioArgs as provided to the dojo.xhr method. The function should return true
			    	//		if the response is valid and false otherwise.
			    	this._customResponseValidator = checkFn;
			    },
			    setOnAuthenticatedHandler: function ( /*Function*/onauth ) {
			    	// summary: Sets a function that CAN be called once authentication has been achieved. IMPORTANT: This handler will NOT
			    	//		be called in the default authentication handler for Portal because it redirects the browser to the login page.
			    	this._onauthenticated = onauth;
			    },
				create: function ( /*String*/data, /*Function*/callbackfn, callbackargs ) {
					// summary: Creates an entry in the backing model.
					// description: Sends a POST request to create an entry in the addressed model.
					// data: the body of the POST request
			    	// callbackfn: the function to call when the operation is complete
			    	// callbackargs: additional arguments to pass to callbackfn
					
			    	this._doXmlHttpRequest( "POST", data, callbackfn, callbackargs );
				},
				read: function ( /*Function?*/callbackfn, /*Object?*/addtlCallbackFnArguments ) {
					// summary: Read the ATOM feed provided by the REST service. 
					// description: If textOnly is set to true, the ATOM feed is returned as text and 
					//		 passed in as a single argument to the specified callback function. 
					//		 Otherwise, the ATOM feed is parsed into an {@link ibm.atom.Feed} object 
					//		 and passed into the callback function along with the original XML Document 
					//		 Object Model object.
					// callbackfn: the function to call when the operation is complete (only valid if
					//		 sync is false)
					// addtlCallbackFnArguments: any arguments to pass through to the callback function
					ibm.portal.debug.entry( "PortalRestServiceRequest.read", [ callbackfn, addtlCallbackFnArguments ] );
					
					if ( !this._sync ) {
						ibm.portal.debug.text( "Queueing request!" );
						var q = com.ibm.portal.services.REQUEST_QUEUE;
						var me = this;
						q.add( 
							   { 
							   	execute: function ( doneCallback ) { 
											com.ibm.portal.EVENT_BROKER.startRequest.fire( { uri: me._feedURI } );
											
											var wrappedCallbackFn = function ( arg1, arg2, arg3, arg4 ) { 
												callbackfn( arg1, arg2, arg3, arg4 );
												if ( doneCallback ) {
													doneCallback();
												}
											}
											
											if ( me._textOnly ) {
												me._retrieveRawFeed( wrappedCallbackFn, addtlCallbackFnArguments );
											}	
											else {
												me._retrieve( wrappedCallbackFn, addtlCallbackFnArguments );
											}
								          }
							   }	          
							);
					}
					else {
						com.ibm.portal.EVENT_BROKER.startRequest.fire( { uri: this._feedURI } );	
						
						if ( this._textOnly ) {
							this._retrieveRawFeed( callbackfn, addtlCallbackFnArguments );
						}	
						else {
							this._retrieve( callbackfn, addtlCallbackFnArguments );
						}
					}	
							
					ibm.portal.debug.exit( "PortalRestServiceRequest.read");
				},
				update: function ( /*String*/data, /*Function*/callbackfn, callbackargs ) {
					// summary: Updates an entry in the backing model. 
					// description: Sends a PUT request to update the addressed entry using the provided data.
					// data: the payload of the request
					// callbackfn: the function to call when the operation is complete
					// callbackargs: any additional arguments to pass to the callbackfn
					
					this._doXmlHttpRequest( "Put", data, callbackfn, callbackargs );
				},
				remove: function ( /*Function*/callbackfn, callbackargs ) {
					// summary: Removes the addressed entry from the backing model. 
					// description: Sends a DELETE request to remove the addressed entry.
					// callbackfn: the function to call when the operation is complete
					// callbackargs: any arguments to be passed to the callbackfn
					
					this._doXmlHttpRequest( "Delete", null, callbackfn, callbackargs );
				},
				_retrieveRawFeed: function ( callbackfn, callbackargs ) {
					ibm.portal.debug.entry( "_retrieveRawFeed", [callbackfn, callbackargs] );
					var me = this;
					dojo.xhrGet({
						url: this._feedURI,
						load: function( type, data, evt ) {
							callbackfn( data, callbackargs );
							com.ibm.portal.EVENT_BROKER.endRequest.fire( { uri: me._feedURI } ); 
						},
						sync: this._sync
					});
					
					ibm.portal.debug.exit( "_retrieveRawFeed" );
				},
				_retrieve: function ( callbackfn, callbackargs, formNode, formFilter ) {
					ibm.portal.debug.entry( "_retrieve", [ callbackfn ] );
					
					if ( this._form && this._form.isMultipart ) {
						this._doIframeRequest( callbackfn, callbackargs );
					}
					else {
						this._doXmlHttpRequest( "Get", null, callbackfn, callbackargs );
					}
					
					ibm.portal.debug.exit( "PortalRestServiceRequest._retrieve" );  
				},
				_doIframeRequest: function ( callbackfn, callbackargs ) {
					// summary: Handles a multi-part form submission.
					// description: Multi-part form submissions are not currently feasible using XMLHttpRequests, so
					// 		we need to submit these forms using IFRAMEs. 
					
					ibm.portal.debug.entry( "PortalRestServiceRequest._doIframeRequest", [ callbackfn ] );
					
					var iframe = null;
					var iframeName = dojo.dnd.getUniqueId(); 
					
					if ( dojo.isIE ) { 
						//Any other method of assigning the onload handler in IE seems to fail miserably...
						iframe = document.createElement( "<iframe name='" + iframeName + "' id='"+iframeName + "' src='about:blank' onload='com.ibm.portal.aggregation.forms.PORTLET_FORM_HANDLER.handleMultiPartResult(this.id);'></iframe>" );
						//This is necessary so that we actually have the Function object to call when the iframe loads (since we seem to
						//only be able to assign an onload handler using text insertion methods).
						com.ibm.portal.aggregation.forms.PORTLET_FORM_HANDLER._callbackfns[iframeName]= { fn: callbackfn, args: callbackargs };
						//IE applies an XSLT to an XML result in an IFRAME so we need text only.
						var url = new com.ibm.portal.utilities.HttpUrl( this._feedURI );
						url.addParameter( "ibm.web2.contentType", "text/plain" );
						this._form.getDOMElement().setAttribute( "action", url.toString() );
					}
					else {
						ibm.portal.debug.text( "Creating the iframe... name is: " + iframeName + "; url is: " + this._feedURI );
						iframe = document.createElement( "IFRAME" );
						iframe.setAttribute( "name", iframeName );
						iframe.setAttribute( "id", iframeName );
						var me = this;
						iframe.onload = function() { var xml = window.frames[iframeName].document; callbackfn( "load", xml, null, callbackargs ); com.ibm.portal.EVENT_BROKER.endRequest.fire( { uri: me._feedURI } ); };
						this._form.getDOMElement().setAttribute( "action", this._feedURI );	
					} 
					//Can't set the iframe's display to 'none' or problems recognizing the iframe will result...
					iframe.style.visibility = "hidden";
					iframe.style.height = "1px";
					iframe.style.width = "1px";
					document.body.appendChild( iframe );
					
					//IE Workaround again... the name isn't always correctly assigned from the above createElement call. 
					if(window.frames[iframeName].name != iframeName) { window.frames[iframeName].name = iframeName; }
					
					ibm.portal.debug.text( "Setting the iframe target attribute to: " + iframeName );
					this._form.getDOMElement().setAttribute( "target", iframeName );
					this._form.submit();
					
					ibm.portal.debug.exit( "PortalRestServiceRequest._doIframeRequest" );
				},
				_doXmlHttpRequest: function ( method, body, callbackfn, callbackargs ) {
					// summary: Performs a standard request using an XMLHttpRequest object.
					// description: If an error response code is returned, the Error object is returned instead of the
					// 		xml payload. This means that a check should be done to see if the response is instanceof Error.
					ibm.portal.debug.entry( "PortalRestServiceRequest._doXmlHttpRequest", [ method, body, callbackfn, callbackargs ] );					
					ibm.portal.debug.text( "Attempting to retrieve: " + this._feedURI + " using method: " + method + "; synchronously? " + this._sync );
					var me = this;
					var args = {
						url: this._feedURI,
						content: {},
                        headers: { "X-IBM-XHR":"true" },
						//headers: { "If-Modified-Since": "Thu, 1 Jan 1970 00:00:00 GMT"}, //temporary to force the browser to ignore cached requests
						handle: function( response, ioArgs ) {
							ibm.portal.debug.entry( "PortalRestServiceRequest.handle", [ response, ioArgs ] );
							//Get the location of the resource actually returned by the response.
							//All re-directs have been followed at this point.
							var xhr = ioArgs.xhr;
							
							ibm.portal.debug.text( "XHR object: " + xhr ); 
							var config = com.ibm.portal.services.PortalRestServiceConfig;
							var digest = xhr.getResponseHeader( "X-Request-Digest" );
							
							if ( digest ) {
								config.digest = digest;	
							}
							
							if ( xhr.status == 200 ) {
								var data = response;
								var loc = xhr.getResponseHeader( "IBM-Web2-Location");
								
								if ( loc ) {
									//Check to see if we are going from a public resource to a protected resource.
									//This means a successful login has occurred and we need to force a full page 
									//refresh.
									if ( loc.indexOf( ibmPortalConfig["portalProtectedURI"]) >= 0 && me._feedURI.indexOf( ibmPortalConfig["portalPublicURI"] ) >= 0 ) {
										top.location.href = loc;
										return;
									}
								}
								
								var contentType = xhr.getResponseHeader( "Content-Type" );
								ibm.portal.debug.text( "content-type is: " + contentType );

                                // XHR request returns a content-type of text/html
                                // on cross page wire events, if the web-2 location is present and
                                // points to a non-contenthandler, skip auth check

                                if (/^text\/html/.exec (contentType) && loc &&  (loc.indexOf( ibmPortalConfig["portalProtectedURI"]) >-1 || loc.indexOf( ibmPortalConfig["portalPublicURI"]) >-1) ){
                                    ibm.portal.debug.text( "content-type is text .. follow IBM-Web2-Location" );
									top.location.href = loc;
									return;
								}								


								
								var auth = com.ibm.ajax.auth;
								var authRequired = false;
								
								if ( me._customResponseValidator ) {
									authRequired = me._customResponseValidator( response, ioArgs );
								}
								if ( !authRequired ) {
									authRequired = auth.isAuthenticationRequired( response, ioArgs );
								}
								
								//If the HTML content is returned, this is probably another re-direction so we need to
								//force a full-page refresh.
								if ( authRequired ) {
									auth.authenticationHandler( response, ioArgs, me._onauthenticated );
									return;
								}	
								
								ibm.portal.debug.text( "Read feed: " + me._feedURI );
								
								if ( dojo.isIE ) {
									var doc = dojox.data.dom.createDocument( data );
									callbackfn( "load", doc, xhr, callbackargs );
								}
								else {
									callbackfn( "load", data, xhr, callbackargs );
								}
                            } else if  (xhr.status==401 || xhr.status==0) {
                                ibm.portal.debug.text( "Basic auth 401 found, trigger reload");
                                com.ibm.ajax.auth.authenticationHandler();
                                return;
                            } else {
                                callbackfn( "error", response, xhr, callbackargs );
							}	
							
							com.ibm.portal.EVENT_BROKER.endRequest.fire( { uri: me._feedURI } );
							ibm.portal.debug.exit( "PortalRestServiceRequest.handle" );
						},
						sync: this._sync,
						handleAs: "xml"	
					}
					
					
					if ( this._form ) {
						//DOJO expects the content parameter to be of the format created by
						//dojo.queryToObject(). The contents of the content parameter are sent either
						//as part of the query string (method=GET) or as the body of the request (method=POST).
						args.content = dojo.queryToObject( this._form.toQuery() );
						method = this._form.method;
					}
					
					//Convert to upper case to make comparisons easier. We always convert to "proper" case right before
					//calling the dojo xhrYyy function.
					method = method.toUpperCase();
					
					if ( method != "GET" && method != "POST" ) {
						if ( ibmPortalConfig && ibmPortalConfig.xMethodOverride ) {
							args.headers["X-Method-Override"] = method.toUpperCase();
							method = "Post";	
						}
					}
					
					if ( method == "PUT" && body ) {
						args.putData = body;
					} else if ( method == "POST" && body ) {
						args.postData = body;
					}	
					
					if ( dojo.isIE ) {
						args.content["ibm.web2.contentType"] = "text/xml";
						args.handleAs = "text"; //temp
					}
					var config = com.ibm.portal.services.PortalRestServiceConfig;
					if ( config.timeout ) {
						args.timeout = config.timeout;
					}
					if ( config.digest ) {
						args.content["digest"] = config.digest;
					}
					
					//Match dojo's convention of xhrGet/xhrPost/xhrPut/etc.
					method = com.ibm.portal.utilities.string.properCase( method );
					
					var xhrMethod = dojo["xhr" + method];
					if ( xhrMethod ) {
						xhrMethod( args );
					} else {
						throw new Error( "Invalid request method attempted: " + method );
					}	
						
					ibm.portal.debug.exit( "PortalRestServiceRequest._doXmlHttpRequest" );
				},
				toString: function () {
					return this._feedURI;
				}
			  }
);
com.ibm.portal.services.PortalRestServiceConfig = {
	timeout: null,
	digest: null
}

com.ibm.ajax.auth.setAuthenticationHandler( function () { 
	if ( typeof( document.isCSA ) == "undefined" ) {
		top.location.reload();
	}
	else {
		ibm.portal.debug.entry( "DefaultAuthenticationHandler" );
		ibm.portal.debug.text( "Illegal response content-type detected!" );
		ibm.portal.debug.text( "Parameterized redirect URL is: " + ibmPortalConfig["contentModelBlankURL"] );
		var state = com.ibm.portal.navigation.controller.NAVIGATION_CONTROLLER.getState();
		var fullPageRefreshURL = ibmPortalConfig["contentModelBlankURL"].replace( "-----oid-----", state.getPageSelection() );
		ibm.portal.debug.text( "fullPageRefreshURL is currently: " + fullPageRefreshURL );
		/*if ( loc ) { 
			fullPageRefreshURL = loc;
			ibm.portal.debug.text( "fullPageRefreshURL is now: " + fullPageRefreshURL );
		}*/
	
		if (dojo.cookie("WASReqURL") != null) {
			// create URL to current navigational state
			// we cannot use fullPageRefreshURL because it does not encode the entire nav state
			var fullStateUrl = state.createLinkToCurrentState();
			var cookieStr = "WASReqURL=" + fullStateUrl + "; path=/";
			// does not work with Dojo cookie APIs
			document.cookie=cookieStr;
		}
	
		ibm.portal.debug.text( "Redirecting to: " + fullPageRefreshURL );
		
		//Fire the redirect event so any necessary clean up can occur.
		com.ibm.portal.EVENT_BROKER.redirect.fire( { url: fullPageRefreshURL } ); 
		top.location.href = fullPageRefreshURL;
		ibm.portal.debug.exit( "DefaultAuthenticationHandler" );
	}
});

}

if(!dojo._hasResource["com.ibm.portal.services.PortletFragmentService"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.portal.services.PortletFragmentService"] = true;
dojo.provide( "com.ibm.portal.services.PortletFragmentService" );

dojo.require( "dojox.data.dom" );

dojo.require( "com.ibm.portal.services.PortalRestServiceRequest" );
dojo.require( "com.ibm.portal.utilities" );
dojo.require( "com.ibm.portal.debug" );
dojo.require( "com.ibm.portal.EventBroker" );

dojo.declare( "com.ibm.portal.services.PortletFragmentURL",
			  null,
			  {
			  	constructor: function ( /*String*/uri ) {
				  	if ( uri.indexOf( "?uri=" ) == 0 ) {
						this.url = ibmPortalConfig["portalURI"] + uri;
						this.url = this.url.replace(/&amp;/g,"&" );
						this.url = this.url.replace( /lm:/, "pm:" );
					}
					else if ( uri.indexOf( "lm:" ) == 0 ) {
						this.url = ibmPortalConfig["portalURI"] + "?uri=fragment:" + uri;
						this.url = this.url.replace( /lm:/, "pm:" );
					}
					else {
						this.url = uri;
					}
				  }
			  }
);

dojo.declare( "com.ibm.portal.services.PortletInfo",
			  null,
			  {
				constructor: function( /*String*/wId, /*String*/pId, /*String*/pMarkup, /*Array*/pModes, /*Array*/wStates, /*Array*/depPortlets, /*Array*/otherPortlets, /*XMLDocument*/stateDOM, /*Array*/ stateVaryExpr, /*PortletMode*/ portletMode, /* WindowState */ windowState ) {
					ibm.portal.debug.entry( "PortletInfo.constructor", [ wId, pId, pMarkup, pModes, wStates, depPortlets, stateDOM ]);
					
					this.windowId = wId;
					this.portletId = pId;
					this.uri = "fragment:pm:oid:" + wId + "@oid:" + pId;
					this.markup = pMarkup;
					this.portletModes = pModes;
					this.windowStates = wStates;
					this.dependentPortlets = depPortlets;
					this.otherPortlets = otherPortlets;
					this.stateVaryExpressions = stateVaryExpr;
					this.updatedState = stateDOM;
					this.currentMode = portletMode;
					this.currentWindowState = windowState;
					
					ibm.portal.debug.exit( "PortletInfo.constructor" );
			    }
			  }
);

dojo.declare( "com.ibm.portal.services.PortletFragmentService",
			  null,
			  {
			  	namespaces: {
		            "xsl" : "http://www.w3.org/1999/XSL/Transform",
		            "thr" : "http://purl.org/syndication/thread/1.0",
		            "atom" : "http://www.w3.org/2005/Atom",
		            "xhtml" : "http://www.w3.org/1999/xhtml",
		            "model" : "http://www.ibm.com/xmlns/prod/websphere/portal/v6.0.1/portal-model-elements",
		            "base" : "http://www.ibm.com/xmlns/prod/websphere/portal/v6.0/ibm-portal-composite-base",
		            "portal" : "http://www.ibm.com/xmlns/prod/websphere/portal/v6.0.1/portal-model",
		            "xsi" : "http://www.w3.org/2001/XMLSchema-instance",
				"state" : "http://www.ibm.com/xmlns/prod/websphere/portal/v6.1/portal-state",
				"state-vary" : "http://www.ibm.com/xmlns/prod/websphere/portal/v6.1/portal-state-vary"
		        },
				_flagPortletUrl: function ( /*String*/ url, /*String*/ portletId ) {
					ibm.portal.debug.entry( "PortletFragmentService._flagPortletUrl", [ url ] );
					
					// Check to see if the uri parameter is already included in url
					var uriIncluded = url.indexOf("uri=fragment:pm:oid:");

					//Create the url and add the necessary parameters.
					var urlObj = new com.ibm.portal.utilities.HttpUrl( url );
					urlObj.addParameter( "ibm.web2.keepRenderMode", "false" );
					
					// If uriIncluded is -1, then add the uri as a parameter
					if(uriIncluded < 0 ){
						//Convert the portlet id to a fragment id.
						portletId = portletId.replace( /lm:/g, "fragment:pm:" );
						urlObj.addParameter( "uri", portletId );
					}
					
					ibm.portal.debug.exit( "PortletFragmentService._flagPortletUrl", [ urlObj.toString() ]);
					return urlObj.toString();
				},
				getPortletInfo: function ( /*String*/portletId, /*String*/ portletUrl, /*Function?*/ callbackFn, /*PortalRestServiceForm?*/form, /*Boolean?*/stateless ) {
					// summary: Retrieves the PortletInfo for the given portlet url.
					// description: Sends a request for the given portlet information, including markup for the current navigational state. If the request does not
					//		complete successfully, a null object will be returned or passed into the callback function. 
					// portletUrl: a portlet URL, should come directly from the Portlet Fragment Feed or be created using the
					//		NavigationalState.newPortletRenderURL() function.
					// callbackFn: OPTIONAL - a callback function to be called when the portlet info is retrieved. the first parameter is the portlet info object
					//		or NULL if an error occurred and the second parameter is the XMLHttpRequest object used to make the request.
					// formNode: OPTIONAL - the form to submit as part of the request OR the query string produced by a "serialized" form
					// formFilter: OPTIONAL - the form filter for elements to encode (see dojo documentation)
					// stateless: OPTIONAL - indicates that this request should not affect the state of the portlet. Setting this to
					//		true cancels the topic publishing for this request only. 
					ibm.portal.debug.entry( "PortletFragmentService.getPortletInfo", [portletId, portletUrl, callbackFn, form, stateless ] );
					
					//Two cases where we don't want this request to continue:
					//1. The url is a hash mark (frequenty used for simply firing onclick events).
					//2. The url is a javascript: url. Usually this would have been discovered by now, but in the off chance
					//		that it isn't, we just want to eval it and return. 
					if ( portletUrl == "#" || portletUrl == window.location.href + "#" ) {
						ibm.portal.debug.text( "Illegal portlet url provided: " + portletUrl );
						ibm.portal.debug.text( "Aborting request." );
						return false;
					}
					
					if ( com.ibm.portal.utilities.isJavascriptUrl( portletUrl )) {
						return eval( portletUrl );
					}
					
					// if the URL is relative (e.g. "?fragment:pm:oid:..."), we need to resolve it
					var tempUrl = portletUrl;
					if(tempUrl.indexOf(top.location.href) == 0) {
						// here we're checking to see if the URL is actually the same as our current
						// url... we then trim that down and see what it really points to, like if it's
						// a relative URL in disguise 
						tempUrl = tempUrl.substring(top.location.href.length);
						while(tempUrl.length > 0 && tempUrl.charAt(0) == "/") {
							tempUrl = tempUrl.substring(1);
						}
					}
					if (tempUrl.indexOf('?') == 0) {
						var state = com.ibm.portal.navigation.controller.NAVIGATION_CONTROLLER.getState();
						portletUrl = state.resolveRelativePortletURL(tempUrl);
					}

					if ( com.ibm.portal.utilities.isExternalUrl( portletUrl ) ) {
						self.location.href = portletUrl;	
					}
					else{
						var url = { url: this._flagPortletUrl( portletUrl, portletId ) }
						var serviceReq = new com.ibm.portal.services.PortalRestServiceRequest( url, form );
						if ( !stateless ) {
							com.ibm.portal.EVENT_BROKER.startFragment.fire( { id: portletId } );
						}
						var me = this;
						serviceReq.read(
							function ( /*String*/type, /*XMLDocument*/xmlData, /*XMLHttpRequest*/xhr ) {
								var pInfo = null;
								if ( type == "load" ) {
									pInfo = me.createPortletInfo( xmlData );
								}
								
								if ( xmlData instanceof Error ) {
									pInfo = xmlData;
								}
								
								if ( !stateless ) {
									me._fireEvents( pInfo, portletId, xhr );
								}
								
								if ( callbackFn ) {
									callbackFn( pInfo, xhr );
								}
							}	
						);
					}

					ibm.portal.debug.exit( "PortletFragmentService.getPortletInfo" );	
				},
				readWindowID: function ( /*XMLDocument*/xmlData ) {
					ibm.portal.debug.entry( "PortletFragmentService.readWindowID", [xmlData] );
					
					var windowIdXPath = "/atom:feed/atom:entry/atom:id";
					var nodes = com.ibm.portal.xpath.evaluateXPath( windowIdXPath, xmlData, this.namespaces );
					var windowId = dojox.data.dom.textContent( nodes[0] );
					
					ibm.portal.debug.exit( "PortletFragmentService.readWindowID", [windowId.substring(4)]);		
					return windowId.substring(4);	
				},
				readPortletID: function ( /*XMLDocument*/xmlData ) {
					ibm.portal.debug.entry( "PortletFragmentService.readPortletID", [xmlData] );
					
					var portletIdXPath = "/atom:feed/atom:id";
					var nodes = com.ibm.portal.xpath.evaluateXPath( portletIdXPath, xmlData, this.namespaces );
					var portletId = dojox.data.dom.textContent( nodes[0] );
					
					ibm.portal.debug.exit( "PortletFragmentService.readPortletID", [portletId.substring(4)]);
					return portletId.substring(4);
				},
				readMarkup: function ( /*XMLDocument*/xmlData ) {
					ibm.portal.debug.entry( "PortletFragmentService.readMarkup", [xmlData] );
					var contentsXPath = "/atom:feed/atom:entry/atom:content";
					var nodes = com.ibm.portal.xpath.evaluateXPath(contentsXPath, xmlData, this.namespaces);
					var markup = "";
					
					if (nodes != null && nodes.length > 0) {
			            markup = dojox.data.dom.textContent( nodes[0] );
			        }
					
					ibm.portal.debug.exit( "PortletFragmentService.readMarkup", [markup]);
					return markup;
				},
				readPortletModes: function ( /*XMLDocument*/xmlData ) {
					ibm.portal.debug.entry( "PortletFragmentService.readPortletModes", [xmlData] );
					var modesXPath = "/atom:feed/atom:entry/atom:link[@portal:rel='portlet-mode']";
					var nodes = com.ibm.portal.xpath.evaluateXPath(modesXPath, xmlData, this.namespaces);
					var modes = new Array();
					
					if (nodes != null && nodes.length > 0) {
			        	var nodeCount = nodes.length;
			            for (var i = 0; i < nodeCount; i++) {
							modes.push( { "link": nodes[i].getAttribute("href"), "mode": nodes[i].getAttribute("title") } );
			            }
			        }
					ibm.portal.debug.exit( "PortletFragmentService.readPortletModes", [modes]);
					return modes;
				},
				readWindowStates: function ( /*XMLDocument*/xmlData ) {
					ibm.portal.debug.entry( "PortletFragmentService.readWindowStates", [xmlData] );
					var wStatesXPath = "/atom:feed/atom:entry/atom:link[@portal:rel='window-state']";
					var nodes = com.ibm.portal.xpath.evaluateXPath(wStatesXPath, xmlData, this.namespaces);
					var wStates = new Array();
					
					if (nodes != null && nodes.length > 0) {
			        	var nodeCount = nodes.length;
			            for (var i = 0; i < nodeCount; i++) {
							wStates.push( { "link": nodes[i].getAttribute("href"), "mode": nodes[i].getAttribute("title") } );
			            }
			        }
					ibm.portal.debug.exit( "PortletFragmentService.readWindowStates", [wStates]);
					return wStates;
				},
				readDependentPortlets: function ( /*XMLDocument*/xmlData ) {
					ibm.portal.debug.entry( "PortletFragmentService.readDependentPortlets", [xmlData] );
					var depPortletsXPath = "/atom:feed/atom:link[@portal:rel='dependent']";
					var nodes = com.ibm.portal.xpath.evaluateXPath(depPortletsXPath, xmlData, this.namespaces );
					var depPortlets = new Array();
					
					if (nodes != null && nodes.length > 0) {
			        	var nodeCount = nodes.length;
			            for (var i = 0; i < nodeCount; i++) {
							depPortlets.push( { "link": nodes[i].getAttribute("href"), "portlet": nodes[i].getAttribute("title"), "uri": nodes[i].getAttribute("portal:uri") ? nodes[i].getAttribute("portal:uri") :  nodes[i].getAttribute("uri") } );
			            }
			        }
					
					ibm.portal.debug.exit( "PortletFragmentService.readDependentPortlets", [depPortlets]);
					return depPortlets;
				},
				readOtherPortlets: function ( /*XMLDocument*/xmlData ) {
					ibm.portal.debug.entry( "PortletFragmentService.readOtherPortlets", [xmlData] );
					var otherPortletsXPath = "/atom:feed/atom:link[@portal:rel='other']";
					var nodes = com.ibm.portal.xpath.evaluateXPath(otherPortletsXPath, xmlData, this.namespaces );
					var otherPortlets = new Array();
					if (nodes != null && nodes.length > 0) {
			        	var nodeCount = nodes.length;
			            for (var i = 0; i < nodeCount; i++) {
							otherPortlets.push( { "link": nodes[i].getAttribute("href"), "portlet": nodes[i].getAttribute("title"), "uri": nodes[i].getAttribute("portal:uri") } );
			            }
			        }
					ibm.portal.debug.exit( "PortletFragmentService.readOtherPortlets", [otherPortlets]);
					return otherPortlets;
				},
				readStateVaryExpressions: function (/*XMLDocument*/xmlData ) {
					ibm.portal.debug.entry( "PortletFragmentService.readStateVaryExpressions", [xmlData] );
					var stateVaryXPath = "/atom:feed/atom:entry/state-vary:state-vary/state-vary:expr";
					var nodes = com.ibm.portal.xpath.evaluateXPath(stateVaryXPath, xmlData, this.namespaces );
					var varyExpr = new Array();
					if (nodes != null && nodes.length > 0) {
						var nodeCount = nodes.length;
						for (var i = 0; i < nodeCount; i++) {
							var txtNode = nodes[i].firstChild;
							if (txtNode != null) {
								varyExpr.push( txtNode.nodeValue );
							}
						}
					}
					ibm.portal.debug.exit( "PortletFragmentService.readStateVaryExpressions", [varyExpr]);
					return varyExpr;
				},
				readPortletState: function ( /*XMLDocument*/xmlData ) {
					return this._readPortletState(xmlData);
				},
				_readPortletState: function ( /*XMLDocument*/xmlData ) {
					ibm.portal.debug.entry( "PortletFragmentService.readPortletState", [xmlData] );
					var stateXPath = "/atom:feed/atom:entry/state:root";
					var nodes = com.ibm.portal.xpath.evaluateXPath(stateXPath, xmlData, this.namespaces);
					var result = null;
					if ( nodes != null && nodes.length > 0 ) {
						var doc = dojox.data.dom.createDocument();
						com.ibm.portal.utilities.addExternalNode(doc, nodes[0]);
						result = doc;
					} else {
						stateXPath = "/atom:feed/state:root";
						nodes = com.ibm.portal.xpath.evaluateXPath(stateXPath,xmlData,this.namespaces);
						if ( nodes != null && nodes.length > 0 ) {
							var doc = dojox.data.dom.createDocument();
							com.ibm.portal.utilities.addExternalNode(doc, nodes[0]);
							result = doc;
						}
					}
					ibm.portal.debug.exit( "PortletFragmentService.readPortletState", [ result ] );
					return result;
				},
				_fireEvents: function ( /*PortletInfo*/pInfo, /*String*/portletId, /*XMLHttpRequest*/xhr ) {
					this._fireGlobalPortletStateChange( pInfo, portletId, xhr );
					//this._fireIndividualPortletStateChange( pInfo );
				},
				_fireGlobalPortletStateChange: function ( /*PortletInfo*/pInfo, /*String*/portletId, /*XMLHttpRequest*/xhr ) {
					//dojo.event.topic.publish( "/portal/PortletFragmentService/portletInfoRetrieved", { portletInfo: pInfo } );
					com.ibm.portal.EVENT_BROKER.endFragment.fire( { portletInfo: pInfo, id: portletId, xhr: xhr } );		
				},
				_fireIndividualPortletStateChange: function ( /*PortletInfo*/pInfo ) {
					//ibm.portal.debug.text( "Firing individual portlet event: /portal/navigation/portlet/" + pInfo.portletId + "@" + pInfo.windowId  );
					//dojo.event.topic.publish( "/portal/PortletFragmentService/portletInfoRetrieved/oid:" + pInfo.windowId + "@oid:" + pInfo.portletId , { portletInfo: pInfo } );	
				},
				createPortletInfo: function( /*XMLDocument*/xmlData ) {
					var windowId = this.readWindowID( xmlData );
					var portletId = this.readPortletID( xmlData ); 
					var markup = this.readMarkup( xmlData );
					var modes = this.readPortletModes( xmlData );
					var wStates = this.readWindowStates( xmlData );
					var depPortlets = this.readDependentPortlets( xmlData );
					var otherPortlets = this.readOtherPortlets( xmlData );
					var newState = this.readPortletState( xmlData );
					var stateVaryExpr = this.readStateVaryExpressions( xmlData );
					// determine the current portlet mode and window state
					var currentState = newState;
					if (currentState == null) {
						currentState = this._readPortletState(xmlData);
					}
					var stateMgr = new com.ibm.portal.state.StateManager();
					var portletAcc = stateMgr.newPortletAccessor( windowId, currentState );
					var mode = portletAcc.getPortletMode();
					var winState = portletAcc.getWindowState();
					return new com.ibm.portal.services.PortletInfo( windowId, portletId, markup, modes, wStates, depPortlets, otherPortlets, newState, stateVaryExpr, mode, winState );
				} 
			  }
);

dojo.declare( "com.ibm.portal.services.IndependentPortletFragmentService",
			  com.ibm.portal.services.PortletFragmentService,
			  {
			  	// summary: Ignores any dependent portlets.
			  	
			  	readDependentPortlets: function ( /*XMLDocument*/xmlData ) {
					ibm.portal.debug.entry( "DependentPortletFragmentService.readDependentPortlets", [xmlData] );
					var depPortlets = new Array();
				
					ibm.portal.debug.exit( "DependentPortletFragmentService.readDependentPortlets", [depPortlets]);
					return depPortlets;
				},	
				readOtherPortlets: function ( /*XMLDocument*/xmlData ) {
					ibm.portal.debug.entry( "DependentPortletFragmentService.readOtherPortlets", [xmlData] );
					var otherPortlets = new Array();
				
					ibm.portal.debug.exit( "DependentPortletFragmentService.readOtherPortlets", [otherPortlets]);
					return otherPortlets;
				},
				readPortletState: function ( /*XMLDocument*/xmlData ) {
					return null;
				}
			}
);

}

if(!dojo._hasResource["ibm.portal.portlet.portlet"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["ibm.portal.portlet.portlet"] = true;
dojo.provide("ibm.portal.portlet.portlet")








ibm.portal.portlet._SafeToExecute = false;

if ( window.addEventListener ) {
    window.addEventListener( "load", function () { ibm.portal.portlet._SafeToExecute = true; }, false );
}
else if ( window.attachEvent ) {
    window.attachEvent( "onload", function () { ibm.portal.portlet._SafeToExecute = true; } );
}

dojo.declare("ibm.portal.portlet.PortletWindow", null, {

    STATUS_UNDEFINED: 0,
    STATUS_OK: 1,
    STATUS_ERROR: 2,
    
    constructor: function (/*String*/ windowid) {
        /**
         * summary:
        *     Constructor
        *
        * windowid: The window id
        */

        if (windowid==null) return; // special constructor for static initializers

        this.windowID = windowid;
        var element = document.getElementById("com.ibm.wps.web2.portlet.preferences."+this.windowID);
        this.preferenceEditID = element.getAttribute("editid");
        this.preferenceConfigID = element.getAttribute("configid");
        this.preferenceEditDefaultsID = element.getAttribute("editdefaultsid");
        this.pageID = element.getAttribute("pageid");

        this.attributes = new Array();
        this._queuedFuncs = new Array();
        this.portletState = new ibm.portal.portlet.PortletState(windowid);
        
        this.isCSA = false; 
        try {
            this.isCSA = (typeof(document.isCSA) != "undefined" );
        }
        catch (e) {}
        
        //Certain functions aren't safe to be executed until the page has loaded. This will execute any functions
        //which have been queued at the page load event.
        var me = this;
        function executeQueued() {
            for ( var i = 0; i < me._queuedFuncs.length; i++ ) {
                me._queuedFuncs[i]();
            }   
        }
        
        if ( window.addEventListener ) {
            window.addEventListener( "load", function () { if ( !ibm.portal.portlet._SafeToExecute) { ibm.portal.portlet._SafeToExecute = true; } executeQueued(); }, false );
        }
        else if ( window.attachEvent ) {
            window.attachEvent( "onload", function () { if ( !ibm.portal.portlet._SafeToExecute) { ibm.portal.portlet._SafeToExecute = true; } executeQueued(); } );
        }
    },
    
    reportError: function(/*ibm.portal.portlet.Error*/ error) {
    /**
     * summary:
     *     Reports an error to the framework for display purposes
     */
        var code;
        if (error.getErrorCode()==ibm.portal.portlet.Error.ERROR) code = "error";
        else if (error.getErrorCode()==ibm.portal.portlet.Error.INFO) code = "info";
        else if (error.getErrorCode()==ibm.portal.portlet.Error.WARN) code = "warning";
        var statusMessage = { "_type" : code,
                              "_message" : error.getMessage(), 
                              "_details" : error.getDescription() };
        if ( this.isCSA )
        {
            dojo.publish("/portal/status",[{message: statusMessage}]);
        }
        else {
            if ( typeof( console ) != "undefined") {
                if (error.getErrorCode()==ibm.portal.portlet.Error.ERROR) 
                    console.error(statusMessage._message+"\n"+statusMessage._details);
                else if (error.getErrorCode()==ibm.portal.portlet.Error.INFO) 
                    console.info(statusMessage._message+"\n"+statusMessage._details);
                else if (error.getErrorCode()==ibm.portal.portlet.Error.WARN) 
                    console.warn(statusMessage._message+"\n"+statusMessage._details);
            }
            else {
                alert(statusMessage._type.toUpperCase()+"\nMessage: "+statusMessage._message+"\nDetails: "+statusMessage._details);
            }
        }
    },
    getAttribute: function(/*String*/ name) {
    /**
     * summary:
     *     Gets the attribute for the given name scoped by the portlet window
     */
        return this.attributes[name]; // Object, maybe null
    },

    setAttribute: function(/*String*/ name, /*Object*/ value) {
    /**
     * summary:
     *     Sets the attribute for the given name scoped by the portlet window
     */
         var ret = this.attributes[name];
         this.attributes[name] = value;
         return ret; // Object, maybe null
    },

    removeAttribute: function(/*String*/ name) {
    /**
     * summary:
     *     Removes the attribute for the given name scoped by the portlet window
     *     
     */
        this.attributes[name] = null;
    },

    clearAttributes: function() {
    /**
     * summary:
     *     Removes all attributes scoped by the portlet window
     *     
     */
         this.attributes = new Array();
    },

    getPortletState: function(/*Function*/ callbackfn) {
    /**
     * summary:
     *     Gets the portlet state bean scoped by the window id
     *     
     * callbackfn: Function - defines the callback function
     *     that is called when method finishes loading the portlet state.
     *     In case NULL is passed in for callbackfn, the method executes synchronously
     */
        var returnObject = this.portletState;
        var pointer2this = this;
        var result = null;
        if (callbackfn != null) {
            // invoke the callback function
            callbackfn(pointer2this, ibm.portal.portlet.PortletWindow.STATUS_OK, returnObject);
        } else {
            result = { "portletWindow" : pointer2this, 
                       "status" : ibm.portal.portlet.PortletWindow.STATUS_OK,
                       "returnObject" : returnObject };
        }
        return result;
    },

    setPortletState: function(/*PortletState*/state, /*Function*/ callbackfn) {
    /**
     * summary:
     *     Sets the portlet state bean (holding the navigational state) scoped
     *     by the window id. The behavior of this function varies depending on
     *     whether or not the surrounding theme is capable of dealing with
     *     client-side state changes. If not, this function will trigger a full
     *     page refresh. Otherwise the provided callback function decides how to
     *     react on the state change.
     *     
     * callbackfn: Function - defines the callback function
     *     that is called when method finishes storing the portlet state.
     *     The callback function defines how to update the portlet's markup
     *     to reflect the new navigational state. If no callback function is
     *     provided (or null is passed in) the method executes synchronously,
     *     and in addition refreshes the portlet (default behavior of reacting
     *     to a navigational state change.
     */
        this.portletState = state;
        
        if ( this.isCSA ) {
            // if no callback function is provided, execute the default behavior:
            // refresh the portlet by sending a render request to the server
            if (callbackfn == null) {
                var navState = com.ibm.portal.navigation.controller.NAVIGATION_CONTROLLER.getState();
                var url = navState.newPortletRenderURL( this.windowID );
                var service = new com.ibm.portal.services.PortletFragmentService();
                service.getPortletInfo( "lm:oid:" + this.windowID + "@oid:"+ this.pageID, url );
            }
        } else {
            var stateManager = new com.ibm.portal.state.StateManager(ibmPortalConfig["contentHandlerURI"]);
            stateManager.reset( state.portletAccessor.stateDOM );
            // serialize the state into a portal URL
            var serializationMgr = stateManager.getSerializationManager();
            var serializationResult = serializationMgr.serialize(stateManager.getState());
            
            // return the URL
            var serializedState = serializationResult["returnObject"];
            
            var url = serializedState;
            window.location.href = url;
        }
        // dispatch
        return this.getPortletState(callbackfn);
    },
    
    _queueUp: function ( /*Function*/funcToQ ) {
        // summary: Certain functions are not safe to execute before the page loads. Any function
        //      passed to this function will be queued up and executed only after the page loads.
        // funcToQ: the function to queue
        this._queuedFuncs.push( funcToQ );
    },
    
    _throwInappropriateRequestError: function ( /*String*/funcName ) {
        throw new Error( "Cannot execute a synchronous call before the page loads! Please use an onload handler to execute this call to \"" + funcName + "\"." );
        return null;
    },
    
    getPortletPreferences: function(/*Function*/ callbackfn) {
    /**
     * summary:
     *     Gets the portlet preferences bean scoped by the window id
     *     
     * callbackfn: Function - defines the callback function
     *     that is called when method finishes loading the portlet preferences.
     *     In case NULL is passed in for callbackfn, the method executes synchronously
     */
        if ( !ibm.portal.portlet._SafeToExecute ) {
            if ( callbackfn ) {
                var me = this;
                this._queueUp( function () { me.getPortletPreferences( callbackfn ) } );
                return false; 
            }
            else {
                return this._throwInappropriateRequestError( "getPortletPreferences" );
            }
        }
        
        var portletMode = this.getPortletState().returnObject.getPortletMode();
         this.status = ibm.portal.portlet.PortletWindow.STATUS_UNDEFINED;
         var tempurl = document.getElementById("com.ibm.wps.web2.portlet.root."+this.windowID).innerHTML;
         var idx = tempurl.indexOf("--portletwindowid--");
         var _url = tempurl.replace(/--portletwindowid--/g, this.windowID);
         
         if ( _url.indexOf( "?" ) < 0 ) {
            _url = _url + "?"; 
         } 
         
         _url += "&verb=download&levels=-all&rep=compact&preferences=aggregated";

         this.requestedPreferenceID = "pm:oid:"+this.preferenceEditID; //+"@oid:"+this.pageID;
         if (portletMode==ibm.portal.portlet.PortletMode.CONFIG) 
             this.requestedPreferenceID = "pm:oid:"+this.preferenceConfigID;
         else if (portletMode==ibm.portal.portlet.PortletMode.EDIT_DEFAULTS) 
             this.requestedPreferenceID = "pm:oid:"+this.preferenceEditDefaultsID;
         
         var pointer2this = this;
         var pointer2return = null;
         
         dojo.xhrGet({
             url: _url,
             handleAs: "xml",
             headers: { "X-IBM-XHR":"true", "If-Modified-Since": "Thu, 1 Jan 1970 00:00:00 GMT"}, //temporary to force the browser to ignore cached requests
             sync: (callbackfn)?false:true,
             handle: function(response, ioArgs){
                 if ( pointer2this.isAuthenticationRequired( ioArgs.xhr, ioArgs.args.handleAs ) ) {
                	 pointer2this.doAuthentication();
                 } else {
            	 
	            	 var type = ( response instanceof Error ) ? "error" : "load";
	                  if(type == "load") {
	                      var responseXML = response;
	                      
	                      //IE doesn't populate the responseXML property here because of the content-type of the response. So we need to create the XML
	                      //document from text to be able to execute XPath queries.
	                      if ( !responseXML || ( typeof( dojox.data.dom.innerXML( response )) == "undefined" ) ) {
	                        responseXML = dojox.data.dom.createDocument( ioArgs.xhr.responseText );
	                      }
	                      
	                      var returnObject = 
	                          new ibm.portal.portlet.PortletPreferences(pointer2this.windowID,
	                                                                        pointer2this.requestedPreferenceID,
	                                                                        responseXML );
	                      if (callbackfn) {
	                          callbackfn(pointer2this,ibm.portal.portlet.PortletWindow.STATUS_OK,returnObject);
	                      }
	                      else {
	                          pointer2return = {"portletWindow" : pointer2this, 
	                              "status" : ibm.portal.portlet.PortletWindow.STATUS_OK,
	                              "returnObject" : returnObject };
	                      }
	                  }else if(type == "error"){
	                      if (callbackfn) {
	                          callbackfn(pointer2this, ibm.portal.portlet.PortletWindow.STATUS_ERROR, null);
	                      }
	                      else {
	                          pointer2return = {"portletWindow" : pointer2this, 
	                              "status" : ibm.portal.portlet.PortletWindow.STATUS_ERROR,
	                              "returnObject" : null };
	                      }
	                  }
                 } 
             },
             transport: "XMLHTTPTransport"
         });
         
         return pointer2return; // Object - synchronously: { portletWindow, status, returnObject } / asynchronously: NULL
    },

    setPortletPreferences: function(/*PortletPreferences*/preferences, /*Function*/ callbackfn) {
    /**
     * summary:
     *     Sets the portlet preferences bean scoped by the window id
     *     
     * callbackfn: Function - defines the callback function
     *     that is called when method finishes storing the portlet preferences.
     *     In case NULL is passed in for callbackfn, the method executes synchronously
     */
         if ( !ibm.portal.portlet._SafeToExecute ) {
            if ( callbackfn ) {
                var me = this;
                this._queueUp( function () { me.setPortletPreferences( preferences, callbackfn ) } );
                return false; 
            }
            else {
                return this._throwInappropriateRequestError( "setPortletPreferences" );
            }
        }
         
         this.status = ibm.portal.portlet.PortletWindow.STATUS_UNDEFINED;
         var tempurl = document.getElementById("com.ibm.wps.web2.portlet.root."+this.windowID).innerHTML;
         var idx = tempurl.indexOf("--portletwindowid--");
         var _url = tempurl.replace(/--portletwindowid--/g, this.windowID);
         if ( _url.indexOf( "?" ) < 0 ) {
             _url += "?verb=download";
         }
         else {
             _url += "&verb=download";
         }

         var requestedPreferenceID = preferences.requestedPreferenceID;
         // strip down to necessary data
         var expr = "/atom:feed/atom:entry[atom:id='"+requestedPreferenceID+"']";
         var nodes = ibm.portal.xml.xpath.evaluateXPath(expr, preferences.xmlData, preferences.ns);
         var entry;
         if (nodes && nodes.length>0) {
             entry = nodes[0];
         }
         else {
             return null; // TODO
         }
         var parentNode = entry.parentNode;
         expr = "/atom:feed/atom:entry";
         nodes = ibm.portal.xml.xpath.evaluateXPath(expr, preferences.xmlData, preferences.ns);
         for (var i=0; i<nodes.length; i++) {
             var node = nodes[i];
             if (node!=entry) {
                 parentNode.removeChild(node);
             }
         }
         
         //alert (dojox.data.dom.innerXML(preferences.xmlData));

         var pointer2this = this;
         var pointer2return = null;


         dojo.rawXhrPut({
             url: _url,
             sync: (callbackfn)?false:true,
             putData: dojox.data.dom.innerXML(preferences.xmlData),
             contentType: "application/xml",
             headers: { "X-IBM-XHR":"true"},
             handleAs: "xml",
             handle: function(response, ioArgs){
	        	 if ( pointer2this.isAuthenticationRequired( ioArgs.xhr, ioArgs.args.handleAs ) ) {
	        		 pointer2this.doAuthentication();
	             } else {  
	        	 	var type = ( response instanceof Error ) ? "error" : "load";
	                  if(type == "load") {
	                      if (callbackfn) {
	                          callbackfn(pointer2this,ibm.portal.portlet.PortletWindow.STATUS_OK,preferences);
	                      }
	                      else {
	                          pointer2return = {"portletWindow" : pointer2this, 
	                              "status" : ibm.portal.portlet.PortletWindow.STATUS_OK,
	                              "returnObject" : preferences };
	                      }
	                  }else if(type == "error") {
	                      if (callbackfn) {
	                          callbackfn(pointer2this, ibm.portal.portlet.PortletWindow.STATUS_ERROR, null);
	                      }
	                      else {
	                          pointer2return = {"portletWindow" : pointer2this, 
	                              "status" : ibm.portal.portlet.PortletWindow.STATUS_ERROR,
	                              "returnObject" : null };
	                      }
	                  }
	             }
             },
             transport: "XMLHTTPTransport"
         });
         return pointer2return; // Object - synchronously: { portletWindow, status, returnObject } / asynchronously: NULL
    },

    getUserProfile: function(/*Function*/ callbackfn) {
    /**
     * summary:
     *     Gets the current user profile
     *     
     * callbackfn: Function - defines the callback function
     *     that is called when method finishes loading the portlet preferences.
     *     In case NULL is passed in for callbackfn, the method executes synchronously
     */
         if ( !ibm.portal.portlet._SafeToExecute ) {
            if ( callbackfn ) {
                var me = this;
                this._queueUp( function () { me.getUserProfile( callbackfn ) } );
                return false; 
            }
            else {
                return this._throwInappropriateRequestError( "getUserProfile" );
            }
        }
         
         this.status = ibm.portal.portlet.PortletWindow.STATUS_UNDEFINED;
         var _url = document.getElementById("com.ibm.wps.web2.portlet.user."+this.windowID).innerHTML;

         var pointer2this = this;
         var pointer2return = null;
         dojo.xhrGet({
             url: _url,
             headers: { "X-IBM-XHR":"true","If-Modified-Since": "Thu, 1 Jan 1970 00:00:00 GMT"}, //temporary to force the browser to ignore cached requests
             sync: (callbackfn)?false:true,
             handleAs: "xml",
             handle: function(response, ioArgs){
            	 if ( pointer2this.isAuthenticationRequired( ioArgs.xhr, ioArgs.args.handleAs ) ) {
            		 pointer2this.doAuthentication();
                 } else { 
	            	 var type = ( response instanceof Error ) ? "error" : "load";
	                  if (type == "load") {
	                      var responseXML = response;
	                      
	                      // IE doesn't populate the responseXML property here because of the content-type of the response.
	                      // We need to create the XML document from text to be able to execute XPath queries.
	                      if ( !responseXML || ( typeof( dojox.data.dom.innerXML( response )) == "undefined" ) ) {
	                          responseXML = dojox.data.dom.createDocument( ioArgs.xhr.responseText );
	                      }
	
	                      var returnObject = 
	                          new ibm.portal.portlet.UserProfile(pointer2this.windowID, responseXML );
	
	                      if (callbackfn) {
	                          callbackfn(pointer2this,ibm.portal.portlet.PortletWindow.STATUS_OK,returnObject);
	                      }
	                      else {
	                          pointer2return = {"portletWindow" : pointer2this, 
	                              "status" : ibm.portal.portlet.PortletWindow.STATUS_OK,
	                              "returnObject" : returnObject };
	                      }
	                  } else if(type == "error"){
	                      if (callbackfn) {
	                          callbackfn(pointer2this, ibm.portal.portlet.PortletWindow.STATUS_ERROR, null);
	                      }
	                      else {
	                          pointer2return = {"portletWindow" : pointer2this, 
	                              "status" : ibm.portal.portlet.PortletWindow.STATUS_ERROR,
	                              "returnObject" : null };
	                      }
	                  }
                 } 
             },
             transport: "XMLHTTPTransport"
         });
         return pointer2return; // Object - synchronously: { portletWindow, status, returnObject } / asynchronously: NULL
    },

    setUserProfile: function(/*userProfile*/userProfile, /*Function*/ callbackfn) {
    /**
     * summary:
     *     Sets the current user profile
     *     
     * callbackfn: Function - defines the callback function
     *     that is called when method finishes loading the portlet preferences.
     *     In case NULL is passed in for callbackfn, the method executes synchronously
     */
         //var serializer = new XMLSerializer();
         //resultStr = serializer.serializeToString(userProfile.xmlData);
         //alert(resultStr);
        if ( !ibm.portal.portlet._SafeToExecute ) {
            if ( callbackfn ) {
                var me = this;
                this._queueUp( function () { me.setUserProfile( userProfile, callbackfn ) } );
                return false; 
            }
            else {
                return this._throwInappropriateRequestError( "setUserProfile" );
            }
        }

         this.status = ibm.portal.portlet.PortletWindow.STATUS_UNDEFINED;
         var _url = document.getElementById("com.ibm.wps.web2.portlet.user."+this.windowID).innerHTML;

         var pointer2this = this;
         var pointer2return = null;
         dojo.rawXhrPost({
             url: _url,
             sync: (callbackfn)?false:true,
             postData: dojox.data.dom.innerXML(userProfile.xmlData),
             contentType: "application/xml",
             headers: { "X-IBM-XHR":"true"},
             handleAs: "xml",
             handle: function(response, ioArgs){
	        	 if ( pointer2this.isAuthenticationRequired( ioArgs.xhr, ioArgs.args.handleAs ) ) {
	        		 pointer2this.doAuthentication();
	             } else {  
	        	 	var type = ( response instanceof Error ) ? "error" : "load";
	                  if(type == "load") {
	                      if (callbackfn) {
	                          callbackfn(pointer2this,ibm.portal.portlet.PortletWindow.STATUS_OK,userProfile);
	                      }
	                      else {
	                          pointer2return = {"portletWindow" : pointer2this, 
	                              "status" : ibm.portal.portlet.PortletWindow.STATUS_OK,
	                              "returnObject" : userProfile };
	                      }
	                  } else if(type == "error"){
	                      if (callbackfn) {
	                          callbackfn(pointer2this, ibm.portal.portlet.PortletWindow.STATUS_ERROR, null);
	                      }
	                      else {
	                          pointer2return = {"portletWindow" : pointer2this, 
	                              "status" : ibm.portal.portlet.PortletWindow.STATUS_ERROR,
	                              "returnObject" : null };
	                      }
	                  }
	             } 
             },
             transport: "XMLHTTPTransport"
         });
         return pointer2return; // Object - synchronously: { portletWindow, status, returnObject } / asynchronously: NULL
    },
    newXMLPortletRequest: function() {
        // summary: Creates a new XMLPortletRequest object with the current page ID and portlet window ID.
        // returns: a new XMLPortletRequest
        return new ibm.portal.portlet.XMLPortletRequest( this ); // ibm.portal.portlet.XMLPortletRequest
    }, 
    isAuthenticationRequired: function ( /*XMLHttpRequest*/xhrResponse, /*String*/expectedContentType ) {
    	// summary: Given an HTTP RESPONSE (completed XMLHttpRequest object), determine if the response indicates that authentication
    	//		is required.
    	// xhrResponse: the XMLHttpRequest object whose readyState property is 4
    	// expectedContentType: one of "xml", "json", or "json-comment-optional".
    	// returns: true if authentication is required; false otherwise
    	if ( xhrResponse.readyState != 4 ) {
    		throw new Error( "isAuthenticationRequired should only be called with a COMPLETED XMLHttpRequest! The readyState on the given XMLHttpRequest is not 4 (COMPLETE)!" );
    	}
    	//Have to wrap the pertinent information in dojo-like objects since the Auth API was designed only for Dojo use-cases.
    	var fakeResponseObj = { dojoType: "valid" };
    	var fakeArgsObj = { 
    			xhr: xhrResponse,
    			args: {
    				handleAs: expectedContentType
    			}
    	};
    	
    	return com.ibm.ajax.auth.isAuthenticationRequired( fakeResponseObj, fakeArgsObj );
    },
    setAuthenticationHandler: function ( /*Function*/authenticationFn ) {
		// summary: Set a PortletWindow instance-specific authentication function.
		// authenticationFn: the function to call
		this._authenticationFn = authenticationFn;
	},
	doAuthentication: function () {
		// summary: Call the configured authentication handler. NOTE: This function call will most likely
		//		result in a REDIRECT.
		if ( this._authenticationFn ) {
			this._authenticationFn();
		} else {
			com.ibm.ajax.auth.authenticationHandler();
		}	
	}
});


/**
 * summary:
 * The <CODE>PortletPreferences</CODE> interface allows the portlet to store
 * configuration data. It is not the
 * purpose of this interface to replace general purpose databases.
 * 
 * description:
 * There are two different types of preferences:
 * <ul>
 * <li>modifiable preferences - these preferences can be changed by the
 *     portlet in any standard portlet mode (<code>EDIT, HELP, VIEW</code>).
 *     Per default every preference is modifiable.
 * <li>read-only preferences - these preferences cannot be changed by the
 *     portlet in any standard portlet mode, but may be changed by administrative modes.
 *     Preferences are read-only, if the are defined in the
 *     deployment descriptor with <code>read-only</code> set to <code>true</code>,
 *     or if the portlet container restricts write access.
 * </ul>
 * <p>
 * Changes are persisted when the <code>store</code> method is called.
 */

dojo.declare("ibm.portal.portlet.PortletPreferences", null, {
    constructor: function (/*String*/ windowid, 
                           /*String*/ requestedpreferenceid,
                           /*XMLDocument */ data) {
        /** 
        * summary:
        *     Objects of this type should never be called directly but always created
        *     through the PortletManagers method getPortletPreferences.
        *
        * windowid: The window id
        */

        this.windowID = windowid;
        this.requestedPreferenceID = requestedpreferenceid;
        this.xmlData = data;
        this.xsltURL = dojo.moduleUrl( "ibm", "portal/portlet/");
        
        this.ns = {
            "xsl" : "http://www.w3.org/1999/XSL/Transform",
            "thr" : "http://purl.org/syndication/thread/1.0",
            "atom" : "http://www.w3.org/2005/Atom",
            "xhtml" : "http://www.w3.org/1999/xhtml",
            "model" : "http://www.ibm.com/xmlns/prod/websphere/portal/v6.0.1/portal-model-elements",
            "base" : "http://www.ibm.com/xmlns/prod/websphere/portal/v6.0/ibm-portal-composite-base",
            "portal" : "http://www.ibm.com/xmlns/prod/websphere/portal/v6.0.1/portal-model",
            "xsi" : "http://www.w3.org/2001/XMLSchema-instance"
        };

        // performance optimization
        this.internal_reset();
    },

    getMap: function (){
    /**
     * summary: 
     *     Returns a <code>Map</code> of the preferences.
     *     If no preferences exist this method returns an empty <code>Map</code>.
     */
        //ibm.portal.debug.entry( "PortletPreferences.internal_applyXSLT" , [ feed.toString(), dom, args ] );

        if (this.result_getMap) {
            return this.result_getMap;
        }

        //load the xslt
        var xslDoc = ibm.portal.xml.xslt.loadXsl(this.xsltURL + "PortletPreferencesMap.xsl");

        //apply the xslt
        if (xslDoc.documentElement == null) {alert("xslDoc is null");}
        var results = ibm.portal.xml.xslt.transform(this.xmlData, xslDoc, null, {"selectionid":this.requestedPreferenceID}, true);
        if (results == null) {
            this.result_getNames = null;
            return null;
        }

        var prefs = eval( results );
        // "portletPreferences = { \"preferences\": [ { \"name\":\"parallel\" , \"values\": [ \"false\" ] , \"read-only\": \"false\" }, { \"name\":\"test\" , \"values\": [ \"newValue\" ] , \"read-only\": \"false\" } ] };"

        if (prefs)            
            prefs = prefs.preferences;

        this.result_getMap = prefs;

        return this.result_getMap; /* object[] {name: string, values: string[], readonly: boolean}
     *             a <code>Map</code> containing preference names as 
     *             keys and preference values as map values, or an empty <code>Map</code>
     *             if no preference exist.
     */
    },

    getNames: function (){
    /**
     * summary:
     *     Returns all of the keys that have an associated value,
     *     or an empty <code>Enumeration</code> if no keys are available.
     */
         //ibm.portal.debug.entry( "PortletPreferences.internal_applyXSLT" , [ feed.toString(), dom, args ] );
         
         if (this.result_getNames) {
             return this.result_getNames;
         }
         
         //load the xslt
         var xslDoc = ibm.portal.xml.xslt.loadXsl(this.xsltURL + "PortletPreferencesNames.xsl");

         //apply the xslt
         if (xslDoc.documentElement == null) {alert("xslDoc is null");}
         var results = ibm.portal.xml.xslt.transform(this.xmlData, xslDoc, null, {"selectionid":this.requestedPreferenceID}, true);
         if (results == null) {
             this.result_getNames = null;
             return null;
         }

         var prefsNames = eval( results );
         // "portletPreferences = { \"preferences\": [ { \"name\":\"parallel\" , \"values\": [ \"false\" ] , \"read-only\": \"false\" }, { \"name\":\"test\" , \"values\": [ \"newValue\" ] , \"read-only\": \"false\" } ] };"

         if (prefsNames)
             prefsNames = prefsNames.names;

         this.result_getNames = prefsNames;

         return this.result_getNames; /* String[] - an Enumeration of the keys that have an associated value,
         *         or an empty <code>Enumeration</code> if no keys are
        *         available.
        */
    },

    getValue: function( /*String*/ key, /*String*/ def ){
    /**
     * summary:
     *     Returns the first String value associated with the specified key of this preference.
     * description:
     *     If there is one or more preference values associated with the given key 
     *     it returns the first associated value.
     *     If there are no preference values associated with the given key, or the 
     *     backing preference database is unavailable, it returns the given 
     *     default value.
     *
     * key: String - key for which the associated value is to be returned
     * def: String - the value to be returned in the event that there is no 
     *            value available associated with this <code>key</code>.
     */
         var expr = "/atom:feed/atom:entry[atom:id='"+this.requestedPreferenceID+"']/atom:content/*/model:portletpreferences[@name='"+key+"']/base:value";
         // /atom:feed/atom:entry[atom:id='pm:oid:5_J12SV3D00O6JD02ECR217F00E0@oid:6_J12SV3D00O6JD02ECR217F00M6']/atom:content/model:portlet-entity/model:portletpreferences[@name='parallel']
         
         var nodes = ibm.portal.xml.xpath.evaluateXPath(expr, this.xmlData, this.ns);         
         var result;
         if (nodes && nodes.length>0) {
             result = nodes[0].getAttribute("value");
         }
         else {
             result = def;
         }

         return result; /* String - the value associated with <code>key</code>, or <code>def</code>
         *         if no value is associated with <code>key</code>, or the backing
         *         store is inaccessible.
         */
    },

    getValues: function( /*String*/ key, /*String[]*/ def ){
    /**
     * summary:
     *     Returns the String array value associated with the specified key in this preference.
     * description:
     *     Returns the specified default if there is no value
     *     associated with the key, or if the backing store is inaccessible.
     *
     *     If the implementation supports <i>stored defaults</i> and such a
     *     default exists and is accessible, it is used in favor of the
     *     specified default.
     *
     * key: String - key for which associated value is to be returned.
     * def: String[] - the value to be returned in the event that this
     *        preference node has no value associated with <code>key</code>
     *        or the associated value cannot be interpreted as a String array,
     *        or the backing store is inaccessible.
     */

         var expr = "/atom:feed/atom:entry[atom:id='"+this.requestedPreferenceID+"']/atom:content/*/model:portletpreferences[@name='"+key+"']/base:value";
         // /atom:feed/atom:entry[atom:id='pm:oid:5_J12SV3D00O6JD02ECR217F00E0@oid:6_J12SV3D00O6JD02ECR217F00M6']/atom:content/model:portlet-entity/model:portletpreferences[@name='parallel']
         
         var nodes = ibm.portal.xml.xpath.evaluateXPath(expr, this.xmlData, this.ns);
         var result;
         if (nodes && nodes.length>0) {
             result = new Array();
             for (var i=0; i<nodes.length; i++) {
                 result[i] = nodes[i].getAttribute("value");
             }
         }
         else {
             result = def;
         }
        
         return result; /* String[] - the String array value associated with
         *         <code>key</code>, or <code>def</code> if the
         *         associated value does not exist.
         */
    },

    isReadOnly: function( /*String*/ key ){
    /**
     * summary:
     *     Returns true, if the value of this key cannot be modified by the user.
     * description:
     *     Modifiable preferences can be changed by the
     *     portlet in any standard portlet mode (<code>EDIT, HELP, VIEW</code>). 
     *     Per default every preference is modifiable.
     * 
     *     Read-only preferences cannot be changed by the
     *     portlet in any standard portlet mode, but inside of custom modes
     *     it may be allowed changing them.
     *     Preferences are read-only, if they are defined in the 
     *     deployment descriptor with <code>read-only</code> set to <code>true</code>,
     *     or if the portlet container restricts write access.
     *
     * key: String - key for which the associated value is to be returned
     */

         var id = this.requestedPreferenceID;
         var expr = "/atom:feed/atom:entry[atom:id='"+id+"']/atom:content/*/model:portletpreferences[@name='"+key+"']";
         var nodes = ibm.portal.xml.xpath.evaluateXPath(expr, this.xmlData, this.ns);         
         
         var result = false;
         if (nodes && nodes.length>0) {
             var temp = nodes[0].getAttribute("read-only");
             if (temp != null) {
                 // convert to a boolean
                 if ( temp == "true" ) {
                    result = true;
                 }
             }
         }
         return result; // boolean - false, if the value of this key can be changed, or if the key is not known
    },

    reset: function ( /*String*/ key ){
    /**
     * summary:
     *     Resets or removes the value associated with the specified key.
     * description:
     *     If this implementation supports stored defaults, and there is such
     *     a default for the specified preference, the given key will be 
     *     reset to the stored default.
     *
     *     If there is no default available the key will be removed.
     *
     * key: String - key to reset
     */
         this.internal_reset();

         var expr = "/atom:feed/atom:entry[atom:id='"+this.requestedPreferenceID+"']/atom:content/*/model:portletpreferences[@name='"+key+"']";
         
         var nodes = ibm.portal.xml.xpath.evaluateXPath(expr, this.xmlData, this.ns);
         if (nodes && nodes.length>0) {
             var parent = nodes[0].parentNode;
             parent.removeChild(nodes[0]);
         }

    },

    setValue: function ( /*String*/ key, /*String*/ value ){
    /**
     * summary:
     *     Associates the specified String value with the specified key in this preference.
     * description:
     *     The key cannot be <code>null</code>, but <code>null</code> values
     *     for the value parameter are allowed.
     *
     * key: String - key with which the specified value is to be associated.
     * value: String - value to be associated with the specified key.
     */
         var values = new Array();
         values[0] = value;
         this.setValues(key,values);
    },

    setValues: function( /*String*/ key, /*String[]*/ values ){
    /**
     * summary:
     *     Associates the specified String array value with the specified key in this preference.
     * description:
     *     The key cannot be <code>null</code>, but <code>null</code> values
     *     in the values parameter are allowed.
     *
     * key: String - key with which the  value is to be associated
     * values: String[] - values to be associated with key
     */
         this.internal_reset();

         var expr = "/atom:feed/atom:entry[atom:id='"+this.requestedPreferenceID+"']/atom:content/*/model:portletpreferences[@name='"+key+"']";
         
         var nodes = ibm.portal.xml.xpath.evaluateXPath(expr, this.xmlData, this.ns);

         var prefNode = null;
         if (nodes && nodes.length>0) {
             prefNode = nodes[0];
             for (var i=prefNode.childNodes.length-1; i>=0; i--) {
                 prefNode.removeChild(prefNode.childNodes[i]);
             }
         }
         else {
             var expr2 = "/atom:feed/atom:entry[atom:id='"+this.requestedPreferenceID+"']/atom:content/*";
             var nodes2 = ibm.portal.xml.xpath.evaluateXPath(expr2, this.xmlData, this.ns);
             if (dojo.isIE) {
                 prefNode = this.xmlData.createNode(1, "model:portletpreferences", this.ns.model); // 1 = NODE_ELEMENT
             }
             else {
                 prefNode = this.xmlData.createElementNS(this.ns.model,"model:portletpreferences");
             }
             prefNode.setAttribute("name",key);
             prefNode.setAttribute("read-only","false");
             nodes2[0].appendChild(prefNode);
         }
         for (var i=0; i<values.length; i++) {
             var newNode;
             if (dojo.isIE) {
                 newNode = this.xmlData.createNode(1, "base:value", this.ns.base); // 1 = NODE_ELEMENT
                 var attribute = this.xmlData.createNode(2, "xsi:type",this.ns.xsi ); // 1 = NODE_ATTRIBUTE
                 attribute.nodeValue = "String";
                 newNode.setAttributeNode(attribute);
             }
             else {
                 newNode = this.xmlData.createElementNS(this.ns.base,"base:value");
                 newNode.setAttributeNS(this.ns.xsi,"xsi:type","String");
             }
             newNode.setAttribute("value",values[i]);
             prefNode.appendChild(newNode);
         }
    },

    internal_reset: function() {
         this.result_getMap = null;
         this.result_getNames = null;
    },

    clone:function()
    {
        var resultStr = dojox.data.dom.innerXML(this.xmlData);
        var xmlDataCopy = dojox.data.dom.createDocument( resultStr ); 

        return new ibm.portal.portlet.PortletPreferences(this.windowID, 
                                                             this.requestedPreferenceID,
                                                             xmlDataCopy);
    }


});















dojo.declare("ibm.portal.portlet.PortletMode", null, {
    VIEW: "view",
    EDIT: "edit",
    EDIT_DEFAULTS: "edit_defaults",
    HELP: "help",
    CONFIG: "config"    
});

dojo.declare("ibm.portal.portlet.WindowState", null, {
    NORMAL: "normal",
    MINIMIZED: "minimized",
    MAXIMIZED: "maximized"
});

dojo.declare("ibm.portal.portlet.PortletState", null, {
    constructor: function (/*String or XMLDocument*/ windowid, /*String?*/portletWindowId ) {
        /**
         * summary:
         *     Objects of this type should never be called directly but always created
         *     through the PortletManagers method getPortletState.
         *
         * windowid: The window id
         */
        var stateManager = new com.ibm.portal.state.StateManager( ibmPortalConfig["contentHandlerURI"] );
        if ( dojo.isString( windowid ) ) {
            var stateDOM = this._getExistingState( windowid, stateManager.getSerializationManager() );
            stateManager.reset( stateDOM );
        }
        else {
            stateManager.reset( windowid );
            windowid = portletWindowId; 
        }
        
        // get a state accessor that allows for reading and writing portlet state
        this.portletAccessor = stateManager.newPortletAccessor(windowid);
        // also get the Parameters object for performance reasons
        this.renderParameters = this.portletAccessor.getRenderParameters();
    },
    _isCSA: function () {
        var retVal = false;
        try {
            retVal = (typeof(document.isCSA )!= "undefined" );
        }
        catch (e) {
            //do nothing here... something was not defined so we aren't in CSA
        }
        
        return retVal;
    },
    _getExistingState: function ( /*String*/windowid, serializationMgr ) {
        var retVal = null;
        if ( this._isCSA() ) {
            // CSA has access to the current state
            retVal = com.ibm.portal.navigation.controller.NAVIGATION_CONTROLLER.getState().stateDOM;
        } else if (serializationMgr != null) {
            // get the current state from the server
            var result = serializationMgr.deserialize( location.href );
            retVal = result.returnObject;
        } else {
            // fall back to an "empty" state
            retVal = dojox.data.dom.createDocument();
        }
        return retVal;
    },
    getPortletMode:function() {
    /**
     * summary:
     *     Returns the portlet mode.
     */
        return this.portletAccessor.getPortletMode(); /*ibm.portal.portlet.PortletMode*/
    },

    setPortletMode:function(/*ibm.portal.portlet.PortletMode*/ portletMode) {
    /**
     * summary:
     *     Sets the portlet mode.
     */
        this.portletAccessor.setPortletMode(portletMode);
        return portletMode;
    },

    getWindowState:function() {
    /**
     * summary:
     *     Returns the window state.
     */
        return this.portletAccessor.getWindowState(); /*ibm.portal.portlet.WindowState*/
    },
    
    setWindowState:function(/*ibm.portal.portlet.WindowState*/windowState) {
    /**
     * summary:
     *     Sets the window state.
     */
        this.portletAccessor.setWindowState(windowState);
        return windowState;
    },

    getParameterNames: function() {
    /**
     * summary:
     *     Returns a String[] containing the names of all parameters that have an
     *     associated value. Returns an empty array if no parameters are available.
     */
        return this.renderParameters.getNames(); // String[]
    },

    getParameterValue: function(/*String*/ name) {
    /**
     * summary:
     *     Returns the String value associated with the render parameter with the given name.
     *     
     * description:
     *     If there are one or more render parameter values associated with the given name 
     *     it returns the first associated value.
     *
     * name: String - Name of the render parameter for which the associated value is to
     *     be returned. Must not be NULL.
     */
        return this.renderParameters.getValue(name); // String
    },

    getParameterValues: function(/*String*/ name) {
    /**
     * summary:
     *     Returns the String[] representing the values that are associated with
     *     the render parameter with the given name.
     *
     * name: String - Name of the render parameter for which the associated values
     *     are to be returned. Must not be NULL.
     */
        return this.renderParameters.getValues(name); // String[]
    },

    getParameterMap: function() {
    /**
     * summary:
     *     Returns an unmodfiable map of render parameters.
     */
        return this.renderParameters.getMap(); /* object[] {name: string, values: string[]} */
    },

    setParameterValue: function(/*String*/ name, /*String*/ value) {
    /**
     * summary:
     *     Sets a simple String value for the render parameter with the given name. Overrides
     *     the value of the render parameter if it already exists.
     *
     * name: String - The name of the render parameter. Must not be NULL.
     * value: String - The value of the render parameter that should be set. Must not be NULL. 
     */
        this.renderParameters.setValue(name, value);
        return value; // String
    },
    
    setParameterValues: function(/*String*/ name, /*String[]*/ values) {
    /**
     * summary:
     *     Sets a String[] representing the value of the render parameter with the given name.
     *     Overrides the value of the render parameter if it already exists.
     *
     * name: String - The name of the render parameter. Must not be NULL.
     * value: String[] - The value of the render parameter that should be set. Must not be NULL. 
     */
        this.renderParameters.setValues(name, values);
        return values; // String[]
    },
    
    setParameterMap:function(/*object[] {name: string, values: string[]}*/map, /*boolean*/replace) {
    /**
     * summary:
     *     Adds all render parameters that are contained in the given map. Overrides the values
     *     of parameters that already exist. Returns the resulting map.
     *
     * map: Object[] {name: String, values: String[]} - Two dimensional object array
     *     representing the map of parameters that should be added. Must not be NULL.
     * replace: boolean - Optional argument that indicates whether the given map should
     *     completely replace the existing parameter map.
     */
        // check if we need to delete the existing parameters
        if (replace == true) {
            this.renderParameters.clear();
        }
        this.renderParameters.putAll(map);
        return this.renderParameters.getMap(); /* object[] {name: string, values: string[]} */
    },
    
    removeParameter:function(/*String*/name) {
    /**
     * summary:
     *     Removes the render parameter with the given name.
     *
     * name: String - Name of the render parameter that should be removed. Must not be NULL.
     */
        this.renderParameters.remove(name);
    }
    
});







dojo.require( "com.ibm.portal.services.PortletFragmentService" );

dojo.declare("ibm.portal.portlet.XMLPortletRequest", null, {
     // summary: Provides XMLHttpRequest functionality for addressing portlets.
     // description: Wrappers and exposes all standard properties on an XMLHttpRequest, as well
     //         as, exposing an additional property called onportletstateready. This new property
     //         can be assigned a function that will be called when the portlet state is ready. If
     //         a handler is set for onportletstateready, the portlet state will not be updated 
     //         globally. The XMLPortletRequest will only work for URLs which point to the portlet
     //         fragment feed.
     // 
     // onportletstateready: Function - handler for intercepting global portlet state updates, the 
     //         PortletState object is the lone parameter passed into this function when called.
     // onreadystatechange: Function - handler for the readyState property changing
     // readyState: int - indicates the current state of the request
     // responseText: String - the text of the response body (only available when readyState == 4)
     // responseXML: XMLDocument - the xml document in the response body
     // status: int - the HTTP status code received in the response
     // statusText: String - the String corresponding to the HTTP status code
     // 
    onreadystatechange: null,     /*Function*/
    readyState: 0,            /* int */
    responseText: null,           /* String */
    responseXML: null,            /* Document */
    status: null,                 /* int */
    statusText: null,             /* String */
    onportletstateready: null,     /* Function(ibm.portal.portlet.PortletState) */
    _location: null,              /* String - stores the location of the request */
    _async: null,				  /* boolean - stores whether or not the request is asynchronous */
    
    constructor: function ( /*PortletWindow*/pWindow ) {
        // summary: Constructor for the XMLPortletRequest object. 
        // description: A correctly initialized instance of this object can be obtained from the portlet window object.  The only
        //      case where this constructor should be called directly is when sending an XPR to a different portlet than the
        //      one represented by the portletWindow object. 
        // page: the page's ObjectID
        // window: the porltet window's ObjectID
		var _method = this.declaredClass + ".constructor";
		ibm.portal.debug.entry( _method, [ pWindow ] )
		this.pageID = pWindow.pageID;
        this.windowID = pWindow.windowID;
        this.windowObj = pWindow;
        ibm.portal.debug.exit( _method );
    },
    _getXHR: function () {
         // summary: Creates the XMLHttpRequest object if necessary and returns it
         // returns: the XMLHttpRequest instance associated with this XMLPortletRequest
        var _method = this.declaredClass + "._getXHR";
        ibm.portal.debug.entry( _method );
    	if ( !this._xhr ) { 
            this._xhr = this._createXHR();
        }
        retVal.setRequestHeader("X-IBM-XHR","true");
    	ibm.portal.debug.exit( _method, this._xhr );
        return this._xhr; //XMLHttpRequest
    },
    _createXHR: function () {
        // summary: Cross-browser creation of XMLHttpRequest or it's equivalent.
        // returns: a new instance of an XMLHttpRequest or it's equivalent
    	var _method = this.declaredClass + "._createXHR";
        ibm.portal.debug.entry( _method );
    	var retVal = null;
        
        if ( typeof( XMLHttpRequest ) != "undefined" ) {
            retVal = new XMLHttpRequest();  
        }
        else {
            retVal = new ActiveXObject( "Microsoft.XMLHTTP" );
        }
        
        ibm.portal.debug.exit( _method, retVal );
        return retVal; //XMLHttpRequest
    },
    _onreadystatechangehandler: function () {
        // summary: Wrappers any user-set onreadystatechange handlers and processes the 
        //      response from the Portlet Fragment feed.
        // description: Intercepts the underlying XMLHttpRequest readyState changes and
        //      extracts the necessary information from the Portlet Fragment feed to 
        //      make the XMLPortletRequest object ready for consumption by the developer.
    	var _method = this.declaredClass + "._onreadystatechangehandler";
        ibm.portal.debug.entry( _method );
        
        if ( !this.handled ) {
        
	        var xhr = this._getXHR();
	        
	        //Copy over common properties that may have changed.
	        this.readyState = xhr.readyState;
	        
	        ibm.portal.debug.text( "ready state is " + xhr.readyState );
	        
	        //Extract the response portlet state and any dependent portlets. We check for the handled
	        //flag to ensure that we only process the response once. This is in case the behavior in 
	        //Mozilla changes for synchronous requests (In 2.x and 3.0.x (and 3.5?) the onreadystatechange handler is
	        //never fired for synchronous requests - so we have to call it manually - if the manual step
	        //is made unnecessary by the browser correcting the behavior, we don't want to process the result
	        //twice).
	        if ( this.readyState == 4 ) {
	        	var authRequired = this.windowObj.isAuthenticationRequired( xhr, "xml" );
	        	
	        	ibm.portal.debug.text( "is auth required: " + authRequired );
	        	
	        	if ( authRequired ) {
	        		this.windowObj.doAuthentication( xhr );
	        		return; 
	        	} else {
		            //Can't copy these common properties over until readyState is 4 because of IE
		            this.responseText = xhr.responseText;
		            this.responseXML = xhr.responseXML;
		            this.status = xhr.status;
		            this.statusText = xhr.statusText;
		            //Use our service object for convenience here. We're just using to parse the
		            //ATOM Feed response, not for actually retrieving any data because we need
		            //direct access to the XMLHttpRequest object in this use case.
		            var service = new com.ibm.portal.services.PortletFragmentService();
		            var portletInfo = service.createPortletInfo( xhr.responseXML );
		            this.responseText = portletInfo.markup;
		            //Will need to set this based on the atom:content type attribute, but since we
		            //aren't supporting any other markup types but HTML out of the box, this should
		            //never be set.
		            this.responseXML = null;
		            
		            var doGlobalStateUpdate = true;
		            var xmlState = portletInfo.updatedState;
		            
		            if ( this.onportletstateready != null ) {
		            	var windowId = portletInfo.windowId;
		                var portletState = new ibm.portal.portlet.PortletState( xmlState, windowId );
		                
		                //allow developer to handle portlet state
		                doGlobalStateUpdate = this.onportletstateready( portletState );
		            }
		            
		            if ( doGlobalStateUpdate && this._isCSA() )
		            {
		                //update global state
		                service._fireGlobalPortletStateChange( portletInfo );
		            } 
		            
		            this._handleDependentPortlets( service.readDependentPortlets( xhr.responseXML ), xmlState );
		            this.handled = true;
	        	}     
	            
	        }
	        
	        //Finally call the user's onreadystate change handler.
	        if ( this.onreadystatechange != null ) {
	            this.onreadystatechange();
	        }
        }
        
        ibm.portal.debug.exit( _method );
    },
    _handleDependentPortlets: function ( /*Array*/portlets, xmlState ) {
        // summary: Trigger reloads for all dependent portlets.
        // description: Reloads any portlets whose content has changed as a result of
        //      this XMLPortletRequest. This generally affects C2A portlets. If we are 
        //      not in Client-Side Aggregation, this will trigger a full page refresh.
    	var _method = this.declaredClass + "._handleDependentPortlets";
        ibm.portal.debug.entry( _method, [ portlets, xmlState ] );
    	
        if ( !this._isCSA() ) {
            if ( portlets.length > 0 ) {
                //Until we have Differential Page Rendering on the server side, we have no 
                //choice but to do a full page refresh, but we must point to the page
                //so the action isn't submitted twice and all portlets are rendered with fresh
                //parameters 
                
                window.location.href = this._newPageURL( xmlState );
            }   
        }
    	
    	ibm.portal.debug.exit( _method );
    },
    _isCSA: function () {
    	var _method = this.declaredClass + "._isCSA";
        ibm.portal.debug.entry( _method );
        
    	var retVal = false;
        try {
            retVal = (typeof(document.isCSA )!= "undefined" );
        }
        catch (e) {
            //do nothing here... something was not defined so we aren't in CSA
        }
        
        ibm.portal.debug.exit( _method, retVal );
        return retVal;
    },
    _flag: function ( /*String*/ uriToFlag ) {
        // summary: Flags a URL with the appropriate url parameters to retrieve a portlet fragment.
    	var _method = this.declaredClass + "._flag";
        ibm.portal.debug.entry( _method, [ uriToFlag ] );
        
    	var id = "lm:oid:" + this.windowID + "@oid:" + this.pageID;
        var service = new com.ibm.portal.services.PortletFragmentService();
        var url = service._flagPortletUrl( uriToFlag, id );
        
        ibm.portal.debug.exit( _method, url );
        return url;
    },
    _newPageURL: function ( xmlState ) {
        // summary: Creates a new page url based on the portlet window id and page id.
        // description: Creates a new page url to the page containing the portlet that 
        // originated this XMLPortletRequest object.
    	var _method = this.declaredClass + "._newPageURL";
        ibm.portal.debug.entry( _method, [ xmlState ] );
    	
        ibm.portal.debug.text( dojox.data.dom.innerXML( xmlState ) );
        
        // get a copy of the state which contains the state of our portlet only    
        var stateManager = new com.ibm.portal.state.StateManager(ibmPortalConfig["contentHandlerURI"]);
        var stateDOM = xmlState;
        if ( !xmlState ) {
        	stateDOM = dojox.data.dom.createDocument();
        }
        stateManager.reset( stateDOM );
            
        //var portletState = stateManager.newPortletAccessor( this.windowID ).getPortletState();
        
        //var selectionAcc = stateManager.newSelectionAccessor(portletState);
        //selectionAcc.setPageSelection(this.pageID);
        
        // serialize the state into a portal URL
        var serializationMgr = stateManager.getSerializationManager();
        var serializationResult = serializationMgr.serialize(stateDOM);
        
        // return the URL
        var serializedState = serializationResult["returnObject"];
        
        var url = serializedState; 
        
        ibm.portal.debug.exit( _method, url );
        return url; // String
    },
    open: function( /*String*/ method, /*String*/ uri ) {
        // @see XMLHttpRequest
    	var _method = this.declaredClass + ".open";
        ibm.portal.debug.entry( _method, [ method, uri ] );
    	
    	this.open( method, uri, false ); 
    	
    	ibm.portal.debug.exit( _method );
    },
    open: function( /*String*/ method, /*String*/ uri,  /*boolean*/ async ) {
        // @see XMLHttpRequest
    	var _method = this.declaredClass + ".open";
        ibm.portal.debug.entry( _method, [ method, uri, async ] );
    	
    	var xhr = this._getXHR();
        var me = this;
        this._location = uri;
        if ( async == undefined ) {
        	async = false;
        }
        this._async = async;
        xhr.onreadystatechange = function () { me._onreadystatechangehandler(); };
        xhr.open( method, this._flag(uri), async );
        
        ibm.portal.debug.exit( _method );
    },
    setRequestHeader: function( /*String*/ header, /*String*/ value ) {
        // @see XMLHttpRequest
    	var _method = this.declaredClass + ".setRequestHeader";
        ibm.portal.debug.entry( _method, [ header, value ] );
    	
    	this._getXHR().setRequestHeader( header, value );
    	
    	ibm.portal.debug.exit( _method );
    },
    send: function( /*String or Document*/ data ) {
        // @see XMLHttpRequest
    	var _method = this.declaredClass + ".send";
        ibm.portal.debug.entry( _method, [ data ] );
    	
    	this._getXHR().send( data );   
    	
    	//Mozilla handles synchronous XHRs differently - the readystatechange event is never dispatched. Call it manually,
    	//but check in the handler if this has already been called. The reason for using this solution is that once Mozilla
    	//fixes the behavior, we won't have to make any code changes to take advantage.
    	if ( !this._async ) {
    		this._onreadystatechangehandler();
    	}
    	
    	ibm.portal.debug.exit( _method );
    },
    abort: function( ) {
        // @see XMLHttpRequest
    	var _method = this.declaredClass + ".abort";
        ibm.portal.debug.entry( _method );
    	
    	this._getXHR().abort();
    	
    	ibm.portal.debug.exit( _method );
    },
    getAllResponseHeaders: function( ) {
        // @see XMLHttpRequest
        return this._getXHR().getAllResponseHeaders();
    },
    getResponseHeader: function( /*String*/ header ) {
        // @see XMLHttpRequest
        return this._getXHR().getResponseHeader( header );
    }

});

















dojo.declare("ibm.portal.portlet.UserProfile", null, {

    constructor: function (/*String*/ windowid,
                           /*XMLDocument */ data) {
    /**
     * summary:
     *     Objects of this type should never be called directly but always created
     *     through the PortletWindows method getUser.
     *
     * windowid: The window id
     */
        this.windowID = windowid;
        this.xmlData = data;

        this.ns = {
            "xsl" : "http://www.w3.org/1999/XSL/Transform",
            "atom" : "http://www.w3.org/2005/Atom",
            "xhtml" : "http://www.w3.org/1999/xhtml",
            "xsi" : "http://www.w3.org/2001/XMLSchema-instance",
            "um" : "http://www.ibm.com/xmlns/prod/websphere/um.xsd"
        };
    },

    getAttribute:function(/*String*/ name) {
    /**
     * summary:
     *     Returns the value of the given user attribute name as defined by the P3P Spec.
     * description:
     *     The portlet must define the user information attribute it is interested in
     *     inside the user-attribute section of the deployment descriptor. 
     *     If an attribute is not supported by the current runtime system or if it is supported
     *     but not defined for a particular user, then this method will return null
     * 
     * name: String - the name of the P3P attribute to return
     */
         var expr = "/atom:entry/atom:content/um:profile[@type='user']/um:attribute[@name='"+name+"']/um:attributeValue";
         //var expr = "/um:profile[@type='user']/um:attribute[@name='"+name+"']";
         
         var nodes = ibm.portal.xml.xpath.evaluateXPath(expr, this.xmlData, this.ns);         

         var result = null;
         if (nodes && nodes.length>0) {
             if (nodes[0].textContent) {
                 result = nodes[0].textContent;
             }
             else {
                 result = nodes[0].text;
             }
         }

         return result; /* String */

    },

    setAttribute:function(/*String*/ name, /*String*/ value) {
         var expr = "/atom:entry/atom:content/um:profile[@type='user']/um:attribute[@name='"+name+"']/um:attributeValue";
         //var expr = "/um:profile[@type='user']/um:attribute[@name='"+name+"']";
         
         var nodes = ibm.portal.xml.xpath.evaluateXPath(expr, this.xmlData, this.ns);         
         var previousText = null;
         if (nodes && nodes.length>0) {
             if (nodes[0].textContent) {
                 previousText = nodes[0].textContent;
                 nodes[0].textContent = value;
             }
             else {
                 previousText = nodes[0].text;
                 nodes[0].text = value;
             }
         }
         else {
             // TODO             
             var expr1 = "/atom:entry/atom:content/um:profile[@type='user']/um:attribute[@name='"+name+"']";
             var nodes1 = ibm.portal.xml.xpath.evaluateXPath(expr1, this.xmlData, this.ns);
             var attrNode = null;
             if (nodes1 && nodes1.length>0) {
                 attrNode = nodes1[0];
             }
             else {
                 var expr2 = "/atom:entry/atom:content/um:profile[@type='user']";
                 var nodes2 = ibm.portal.xml.xpath.evaluateXPath(expr2, this.xmlData, this.ns);
                 
                 if (dojo.isIE) {
                     attrNode = this.xmlData.createNode(1, "um:attribute", this.ns.um); // 1 = NODE_ELEMENT
                 }
                 else {
                     attrNode = this.xmlData.createElementNS(this.ns.um, "um:attribute");
                 }
                 attrNode.setAttribute("type","xs:string");
                 attrNode.setAttribute("multiValued","false");
                 attrNode.setAttribute("name",name);
                 nodes2[0].appendChild(attrNode);
             }
             var newNode;
             if (dojo.isIE) {
                 newNode = this.xmlData.createNode(1, "um:attributeValue", this.ns.um); // 1 = NODE_ELEMENT
                 newNode.text = value;
             }
             else {
                 newNode = this.xmlData.createElementNS(this.ns.um, "um:attributeValue");
                 newNode.textContent = value;
             }
             attrNode.appendChild(newNode);
         }

         return previousText;
    },

    clone:function()
    {
        var resultStr = dojox.data.dom.innerXML(this.xmlData);
        var xmlDataCopy = dojox.data.dom.createDocument( resultStr ); 

        return new ibm.portal.portlet.UserProfile(this.windowID,
                                                      xmlDataCopy);
    }
    
});







dojo.declare("ibm.portal.portlet.Error", null, {

    INFO: 0,
    WARN: 1,
    ERROR: 2,
    
    constructor: function (/*String*/ errorCode, /*String*/ message, /*String*/ description) {
        this.errorCode = errorCode;
        this.message = message;
        this.description = description;
    },
    
    getErrorCode: function() {
    /**
     * summary:
     *     Returns the error code
     */
        return this.errorCode;
    },
    
    getMessage: function() {
    /**
     * summary:
     *     Returns the message
     */
        return this.message;
    },
    
    getDescription: function() {
    /**
     * summary:
     *     Returns the description
     */
        return this.description;
    }

});


{ // create static initializers
var com_ibm_portal_portlet_portletwindow = new ibm.portal.portlet.PortletWindow();
ibm.portal.portlet.PortletWindow.STATUS_UNDEFINED = com_ibm_portal_portlet_portletwindow.STATUS_UNDEFINED;
ibm.portal.portlet.PortletWindow.STATUS_OK = com_ibm_portal_portlet_portletwindow.STATUS_OK;
ibm.portal.portlet.PortletWindow.STATUS_ERROR = com_ibm_portal_portlet_portletwindow.STATUS_ERROR;
com_ibm_portal_portlet_portletwindow = null;
var com_ibm_portal_portlet_portletmode = new ibm.portal.portlet.PortletMode();
ibm.portal.portlet.PortletMode.VIEW = com_ibm_portal_portlet_portletmode.VIEW;
ibm.portal.portlet.PortletMode.EDIT = com_ibm_portal_portlet_portletmode.EDIT;
ibm.portal.portlet.PortletMode.EDIT_DEFAULTS = com_ibm_portal_portlet_portletmode.EDIT_DEFAULTS;
ibm.portal.portlet.PortletMode.HELP = com_ibm_portal_portlet_portletmode.HELP;
ibm.portal.portlet.PortletMode.CONFIG = com_ibm_portal_portlet_portletmode.CONFIG;
com_ibm_portal_portlet_portletmode = null;
var com_ibm_portal_portlet_windowstate = new ibm.portal.portlet.WindowState();
ibm.portal.portlet.WindowState.NORMAL = com_ibm_portal_portlet_windowstate.NORMAL;
ibm.portal.portlet.WindowState.MINIMIZED = com_ibm_portal_portlet_windowstate.MINIMIZED;
ibm.portal.portlet.WindowState.MAXIMIZED = com_ibm_portal_portlet_windowstate.MAXIMIZED;
com_ibm_portal_portlet_windowstate = null;
var com_ibm_portal_portlet_error = new ibm.portal.portlet.Error();
ibm.portal.portlet.Error.INFO = com_ibm_portal_portlet_error.INFO;
ibm.portal.portlet.Error.WARN = com_ibm_portal_portlet_error.WARN;
ibm.portal.portlet.Error.ERROR = com_ibm_portal_portlet_error.ERROR;
com_ibm_portal_portlet_error = null;
}


}

if(!dojo._hasResource["com.ibm.domUtilities"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.domUtilities"] = true;
/*
 * @author Ben
 */
dojo.provide( "com.ibm.domUtilities" );
/*
 * This module provides cross-browser functions for interacting with a DOM object to
 * create nodes and get and set attributes that may or may not be namespaced.  Since
 * browsers use various functions for interacting with namespaced DOM nodes and attributes,
 * this module abstracts those away and provides a single layer for using those operations.
 */

dojo.require( "dojox.data.dom" );
dojo.require( "com.ibm.portal.xslt" );

com.ibm.domUtilities = {
	
	constants: {
		// MSXML_NodeTypes: Constants for defining integer values for node type strings
		MSXML_NodeTypes: {
			element: 1,
			attribute: 2,
			text: 3,
			cdata: 4,
			entity_reference: 5,
			entity: 6,
			processing_instruction: 7,
			comment: 8,
			document: 9,
			document_type: 10,
			document_fragment: 11,
			notation: 12
		}
	},
	
	nsInfo: function(/*String*/ str, /*Object*/ namespaces) {
		// summary: Extracts the namespace URI, prefix, and local name of a QName according to this
		//		object's namespaces map that includes known prefixes and their namespace URIs.  If
		//		the string is not namespaced, then the namespaceURI and prefix are set to null, and
		//		the localName is set to the str as-is.
		// str: QName to extract namespace from
		// namespaces: Map of namespaces where keys are namespace prefixes and values are the namespace URIs.
		// returns: Map - {namespaceURI: namespaceURI, prefix: prefix, localName: localName}
		var parts = str.split(":");
		var prefix, localName;
		if(parts.length > 1) {
			prefix = parts[0];
			localName = parts[1];
			return { namespaceURI: namespaces[prefix], prefix: prefix, localName: localName};
		}
		else {
			return { namespaceURI: null, prefix: null, localName: str};
		}
	},
	getAttribute: function(/*DOMNode*/ node, /*String*/ attrName, /*Object*/ namespaces) {
		// summary: Gets an attribute of the given node, supporting namespaced and 
		// 		non-namespaced attributes.
		// node: Node to retrieve the attribute value from
		// attrName: The name of the attribute to get from the node.
		//		If the attribute is namespaced, it will be split into its parts using the : delimiter
		//		and the namespace used during lookup will be the one keyed in the namespace map.
		// namespaces: Map of prefixes to namespaceURIs
		// returns: Object value of attribute
		var ret = null;
		var parts = com.ibm.domUtilities.nsInfo(attrName, namespaces);
		if(parts.namespaceURI) {
			if(node.getAttributeNS) {
				ret = node.getAttributeNS( parts.namespaceURI, parts.localName );
			}
			else if(dojo.isIE) {
				ret = node.attributes.getQualifiedItem( parts.localName, parts.namespaceURI );
				if(ret) ret = ret.value;
			}
			else ret = node.getAttribute( attrName );
		}
		else {
			ret = node.getAttribute( attrName );
		}
		return ret;
	},
	setAttribute: function(/*DOMNode*/ node, /*String*/ attrName, /*String*/ value, /*Object*/ namespaces) {
		// summary: Sets an attribute of the given node, supporting namespaced and 
		// 		non-namespaced attributes.
		// node: Node to set the attribute value on
		// attrName: The name of the attribute to set on the node.
		//		If the attribute is namespaced, it will be split into its parts using the : delimiter
		//		and the namespace used during lookup will be the one keyed in the namespace map.
		// value: The actual value to store in the node at the key attribute specified by attrName.
		// namespaces: Map of prefixes to namespaceURIs
		if(value === true) value = "true";
		else if(value === false) value = "false";
		var parts = com.ibm.domUtilities.nsInfo(attrName, namespaces);
		if(parts.namespaceURI) {
			if(node.setAttributeNS) {
				node.setAttributeNS( parts.namespaceURI, attrName, value );
			}
			else if(dojo.isIE && node.ownerDocument) {
				var attrNode = node.ownerDocument.createNode(com.ibm.domUtilities.constants.MSXML_NodeTypes.attribute, attrName, parts.namespaceURI);
				attrNode.value = value;
				node.setAttributeNode(attrNode);
			}
			else node.setAttribute( attrName, value );
		}
        else node.setAttribute( attrName, value );
	},
	removeAttribute: function(/*DOMNode*/ node, /*String*/ attrName, /*Object*/ namespaces) {
		// summary: Removes an attribute of the given node, supporting namespaced and 
		// 		non-namespaced attributes.
		// node: Node to remove the attribute from
		// attrName: The name of the attribute to remove from the node.
		//		If the attribute is namespaced, it will be split into its parts using the : delimiter
		//		and the namespace used during lookup will be the one keyed in the namespaces map.
		// namespaces: Map of prefixes to namespaceURIs
		var parts = com.ibm.domUtilities.nsInfo(attrName, namespaces);
		if(parts.namespaceURI) {
			if(node.removeAttributeNS) {
				// for some reason we have to use the localName when getting the attribute even
				// though we have to use the full name when setting it
				node.removeAttributeNS( parts.namespaceURI, attrName );
			}
			else if(dojo.isIE) {
				node.attributes.removeQualifiedItem( parts.localName, parts.namespaceURI );
			}
			else node.removeAttribute( attrName );
		}
        else node.removeAttribute( attrName );
	},
	hasAttribute: function(/*DOMNode*/ node, /*String*/ attrName, /*Object*/ namespaces) {
		// summary: Checks if an attribute of the given node exists, supporting namespaced and 
		// 		non-namespaced attributes.
		// node: Node to check for the existence of the attribute from
		// attrName: The name of the attribute to check from the node.
		//		If the attribute is namespaced, it will be split into its parts using the : delimiter
		//		and the namespace used during lookup will be the one keyed in this item or store's 
		// 		namespace map.
		// namespaces: Map of prefixes to namespaceURIs
		// returns: Boolean true if attribute exists, false otherwise
		var ret = null;
		var parts = com.ibm.domUtilities.nsInfo(attrName, namespaces);
		if(parts.namespaceURI) {
			if(node.hasAttributeNS) {
				ret = node.hasAttributeNS( parts.namespaceURI, parts.localName );
			}
			else if(dojo.isIE) {
				ret = node.attributes.getQualifiedItem( parts.localName, parts.namespaceURI ) != null;
			}
			else ret = node.hasAttribute( attrName );
		}
		else if(!dojo.isIE) ret = node.hasAttribute( attrName );
		else ret = node.getAttributeNode( attrName ) != null;
		
		return ret;	
	},
	createElement: function(/*DOMDoc*/ doc, /*String*/ tagName, /*Object*/ namespaces, /*Object?*/ attrMap) {
		// summary: Cross-browser implementation for creating a namespaced node using the namespace
		//		map in this object to resolve prefixes to namespace URIs.
		//		If the tagName is not namespaced or a namespace URI cannot be resolved
		// 		using this object's namespaces map, a non-namespaced element will be created instead.
		// doc: DOMDoc document object to use to create the DOM node.
		// tagName: String name for the tag name of the element to create.  
		// 		Can be namespaced like prefix:localName or not like localName.
		// namespaces: Map of namespaces where keys are namespace prefixes and values are the namespace URIs.
		// attrMap: Optional argument specifying a key-value map of attributes to be
		// 		set on the node before returning it. 
		// returns: DOMNode A new DOM node that was created by doc
		var node = null;
		var parts = com.ibm.domUtilities.nsInfo(tagName, namespaces);
		if(parts.namespaceURI) {
			if(doc.createElementNS) {
				// W3C standard way of creating namespaced elements
				node = doc.createElementNS(parts.namespaceURI, tagName);
			}
			else if(dojo.isIE) {
				// we have to check dojo.isIE because IE throws an error when trying to check for
				// the existence of particular methods on the document object
				
				// this is IE's way of creating a namespaced node
				// use the tagName since it already includes the prefix as well
				node = doc.createNode("element", tagName, parts.namespaceURI);
			}
		}
		// if we don't have a node at this point, just create it without a namespace
		if(!node) node = doc.createElement(tagName);
		
		for(var name in attrMap) {
			com.ibm.domUtilities.setAttribute(node, name, attrMap[name], namespaces);
		}
		
		return node;
	},
	createFromJson: function(/*DOMDoc*/ doc, /*Object*/ def, /*Object*/ namespaces, /*DOMNode?*/ parentNode) {
		var obj = null;
		if(dojo.isString(def)){
			obj =  doc.createTextNode(def);
		}
		else {
			obj = com.ibm.domUtilities.createElement(doc, def.name, namespaces, def.attributes);
			dojo.forEach(def.children, function(childDef) {
				com.ibm.domUtilities.createFromJson(doc, childDef, namespaces, obj);
			});
		}
		
		if(parentNode) parentNode.appendChild(obj);
		return obj;
	},
	removeChildren: function(node) {
		while(node.hasChildNodes()) {
			var f = node.removeChild(node.firstChild);
			delete f;
		}
	},
	textContent: function(/*DOMNode*/ node, /*String?*/ text) {
		return dojox.data.dom.textContent.apply(null, arguments);
	},
	innerXML: function(/*DOMNode*/ node) {
		return dojox.data.dom.innerXML(node);
	},
	stringFromDoc: function(/*DOMNode*/ node) {
		return com.ibm.domUtilities.innerXML(node);
	},
	docFromString: function(/*String*/ str) {
		return com.ibm.portal.xslt.loadXmlString(str);
	},
	encodeXML: function(/*String*/ xmlStr, /*Boolean?*/ encodeQuotes) {
		// summary: Encodes a string for inclusion into an XML document so that any XML delimiters will
		//		be encoded as CDATA.
		if(dojo.isString(xmlStr)) {
			xmlStr = xmlStr.replace(/&/gm, "&amp;").replace(/</gm, "&lt;").replace(/>/gm, "&gt;");
			if(encodeQuotes) xmlStr = xmlStr.replace(/'/gm, "&#039;").replace(/"/gm, "&#034;");
			return xmlStr;
		}
		else if(xmlStr != null) return xmlStr;
		else return "";
	},
	decodeXML: function(/*String*/ xmlStr, /*Boolean?*/ decodeQuotes) {
		if(dojo.isString(xmlStr)) {
			xmlStr = xmlStr.replace(/&lt;/gm, "<").replace(/&gt;/gm, ">").replace(/&amp;/gm, "&");
			if(decodeQuotes) xmlStr = xmlStr.replace(/&#039;/gm, "\'").replace(/&#034;/gm, "\"");
			return xmlStr;
		}
		else if(xmlStr != null) return xmlStr;
		else return "";
	}
}

}

if(!dojo._hasResource["com.ibm.data.XpathHelper"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.data.XpathHelper"] = true;
dojo.provide( "com.ibm.data.XpathHelper" );
// summary: This module is meant to be extended by modules that want to use XPath
//		to query DOM documents for information.  It provides read support and limited 
// 		write support.  Write support is limited in that if an xpath query is used to
//		set a node, property of a node, or DOM attribute of a node, then the write support
//		will only work if a node that matches that query already exists and is returned.
//		If no node matches the query and the Xpath query returns null, the all write operations
//		provided by this module will return false to indicate that the caller needs to handle
//		them in a different way like creating the node from scratch.
//
//		This module provides cross-browser methods for reading and writing to DOM nodes,
//		properties of DOM nodes, and DOM attributes of DOM nodes.  It also supports extensions
//		so that special constructs can be returned by a query instead of a DOM node or String value
//		of a property or attribute.  By default, no constructs are defined by this module.


dojo.require( "com.ibm.portal.xpath" );
dojo.require( "com.ibm.portal.xslt" );
dojo.require( "com.ibm.domUtilities" );

dojo.declare( "com.ibm.data.XpathHelper",
			null,
			{
				// namespaces: A map of prefix - namespace URI pairs used to specify what namespaces
				//		are used by this XpathHelper to query nodes in a DOM document
				namespaces: {},
				
				_getNodesByXpath: function(/*Object*/ context, /*String*/expr, /*String?*/prop) {
					// summary: Gets an array of DOM nodes or String node properties using the XPath expr relative 
					// 		to the context (not relative to the document root itself).  Returns an object allowing
					//		the caller to determine if the actual value requested is null or if there were no nodes
					//		found at all.
					// context: The XML element to use as the root context for the XPath query
					// expr: XPath expression used to find the nodes
					// prop: Optional prop to specify to get a property of the nodes instead of the nodes themselves.
					// returns: Object with two properties:
					//		-	{
					//		-		found: Boolean indicating if any nodes were found matching the XPath expression
					//		-		value: Array the actual nodes found by the expression, or the properties of the nodes
					// 		-			found by the expression as specified by the prop argument
					// 		-	} 
					var results = com.ibm.portal.xpath.evaluateXPath(expr, context, this.namespaces);
					var found = results && results.length > 0;
					if(prop) {
						var nodes = results;
						results = new Array();
						for(var i = 0; i < nodes.length; i++) {
							results[i] = this._getNodeProp(nodes[i], prop);
						}
					}
					return {found: found, value: results};
				},
				_getNodeByXpath: function(/*Object*/ context, /*String*/expr, /*String?*/ prop) {
					// summary: Gets a node using the XPath expr relative to 
					// 		the context	(not relative to the document root itself).  Returns an object allowing
					//		the caller to determine if the actual value requested is null or if there were no nodes
					//		found at all.
					// context: The XML element to use as the root context for the XPath query
					// expr: XPath expression used to find the node
					// prop: Optional prop to specify to get an property of the node instead of the node itself.
					// returns: Object with two properties:
					//		-	{
					//		-		found: Boolean indicating if any nodes were found matching the XPath expression
					//		-		value: DOMNode|Object the first node found by the expression, or the property of the first
					// 		-			node found by the expression as specified by the prop argument
					// 		-	}
					var result = this._getNodesByXpath(context, expr);
					var found = result.found;
					if(!found) return {found: found};
					var nodes = result.value;
					if(nodes.length > 0) {
						if(prop) return {found: true, value: this._getNodeProp(nodes[0], prop)};
						else return {found: true, value: nodes[0]};
					}
					return {found: false};
				},
				_getNodeProp: function(/*DOMNode*/ node, /*String*/ prop) {
					// summary:  Function to provide cross-browser support for properties of a queried
					//		node.  If the prop string is not special, control will be passed to the 
					//		handleConstructs function for this object.
					//		Currently only supports textContent as a special property since not
					//		all browsers implement the textContent property of DOM nodes.
					switch(prop) {
						case "textContent":
							return dojox.data.dom.textContent(node);
						default:
							return this.handleConstructs(node, prop);
					}
				},
				handleConstructs: function(/*DOMNode*/ node, /*String*/ prop) {
					// summary: Allows a data store to return complex javascript objects
					//		or alternative values when a specific non-standard property of a node 
					// 		is requested.  Example: An Atom Feed data store may create a special 
					// 		Person Construct when querying an <atom:author> element.  This construct
					//		may provide accessor functions to the name, email, and URI of the author.
					//		See http://tools.ietf.org/html/rfc4287#section-3.2
					//		Constructs that are created here should implement and handle write functionality
					//		themselves as this module will not handle writes to constructs natively.
					
					return node[prop];
				},
				_setNodeProp: function(/*DOMNode*/ node, /*String*/ prop, /*Object*/ value) {
					// summary: Allows a data store to set properties of a node in a cross-browser
					//		way for properties that may be non-standard.
					//		Currently only supports textContent as a special property since not
					//		all browsers implement the textContent property of DOM nodes.
					//		Note that for special constructs that are created using the handleConstructs
					// 		function, write support is handled by the returned construct object not by
					//		this module's functions.
					switch(prop) {
						case "textContent":
							dojox.data.dom.textContent(node, value);
						default:
							node[prop] = value;
					}
				},
				_getAttrsByXpath: function(/*Object*/ context, /*String*/ expr, /*String*/attrName) {
					// summary: Gets an array of attribute values for the nodes returned 
					// 		using the XPath expr relative to the context (not relative to the 
					// 		document root itself).  The attributes are retrieved using the 
					// 		getAttributeNS/getAttribute	functions of the nodes.  Returns an object allowing
					//		the caller to determine if the actual value requested is null or if there were no nodes
					//		found at all.
					// context: The XML element to use as the root context for the XPath query
					// expr: XPath expression used to find the nodes
					// attrName: The name of the attribute to get from each node returned by the XPath expr.
					//		If the attribute is namespaced, it will be split into its parts using the : delimiter
					//		and the namespace used during lookup will be the one keyed in this item or store's 
					// 		namespace map.
					// returns: Object with two properties:
					//		-	{
					//		-		found: Boolean indicating if any nodes were found matching the XPath expression
					//		-		value: Array the attribute values of the nodes found by the expression
					// 		-	}
					var result = this._getNodesByXpath(context, expr);
					var found = result.found;
					if(!found) return {found: found};
					var nodes = result.value;
					var attrs = [];
					for(var i = 0; i < nodes.length; i++) {
						attrs[i] = this._getAttribute(nodes[i], attrName);
					}
                    return {found: found, value: attrs};
				},
				_getAttrByXpath: function(/*Object*/ context, /*String*/expr, /*String*/ attrName) {
					// summary: Gets the attribute value of the first node returned 
					// 		using the XPath expr relative to the context (not relative to the 
					// 		document root itself).  The attribute is retrieved using the 
					// 		getAttributeNS/getAttribute	functions of the node.  Returns an object allowing
					//		the caller to determine if the actual value requested is null or if there were no nodes
					//		found at all.
					// context: The XML element to use as the root context for the XPath query
					// expr: XPath expression used to find the node
					// attrName: The name of the attribute to get from the node returned by the XPath expr.
					//		If the attribute is namespaced, it will be split into its parts using the : delimiter
					//		and the namespace used during lookup will be the one keyed in this item or store's 
					// 		namespace map.
					// returns: Object with two properties:
					//		-	{
					//		-		found: Boolean indicating if any nodes were found matching the XPath expression
					//		-		value: Array the attribute value of the first node found by the expression
					// 		-	}
					var result = this._getNodeByXpath(context, expr);
					var found = result.found;
					if(!found) return {found: found}; 
					var node = result.value;
                    return {found: found, value: this._getAttribute(node, attrName)};
				},
				_extractNSInfo: function(str) {
					// summary: Extracts the namespace URI, prefix, and local name of a QName according to this
					//		object's namespaces map that includes known prefixes and their namespace URIs.  If
					//		the string is not namespaced, then the namespaceURI and prefix are set to null, and
					//		the localName is set to the str as-is.
					// str: QName to extract namespace from
					// returns: Map - {namespaceURI: namespaceURI, prefix: prefix, localName: localName}
					return com.ibm.domUtilities.nsInfo(str, this.namespaces);
				},
				_getAttribute: function(/*DOMNode*/ node, /*String*/ attrName) {
					// summary: Gets an attribute of the given node, supporting namespaced and 
					// 		non-namespaced attributes.
					// node: Node to retrieve the attribute value from
					// attrName: The name of the attribute to get from the node.
					//		If the attribute is namespaced, it will be split into its parts using the : delimiter
					//		and the namespace used during lookup will be the one keyed in this item or store's 
					// 		namespace map.
					return com.ibm.domUtilities.getAttribute(node, attrName, this.namespaces);
				},
				_setAttribute: function(/*DOMNode*/ node, /*String*/ attrName, /*String*/ value) {
					// summary: Sets an attribute of the given node, supporting namespaced and 
					// 		non-namespaced attributes.
					// node: Node to set the attribute value on
					// attrName: The name of the attribute to set on the node.
					//		If the attribute is namespaced, it will be split into its parts using the : delimiter
					//		and the namespace used during lookup will be the one keyed in this item or store's 
					// 		namespace map.
					// value: The actual value to store in the node at the key attribute specified by attrName.
					if(value) com.ibm.domUtilities.setAttribute(node, attrName, value, this.namespaces);
					else com.ibm.domUtilities.removeAttribute(node, attrName, this.namespaces);
				},
				_setNodesByXpath: function(/*Object*/ context, /*String*/expr, /*String*/ prop, /*Array*/values) {
					// Empty for now since there's little use for this type of function, particularly due to 
					// mismatches between the number of values and number of returned nodes.
					//var nodes = this._getNodesByXpath(context, expr);
					
					return false;
				},
				_setNodeByXpath: function(/*Object*/ context, /*String*/expr, /*String*/ prop, /*Object*/value) {
					// summary: Will replace a node returned by the xpath expr query with the value object
					// 		if prop is null.  If prop exists, the specified property on the returned node
					// 		will be set to the value.
					// 		If no node is found that matches the xpath expr, this function returns false to indicate
					//		failure to the caller for further processing if necessary.
					// context: The DOM element to use as the root context for the XPath query
					// expr: XPath expression used to find the node
					// prop: Optional prop to specify to set a property of the node instead of the node itself.
					// returns: true if the set operation was successful, false otherwise
					var result = this._getNodeByXpath(context, expr);
					var found = result.found;
					if(!found) return false; 
					var node = result.value;
					if(prop) {
						this._setNodeProp(node, prop, value);
					}
					else {
						dojo.place(value, node, "before");
						node.parentNode.removeChild(node);
						delete node;
					}
					return true;
				},
				_setAttrsByXpath: function(/*Object*/ context, /*String*/expr, /*String*/ attrName, /*Array*/values) {
					// Empty for now since there's little use for this type of function, particularly due to 
					// mismatches between the number of values and number of returned nodes.
					//var nodes = this._getNodesByXpath(context, expr);
					
					return false;
				},
				_setAttrByXpath: function(/*Object*/ context, /*String*/expr, /*String*/ attrName, /*String*/value) {
					// summary: The specified DOM attribute on the returned node will be set to the value.
					// 		If no node is found that matches the xpath expr, this function returns false to indicate
					//		failure to the caller for further processing if necessary.
					// context: The DOM element to use as the root context for the XPath query
					// expr: XPath expression used to find the node
					// attrName: The name of the attribute to get from the node returned by the XPath expr.
					//		If the attribute is namespaced, it will be split into its parts using the : delimiter
					//		and the namespace used during lookup will be the one keyed in this item or store's 
					// 		namespace map.
					// returns: true if the set operation was successful, false otherwise
					var result = this._getNodeByXpath(context, expr);
					var found = result.found;
					if(!found) return false;
					var node = result.value;
					this._setAttribute(node, attrName, value);
					return true;
				},
				_createNSElement: function(doc, tagName, attrMap) {
					// summary: Cross-browser implementation for creating a namespaced node using the namespace
					//		map in this object to resolve prefixes to namespace URIs.
					//		If the tagName is not namespaced or a namespace URI cannot be resolved
					// 		using this object's namespaces map, a non-namespaced element will be created instead.
					// doc: DOMDoc document object to use to create the DOM node.
					// tagName: String name for the tag name of the element to create.  
					// 		Can be namespaced like prefix:localName or not like localName.
					// attrMap: Optional argument specifying a key-value map of attributes to be
					// 		set on the node before returning it. 
					// returns: DOMNode A new DOM node that was created by doc
					return com.ibm.domUtilities.createElement(doc, tagName, this.namespaces, attrMap);
				},
				__getClassName: function() {
					var cls = this.declaredClass;
					if(!cls) return "Object";
					var idx = cls.lastIndexOf(".");
					if(idx > -1 && (idx < cls.length - 1)) cls = cls.substring(idx + 1);
					return cls;
				}
			}
);

dojo.declare( "com.ibm.data._XmlConstruct",
			com.ibm.data.XpathHelper,
			{
				// summary: Provides a base construct for modules to extend when building constructs
				//		to be returned by queries using this module's APIs.
				isConstruct: true,
				toString: function() {
					// summary: Default toString method for this object so that it can be inserted
					//		in a string and be properly represented.  Overridable by extensions of this
					//		module.
					return "<"   + this.__getClassName() + ">";
				}
			}
);


}

if(!dojo._hasResource["com.ibm.data.AtomFeedStore"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.data.AtomFeedStore"] = true;
dojo.provide( "com.ibm.data.AtomFeedStore" );

dojo.require( "com.ibm.data.XpathHelper" );
dojo.require( "dojo.date.stamp" );

dojo.declare( "com.ibm.data.AtomFeedStore",
			com.ibm.data.XpathHelper,
			{
				// namespaces: Map
				//		Map of namespaces used by the ATOM feeds
				namespaces: {
		            "atom" : "http://www.w3.org/2005/Atom"
		        },
		        // _features: Map
				//		Map of features that this store supports.
				//		This generic AtomFeedStore only supports Read and Identity.
				_features: {
					'dojo.data.api.Read': true,
					'dojo.data.api.Write': false,
					'dojo.data.api.Identity': false,
					'dojo.data.api.Notification': false
				},
				attrMappings: {
					title: {xpath: "./atom:title", targetName: "textContent", type: "node", setter: 
						function(item, rule, value){
							var elem = this._createNSElement(item.element.ownerDocument, "atom:title");
							this._setNodeProp(elem, rule.targetName, value);
							item.element.appendChild(elem);
							return true;
						}
					},
					id: {xpath: "./atom:id", targetName: "textContent", type: "node", setter: 
						function(item, rule, value){
							var elem = this._createNSElement(item.element.ownerDocument, "atom:id");
							this._setNodeProp(elem, rule.targetName, value);
							item.element.appendChild(elem);
							return true;
						}
					},
					updated: {xpath: "./atom:updated", targetName: "AtomDateConstruct", type: "node"},
					category: {xpath: "./atom:category", targetName: "term", type: "attr", setter: 
						function(item, rule, value){
							var elem = this._createNSElement(item.element.ownerDocument, "atom:category");
							this._setAttribute(elem, rule.targetName, value);
							item.element.appendChild(elem);
							return true;
						}
					},
					categoryScheme: {xpath: "./atom:category", targetName: "scheme", type: "attr", setter: 
						function(item, rule, value){
							var elem = this._createNSElement(item.element.ownerDocument, "atom:category");
							this._setAttribute(elem, rule.targetName, value);
							item.element.appendChild(elem);
							return true;
						}
					},
					categoryLabel: {xpath: "./atom:category", targetName: "label", type: "attr", setter: 
						function(item, rule, value){
							var elem = this._createNSElement(item.element.ownerDocument, "atom:category");
							this._setAttribute(elem, rule.targetName, value);
							item.element.appendChild(elem);
							return true;
						}
					},
					contributer: {xpath: "./atom:contributer", targetName: "AtomPersonConstruct", type: "node"},
					author: {xpath: "./atom:author", targetName: "AtomPersonConstruct", type: "node"},
					summary: {xpath: "./atom:summary", targetName: "textContent", type: "node", setter: 
						function(item, rule, value){
							var elem = this._createNSElement(item.element.ownerDocument, "atom:summary");
							this._setNodeProp(elem, rule.targetName, value);
							item.element.appendChild(elem);
							return true;
						}
					},
					source: {xpath: "./atom:source", type: "node", setter: 
						function(item, rule, value){
							item.element.appendChild(value);
							return true;
						}
					},
					rights: {xpath: "./atom:rights", targetName: "textContent", type: "node", setter: 
						function(item, rule, value){
							var elem = this._createNSElement(item.element.ownerDocument, "atom:rights");
							this._setNodeProp(elem, rule.targetName, value);
							item.element.appendChild(elem);
							return true;
						}
					},
					selfLink: {xpath: "./atom:link[@rel='self']", targetName: "href", type: "attr", setter: 
						function(item, rule, value){
							var elem = this._createNSElement(item.element.ownerDocument, "atom:link");
							this._setAttribute(elem, "rel", "self");
							this._setAttribute(elem, rule.targetName, value);
							item.element.appendChild(elem);
							return true;
						}
					},
					link: {xpath: "./atom:link[@href]", targetName: "href", type: "attr", setter: 
						function(item, rule, value){
							var elem = this._createNSElement(item.element.ownerDocument, "atom:link");
							this._setAttribute(elem, rule.targetName, value);
							item.element.appendChild(elem);
							return true;
						}
					},
					content: {xpath: "./atom:content", type: "node", setter: 
						function(item, rule, value){
							item.element.appendChild(value);
							return true;
						}
					}
				},
				
				// timeout: Number milliseconds to wait for a response for any request
				//		sent by this data store.
				timeout: null,
				
				// itemClass: String the class used to represent items of this store
				itemClass: "com.ibm.data.AtomEntryItem",
								
				constructor: function( /*Map*/ args ) {
					// summary: Creates a new instance of a com.ibm.data.AtomFeedStore
					// args: Map
					//		The args map will be used to replace any default values of this store with the
					//		values specified in the args map.
					dojo.mixin(this, args);
					this._dirtyItems = new Array();
					this._deletedItems = new Array();
					this._newItems = new Array();
				},
				toString: function() {
					return "<" + this.__getClassName() + ": " + this.url + ">";
				},
				handleConstructs: function(/*DOMNode*/ node, /*String*/ prop) {
					switch(prop) {
						case "AtomPersonConstruct": return new com.ibm.data.AtomPersonConstruct(node);
						case "AtomDateConstruct": return new com.ibm.data.AtomDateConstruct(node);
						default: return this.inherited(arguments);
					}
				},
				
				_assertIsItem: function(/*Object*/ something) {
					// summary: Throws an exception if the argument is not a valid item in this store.
					// something: Object to check to determine if it is an item in this store.
					if(!this.isItem(something)) throw new Error(something + " is not an item in this store");
					return true;
				},
				_assertIsString: function(/*Object*/ something) {
					// summary: Throws an exception if the argument is not a string.
					// something: Object to check to determine if it is a string.
					if(!dojo.isString(something)) throw new Error(something + " is not a string");
					return true;
				},
				_getItem: function(args) {
					// summary: Overridable function to create a new item in this store based on the args map.
					var cls = this.itemClass;
					if(dojo.isString(cls)) {
						cls = dojo.getObject(this.itemClass);
					}
					return new cls({store: this, element: args.element, loaded: true}); 
				},
				/********************************/
				/**                            **/
				/**                            **/
				/**    		 Public  		   **/
				/**                            **/
				/**                            **/
				/********************************/
								
				getFeedValue: function( /*String*/ attribute, /*Value?*/ defaultValue) {
					var ret = defaultValue;
					this._assertIsString(attribute);
					var mapRule = this.getMapRule(attribute, this.attrMappings);
					// if mapRule is null here, then we couldn't find one in the map, 
					// so we can't proceed successfully
					if(mapRule) {
						ret = this.getValueByMapping(null, mapRule, defaultValue);
					}
					
					return ret;
				},
				getFeedValues: function( /*String*/ attribute) {
					var ret = [];
					this._assertIsString(attribute);
					var mapRule = this.getMapRule(attribute, this.attrMappings);
					// if mapRule is null here, then we couldn't find one in the map, 
					// so we can't proceed successfully
					if(mapRule) {
						ret = this.getValuesByMapping(null, mapRule);
					}
					
					return ret;
				},
				extractEmptyFeed: function() {
					var toClone = this._getNodeByXpath(this._feed, "//atom:feed").value;
					var feedDOM = toClone.cloneNode(false);
					// get all non-entry nodes
					var result = this._getNodesByXpath(toClone, "/atom:feed/*");
					var nodes = result.value;
					for(var i = 0; i < nodes.length; i++) {
						if(nodes[i].nodeName != "atom:entry") {
							feedDOM.appendChild(nodes[i].cloneNode(true));
						}
					}
					return feedDOM;
				},
				extractSingleEntryFeed: function(/* com.ibm.data.AtomEntryItem */ item ) {
					var ret = this.extractEmptyFeed();
					ret.appendChild(item.element.cloneNode(true));
					return ret;
				},
				extractMultipleEntryFeed: function(/* Array */ items ) {
					var ret = this.extractEmptyFeed();
					dojo.forEach(items, function(item){
						ret.appendChild(item.element.cloneNode(true));
					});
					return ret;
				},
				
				/********************************/
				/**                            **/
				/**                            **/
				/**   dojo.data.api.Identity   **/
				/**                            **/
				/**                            **/
				/********************************/				
				getIdentity: function(/* item */ item) {
					// summary: See dojo.data.api.Identity.getIdentity()
					// returns: The entry's unique identifier
					if(item._id) return item._id;
					// this is a common operation... so cache this on the item itself
					var attrs = this.getIdentityAttributes(item);
					var id = "";
					dojo.forEach(attrs, function(attr){
						id += this.getValue(item, attr, "");
					}, this);
					item._id = id;
					return id;
				},
				
				getIdentityAttributes: function(/* item */ item){
					//	summary:
					//		Returns an array of attribute names that are used to generate the identity. 
					//		For most stores, this is a single attribute, but for some complex stores
					//		such as RDB backed stores that use compound (multi-attribute) identifiers
					//		it can be more than one.  If the identity is not composed of attributes
					//		on the item, it will return null.  This function is intended to identify
					//		the attributes that comprise the identity so that so that during a render
					//		of all attributes, the UI can hide the the identity information if it 
					//		chooses.
					//	item:
					//		The item from the store from which to obtain the array of public attributes that 
					//		compose the identifier, if any.
					return ['id']; // Array
				},
			
				fetchItemByIdentity: function(/* object */ keywordArgs){
					//	summary:
					//		Given the identity of an item, this method returns the item that has 
					//		that identity through the onItem callback.  Conforming implementations 
					//		should return null if there is no item with the given identity.  
					//		Implementations of fetchItemByIdentity() may sometimes return an item 
					//		from a local cache and may sometimes fetch an item from a remote server, 
					//
					// 	keywordArgs:
					//		An anonymous object that defines the item to locate and callbacks to invoke when the 
					//		item has been located and load has completed.  The format of the object is as follows:
					//		{
					//			identity: string|object,
					//			onItem: Function,
					//			onError: Function,
					//			scope: object
					//		}
					//	The *identity* parameter.
					//		The identity parameter is the identity of the item you wish to locate and load
					//		This attribute is required.  It should be a string or an object that toString() 
					//		can be called on.
					//		
					//	The *onItem* parameter.
					//		Function(item)
					//		The onItem parameter is the callback to invoke when the item has been loaded.  It takes only one
					//		parameter, the item located, or null if none found.
					//
					//	The *onError* parameter.
					//		Function(error)
					//		The onError parameter is the callback to invoke when the item load encountered an error.  It takes only one
					//		parameter, the error object
					//
					//	The *scope* parameter.
					//		If a scope object is provided, all of the callback functions (onItem, 
					//		onError, etc) will be invoked in the context of the scope object.
					//		In the body of the callback function, the value of the "this"
					//		keyword will be the scope object.   If no scope object is provided,
					//		the callback functions will be called in the context of dojo.global.
					//		For example, onItem.call(scope, item, request) vs. 
					//		onItem.call(dojo.global, item, request)
					
					
					// not implemented by the AtomFeedStore since this supports generic Atom Feeds and therefore
					// can't generate a URL to get a particular item by its identity without additional knowledge
					// of how the feed URLs are created... however, this can be overridden by a application consuming
					// an instance of this store that does have knowledge of the particular feed URLs
					return false;
				},
				/********************************/
				/**                            **/
				/**                            **/
				/**     dojo.data.api.Read     **/
				/**                            **/
				/**                            **/
				/********************************/
				getValue: function(	/* com.ibm.data.AtomEntryItem */ item, 
						/* String */ attribute, 
						/* Value? */ defaultValue){
					var ret = null;
					if(this.hasAttribute(item, attribute)) {
						var mapRule = this.getMapRule(attribute, item.attrMappings);
						// if mapRule is null here, then we couldn't find one in the map, 
						// so we return the defaultValue 
						if(!mapRule) return ret;
						ret = this.getValueByMapping(item, mapRule, defaultValue);
					}
					if(!ret) ret = defaultValue;
					return ret;
				},
				
				getValues: function(/* com.ibm.data.AtomEntryItem */ item,
						/* String */ attribute){
					if(this.hasAttribute(item, attribute)) {
						var mapRule = this.getMapRule(attribute, item.attrMappings);
						// if mapRule is null here, then we couldn't find one in the map, 
						// so we return an empty list
						if(!mapRule) return [];
						return this.getValuesByMapping(item, mapRule);
					}
					return [];
				},
				_extractParameterizedMapKey: function( /*String*/ mapKey ) {
					// summary: Expands a mapKey and determines if it is a key to a parameterizable map rule.
					//		If it is, extract the parameters from the argument and return the base key name
					//		used to look up the correct map rule in this object's attrMappings without the parameter
					// 		values, and also return the parameters as an array of strings.  
					// 		If the mapKey is not the key of a parameterizable map rule, just return the key and a 
					// 		null parameter array.
					// returns: Object {key: stringMapKey, parameters: arrayOfParameterValues}
					if(mapKey.charAt(mapKey.length - 1) == '$') {
						var start = mapKey.indexOf('[');
						var end = mapKey.lastIndexOf(']');
						if(start > -1 && end > start) {
							var baseName = mapKey.substring(0, start) + "$";
							var parms = mapKey.substring(start + 1, end).split(',');
							return {key: baseName, parameters: parms};
						}
					}
					return {key: mapKey, parameters: null};
				},
				
				getMapRule: function( /*String*/ mapKey, /*Object*/map, /*Boolean?*/ multiValued ) {
					// summary: Takes a mapKey string that ends in '$' to key into this object's 
					// 		attrMappings, and then parameterizes the map it finds according
					// 		to the parameters found within the '[...]' block of the mapKey.
					// 		Example: A mapKey of 'localizedName[edward, tj]$' would lookup
					// 			the key 'localizedName$' in this.attrMappings.
					// 			The resulting map rule would be used as a template for the returned
					//			map rule.  The parameters used to parameterize the template would
					//			be ['edward', 'tj'] and would match the ${0} and ${1} parameters
					//			in the map rule respectively.
					// returns: The map rule specified by this mapKey after all parameters have been
					//			bound to their values as specified by the caller.
					var obj = this._extractParameterizedMapKey(mapKey);
					var rule = map[obj.key];
					
					if(!rule) return rule;
					// if this is not a parameterized map rule, just return the map rule as-is
					if(!obj.parameters) {
						rule._ruleKey = obj.key;
						return rule;
					}
					
					// otherwise, parameterize the map by using the array of parameters passed into the attribute
					// like this ->  attribute[parm1, parm2, parm3]$
					// parameterized attributes always end with $
					var expRule = new Object();
					for(var prop in rule) {
						if(dojo.isString(rule[prop])) {
							expRule[prop] = dojo.string.substitute(rule[prop], obj.parameters, function(part){
								return dojo.string.trim(part);
							});
						}
						else {
							expRule[prop] = rule[prop];
						}
					}
					expRule._parameters = obj.parameters;
					expRule._ruleKey = obj.key;
					expRule.multiValued = !!multiValued;
					return expRule;
				},
				
				getValuesByMapping: function( /* com.ibm.data.AtomEntryItem */ item, 
						/* Object */ mapping){
					// summary: Executes the correct query API using the mapping argument to
					//		retrieve the desired attribute value for the item as specified by the 
					// 		mapping.
					// mapping: A mapping object from this object's attrMappings
					var ret = null;
					var xpath = mapping.xpath;
					var type = mapping.type;
					var targetName = mapping.targetName;
					var context = this._feed;
					if(item) {
						this._assertIsItem(item);
						context = item.element;
					}
					if(type == "attr") {
						ret = this._getAttrsByXpath(context, xpath, targetName);
					}
					else {
						ret = this._getNodesByXpath(context, xpath, targetName);
					}
					
					if(!ret.found && item._backup) {
						// we didn't find any nodes matching the xpath query, and
						// this item has been copied from its original for modification,
						// so perhaps we explicitly removed it in the modified version for
						// performance reasons... so lets look it up in the original unmodified version						
						context = item._backup;
						if(type == "attr") {
							ret = this._getAttrsByXpath(context, xpath, targetName);
						}
						else {
							ret = this._getNodesByXpath(context, xpath, targetName);
						}
						
						// if ret.found is still false, then just return the defaultValue
						if(!ret.found) ret.value = new Array();
					}
					
					return ret.value;
				},
				
				getValueByMapping: function( /* com.ibm.data.AtomEntryItem */ item, 
						/* Object */ mapping, 
						/* Value? */ defaultValue){
					// summary: Executes the correct query API using the mapping argument to
					//		retrieve the desired attribute value for the item as specified by the 
					// 		mapping.
					// mapping: A mapping object from this object's attrMappings
					// defaultValue: The default value to return if no value exists for the mapping.
					//		If null is returned by the query, the defaultValue will be returned
					//		instead.
					var ret = null;
					var xpath = mapping.xpath;
					var type = mapping.type;
					var targetName = mapping.targetName;
					var context = this._feed;
					if(item) {
						this._assertIsItem(item);
						context = item.element;
					}
					if(type == "attr") {
						ret = this._getAttrByXpath(context, xpath, targetName);
					}
					else {
						ret = this._getNodeByXpath(context, xpath, targetName);
					}
					
					if(!ret.found && item && item._backup) {
						// we didn't find any nodes matching the xpath query, and
						// this item has been copied from its original for modification,
						// so perhaps we explicitly removed it in the modified version for
						// performance reasons... so lets look it up in the original unmodified version						
						context = item._backup;
						if(type == "attr") {
							ret = this._getAttrByXpath(context, xpath, targetName);
						}
						else {
							ret = this._getNodeByXpath(context, xpath, targetName);
						}
						
						// if ret.found is still false, then just return the defaultValue
						if(!ret.found && defaultValue) ret.value = defaultValue;
					}
					
					if(type == "attr" && ret.value && ret.value.length == 0) ret.value = null;
					
					return ret.value;
				},
				
				setValueByMapping: function( /* com.ibm.data.AtomEntryItem */ item, 
						/* Object */ mapping, 
						/* Value */ value){
					// summary: Executes the correct query API using the mapping argument to
					//		retrieve the desired attribute value for the item as specified by the 
					// 		mapping.
					// mapping: A mapping object from this object's attrMappings
					// value: The value to set that matches the mapping rule on the item.
					var xpath = mapping.xpath;
					var type = mapping.type;
					var targetName = mapping.targetName;
					var context = this._feed;
					var ret = false;
					if(item) {
						this._assertIsItem(item);
						context = item.element;
					}
					if(type == "attr") {
						ret = this._setAttrByXpath(context, xpath, targetName, value);
					}
					else {
						ret = this._setNodeByXpath(context, xpath, targetName, value);
					}
					
					if(!ret && mapping.setter) {
						return mapping.setter.apply(this, arguments);
					}
					return ret;
				},
				
				setValuesByMapping: function( /* com.ibm.data.AtomEntryItem */ item, 
						/* Object */ mapping, 
						/* Array */ values){
					// summary: Executes the correct query API using the mapping argument to
					//		retrieve the desired attribute value for the item as specified by the 
					// 		mapping.
					// mapping: A mapping object from this object's attrMappings
					// values: The value to set that matches the mapping rule on the item.
					var xpath = mapping.xpath;
					var type = mapping.type;
					var targetName = mapping.targetName;
					var context = this._feed;
					var ret = false;
					if(item) {
						this._assertIsItem(item);
						context = item.element;
					}
					if(type == "attr") {
						ret = this._setAttrsByXpath(context, xpath, targetName, value);
					}
					else {
						ret = this._setNodesByXpath(context, xpath, targetName, value);
					}
					
					if(!ret && mapping.setter) {
						return mapping.setter.apply(this, arguments);
					}					
					return ret;
				},
				
				getAttributes: function(/* com.ibm.data.AtomEntryItem? */ item){
					// summary: Gets the valid attributes for the given item if one is provided and
					//		returns an array of attribute names in String format.  If the item is
					//		null, it returns an array of attributes on the current feed that can
					//		be retrieved via the getFeedValue function.
					// item: Optional argument to get the list of attributes from.
					var attrs = [];
					if(item) {
						this._assertIsItem(item);
						for(var x in item.attrMappings) {
							attrs.push(x);
						}
					}
					else {
						for(var x in this.attrMappings) {
							attrs.push(x);
						}
					}
					
					return attrs;
				},
				
				hasAttribute: function(	/* com.ibm.data.AtomEntryItem */ item,
							/* String */ attribute){
					// summary: Returns true if the attribute is a valid attribute on the given item,
					//		false otherwise.  This does not check if the attribute value on the item
					//		is null or empty, but just checks if the item supports that attribute.
					// item: Item to check if the attribute is valid
					// attribute: Name of the attribute to check
					this._assertIsItem(item);
					this._assertIsString(attribute);
					if(attribute.charAt(attribute.length - 1) == '$') {
						// this looks like an attribute whose map rule is parameterizable
						// so lets defer checking if its valid until later so we don't
						// duplicate any string processing
						return true;
					}
					if(item.attrMappings[attribute]) return true;
					else return false;
				},
				
				containsValue: function(/* com.ibm.data.AtomEntryItem */ item,
							/* String */ attribute, 
							/* Object */ value){
					// summary: Returns true if the value of the attribute on the given item is
					//		equal to the value argument, false otherwise.  If the attribute is a
					//		multi-valued attribute, it will check all the values of the attribute.
					// item: Item to check if the attribute is valid
					// attribute: Name of the attribute to check
					// value: Value to compare the actual value(s) to.
					var values = this.getValues(item, attribute);
					for(var i = 0; i < values.length; i++) {
						if(values[i] == value) return true;
					}
					return false;
				},
				
				isItem: function(/* Object */ something){
					// summary: Returns true if the argument is a valid item in this store, false otherwise.
					// something: Object to check to determine if it is an item in this store.
					return something.store == this && something.element && !something._isDeleted;
				},
				
				isItemLoaded: function(/* Object */ something) {
					// summary: All valid items in this data store are loaded all of the time as there
					//		is no support currently for stubs.  Therefore, this is effectively the same
					//		as isItem.
					return this.isItem(something) && something.loaded;
				},
				
				loadItem: function(/* Object */ keywordArgs){
					// summary: All valid items in this data store are loaded all of the time as there
					//		is no support currently for stubs.  Therefore, this function is a no-op. 
				},
				getResultSize: function(/*DOMDoc*/ doc, /*Request*/ request, /*Array*/ items) {
					// summary: Gets the total number of items retrieved by the query, which is not
					//		necessarily the number of items returned to the callbacks to fetch.
					//		This can be used for paging purposes to get the total number of items
					//		on the server that match the query, where subsequent fetch requests can
					//		be made to retrieve additional pages.
					return items.length;
				},
				processFetchedItems: function(/*Array*/ items, /*Request*/ request) {
					// summary: Extension point for descendants or consumers of this store to preprocess
					// 		the list of items that the store returns from a fetch call.  Allows a store
					// 		to filter the list or implement caching techniques on the client, or sort
					// 		the items, or anything else.
					// items: Array items of this data store found in the response of a fetch call
					// returns: Array items of this data store after processing
					return items;
				},		
				processResponse: function(/*DOMDoc*/ xmlDoc, /*Request*/ request) {
					// summary: Extension point for descendants or consumers of this store to handle
					//		responses from server requests for data.  Most subclasses can leave this
					// 		function as-is, but if special handling is required that cannot be done
					// 		with other extension points, this can be overridden as well.
					// 		Must call onBegin, onItem, and onComplete callbacks correctly as 
					// 		specified by dojo.data.api.Read.  The onError callback is handled elsewhere.
					// xmlDoc: DOMDoc of the response from an IO request
					// request: Request used to fetch the result
					if(request.aborted) return;
					var composite = this._parseFeed(request, xmlDoc); 
					var items = composite.items;
					this._feed = composite.root;
					items = this.processFetchedItems(items, request);
					if(request.onBegin) request.onBegin.call(request.scope, this.getResultSize(composite.root, request, items), request);
					if(request.onItem) {
						for(var i = 0; i < items.length; i++) {
							if(request.aborted) return;
							request.onItem.call(request.scope, items[i], request);
						}
					}
					if(request.onComplete) {
						// call onComplete with items array if onItem wasn't specified, otherwise
						// call it with null
						if(request.aborted) return;
						if(!request.onItem) request.onComplete.call(request.scope, items, request);
						else request.onComplete.call(request.scope, null, request);
					}
				},
				fetch: function( keywordArgs ) {
					//    summary:
			        //        Given a query and set of defined options, such as a start and count of items to return,
			        //        this method executes the query and makes the results available as data items.
			        //        The format and expectations of stores is that they operate in a generally asynchronous 
			        //        manner, therefore callbacks are always used to return items located by the fetch parameters.
			        //
			        //    description:
			        //        A Request object will always be returned and is returned immediately.
			        //        The basic request is nothing more than the keyword args passed to fetch and 
			        //        an additional function attached, abort().  The returned request object may then be used 
			        //        to cancel a fetch.  All data items returns are passed through the callbacks defined in the 
			        //        fetch parameters and are not present on the 'request' object.
			        //
			        //        This does not mean that custom stores can not add methods and properties to the request object
			        //        returned, only that the API does not require it.  For more info about the Request API, 
			        //        see dojo.data.api.Request
			        //
			        //    keywordArgs:
			        //        The keywordArgs parameter may either be an instance of 
			        //        conforming to dojo.data.api.Request or may be a simple anonymous object
			        //        that may contain any of the following:
			        //        { 
			        //            query: query-string or query-object,
			        //            queryOptions: object,
			        //            onBegin: Function,
			        //            onItem: Function,
			        //            onComplete: Function,
			        //            onError: Function,
			        //            scope: object,
			        //            start: int
			        //            count: int
			        //            sort: array
			        //        }
			        //        All implementations should accept keywordArgs objects with any of
			        //        the 9 standard properties: query, onBegin, onItem, onComplete, onError 
			        //        scope, sort, start, and count.  Some implementations may accept additional 
			        //        properties in the keywordArgs object as valid parameters, such as 
			        //        {includeOutliers:true}.         
			        //
					//	The *query* parameter.
					//        The query may be optional in some data store implementations.
					//        The dojo.data.api.Read API does not specify the syntax or semantics
					//        of the query itself -- each different data store implementation
					//        may have its own notion of what a query should look like.
					//        However, as of dojo 0.9, 1.0, and 1.1, all the provided datastores in dojo.data
					//        and dojox.data support an object structure query, where the object is a set of 
					//        name/value parameters such as { attrFoo: valueBar, attrFoo1: valueBar1}.  Most of the
					//        dijit widgets, such as ComboBox assume this to be the case when working with a datastore 
					//        when they dynamically update the query.  Therefore, for maximum compatibility with dijit 
					//        widgets the recommended query parameter is a key/value object.  That does not mean that the
					//        the datastore may not take alternative query forms, such as a simple string, a Date, a number, 
					//        or a mix of such.  Ultimately, The dojo.data.api.Read API is agnostic about what the query 
					//        format.  
					//        Further note:  In general for query objects that accept strings as attribute 
					//        value matches, the store should also support basic filtering capability, such as * 
					//        (match any character) and ? (match single character).  An example query that is a query object
					//        would be like: { attrFoo: "value*"}.  Which generally means match all items where they have 
					//        an attribute named attrFoo, with a value that starts with 'value'.
			        //
			        //    The *queryOptions* parameter
			        //        The queryOptions parameter is an optional parameter used to specify optiosn that may modify
			        //        the query in some fashion, such as doing a case insensitive search, or doing a deep search
			        //        where all items in a hierarchical representation of data are scanned instead of just the root 
			        //        items.  It currently defines two options that all datastores should attempt to honor if possible:
			        //        {
			        //            ignoreCase: boolean, //Whether or not the query should match case sensitively or not.  Default behaviour is false.
			        //            deep: boolean     //Whether or not a fetch should do a deep search of items and all child 
			        //                            //items instead of just root-level items in a datastore.  Default is false.
			        //        }
			        //
			        //    The *onBegin* parameter.
			        //        function(size, request);
			        //        If an onBegin callback function is provided, the callback function
			        //        will be called just once, before the first onItem callback is called.
			        //        The onBegin callback function will be passed two arguments, the
			        //        the total number of items identified and the Request object.  If the total number is
			        //        unknown, then size will be -1.  Note that size is not necessarily the size of the 
			        //        collection of items returned from the query, as the request may have specified to return only a 
			        //        subset of the total set of items through the use of the start and count parameters.
			        //
			        //    The *onItem* parameter.
			        //        function(item, request);
			        //        If an onItem callback function is provided, the callback function
			        //        will be called as each item in the result is received. The callback 
			        //        function will be passed two arguments: the item itself, and the
			        //        Request object.
			        //
			        //    The *onComplete* parameter.
			        //        function(items, request);
			        //
			        //        If an onComplete callback function is provided, the callback function
			        //        will be called just once, after the last onItem callback is called.
			        //        Note that if the onItem callback is not present, then onComplete will be passed
			        //        an array containing all items which matched the query and the request object.  
			        //        If the onItem callback is present, then onComplete is called as: 
			        //        onComplete(null, request).
			        //
			        //    The *onError* parameter.
			        //        function(errorData, request); 
			        //        If an onError callback function is provided, the callback function
			        //        will be called if there is any sort of error while attempting to
			        //        execute the query.
			        //        The onError callback function will be passed two arguments:
			        //        an Error object and the Request object.
			        //
			        //    The *scope* parameter.
			        //        If a scope object is provided, all of the callback functions (onItem, 
			        //        onComplete, onError, etc) will be invoked in the context of the scope
			        //        object.  In the body of the callback function, the value of the "this"
			        //        keyword will be the scope object.   If no scope object is provided,
			        //        the callback functions will be called in the context of dojo.global().  
			        //        For example, onItem.call(scope, item, request) vs. 
			        //        onItem.call(dojo.global(), item, request)
			        //
			        //    The *start* parameter.
			        //        If a start parameter is specified, this is a indication to the datastore to 
			        //        only start returning items once the start number of items have been located and
			        //        skipped.  When this parameter is paired withh 'count', the store should be able
			        //        to page across queries with millions of hits by only returning subsets of the 
			        //        hits for each query
			        //
			        //    The *count* parameter.
			        //        If a count parameter is specified, this is a indication to the datastore to 
			        //        only return up to that many items.  This allows a fetch call that may have 
			        //        millions of item matches to be paired down to something reasonable.  
			        //
			        //    The *sort* parameter.
			        //        If a sort parameter is specified, this is a indication to the datastore to 
			        //        sort the items in some manner before returning the items.  The array is an array of 
			        //        javascript objects that must conform to the following format to be applied to the
			        //        fetching of items:
			        //        {
			        //            attribute: attribute || attribute-name-string,
			        //            descending: true|false;   // Optional.  Default is false.
			        //        }
			        //        Note that when comparing attributes, if an item contains no value for the attribute
			        //        (undefined), then it the default ascending sort logic should push it to the bottom 
			        //        of the list.  In the descending order case, it such items should appear at the top of the list.
			        // 
			        //    returns:
			        //        The fetch() method will return a javascript object conforming to the API
			        //        defined in dojo.data.api.Request.  In general, it will be the keywordArgs
			        //        object returned with the required functions in Request.js attached.
			        //        Its general purpose is to provide a convenient way for a caller to abort an
			        //        ongoing fetch.  
			        // 
			        //        The Request object may also have additional properties when it is returned
			        //        such as request.store property, which is a pointer to the datastore object that 
			        //        fetch() is a method of.
			        //
			        //    exceptions:
			        //        Throws an exception if the query is not valid, or if the query
			        //        is required but was not supplied.
					if(!keywordArgs) keywordArgs = {};
			        var me = this;
					keywordArgs.aborted = false;
					if(!keywordArgs.scope) keywordArgs.scope = dojo.global;
					var preventCache = false;
					if(keywordArgs.queryOptions && keywordArgs.queryOptions.preventCache) {
						preventCache = true; 
					}
					var url = this._buildUrl(keywordArgs, this.url);
					keywordArgs.url = url;
					var loadHandler = function(response, ioArgs) {
						if(keywordArgs.aborted) return;
						if(dojo.isIE) response = com.ibm.domUtilities.docFromString(response);
						me.doc = response;
						me.processResponse(response, keywordArgs);
					};
					var errorHandler = function(error, ioArgs) {
						if(keywordArgs.onError) keywordArgs.onError.call(keywordArgs.scope, error, keywordArgs);
					};
					var args = {
						preventCache: preventCache,
						content: {},
						url: url,
						handleAs: "xml"
					}
					if(keywordArgs.queryOptions && keywordArgs.queryOptions.timeout) {
						args.timeout = keywordArgs.queryOptions.timeout;
					}
					else if(this.timeout) {
						args.timeout = this.timeout;
					}
					if(dojo.isIE) {
						args.handleAs = "text";
						args.content["ibm.web2.contentType"] = "text/xml";
					}
					
					var handle = null;
					keywordArgs.abort = function() {
						keywordArgs.aborted = true;
						handle.cancel();
					};
					args = this.modifyRequestArgs(args, keywordArgs);
					
					handle = dojo.xhrGet(args);
					handle.addCallback(loadHandler);
					handle.addErrback(errorHandler);

					this._lastRequest = keywordArgs;
					return keywordArgs;
				},
				modifyRequestArgs: function(ioArgs, request) {
					// summary: Allows modification to request arguments before sending a request
					//		to the server.  Subclasses may override this to modify arguments
					//		like setting headers, manipulating the url, overriding a handleAs argument,
					//		or anything else.  Returns the modified request args.
					// ioArgs: dojo.__XhrArgs request args to be sent to the server
					// request: dojo.data.api.Request object
					// returns: dojo.__XhrArgs modified request arguments
					return ioArgs;
				},
				_queryUrlToObject: function(queryStr) {
					if(!queryStr || queryStr.length == 0) return {};
					var start = queryStr.indexOf("?");
					var str = queryStr;
					if(start > -1 && (start < str.length - 1)) { 
						// extract only the query part of the queryStr URL
						str = queryStr.substring(start + 1);
					}
					return dojo.queryToObject(str);
				},
				_prepareQuery: function(keywordArgs) {
					var query = keywordArgs.query;
					if(!query) keywordArgs.query = {};
					else if(dojo.isString(query)) {
						keywordArgs.query = this._queryUrlToObject(query);
					}
					return this.prepareQuery(keywordArgs);
				},
				prepareQuery: function(keywordArgs) {
					// summary: User overridable function to modify the keywordArgs object
					// 		used to fetch results from the back end after the keywordArgs.query
					//		property has been normalized to an object map but before any other
					//		processing has taken place to build the URL.  This can be used to
					//		extract other parts of the keywordArgs map to add properties to the
					//		query object that are dependent on the back end implementation.  One
					//		example includes extracting the keywordArgs.sort parameters and appending
					//		appropriate properties to the keywordArgs.query property that will end
					//		up being built into the generated URL to the server.
					// returns: Object Modified keywordArgs object.
					return keywordArgs;
				},
				_buildUrl: function(keywordArgs, baseUrl) {
					// summary: Builds a url string from this store's base url and the
					// 		query argument.
					// keywordArgs: Object
					//		A request object map as sent to the fetch function
					// returns: String The constructed url.
					var ret = "";
					var keywordArgs = this._prepareQuery(keywordArgs);
					var queryPart = dojo.objectToQuery(keywordArgs.query);
					if(baseUrl.indexOf("?") > -1) {
						ret = baseUrl + "&" + queryPart; // String
					}
					else ret = baseUrl + "?" + queryPart; // String
					
					return (this.modifyUrl(keywordArgs, ret));
				},
				modifyUrl: function(keywordArgs, url) {
					return url;
				},
				_parseFeed: function(request, xmlDoc) {
					var items = new Array();
					var root = null;
					var result = this._getNodeByXpath(xmlDoc, "/atom:feed");
					if(!result.found) {
						result = this._getNodeByXpath(xmlDoc, "/atom:entry");
						if(!result.found) {
							// the root is not an atom:feed or atom:entry
							throw new Error("Illegal atom feed format: the root element is not an ATOM feed or entry element.");
						}
						else {
							// the root is an atom:entry element, so there's only one item
							root = result.value;
							var query = this._queryUrlToObject(request.url);
							items.push(this._getItem({element: root, query: query}));
						}
					}
					else {
						// the root is an atom:feed element
						root = result.value;
						var query = this._queryUrlToObject(request.url);
						result = this._getNodesByXpath(root ? root : xmlDoc, "./atom:entry");
						if(result.found) {
							var nodes = result.value;
							for(var i = 0; i < nodes.length; i++) {
								items.push(this._getItem({element: nodes[i], query: query}));
							}
						}
					}
					
					return {items: items, root: root};
				},
				
				getFeatures: function () {
					//	summary:
					//		Return supported data APIs
					//	returns:
					//		Map of supported data APIs with keys as API classes and values as true/false to indicate support
					//		by this store.
					return this._features; //returns Map
				},
				
				close: function(/*dojo.data.api.Request || keywordArgs || null */ request){
					if(request && request.abort) request.abort();
				},
				
				getLabel: function(/* com.ibm.data.AtomEntryItem */ item){
					return this.getValue(item, "title");
				},
				
				getLabelAttributes: function(/* com.ibm.data.AtomEntryItem */ item){
					return ['title'];
				},
				
				/********************************/
				/**                            **/
				/**                            **/
				/**    dojo.data.api.Write     **/
				/**                            **/
				/**                            **/
				/********************************/
				newItem: function(/* Object? */ keywordArgs, /*Object?*/ parentInfo){
					// summary: Must be overridden by stores that extend this but support writes,
					//		like ATOM services that support APP.
					return null;
				},
				
				deleteItem: function(/* com.ibm.data.AtomEntryItem */ item){
					// summary: Deletes an item from the store.  Does not persist to the server until save is called.
					// item: The item to delete.
					// returns: Boolean true if successful, false otherwise.							
					if(!this._deletedItems) this._deletedItems = new Array();
					item.backup();
					this._deletedItems.push(item);
					// storing identity into item since we need it later and can't access it through store APIs
					// after it's been marked as deleted
					item.id = this.getIdentity(item);
					item._isDeleted = true;
					// we are assuming that order does not matter, so we don't have to save the item's
					// current position in the list of entries in this feed
					return true;
				},
				
				setValue: function(	/* com.ibm.data.AtomEntryItem */ item, 
						/* String */ attribute,
						/* almost anything */ value){
					var ret = false;
					var oldValue = null;
					if(this.hasAttribute(item, attribute)) {
						var mapRule = this.getMapRule(attribute, item.attrMappings);
						// if mapRule is null here, then we didn't find one
						// in the map, so we can't proceed successfully
						if(mapRule) {
							item.backup();
							oldValue = this.getValueByMapping(item, mapRule);
							ret = this.setValueByMapping(item, mapRule, value);
							if(ret) {
								this._addDirtyItem(item);
								item.logWrite({attribute: attribute, value: value});
							}
						}
					}
					else {
						throw new Error(attribute + " is not an attribute of any item in this store");
					}
					return {success: ret, oldValue: oldValue, newValue: value};
				},
				
				setValues: function(/* com.ibm.data.AtomEntryItem */ item,
						/* String */ attribute, 
						/* array */ values){
					var ret = false;
					var oldValue = null;
					if(this.hasAttribute(item, attribute)) {
						var mapRule = this.getMapRule(attribute, item.attrMappings, true);
						// if mapRule is null here, then we didn't find one
						// in the map, so we can't proceed successfully
						if(mapRule) {
							item.backup();
							oldValue = this.getValueByMapping(item, mapRule);
							ret = this.setValuesByMapping(item, mapRule, values);
							if(ret) {
								this._addDirtyItem(item);
								item.logWrite({attribute: attribute, values: values});
							}
						}
					}
					else {
						throw new Error(attribute + " is not an attribute of any item in this store");
					}
					return {success: ret, oldValue: oldValue, newValue: values};
				},
				
				unsetAttribute: function(/* com.ibm.data.AtomEntryItem */ item, 
								/* String */ attribute){
					var ret = false;
					var oldValue = null;
					var value = null;
					if(this.hasAttribute(item, attribute)) {
						var mapRule = this.getMapRule(attribute, item.attrMappings);
						// if mapRule is null here, then we didn't find one
						// in the map, so we can't proceed successfully
						if(mapRule) {
							item.backup();
							oldValue = this.getValueByMapping(item, mapRule);
							if(mapRule.type == "attr") {
								ret = this.setValueByMapping(item, mapRule, "");
								value = "";
							}
							else {
								// it's a node or node property
								if(mapRule.targetName) ret = this.setValueByMapping(item, mapRule, null);
								// if targetName, then it's a property
								else if(oldValue) {
									// if no targetName, then it's a node... so remove the node				
									oldValue.parentNode.removeChild(oldValue);
									ret = true;
								}
							}
							
							if(ret) {
								this._addDirtyItem(item);
								item.logWrite({attribute: attribute, value: value});
							}
						}
					}
					return {success: ret, oldValue: oldValue, newValue: value};
				},
				
				save: function(/* Object */ keywordArgs){
					var it = null;
					for(var d = 0; d < this._deletedItems.length; d++) {
						it = this._deletedItems[d];
						it.persist();
						delete it.element;
					}
					for(var i = 0; i < this._dirtyItems.length; i++) {
						this._dirtyItems[i].persist();
					}
					for(var i = 0; i < this._newItems.length; i++) {
						this._newItems[i].persist();
					}
					
					// the persist operation of the above items set some values on their backups
					// which may have updated the dirtyItems list... by putting this below here
					// we're removing those immediately if they are here 
					
					// instead of just reinitializing these pointers,
					// splice these so that we can keep the same array references forever in case others have
					// pointers to these still (so that they won't break)
					this._newItems.splice(0, this._newItems.length);
					this._dirtyItems.splice(0, this._dirtyItems.length);
					this._deletedItems.splice(0, this._deletedItems.length);
				},
				_addDirtyItem: function(/* com.ibm.portal.data.ContentModelItem */ item) {
					if(item._isDirty) return;
					item._isDirty = true;
					
					// need to check this
					for(var i = 0; i < this._dirtyItems.length; i++) {
						if(this._dirtyItems[i] == item) return;
					}
					
					this._dirtyItems.push(item);
				},
				
				revert: function(){
					var it = null;
					for(var d = 0; d < this._deletedItems.length; d++) {
						it = this._deletedItems[d];
						it.restore();
						delete item._isDeleted;
					}
					for(var i = 0; i < this._dirtyItems.length; i++) {
						this._dirtyItems[i].restore();
					}
					this._dirtyItems = new Array();
					this._deletedItems = new Array();
				},
				
				isDirty: function(/* com.ibm.data.AtomEntryItem? */ item){
					// summary: Determines whether or not an item is dirty or if this store in general has dirty items.
					//		If item is specified, it returns true if that item is dirty, and false otherwise.
					//		If no item is specified, it returns an array of all the dirty items in this store (modified,
					//		deleted, and new), and false if there are none.
					// item: Optional argument to check if a particular item is dirty.  Leaving this null
					if(item && this._assertIsItem(item)) return item._isDirty;
					else {
						var array = this._dirtyItems.concat(this._deletedItems).concat(this._newItems);
						if(!array || array.length == 0) return false;
						else return array;
					}
				}
			}
);	


dojo.declare( "com.ibm.data.AtomEntryItem",
			com.ibm.data.XpathHelper, 
			{
				namespaces: dojo.mixin({}, com.ibm.data.AtomFeedStore.prototype.namespaces),
		        // attrMappings: This maps attribute names to a query object consisting of an 
		        // 		xpath expression used to find the relevant node(s), an attr name, and a type.
		        // 		The map contains key-value pairs in this format:
		        //		{
		        //			attributeName: {xpath: "./this/is/the/xpath/expr", targetName: "attrName"|null, type: "node"|"attr"}  
		        //		}
		        //		The xpath expression is resolved from the context of the atom:entry node 
		        // 		assigned to this atom feed entry item.  The attr property is an optional property
		        //		used to specify whether to get an object property of the returned DOM node object or 
		        // 		an attribute of the returned DOM node.  The type specifies what type the lookup
		        //		will perform in conjunction with the attr.  If the lookup is an attribute of the
		        // 		DOM node, it will attempt to resolve any namespacing it encounters when looking
		        // 		up the attribute.  The following explains the possible combinations of lookup 
		        // 		mechanisms.
		        // 		
		        // 		xpath: "./node", targetName: "textContent", type: "node" = node["textContent"]
		        //		xpath: "./node", targetName: "href", type: "attr" = node.getAttribute("href")
		        // 		xpath: "./node", targetName: "textContent", type: "node" = cross browser node["textContent"] property
		        // 		xpath: "./node", targetName: null, type: "node" = node
		        //  	xpath: "./node", targetName: null, type: "attr" = invalid query, requires the attribute name
		        //
		        //		Map rules can be parameterized by substituting parameters specified by the caller into the
		        //		rule template.  Parameterized map rules MUST end with a $ character to mark them as such.
		        // 		Example:
		        //	 		pAttribute$: {xpath: "./${0}['${1}']", targetName: "${2}", type: "node", customRuleProperty: "${1}"}
		        //
		        //		Callers supply a comma-separated list of parameter values to be bound to subsequent numerical
		        //		parameter keys in the template respectively surrounded by brackets immediately following the
		        //		name of the attribute key but before the $ character.
		        //		Example:
		        // 			To request the value of pAttribute$ with values set for the parameters, the caller would 
		        // 			use code like this -
		        //		store.getValue(item, "pAttribute[div, id, nodeValue]$");
		        //
		        attrMappings: dojo.mixin({}, com.ibm.data.AtomFeedStore.prototype.attrMappings, { 		
					subtitle: {xpath: "./atom:subtitle", targetName: "textContent", type: "node", setter: 
						function(item, rule, value){
							var elem = this._createNSElement(item.element.ownerDocument, "atom:subtitle");
							this._setNodeProp(elem, rule.targetName, value);
							item.element.appendChild(elem);
							return true;
						}
					},
					generator: {xpath: "./atom:generator", targetName: "textContent", type: "node", setter: 
						function(item, rule, value){
							var elem = this._createNSElement(item.element.ownerDocument, "atom:generator");
							this._setNodeProp(elem, rule.targetName, value);
							item.element.appendChild(elem);
							return true;
						}
					},
					icon: {xpath: "./atom:icon", targetName: "textContent", type: "node", setter: 
						function(item, rule, value){
							var elem = this._createNSElement(item.element.ownerDocument, "atom:icon");
							this._setNodeProp(elem, rule.targetName, value);
							item.element.appendChild(elem);
							return true;
						}
					},
					logo: {xpath: "./atom:logo", targetName: "textContent", type: "node", setter: 
						function(item, rule, value){
							var elem = this._createNSElement(item.element.ownerDocument, "atom:logo");
							this._setNodeProp(elem, rule.targetName, value);
							item.element.appendChild(elem);
							return true;
						}
					}
				}), 
				
				constructor: function( /*Map*/ args ) {
					dojo.mixin(this, args);
					this._writeLog = new Array();
				},
				toString: function() {
					return "<" + this.__getClassName() + ">";
				},
				_onCreate: function() {
					// summary: Called internally to indicate an item has been created.  Should
					//		be called immediately on creation for stores that do not save to
					//		a backend server, but should be called on a valid server response for
					// 		an item that was created and saved to the server successfully.  This
					// 		calls onCreate to notify listeners of the event and can therefore be
					// 		overriden if custom logic needs to be applied to handle cases where
					// 		other conditions need to be satisfied before the onCreate event is called.
					this.onCreate();
				},
				onCreate: function() {
					// summary: Called when this item is created.  This callback is reserved
					// 		for sending notifications when a new item stub has been created
					// 		on the actual server.  This will be called when a new item has been
					//		created, saved to the server, and the server responds back with
					//		a verification of the created item.  Some stores may not have any
					// 		notion of creating items on the server and should call this immediately
					// 		when the item is created on the client, while others actually defer 
					// 		the full creation of a new item from the newItem call until after the 
					// 		save operation has persisted to the backend.  This allows interested 
					// 		parties to get notified when an item they've created is actually saved
					// 		on the server.  This is especially useful if the server has to generate
					//		something like a unique ID for the item which is not available on the
					//		item until the server response comes back.
				},
				_makeModifiable: function() {
					// summary: Modifies the element of this item to become modifiable
					//		for writing back to the server.  Subclasses can override this
					//		to do things like prune an item to only include necessary information
					//		for updates and nothing more.  This is called by backup once after
					//		backing up the original element first.  After this returns,
					//		this item's element may have been modified.  Any queries against
					//		this item should now include logic to check the backup copy as well
					//		if a query doesn't return anything as it could have been deleted by
					//		this function.  Care should be taken to ensure that the query result
					//		specifically detects if nothing was found or if the actual value was
					//		null or empty.
				},
				backup: function() {
					// summary: Creates a single backup copy of this item on the client for
					//		later restoration if necessary.  Calling this function multiple
					//		times before restore() or persist() is called on this item will do nothing
					//		after the initial backup, effectively maintaining only the first
					//		version of the item before any changes were made.
					if(!this._backup) {
						this._backup = this.element.cloneNode(true);
						this._makeModifiable();
						this._logEnabled = true;
						return true;
					}
					return false;
				},
				restore: function() {
					// summary: Restores the single backup copy of this item on the client,
					//		erasing all modifications made since backup() was called.
					if(!this._backup) {
						dojo.place(this._backup, this.element, "before");
						this.element.parentNode.removeChild(this.element);
						delete this.element;
						this.element = this._backup;
						this.backup = null;
						this._writeLog.splice(0, this._writeLog.length);
						return true;
					}
					return false;
				},
				persist: function() {
					// summary: Persists the changes made to this item since the backup() was
					// 		called.  After this is called, there is no way to restore the backup
					//		as it is erased completely.
					this._writeLogToBackup();
					this._isDirty = false;
					delete this._backup;
				},
				logWrite: function(map) {
					// summary: Logs write operations to this item so that they can later
					//		be repeated to the backup during persistence.
					if(this._logEnabled) this._writeLog.push(map);
				},
				_writeLogToBackup: function() {
					// summary: Repeates the write log for this item to the original backup
					// 		node.  Used mainly for persisting changes to support a 2-phase
					//		write operation (write, commit).
					if(this._backup) {
						this.element = this._backup;
						this._logEnabled = false;
						for(var i = 0; i < this._writeLog.length; i++) {
							var op = this._writeLog[i];
							if(op.values) {
								this.store.setValues(this, op.attribute, op.values);
							}
							else {
								this.store.setValue(this, op.attribute, op.value);
							}
						}
						this._writeLog.splice(0, this._writeLog.length);
					}
				}
			}
);


dojo.declare( "com.ibm.data.AtomPersonConstruct",
			com.ibm.data._XmlConstruct,
			{
				// summary: Construct for retrieving appropriate information
				// 		from an Atom Person Construct as defined in 
				// 		http://tools.ietf.org/html/rfc4287#section-3.2.
				
				namespaces: dojo.mixin({}, com.ibm.data.AtomFeedStore.prototype.namespaces),
		        
				constructor: function(/*DOMNode*/ root) {
					this.root = root;
				},
				getName: function() {
					// summary: Gets the name specified by this Atom person construct.
					// returns: String
					var result = this._getNodeByXpath(this.root, "./atom:name", "textContent");
					if(!result.found) result.value = "";
					return result.value;
				},
				getEmail: function() {
					// summary: Gets the email specified by this Atom person construct.
					// returns: String
					var result = this._getNodeByXpath(this.root, "./atom:email", "textContent");
					if(!result.found) result.value = "";
					return result.value;
				},
				getURI: function() {
					// summary: Gets the name specified by this Atom person construct.
					// returns: String
					var result = this._getNodeByXpath(this.root, "./atom:uri", "textContent");
					if(!result.found) result.value = "";
					return result.value;
				},
				toString: function() {
					// summary: Gets the name string specified by this Atom person construct.
					// returns: String
					return this.getName();
				}
			}
);

dojo.declare( "com.ibm.data.AtomDateConstruct",
			com.ibm.data._XmlConstruct,
			{
				// summary: Construct for retrieving javascript-appropriate information
				// 		from an Atom Date Construct as defined in 
				// 		http://tools.ietf.org/html/rfc4287#section-3.3.
				
				namespaces: dojo.mixin({}, com.ibm.data.AtomFeedStore.prototype.namespaces),
		        
				// Supports date strings in the following formats - 
				//		2003-12-13T18:30:02Z
				//		2003-12-13T18:30:02.25Z
				//		2003-12-13T18:30:02+01:00
				//		2003-12-13T18:30:02.25+01:00
				
				constructor: function(/*DOMNode*/ root) {
					this.root = root;
				},
				getDate: function() {
					// summary: Parses and retrieves a javascript Date object from a date string
					//		specified in an Atom feed according to the allowable string formats
					//		by the Atom spec itself (http://tools.ietf.org/html/rfc4287#section-3.3)
					// returns: Date
					if(this.date) return this.date;
					
					var d = this._getNodeProp(this.root, "textContent");
					if(!d) return null;
					
					this.date = dojo.date.stamp.fromISOString(d);
					return this.date;
				},
				getTime: function() {
					// summary: Gets the time specified by this Atom date construct.
					// returns: int
					this.getDate();
					if(this.date) return this.date.getTime();
					
					return null;
				},
				toString: function() {
					// summary: Gets a string representation of the date specified by this
					//		Atom data construct.
					this.getDate();
					if(this.date) return this.date.toString();
					return "";
				}
			}
);

}

if(!dojo._hasResource["com.ibm.data.TemplateInstantiator"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.data.TemplateInstantiator"] = true;
dojo.provide( "com.ibm.data.TemplateInstantiator" );

dojo.require( "com.ibm.portal.xslt" );

dojo.declare( "com.ibm.data.TemplateInstantiator",
			null,
			{	
				_retrieveTemplate: function(template, args) {
					// summary: Retrieves the template string for this object.
					// template: String template containing spots where parameters can be substituted,
					// 		such as ${0}, ${1}, etc.  The parameters can have names like ${name}, in 
					// 		which case the property with that name is looked up on the args object and
					// 		replaced with its property value.  Parameters can also be numerical like ${0},
					// 		in which case the args must be an array to match each parameter with its
					// 		corresponding value at the index noted.  
					// throws: Error if the template string is empty or does not exist.
					// returns: String template string
					if(!template) {
						throw new Error( "No template defined for " + this.toString());
					}
					return template;
				},
				
				_fillOutTemplate: function(str, args, transform, obj) {
					// summary: Performs a string substitution in the str argument using the args
					//		map/array for property substitutions.
					// str: String to perform substitution on
					// args: Object|Array to use to specify key-value binding pairs for parameter substitution 
					// returns: String parameterized string after parameter substitution has taken place
					return dojo.string.substitute(str, args, transform, obj);
				},
				
				getTemplateInstance: function(template, args, formatterObj) {
					// summary: Performs a string substitution in the str argument using the args
					//		map/array for property substitutions.
					// template: String template containing spots where parameters can be substituted,
					// 		such as ${0}, ${1}, etc.  The parameters can have names like ${name}, in 
					// 		which case the property with that name is looked up on the args object and
					// 		replaced with its property value.  Parameters can also be numerical like ${0},
					// 		in which case the args must be an array to match each parameter with its
					// 		corresponding value at the index noted. 
					// args: Object|Array to use to specify key-value binding pairs for parameter substitution
					// formatterObj: Object to look in for formatter functions to apply during substitution
					// throws: Error if the template string is empty or does not exist.
					// returns: DOM document containing content according to template after substitution
					//		for parameters using values specified by args has been completed.
					var str = this._fillOutTemplate(template, args, com.ibm.domUtilities.encodeXML, formatterObj);
					var doc = com.ibm.domUtilities.docFromString(str);
					return doc;
				}
			}
);

}

if(!dojo._hasResource["com.ibm.data._NotificationHelper"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.data._NotificationHelper"] = true;
dojo.provide( "com.ibm.data._NotificationHelper" );

dojo.declare( "com.ibm.data._NotificationHelper",
			null,
			{
				/********************************/
				/**                            **/
				/**                            **/
				/** dojo.data.api.Notification **/
				/**                            **/
				/**                            **/
				/********************************/
				onDelete: function(/* Item */ deletedItem) {
					// summary: See dojo.data.api.Notification.onDelete()
					return deletedItem;
				},
		
				onNew: function(/* Item */ newItem, /* Object */ parentInfo) {
					// summary: See dojo.data.api.Notification.onNew()
					return {newItem: newItem, parentInfo: parentInfo};
				},
		
				onSet: function(/* Item */ item, /*String*/ attribute, /*Object | Array*/ oldValue, /*Object | Array*/ newValue) {
					// summary: See dojo.data.api.Notification.onSet()
					return {item: item, attribute: attribute, oldValue: oldValue, newValue: newValue};
				}
			}
);

}

if(!dojo._hasResource["com.ibm.portal.data._PortalModelStore"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.portal.data._PortalModelStore"] = true;
dojo.provide( "com.ibm.portal.data._PortalModelStore" );

dojo.require( "com.ibm.data.AtomFeedStore" );
dojo.require( "com.ibm.data.TemplateInstantiator" );
dojo.require( "com.ibm.data._NotificationHelper" );


dojo.declare( "com.ibm.portal.data._PortalModelStore",
			[com.ibm.data.AtomFeedStore, com.ibm.data.TemplateInstantiator, com.ibm.data._NotificationHelper],
			{
				// namespaces: Map
				//		Map of namespaces used by the Portal Model SPI feeds
				namespaces: dojo.mixin({}, com.ibm.data.AtomFeedStore.prototype.namespaces, {
		            "xsl" : "http://www.w3.org/1999/XSL/Transform",
		            "thr" : "http://purl.org/syndication/thread/1.0",
		            "xhtml" : "http://www.w3.org/1999/xhtml",
		            "model" : "http://www.ibm.com/xmlns/prod/websphere/portal/v6.0.1/portal-model-elements",
		            "base" : "http://www.ibm.com/xmlns/prod/websphere/portal/v6.0/ibm-portal-composite-base",
		            "portal" : "http://www.ibm.com/xmlns/prod/websphere/portal/v6.0.1/portal-model",
		            "creation-context" : "http://www.ibm.com/xmlns/prod/websphere/portal/v6.1.0/portal-creation-context",
		            "xsi" : "http://www.w3.org/2001/XMLSchema-instance"
		        }),
		        
		        // _notifyOn: Boolean indicating whether or not notifications should be
		        //		made with the dojo.data.Notification API.  Can be turned on/off after
		        //		store creation to disable notification during some operations if desired
		        _notifyOn: true,
		        
		        // itemClass: String the class used to represent items of this store
				itemClass: "com.ibm.portal.data._PortalModelItem",
				
				constructor: function( /*Map*/ args ) {
					// summary: Creates a new instance of a com.ibm.portal.data._PortalModelStore
					// args: Map
					//		The args map will be used to replace any default values of this store with the
					//		values specified in the args map.
					this._cachedItems = new Object();
				},
				
				/********************************/
				/**                            **/
				/**                            **/
				/**   dojo.data.api.Identity   **/
				/**                            **/
				/**                            **/
				/********************************/
				
				// inheriting getIdentity and getIdentityAttributes function from AtomFeedStore
							
				fetchItemByIdentity: function(/* object */ keywordArgs){
					//	summary:
					//		Given the identity of an item, this method returns the item that has 
					//		that identity through the onItem callback.  Conforming implementations 
					//		should return null if there is no item with the given identity.  
					//		Implementations of fetchItemByIdentity() may sometimes return an item 
					//		from a local cache and may sometimes fetch an item from a remote server, 
					//
					// 	keywordArgs:
					//		An anonymous object that defines the item to locate and callbacks to invoke when the 
					//		item has been located and load has completed.  The format of the object is as follows:
					//		{
					//			identity: string|object,
					//			onItem: Function,
					//			onError: Function,
					//			scope: object
					//		}
					//	The *identity* parameter.
					//		The identity parameter is the identity of the item you wish to locate and load
					//		This attribute is required.  It should be a string or an object that toString() 
					//		can be called on.
					//		
					//	The *onItem* parameter.
					//		Function(item)
					//		The onItem parameter is the callback to invoke when the item has been loaded.  It takes only one
					//		parameter, the item located, or null if none found.
					//
					//	The *onError* parameter.
					//		Function(error)
					//		The onError parameter is the callback to invoke when the item load encountered an error.  It takes only one
					//		parameter, the error object
					//
					//	The *scope* parameter.
					//		If a scope object is provided, all of the callback functions (onItem, 
					//		onError, etc) will be invoked in the context of the scope object.
					//		In the body of the callback function, the value of the "this"
					//		keyword will be the scope object.   If no scope object is provided,
					//		the callback functions will be called in the context of dojo.global.
					//		For example, onItem.call(scope, item, request) vs. 
					//		onItem.call(dojo.global, item, request)
					// returns: Request|null the request object used to fetch the item from
					//		the datastore if a remote call is required.  Returns null if the item
					//		is found in the cache, in which case the onItem function is called
					//		immediately.
					var id = keywordArgs.identity;
					var scope = keywordArgs.scope ? keywordArgs.scope : dojo.global;
					if(this._cachedItems[id] && (!keywordArgs.queryOptions || !keywordArgs.queryOptions.preventCache)) {
						if(keywordArgs.onItem) keywordArgs.onItem.call(scope, this._cachedItems[id]);
						return keywordArgs;
					} 
					var args = {
						query: {
							uri: id,
							levels: 1,
							rep: "full",
							mode: "download"
						},
						queryOptions: keywordArgs.queryOptions,
						onComplete: dojo.hitch(this, 
							function(items) {
								if(items.length == 0 && keywordArgs.onError) {
									keywordArgs.onError.call(scope, "No items returned matching identity " + id);
								}
								else if(keywordArgs.onItem) {
									keywordArgs.onItem.call(scope, items[0]);
								}
							}
						)
					};
					if(keywordArgs.onError) args.onError = dojo.hitch(scope, keywordArgs.onError);

					return this.fetch(args);
				},
				
				_getItem: function(args) {
					// summary: See com.ibm.data.AtomFeedStore#_getItem
					var item = this.inherited(arguments);
					item.isFull = (args.query.rep && args.query.rep.toLowerCase() == "full");
					item.created = true;
					return item; 
				},
				
				invalidateCache: function(/*Item?*/ item) {
					// summary: Invalidates the client cache of items in this store.  Can invalidate
					//		a single item by passing the item as an argument, or the entire cache
					//		by passing no arguments.
					// item: Item optional data item to invalidate.
					if(item) delete this._cachedItems[this.getIdentity(item)];
					else this._cachedItems = new Object();
				},
				
				_replaceItemInCache: function(item, /*Boolean?*/ full) {
					// summary: Puts the item in the cache, replacing an older version of the same
					// 		item if it's already present, otherwise just adding it to the cache
					// item: Item to replace
					// full: Boolean flag to indicate if the entire item object should be replaced
					//		or just the element contents.  Default is to simply replace the element
					//		contents (in order to keep any properties on the item from being lost).
					var id = this.getIdentity(item);
					if(!full && this._cachedItems[id]) {
						this._cachedItems[id].element = item.element;
					}
					else this._cachedItems[id] = item;
				},
				
				_fromCache: function(id) {
					return this._cachedItems[id];
				},
				
				processFetchedItems: function(/*Array*/ items, /*Request*/request) {
					// summary: Extension point for descendants or consumers of this store to preprocess
					// 		the list of items that the store returns from a fetch call.  Allows a store
					// 		to filter the list or implement caching techniques on the client or anything
					// 		else.
					// items: Array items of this data store found in the response of a fetch call
					// returns: Array items of this data store after processing
					var preventClientCache = (request.queryOptions && request.queryOptions.preventClientCache);
					var replaceCache = (request.queryOptions && request.queryOptions.replaceCache);
					
					// iterate through the items we just fetched and handle them according to the queryOptions cache parameters
					// and what we already have in the cache
					for(var i = 0; i < items.length; i++) {
						var id = this.getIdentity(items[i]);
						
						if(this._cachedItems[id]) {
							// this item is already in our client cache
							if(replaceCache && !this.isDirty(this._cachedItems[id])) {
								// we want to replace the cached item with the retrieved item 
								// as long as our cached copy is not dirty
								this._replaceItemInCache(items[i]);
							}
							if(!preventClientCache && this._cachedItems[id].isFull == items[i].isFull) {
								// we want to replace what the server returns with what we have in the cache
								// and send back our cached version instead of what we got from the server
								// as long as we asked for the same representation as what's in our cache (full vs compact?)
								items.splice(i, 1, this._cachedItems[id]);
							}
						}
						else {
							// the item is not in our cache, so lets add it regardless of the queryOptions
							this._replaceItemInCache(items[i]);
						}
					}
					
					return items;
				},
				
				/********************************/
				/**                            **/
				/**                            **/
				/**    dojo.data.api.Write     **/
				/**                            **/
				/**                            **/
				/********************************/
				setValue: function(	/* Object */ item, 
						/* String */ attribute,
						/* almost anything */ value){
					var ret = this.inherited(arguments);
				
					if(ret.success) {
						if(!this._settingComplexAttr) {
							this._settingComplexAttr = true;
							var notify = this._notifyOn;
							this._notifyOn = false;
							var par = null;
							switch(attribute) {
								case "next":
									this.setValue(item, "nextURI", value);
									par = this.getValue(item, "parent");
									break;
								case "nextURI":
									this.setValue(item, "next", value);
									par = this.getValue(item, "parent");
									break;
								case "parent":
									this.setValue(item, "parentURI", value);
									break;
								case "parentURI":
									this.setValue(item, "parent", value);
									break;
							}
							if(par) {
								this.setValue(item, "parent", par);
								this.setValue(item, "parentURI", par);
							}
							this._notifyOn = notify;
							this._settingComplexAttr = false;
						}
						
						if(this._notifyOn) this.onSet(item, attribute, ret.oldValue, ret.newValue);
					}
					if((attribute == "next" || attribute == "nextURI") && !value) {
						var rule = this.getMapRule(attribute, item.attrMappings);
						var resultSet = this._getNodeByXpath(item.element, rule.xpath);
						if(resultSet.found) {
							resultSet.value.parentNode.removeChild(resultSet.value);
							delete resultSet.value;
						}
					}

					return ret;
				},
				deleteItem: function(/* Object */ item){
					var ret = this.inherited(arguments);
					if(ret && this._notifyOn) this.onDelete(item);
					return ret;
				},
				newItem: function(/* Object? */ keywordArgs, /*Object?*/ parentInfo){
					// summary: Creates a new Portal Content Model node in the Portal which can be either a
					//		label, url (internal or external), or page.
					// 		Unfortunately, this implementation of the newItem function must
					//		deviate slightly from the API details as specified by dojo.data.api.Write.  
					//		Generating a new item on the client can create an entire DOM entry that can 
					//		represent this model node and return that DOM node directly.  However, the model
					// 		feeds for Portal only provide the actual ID of the new item in the response from
					//		the POST operation to create the new item on the server.  Therefore, this function
					//		immediately returns the new item, but the item's ID will not be the real ID that
					//		the server has generated for it and therefore callers should take careful heed
					//		not to attempt to write back any additional changes to this returned item until
					//		the server has returned back and updated the item's ID correctly.  In order to support
					//		that, onComplete and onError handlers can be specified in the keywordArgs map
					//		that are handled in a special way to be called on response from the server in order
					//		to pass control to the caller after the real ID has been updated in the item.  The
					//		the onComplete handler can assume that the item passed into it has the correct ID
					//		as specified by the server and can therefore operate on that item without any side-effects.
					// 		The onError handler will be used to notify the caller of problems encountered when saving
					// 		the new item to the server.
					// keywordArgs:  A javascript object defining the initial content of the item as a set of 
					// 		JavaScript 'property name: value' pairs.
			        //
			        // returns: Item An item stub that is incomplete in that its ID is not the ID of the item
			        //		on the server.  The server has no knowledge of this item until it has been
			        //		sent to the server for creation.  At that time, the server will respond with
			        //		an XML response that has the correct ID for the item in the DOM.  In order
			        //		to initiate this send operation, the caller must call this store's save function,
			        //		at which time all pending write operations (edits, creates, deletes) will be sent
			        //		to the server.  On response from the create operations, the item's information will
			        // 		be completed as specified by the server, and the appropriate onComplete
			        //		and onError handlers for each create will be called as they were specified in the
			        //		keywordArgs for this particular item.
			        if(!parentInfo) parentInfo = {};
					var item = this._itemFromProps(keywordArgs, parentInfo);
					delete item.created;
					this._newItems.push(item);
					
					parentInfo.item = parentInfo.parent;
					item.loaded = false;
					item.created = false;
					if(this._notifyOn) this.onNew(item, parentInfo);
					return item;
				},
				getStub: function(/* Object? */ keywordArgs, /*Object?*/ parentInfo) {
					if(!parentInfo) parentInfo = {};
					var item = this._itemFromProps(keywordArgs, parentInfo);
					item.loaded = false;
					
					if(keywordArgs.id) {
						// use setValueByMapping to get around notification APIs and adding this stub
						// to the dirty list
						this.setValueByMapping(item, this.getMapRule("id", item.attrMappings), keywordArgs.id);
					}
					
					delete item._createUri;
					return item;
				},
				getItem: function(/*String*/ id) {
					// summary: Gets an item by its identity directly from the cache if it's 
					// 		present; if it's not present, return a stub which is not loaded but 
					// 		can be used to load the item from the store.
					//		Note - if no item exists with the given id, a stub will still be 
					//		returned but it will be impossible to load from the server.
					var item = this._fromCache(id);
					if(!item) {
						item = this.getStub({id: id});
					}
					return item;
				},
				_itemFromProps: function(/* Object? */ keywordArgs, /*Object?*/ parentInfo) {
					var map = this._prepareNewItemArgs(keywordArgs, parentInfo);
					var createUri = this._getCreateUri(map, parentInfo);
					var xmlDoc = this.getTemplateInstance(this._getTemplate(map, parentInfo), dojo.mixin({parent: ""}, map));
					if(xmlDoc) {
						var result = this._getNodeByXpath(xmlDoc, "//atom:feed");
						if(result.found) {
							result = this._getNodeByXpath(result.value, "./atom:entry");
							if(result.found) xmlDoc = result.value;
						}
						else {
							result = this._getNodeByXpath(xmlDoc, "//atom:entry");
							if(result.found) xmlDoc = result.value;
						}
						
						if(!map.parent) {
							// we don't want the thr:in-reply-to element in the DOM data to send, so remove it
							var inReplyTo = this._getNodeByXpath(xmlDoc, "./thr:in-reply-to").value;
							if(inReplyTo) {
								inReplyTo.parentNode.removeChild(inReplyTo);
								delete inReplyTo;
							}
						}
					}
					// the query.rep stuff is for _getItem to use in order to know the representation
					// of this item
					var item = this._getItem({element: xmlDoc, query: {rep: 'compact'}});
					item._createUri = createUri;
					return item;
				},
				
				_prepareNewItemArgs: function(args, parentInfo) {
					// summary: Used to modify arguments used to create a new item.  Can be overrided by subclasses
					//		to provide custom modifications and preparations for the object map which is used
					//		to instantiate the template.
					// args: Object arguments that are passed into the newItem function for this store
					// parentInfo: Object parentInfo that is passed into the newItem function for this store
					// returns: Object modified arguments map used to instantiate the template
					
					if(parentInfo.parent) {
						// if the parent id wasn't specified in keywordArgs but we got a parent item in the parentInfo
						// object, set the keywordArgs.parent prop to the id of the parent item
						if(!args.parent) args.parent = parentInfo.parent.store.getIdentity(parentInfo.parent);
					}
					else if(args.parent){
						if(dojo.isString(args.parent)) {
							// get the parent item from either cache or as a stub (which is not loaded)
							parentInfo.parent = this.getItem(args.parent);
						}
						else {
							// set the parentInfo.parent to the item, and the args.parent to the ID
							parentInfo.parent = args.parent;
							args.parent = args.parent.store.getIdentity(args.parent);
						}
					}
					// copy the args map
					// mixin the locale since some templates may need it... if it's already supplied
					// then it's just an exact copy of the original
					return dojo.mixin({locale: dojo.locale}, args);
				},
				_getTemplate: function(args, parentInfo) {
					// summary: Used to modify arguments used to create a new item.  Can be overrided by subclasses
					//		to provide custom modifications and preparations for the object map which is used
					//		to instantiate the template.
					// args: Object arguments that are passed into the newItem function for this store
					// parentInfo: Object parentInfo that is passed into the newItem function for this store
					// returns: String template to instantiate with arguments map
					return this.template;
				},
				_getCreateUri: function(args, parentInfo) {
					// summary: Used to modify arguments used to create a new item.  Can be overrided by subclasses
					//		to provide custom modifications and preparations for the object map which is used
					//		to instantiate the template.
					// args: Object arguments that are passed into the newItem function for this store
					// parentInfo: Object parentInfo that is passed into the newItem function for this store
					// returns: String value to use as the uri parameter when creating a resource.  If null
					//		is returned, it is not used at all.  When creating multiple resources, only the value 
					// 		of create uri of the first item in the list of new items will be used when sending
					// 		the single request to create all items. 
					return null;
				},
				_fixModelId: function(id, prefix) {
					if(id.indexOf(prefix + ":oid:") < 0) {
						id = prefix + ":oid:" + id;
					}
					return id;
				},
				
				onSaveComplete: function(/*Array*/ errors) {
					// summary: Callers can attach listeners to this function to get notified when a save operation
					//		on this store has received its last response from the server for all write operations.
					//		This is called before callback handlers to the save function itself are called but after
					// 		all the responses for the requests to the server have returned.
					// errors: Array of any errors that occurred during the save operation.  There can be multiple
					//		errors from a save operation since it is not atomic and may consist of many requests
					//		sent to the server.  Each error response from the server is recorded and kept for handling
					//		in this callback.
				},
				
				save: function(/* Object */ keywordArgs){
					var me = this;
					var numLeft = 0;
					if(this._newItems.length > 0) numLeft++; 
					if(this._dirtyItems.length > 0) numLeft++; 
					numLeft += this._deletedItems.length;
					var errors = new Array();
					
					// if there are any updates to be made, this is called once for the entire batch of updates
					// if there are any creates to be made, this is called once for the entire batch of creates
					// if there are any deletes to be made, this is called once per each delete
					var callbackfn = function(obj, isNew, data, ioArgs) {
						if(data) {
							if(data instanceof Error) {
								errors.push(data);
							}
							else if(isNew) {
								if(dojo.isIE) data = com.ibm.domUtilities.docFromString(data);
								var entries = me._getNodesByXpath(data, "./atom:feed/atom:entry").value;
								for(var i = 0; i < entries.length; i++) {
									obj[i].element = entries[i];
									me._replaceItemInCache(obj[i]);
									obj[i].created = true;
									obj[i]._onCreate();
								}
							}
						}
						
						if(--numLeft == 0) {
							// notify listeners that we've received all our responses
							me.onSaveComplete(errors);
							// only execute the onComplete or onError handler once at the end
							// we don't want to execute the onError handler on the first error
							// since we won't get a roll-up of all the errors afterwards and they will be lost
							if(errors.length > 0) {
								if(keywordArgs && keywordArgs.onError) { 
									keywordArgs.onError.call(keywordArgs.scope ? keywordArgs.scope : dojo.global, errors);
								} else { 
									dojo.forEach(errors, function(error){
										var message = error.message;
										var details = error.responseText;
										if(message.match(/\D401/)){ // Portal session not authenticated
											bundle = dojo.i18n.getLocalization("com.ibm.bundles", "Shelf");
											details = message;
											message = bundle["shelf_session_timeout"];
										}
										var statusMessage = new com.ibm.widgets.StatusMessage( "error", message, details );
										dojo.publish("/portal/status",[{message: statusMessage, uid: 'ibmPortalStatusBox'}]);
									});
								}
							}
							else {
								if(keywordArgs && keywordArgs.onComplete) {
									keywordArgs.onComplete.call(keywordArgs.scope ? keywordArgs.scope : dojo.global);
								}
							}
						}
					};
					
					// nothing to do, call onComplete immediately
					if(numLeft == 0) {
						setTimeout(function(){
							if(keywordArgs && keywordArgs.onComplete) { 
								keywordArgs.onComplete.call(keywordArgs.scope ? keywordArgs.scope : dojo.global);
							}
							me.onSaveComplete(errors);
						},1);
					}
					
					/////////////////////////////
					/////// Send Creates ////////
					/////////////////////////////
					if(this._newItems.length > 0) {
						var url = this.url;
						if(url.indexOf("?") < 0) url += "?";
						var createUri = this.getValue(this._newItems[0], "parent");
						if(!createUri) createUri = this._newItems[0]._createUri;
						url += "uri=" + createUri;
						var updateDoc = this.extractMultipleEntryFeed(this._newItems);
						var args = {
							postData: com.ibm.domUtilities.stringFromDoc(updateDoc), 
							url: url,
							content: {},
							headers: {'Content-type': 'application/atom+xml'},
							// when creating multiple Portal Model feed items in a single POST request,
							// they come back in reverse order in which they appear in the POST 
							// body of the request, so reverse the order we expect
							handle: dojo.partial(callbackfn, this._newItems.slice().reverse(), true),
							handleAs: "xml"
						};
						if(dojo.isIE) {
							args.handleAs = "text";
							args.content["ibm.web2.contentType"] = "text/xml";
						}
						
						dojo.rawXhrPost(args);
					}
					/////////////////////////////
					
					/////////////////////////////
					/////// Send Updates ////////
					/////////////////////////////
					if(this._dirtyItems.length > 0) {
						var url = this.url;
						if(url.indexOf("?") < 0) url += "?";
						url += "uri=" + this.getIdentity(this._dirtyItems[0]) + "&mode=merge&rep=empty";
						var updateDoc = this.extractMultipleEntryFeed(this._dirtyItems);
						var args = {
							putData: com.ibm.domUtilities.stringFromDoc(updateDoc), 
							url: url,
							content: {},
							headers: {'Content-type': 'application/atom+xml'},
							handle: dojo.partial(callbackfn, this._dirtyItems.slice(), false),
							handleAs: "xml"
						};
						if(dojo.isIE) {
							args.handleAs = "text";
							args.content["ibm.web2.contentType"] = "text/xml";
						}
						
						dojo.rawXhrPut(args);
					}
					/////////////////////////////
					
					/////////////////////////////
					/////// Send Deletes ////////
					/////////////////////////////
					dojo.forEach(this._deletedItems, function(item) {
						me._removeItem(item, dojo.partial(callbackfn, item, false));
					});
					/////////////////////////////
					
					// disable notification while persist operations are taking place, then turn
					// it back on
					this._notifyOn = false;
					this.inherited(arguments);
					this._notifyOn = true;
				},
				
				_removeItem: function(/*Item*/ item, /*Function?*/callbackfn) {
					var url = this.url;
					if(url.indexOf("?") < 0) url += "?";
					url += "uri=" + item.id + "&rep=empty";
					var args = {
						url: url,
						content: {},
						handle: callbackfn,
						handleAs: "xml"
					};
					if(dojo.isIE) {
						args.handleAs = "text";
						args.content["ibm.web2.contentType"] = "text/xml";
					}
					
					dojo.xhrDelete(args);
				}
			}
);

(function(){
	var namespaces = com.ibm.portal.data._PortalModelStore.prototype.namespaces;
	var nsDecl = new Array();
	
	for(var prefix in namespaces) {
		nsDecl.push('xmlns:', prefix, '="', namespaces[prefix], '" ');
	}
	dojo.extend(com.ibm.portal.data._PortalModelStore, {
		_feed:	 	com.ibm.domUtilities.docFromString(['<?xml version="1.0" encoding="UTF-8"?>',
					'<atom:feed ',
						nsDecl.join(''),
						'>',
						'<atom:author>',
							'<atom:name>IBM WebSphere Portal/6.1</atom:name>',
						'</atom:author>',
						'<atom:title>IBM WebSphere Portal Model Feed</atom:title>',
						'<atom:link href="." rel="self" type="application/atom+xml"/>',
					'</atom:feed>'].join(''))
	}
);
})();


dojo.declare( "com.ibm.portal.data._PortalModelItem",
			com.ibm.data.AtomEntryItem, 
			{
				// namespaces: Map
				//		Map of namespaces used by the Portal Model SPI feeds
				namespaces: dojo.mixin({}, com.ibm.portal.data._PortalModelStore.prototype.namespaces),
				
		        attrMappings: dojo.mixin({},com.ibm.data.AtomEntryItem.prototype.attrMappings, {
					uniqueName: {xpath: "./atom:id[@portal:uniquename]", targetName: "portal:uniquename", type: "attr", setter: 
						function(item, rule, value){
							var elem = this._createNSElement(item.element.ownerDocument, "atom:id");
							this._setAttribute(elem, rule.targetName, value);
							item.element.appendChild(elem);
							return true;
						}
					},
					parent: {xpath: "./thr:in-reply-to", targetName: "ref", type: "attr", setter: 
						function(item, rule, value){
							var elem = this._createNSElement(item.element.ownerDocument, "thr:in-reply-to");
							this._setAttribute(elem, rule.targetName, value);
							item.element.appendChild(elem);
							return true;
						}
					},
					parentURI: {xpath: "./thr:in-reply-to", targetName: "href", type: "attr", setter: 
						function(item, rule, value){
							var elem = this._createNSElement(item.element.ownerDocument, "thr:in-reply-to");
							this._setAttribute(elem, rule.targetName, value);
							item.element.appendChild(elem);
							return true;
						}
					},
					
					// next and nextURI are used to reorder nodes in a list of children of a node in a tree model
					// not all portal models are tree models and thus not all use these (ex. Portlet Model)
					next: {xpath: "./atom:link[@portal:rel='next']", targetName: "portal:uri", type: "attr", setter: 
						function(item, rule, value){
							var attrs = {
								"portal:rel": "next", 
								"rel": "related",
								"type": "application/atom+xml"
							};
							attrs[rule.targetName] = value;
							var elem = this._createNSElement(item.element.ownerDocument, "atom:link", attrs);
							item.element.appendChild(elem);
							return true;
						}
					},
					nextURI: {xpath: "./atom:link[@portal:rel='next']", targetName: "href", type: "attr", setter: 
						function(item, rule, value){
							var attrs = {
								"portal:rel": "next", 
								"rel": "related",
								"type": "application/atom+xml"
							};
							attrs[rule.targetName] = value;
							var elem = this._createNSElement(item.element.ownerDocument, "atom:link", attrs);
							item.element.appendChild(elem);
							return true;
						}
					},
					childrenURI: {xpath: "./atom:link[@rel='replies']", targetName: "href", type: "attr", setter: 
						function(item, rule, value){
							var elem = this._createNSElement(item.element.ownerDocument, "atom:link");
							this._setAttribute(elem, "rel", "replies");
							this._setAttribute(elem, rule.targetName, value);
							item.element.appendChild(elem);
							return true;
						}
					},
					
					// localizedTitle and localizedDescription are parameterized by language code; not all Portal models use them
					localizedTitle$: {xpath: "./atom:content/*[model:title]/model:title/base:nls-string[" + (dojo.isIE ? "@xml:lang = '${0}'": "lang('${0}')") + "]", targetName: "textContent", type: "node", locale: "${0}", setter: 
						function(item, rule, value){
							var result = this._getNodeByXpath(item.element, "./atom:content/*");
							var modelNode = result.value;
							var node = this._getNodeByXpath(modelNode, "./model:title").value;
							if(!node) {
								node = this._createNSElement(item.element.ownerDocument, "model:title");
								modelNode.appendChild(node);
							}
							// here we're using the locale specified by the parameterized rule that was passed by the caller
							var elem = this._createNSElement(item.element.ownerDocument, "base:nls-string", {"xml:lang": rule.locale});
							this._setNodeProp(elem, rule.targetName, value);
							node.appendChild(elem);
							return true;
						}
					},
					localizedDescription$: {xpath: "./atom:content/*[model:description]/model:description/base:nls-string[" + (dojo.isIE ? "@xml:lang = '${0}'": "lang('${0}')") + "]", targetName: "textContent", type: "node", locale: "${0}", setter: 
						function(item, rule, value){
							var result = this._getNodeByXpath(item.element, "./atom:content/*");
							var modelNode = result.value;
							var node = this._getNodeByXpath(modelNode, "./model:description").value;
							if(!node) {
								node = this._createNSElement(item.element.ownerDocument, "model:description");
								modelNode.appendChild(node);
							}
							// here we're using the locale specified by the parameterized rule that was passed by the caller
							var elem = this._createNSElement(item.element.ownerDocument, "base:nls-string", {"xml:lang": rule.locale});
							this._setNodeProp(elem, rule.targetName, value);
							node.appendChild(elem);
							return true;
						}
					}
				}),
		        _makeModifiable: function() {
					// summary: Modifies the element of this item to become modifiable
					//		for writing back to the server.  Subclasses can override this
					//		to do things like prune an item to only include necessary information
					//		for updates and nothing more.  This is called by backup once after
					//		backing up the original element first.  After this returns,
					//		this item's element may have been modified.  Any queries against
					//		this item should now include logic to check the backup copy as well
					//		if a query doesn't return anything as it could have been deleted by
					//		this function.  Care should be taken to ensure that the query result
					//		specifically detects if nothing was found or if the actual value was
					//		null or empty.
					
					var toRemove = ["./thr:in-reply-to"];
					dojo.forEach(toRemove, function(expr) {
						var nodes = this._getNodesByXpath(this.element, expr).value;
						dojo.forEach(nodes, function(node) {
							node.parentNode.removeChild(node);
						}, this);
					}, this);
					
					this.inherited(arguments);
				}
			}
);

				

}

if(!dojo._hasResource["com.ibm.portal.data.ContentModelStore"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.portal.data.ContentModelStore"] = true;
dojo.provide( "com.ibm.portal.data.ContentModelStore" );

dojo.require( "com.ibm.portal.data._PortalModelStore" );

dojo.declare( "com.ibm.portal.data.ContentModelStore",
			com.ibm.portal.data._PortalModelStore, 
			{
				// itemClass: String the class used to represent items of this store
				itemClass: "com.ibm.portal.data.ContentModelItem",
				
				constructor: function( /*Map*/ args ) {
					// summary: Creates a new instance of a com.ibm.portal.data.ContentModelStore
					// args: Map
					this._features['dojo.data.api.Write'] = true;	// adding Write support for this implementation
					this._features['dojo.data.api.Notification'] = true; // adding Notification support for this implementation
					
					// URL basic format - /wps/[my]contenthandler[/vpmapping]?(uri=model-uri)+(&mode=verb)?(&name=value)*
				},
				
				/********************************/
				/**                            **/
				/**    Extensions used by      **/
				/**    functions implementing  **/
				/**    dojo.data.api.Write     **/
				/**                            **/
				/**                            **/
				/********************************/
				_prepareNewItemArgs: function(args, parentInfo) {
					var map = this.inherited(arguments);
					
					// Disabled popup checkbox for checking private or public
					/*if(map.isPrivate == "on"){
						map.isPrivate = "true";
					}else{
						map.isPrivate = "false";
					}*/
					
					// if layout is null, set to empty string
					if(!map.layout){
						map.layout = "";
					}	
						
					return map;
				},
				_getTemplate: function(args, parentInfo) {
					return this.template;
				}
			}
);

(function(){
	var namespaces = com.ibm.portal.data.ContentModelStore.prototype.namespaces;
	var nsDecl = new Array();
	
	for(var prefix in namespaces) {
		nsDecl.push('xmlns:', prefix, '="', namespaces[prefix], '" ');
	}
	dojo.extend(com.ibm.portal.data.ContentModelStore, {
		template: 	['<?xml version="1.0" encoding="UTF-8"?>',
					'<atom:feed ',
						nsDecl.join(''),
						'>',
						'<atom:author>',
							'<atom:name>IBM WebSphere Portal/6.1</atom:name>',
						'</atom:author>',
						'<atom:title>IBM WebSphere Portal Model Feed</atom:title>',
						'<atom:link href="." rel="self" type="application/atom+xml"/>',
						'<atom:entry>',
							'<atom:title>${title}</atom:title>',
							'<atom:id></atom:id>',
							'<atom:content type="application/xml">',
								'<model:content-page creation-context:private="${isPrivate}">',
									'<model:supported-markup>html</model:supported-markup>',
									'<model:title>',
									'<base:nls-string xml:lang="${locale}">${title}</base:nls-string>',
									'</model:title>',
									'<model:metadata  name="layout">',
									'<base:value xsi:type="base:String" value="${layout}"/>',
									'</model:metadata>',
									'<model:metadata  name="com.ibm.portal.friendly.name">',
									'<base:value xsi:type="base:String" value="${friendlyURL}"/>',
									'</model:metadata>',
								'</model:content-page>',
							'</atom:content>',
							'<thr:in-reply-to portal:uri="${parent}" href="${parent}" ref="${parent}" type="application/atom+xml"/>',
						'</atom:entry>',
					'</atom:feed>'].join('')
	}
);
})();


dojo.declare( "com.ibm.portal.data.ContentModelItem",
			com.ibm.portal.data._PortalModelItem,
			{
				// summary: Helper class used to extend attrMappings for additional attributes provided by
				// 		content model items
				attrMappings: dojo.mixin({}, com.ibm.portal.data._PortalModelItem.prototype.attrMappings, {
					layout: {xpath: "./atom:link[@portal:rel='layout']", targetName: "portal:uri", type: "attr", setter: 
						function(item, rule, value){
							var attrs = {"portal:rel": "layout"};
							attrs[rule.targetName] = value;
							var elem = this._createNSElement(item.element.ownerDocument, "atom:link", attrs);
							item.element.appendChild(elem);
							return true;
						}
					},
					layoutURI: {xpath: "./atom:link[@portal:rel='layout']", targetName: "href", type: "attr", setter: 
						function(item, rule, value){
							var attrs = {"portal:rel": "layout"};
							attrs[rule.targetName] = value;
							var elem = this._createNSElement(item.element.ownerDocument, "atom:link", attrs);
							item.element.appendChild(elem);
							return true;
						}
					},
					theme: {xpath: "./atom:link[@portal:rel='theme']", targetName: "portal:uri", type: "attr", setter: 
						function(item, rule, value){
							var attrs = {"portal:rel": "theme"};
							attrs[rule.targetName] = value;
							var elem = this._createNSElement(item.element.ownerDocument, "atom:link", attrs);
							item.element.appendChild(elem);
							return true;
						}
					},
					contextMenu: {xpath: "./atom:link[@portal:rel='contextMenu']", targetName: "portal:uri", type: "attr", setter: 
						function(item, rule, value){
							var attrs = {"portal:rel": "contextMenu"};
							attrs[rule.targetName] = value;
							var elem = this._createNSElement(item.element.ownerDocument, "atom:link", attrs);
							item.element.appendChild(elem);
							return true;
						}
					},
					contextMenuURI: {xpath: "./atom:link[@portal:rel='contextMenu']", targetName: "href", type: "attr", setter: 
						function(item, rule, value){
							var attrs = {"portal:rel": "contextMenu"};
							attrs[rule.targetName] = value;
							var elem = this._createNSElement(item.element.ownerDocument, "atom:link", attrs);
							item.element.appendChild(elem);
							return true;
						}
					},
					shareable: {xpath: "./atom:content/*[model:shareable]/model:shareable", targetName: "textContent", type: "node", setter: 
						function(item, rule, value){
							var nodes = this._getNodesByXpath(item.element, "./atom:content/*").value;
							if(!nodes || nodes.length == 0) return false;
							var elem = this._createNSElement(item.element.ownerDocument, "model:shareable");
							this._setNodeProp(elem, rule.targetName, value);
							nodes[0].appendChild(elem);
							return true;
						}
					},
					bookmarkable: {xpath: "./atom:content/*[model:bookmarkable]/model:bookmarkable", targetName: "textContent", type: "node", setter: 
						function(item, rule, value){
							var nodes = this._getNodesByXpath(item.element, "./atom:content/*").value;
							if(!nodes || nodes.length == 0) return false;
							var elem = this._createNSElement(item.element.ownerDocument, "model:bookmarkable");
							this._setNodeProp(elem, rule.targetName, value);
							nodes[0].appendChild(elem);
							return true;
						}
					},
					contentNodeType: {xpath: "./atom:content/*", targetName: dojo.isIE ? "baseName" : "localName", type: "node", setter: 
						function(item, rule, value){
							// don't support changing a content node's type
							return false;
						}
					},
					internalRef: {xpath: "./atom:link[@portal:rel='internal-url']", targetName: "portal:uri", type: "attr"},
					internalURL: {xpath: "./atom:link[@portal:rel='internal-url']", targetName: "href", type: "attr"},
					externalURL: {xpath: "./atom:link[@portal:rel='external-url']", targetName: "href", type: "attr"},
					metadata$: {xpath: "./atom:content/*/model:metadata[@name='${0}']/base:value", targetName: "value", type: "attr", mdname: "${0}", setter: 
						function(item, rule, value){
							var result = this._getNodeByXpath(item.element, "./atom:content/*");
							var modelNode = result.value;
							var node = this._getNodeByXpath(modelNode, "./model:metadata[@name='" + rule.mdname + "']").value;
							if(!node) {
								node = this._createNSElement(item.element.ownerDocument, "model:metadata");
								this._setAttribute(node, "name", rule.mdname);
								modelNode.appendChild(node);
							}
							var attrs = {"xsi:type": "base:String"};
							attrs[rule.targetName] = value;
							var elem = this._createNSElement(item.element.ownerDocument, "base:value", attrs);
							node.appendChild(elem);
							return true;
						}
					}
				}),
		        _makeModifiable: function() {
					// summary: Modifies the element of this item to become modifiable
					//		for writing back to the server.  Subclasses can override this
					//		to do things like prune an item to only include necessary information
					//		for updates and nothing more.  This is called by backup once after
					//		backing up the original element first.  After this returns,
					//		this item's element may have been modified.  Any queries against
					//		this item should now include logic to check the backup copy as well
					//		if a query doesn't return anything as it could have been deleted by
					//		this function.  Care should be taken to ensure that the query result
					//		specifically detects if nothing was found or if the actual value was
					//		null or empty.
					var node = this._getNodeByXpath(this.element, "./atom:content/*").value;
					if(node) {
						while(node.childNodes.length > 0) {
							node.removeChild(node.childNodes[0]);
						}
					}
					
					var toRemove = ["./atom:link"];
					dojo.forEach(toRemove, function(expr){
						var nodes = this._getNodesByXpath(this.element, expr).value;
						dojo.forEach(nodes, function(node){
							node.parentNode.removeChild(node);
						}, this);
					}, this);
					
					this.inherited(arguments);
				}
			}
);

}

if(!dojo._hasResource["com.ibm.portal.data.LayoutModelStore"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.portal.data.LayoutModelStore"] = true;
dojo.provide( "com.ibm.portal.data.LayoutModelStore" );

dojo.require( "com.ibm.portal.data._PortalModelStore" );

dojo.declare( "com.ibm.portal.data.LayoutModelStore",
			com.ibm.portal.data._PortalModelStore, 
			{
				attrMappings: dojo.mixin({}, com.ibm.portal.data._PortalModelStore.prototype.attrMappings,
					{
						allPortletsAllowed: {xpath: "./model:allPortletsAllowed", targetName: "textContent", type: "node"},
						wmURI: {xpath: "./atom:link[@rel='related']", targetName: "href", type: "attr"}
					}
				),
				
				// itemClass: String the class used to represent items of this store
				itemClass: "com.ibm.portal.data.LayoutModelItem",

				constructor: function( /*Map*/ args ) {
					// summary: Creates a new instance of a com.ibm.portal.data.LayoutModelStore
					// args: Map
					this._features['dojo.data.api.Write'] = true;	// adding Write support for this implementation
					this._features['dojo.data.api.Notification'] = true; // adding Notification support for this implementation
					
					// URL basic format - /wps/[my]contenthandler[/vpmapping]?(uri=model-uri)+(&mode=verb)?(&name=value)*
				},

				/********************************/
				/**                            **/
				/**    Extensions used by      **/
				/**    functions implementing  **/
				/**    dojo.data.api.Write     **/
				/**                            **/
				/**                            **/
				/********************************/
				_prepareNewItemArgs: function(args, parentInfo) {
					var map = this.inherited(arguments);
					
					// this code below determines if we're creating a layout node whose parent is another layout
					// node, or if we're creating a layout node which will be the root layout node of a page,
					// the map.parent will have a layoutId part if we're creating a child of an existing layout node,
					// but if it does not, then we only have a pageId and we will want to remove the thr:in-reply-to
					// element from the data that's sent to the server (so that no parent is specified)
					var compParts = this._extractCompositeIds(map.parent);
					if(compParts.pageId) {
						map.pageId = compParts.pageId;
					}
					if(compParts.layoutId) {
						// the parent is a layout node
						map.layoutId = compParts.layoutId;
					}
					else {
						// the parent is the page itself, so we're creating a root layout node
						delete map.parent;
					}
					
					if(map.portletId) {
						map.portletId = this._fixModelId(map.portletId, "pm").replace(/\s/g, "%20");
					}
					
					return map;
				},
				_getTemplate: function(args, parentInfo) {
					if(args.portletId) {
						// adding a portlet control to the page
						return this.ptemplate;
					}
					else {
						// just adding a layout node to the page
						return this.ltemplate;
					}
				},
				_getCreateUri: function(args, parentInfo) {
					// if there's no parent, we're creating the root layout node of a page
					if(!args.parent) return "lm:oid:" + args.pageId + "@oid:" + args.pageId;
					else return args.parent;
				},
				_extractCompositeIds: function(/*String*/ compositeId) {
					// summary: Extracts the parts from a composite id consisting of a layout part and a page part.
					if(compositeId.indexOf("lm:") == 0) {
						var lid = compositeId.substring(compositeId.indexOf("lm:oid:") + 7, compositeId.indexOf("@"));
						return {layoutId: lid, pageId: compositeId.substring(compositeId.lastIndexOf("@oid:") + 5)};
					}
					else if(compositeId.indexOf("cm:") == 0) {
						return {layoutId: null, pageId: compositeId.substring(compositeId.lastIndexOf(":") + 1)};
					}
					else {
						return {layoutId: null, pageId: compositeId};
					}
				}
			}
);


(function(){
	var namespaces = com.ibm.portal.data.LayoutModelStore.prototype.namespaces;
	var nsDecl = new Array();
	
	for(var prefix in namespaces) {
		nsDecl.push('xmlns:', prefix, '="', namespaces[prefix], '" ');
	}
	dojo.extend(com.ibm.portal.data.LayoutModelStore, {
		ltemplate: 	['<?xml version="1.0" encoding="UTF-8"?>',
					'<atom:feed ',
						nsDecl.join(''),
						'>',
						'<atom:author>',
							'<atom:name>IBM WebSphere Portal/6.1</atom:name>',
						'</atom:author>',
						'<atom:title>IBM WebSphere Portal Model Feed</atom:title>',
						'<atom:link href="." rel="self" type="application/atom+xml"/>',
						'<atom:entry>',
							'<atom:title>lm:oid:${pageId}@oid:${pageId}</atom:title>',
							'<atom:id>lm:oid:${pageId}</atom:id>',
							'<atom:content type="application/xml">',
								'<model:layout-container/>',
							'</atom:content>',
							'<thr:in-reply-to portal:uri="${parent}" href="${parent}" ref="${parent}" type="application/atom+xml"/>',
						'</atom:entry>',
					'</atom:feed>'].join('')
	});
	
	dojo.extend(com.ibm.portal.data.LayoutModelStore, {
		ptemplate: 	['<?xml version="1.0" encoding="UTF-8"?>',
					'<atom:feed ',
						nsDecl.join(''),
						'>',
						'<atom:author>',
							'<atom:name>IBM WebSphere Portal/6.1</atom:name>',
						'</atom:author>',
						'<atom:title>IBM WebSphere Portal Model Feed</atom:title>',
						'<atom:link href="." rel="self" type="application/atom+xml"/>',
						'<atom:entry>',
							'<atom:title>lm:oid:${pageId}@oid:${pageId}</atom:title>',
							'<atom:id>lm:oid:${pageId}</atom:id>',
							'<atom:content type="application/xml">',
								'<model:layout-control creation-context:portlet-definition="${portletId}">',
									'<model:deletable>true</model:deletable>', 
					                '<model:deletableFlag>true</model:deletableFlag>',
					                '<model:modifiable>true</model:modifiable>', 
					                '<model:modifiableFlag>true</model:modifiableFlag>',
								'</model:layout-control>',
							'</atom:content>',
							'<thr:in-reply-to portal:uri="${parent}" href="${parent}" ref="${parent}" type="application/atom+xml"/>',
						'</atom:entry>',
					'</atom:feed>'].join('')
	});
})();


dojo.declare( "com.ibm.portal.data.LayoutModelItem",
			com.ibm.portal.data._PortalModelItem,
			{
				// summary: Helper class used to extend attrMappings for additional attributes provided by
				// 		layout model items
				attrMappings: dojo.mixin({}, com.ibm.portal.data._PortalModelItem.prototype.attrMappings, {
					contextMenu: {xpath: "./atom:link[@portal:rel='contextMenu']", targetName: "portal:uri", type: "attr"},
					contextMenuURI: {xpath: "./atom:link[@portal:rel='contextMenu']", targetName: "href", type: "attr"},
					skin: {xpath: "./atom:link[@portal:rel='skin']", targetName: "portal:uri", type: "attr", setter: 
						function(item, rule, value){
							var elem = this._createNSElement(item.element.ownerDocument, "atom:link");
							this._setAttribute(elem, rule.targetName, value);
							item.element.appendChild(elem);
							return true;
						}
					},
					skinUniqueName: {xpath: "./atom:link[@portal:rel='skin']", targetName: "portal:uniquename", type: "attr", setter:
						function(item, rule, value){
							var elem = this._createNSElement(item.element.ownerDocument, "atom:link");
							this._setAttribute(elem, rule.targetName, value);
							item.element.appendChild(elem);
							return true;
						}
					},
					portlet: {xpath: "./atom:link[@portal:rel='portlet']", targetName: "portal:uri", type: "attr"},
					portletURI: {xpath: "./atom:link[@portal:rel='portlet']", targetName: "href", type: "attr"},
					portletDefinition: {xpath: "./atom:link[@portal:rel='portlet-definition']", targetName: "portal:uri", type: "attr"},
					portletDefinitionURI: {xpath: "./atom:link[@portal:rel='portlet-definition']", targetName: "href", type: "attr"},
					templateName: {xpath: "./atom:content/*[model:templateName]/model:templateName", targetName: "textContent", type: "node"},
					modifiable: {xpath: "./atom:content/*[model:modifiable]/model:modifiable", targetName: "textContent", type: "node"},
					modifiableFlag: {xpath: "./atom:content/*[model:modifiableFlag]/model:modifiableFlag", targetName: "textContent", type: "node"},
					deletable: {xpath: "./atom:content/*[model:deletable]/model:deletable", targetName: "textContent", type: "node"},
					deletableFlag: {xpath: "./atom:content/*[model:deletableFlag]/model:deletableFlag", targetName: "textContent", type: "node"},
					containerChild: {xpath: "./atom:content/*[model:containerChild]/model:containerChild", targetName: "textContent", type: "node"},
					controlChild: {xpath: "./atom:content/*[model:controlChild]/model:controlChild", targetName: "textContent", type: "node"}
				}),
		        _makeModifiable: function() {
					// summary: Modifies the element of this item to become modifiable
					//		for writing back to the server.  Subclasses can override this
					//		to do things like prune an item to only include necessary information
					//		for updates and nothing more.  This is called by backup once after
					//		backing up the original element first.  After this returns,
					//		this item's element may have been modified.  Any queries against
					//		this item should now include logic to check the backup copy as well
					//		if a query doesn't return anything as it could have been deleted by
					//		this function.  Care should be taken to ensure that the query result
					//		specifically detects if nothing was found or if the actual value was
					//		null or empty.
					var node = this._getNodeByXpath(this.element, "./atom:content/*").value;
					if(node) {
						while(node.childNodes.length > 0) {
							node.removeChild(node.childNodes[0]);
						}
					}
					
					var toRemove = ["./atom:link"];
					dojo.forEach(toRemove, function(expr){
						var nodes = this._getNodesByXpath(this.element, expr).value;
						dojo.forEach(nodes, function(node){
							node.parentNode.removeChild(node);
						}, this);
					}, this);
					
					this.inherited(arguments);
				}
			}
);

}

if(!dojo._hasResource["com.ibm.portal.data.PortletModelStore"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.portal.data.PortletModelStore"] = true;
dojo.provide( "com.ibm.portal.data.PortletModelStore" );

dojo.require( "com.ibm.portal.data._PortalModelStore" );

dojo.declare( "com.ibm.portal.data.PortletModelStore",
			com.ibm.portal.data._PortalModelStore, 
			{
				// itemClass: String the class used to represent items of this store
				itemClass: "com.ibm.portal.data.PortletModelItem",
				
				constructor: function( /*Map*/ args ) {
					// summary: Creates a new instance of a com.ibm.portal.data.PortletModelStore
					// args: Map
					this._features['dojo.data.api.Write'] = true;	// adding Write support for this implementation
					this._features['dojo.data.api.Notification'] = true; // adding Notification support for this implementation
					
					// URL basic format - /wps/[my]contenthandler[/vpmapping]?(uri=model-uri)+(&mode=verb)?(&name=value)*
				},
				handleConstructs: function(/*DOMNode*/ node, /*String*/ prop) {
					switch(prop) {
						case "PortletPreferenceConstruct": return new com.ibm.portal.data.PortletPreferenceConstruct(node);
						default: return this.inherited(arguments);
					}
				},
				
				/********************************/
				/**                            **/
				/**    Extensions used by      **/
				/**    functions implementing  **/
				/**    dojo.data.api.Write     **/
				/**                            **/
				/**                            **/
				/********************************/
				_getTemplate: function(args, parentInfo) {
					switch(args.type) {
						case "portlet-entity": 
							return this.entityTemplate;
						case "portlet": 
							return this.portletTemplate;
						case "portlet-definition": 
							return this.definitionTemplate;
						default: 
							return this.entityTemplate;
					}
				},
				_getCreateUri: function(args, parentInfo) {
					return args.parent;
				}
			}
);

(function(){
	var namespaces = com.ibm.portal.data.PortletModelStore.prototype.namespaces;
	var nsDecl = new Array();
	
	for(var prefix in namespaces) {
		nsDecl.push('xmlns:', prefix, '="', namespaces[prefix], '" ');
	}
	
	// relationship model:
	//		portlet-window -> [private portlet-entity ->] shared portlet-entity -> 
	// 		portlet-definition -> portlet -> web-application
	// 
	// private portlet-entity is not there by default but can be created as a child
	// of the shared portlet-entity
	
	dojo.extend(com.ibm.portal.data.PortletModelStore, {
		entityTemplate: 	['<?xml version="1.0" encoding="UTF-8"?>',
					'<atom:feed ',
						nsDecl.join(''),
						'>',
						'<atom:author>',
							'<atom:name>IBM WebSphere Portal/6.1</atom:name>',
						'</atom:author>',
						'<atom:title>IBM WebSphere Portal Model Feed</atom:title>',
						'<atom:link href="." rel="self" type="application/atom+xml"/>',
						'<atom:entry>',
							'<atom:title></atom:title>',
							'<atom:id></atom:id>',
							'<atom:content type="application/xml">',
								'<model:portlet-entity/>',
							'</atom:content>',
							'<thr:in-reply-to portal:uri="${parent}" href="${parent}" ref="${parent}" type="application/atom+xml"/>',
						'</atom:entry>',
					'</atom:feed>'].join('')
	});
	
	dojo.extend(com.ibm.portal.data.PortletModelStore, {
		definitionTemplate: 	['<?xml version="1.0" encoding="UTF-8"?>',
					'<atom:feed ',
						nsDecl.join(''),
						'>',
						'<atom:author>',
							'<atom:name>IBM WebSphere Portal/6.1</atom:name>',
						'</atom:author>',
						'<atom:title>IBM WebSphere Portal Model Feed</atom:title>',
						'<atom:link href="." rel="self" type="application/atom+xml"/>',
						'<atom:entry>',
							'<atom:title>${title}</atom:title>',
							'<atom:summary>${summary}</atom:summary>',
							'<atom:id></atom:id>',
							'<atom:content type="application/xml">',
								'<model:portlet-definition/>',
							'</atom:content>',
							'<thr:in-reply-to portal:uri="${parent}" href="${parent}" ref="${parent}" type="application/atom+xml"/>',
						'</atom:entry>',
					'</atom:feed>'].join('')
	});
	
	dojo.extend(com.ibm.portal.data.PortletModelStore, {
		portletTemplate: 	['<?xml version="1.0" encoding="UTF-8"?>',
					'<atom:feed ',
						nsDecl.join(''),
						'>',
						'<atom:author>',
							'<atom:name>IBM WebSphere Portal/6.1</atom:name>',
						'</atom:author>',
						'<atom:title>IBM WebSphere Portal Model Feed</atom:title>',
						'<atom:link href="." rel="self" type="application/atom+xml"/>',
						'<atom:entry>',
							'<atom:title>${title}</atom:title>',
							'<atom:id></atom:id>',
							'<atom:content type="application/xml">',
								'<model:portlet/>',
							'</atom:content>',
							'<thr:in-reply-to portal:uri="${parent}" href="${parent}" ref="${parent}" type="application/atom+xml"/>',
						'</atom:entry>',
					'</atom:feed>'].join('')
	});

})();


dojo.declare( "com.ibm.portal.data.PortletModelItem",
			com.ibm.portal.data._PortalModelItem,
			{
				// summary: Helper class used to extend attrMappings for additional attributes provided by
				// 		portlet model items
				attrMappings: dojo.mixin({}, com.ibm.portal.data._PortalModelItem.prototype.attrMappings, {
					initParameters: {xpath: "./atom:content/model:portlet/model:initparameters", targetName: "textContent", type: "node"},
					supportedModes: {xpath: "./atom:content/model:portlet/model:supports/model:portlet-mode", targetName: "textContent", type: "node"},
					supportedMarkups: {xpath: "./atom:content/model:portlet/model:supports/model:mime-type", targetName: "textContent", type: "node"},
					contextRoot: {xpath: "./atom:content/model:web-application/model:context-root", targetName: "textContent", type: "node"},
					modelType: {xpath: "./atom:content/*", targetName: dojo.isIE ? "baseName" : "localName", type: "node"},
					
					// the most common attribute for this store, provides read/write operations for portlet preferences on items
					// that support it
					preferenceValue$: {xpath: "./atom:content/*[model:portletpreferences]/model:portletpreferences[name=${0}]", targetName: "PortletPreferenceConstruct", type: "node", key: "${0}", setter: 
						function(item, rule, value) {
							var result = this._getNodeByXpath(item.element, "./atom:content/*");
							if(!result.found) return false;
							var modelNode = result.value;
							var type = this._getNodeProp(modelNode, dojo.isIE ? "baseName" : "localName");
							// only create preferences on portlet-entity and portlet-definition items
							if(type != "portlet-entity" && type != "portlet-definition") return false;
							var prefsNode = this._createNSElement(item.element.ownerDocument, "model:portletpreferences",
								{
									"name": rule.key,
									"read-only": false
								});
							modelNode.appendChild(prefsNode);
							if(rule.multiValued) {
								dojo.forEach(value, function(singleValue){
									prefsNode.appendChild(this._createNSElement(item.element.ownerDocument, "base:value",
										{
											"xsi:type": "base:String",
											"value": singleValue
										}
									));
								}, this);
							}
							else {
								prefsNode.appendChild(this._createNSElement(item.element.ownerDocument, "base:value",
									{
										"xsi:type": "base:String",
										"value": value
									}
								));
							}
							return true;
						}
					},
					preferenceReadOnly$: {xpath: "./atom:content/*[model:portletpreferences]/model:portletpreferences[name=${0}]", targetName: "read-only", type: "attr", key: "${0}"},
					
					// provide a read-only construct for easily accessing all the portlet preferences on the current item
					preferences: {xpath: "./atom:content/*[model:portletpreferences]/model:portletpreferences", targetName: "PortletPreferenceConstruct", type: "node"}
				}),
				_makeModifiable: function() {
					// summary: Modifies the element of this item to become modifiable
					//		for writing back to the server.  Subclasses can override this
					//		to do things like prune an item to only include necessary information
					//		for updates and nothing more.  This is called by backup once after
					//		backing up the original element first.  After this returns,
					//		this item's element may have been modified.  Any queries against
					//		this item should now include logic to check the backup copy as well
					//		if a query doesn't return anything as it could have been deleted by
					//		this function.  Care should be taken to ensure that the query result
					//		specifically detects if nothing was found or if the actual value was
					//		null or empty.
					var node = this._getNodeByXpath(this.element, "./atom:content/*").value;
					if(node) {
						while(node.childNodes.length > 0) {
							node.removeChild(node.childNodes[0]);
						}
					}
					
					var toRemove = ["./atom:link"];
					dojo.forEach(toRemove, function(expr){
						var nodes = this._getNodesByXpath(this.element, expr).value;
						dojo.forEach(nodes, function(node){
							node.parentNode.removeChild(node);
						}, this);
					}, this);
					
					this.inherited(arguments);
				}
			}
);

dojo.declare( "com.ibm.portal.data.PortletPreferenceConstruct",
			com.ibm.data._XmlConstruct,
			{
				namespaces: dojo.mixin({}, com.ibm.portal.data.PortletModelStore.prototype.namespaces),
				
		        constructor: function(node) {
		        	this.root = node;
		        },
		        getName: function() {
		        	return this._getAttribute(this.root, "name");
		        },
		        isReadOnly: function() {
		        	return this._getAttribute(this.root, "read-only") == "true";
		        },
		        getValue: function() {
		        	return this._getAttrByXpath(this.root, "./base:value", "value").value;
		        },
		        getValues: function() {
		        	return this._getAttrsByXpath(this.root, "./base:value", "value").value;
		        },
		        toString: function() {
		        	return "<" + this.__getClassName() + " name='" + this.getName() + "'>"
		        }
			}
);

}

if(!dojo._hasResource["com.ibm.data.DataTreeModel"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.data.DataTreeModel"] = true;
dojo.provide( "com.ibm.data.DataTreeModel" );

// This module provides the API for a data model that corresponds to any data set that contains
// parent-child relationships that can be represented as a tree.  It's exactly the same as the
// model API that's used by dijit.Tree with some functions already implemented for ease of use.
// As a result, any implementation of this API can be used as the model to a dijit.Tree widget
// or any other widget that uses a data model as its backend service provider.  This data API
// also adds some additional constraints and extension points that implementations should support
// in addition to the model API that's used by dijit.Tree, but by no means breaks the API or
// deviates from the required functions of the dijit model API.  One such addition is the
// support for additional query parameters that can be specified when instantiating a model
// that are always appended to any request to the server for data.  This allows particular instances
// of a data model to include metadata information that would not otherwise be included by certain
// data services that support it.

dojo.declare( "com.ibm.data.DataTreeModel",
			null,
			{
				// store: The dojo.data.Read/Write implementation 
				store: null,
				
				// query: The query used to retrieve the root item for this model
				query: null,
				
				// root: The root item of this model
				root: null,
				
				// addQueryParams: Object additional query parameters that should be appended
				//		to any request for items from the back end.  Is useful for getting
				// 		additional information such as metadata for each item from a data service 
				// 		that provides it.
				addQueryParams: null,
				
				constructor: function(args) {
					dojo.mixin(this, args);
					if(!this.addQueryParams) this.addQueryParams = {};
				},
				
				destroy: function() {
				        // summary: destroys this object, releasing connections to the store
				},
				reset: function() {
					// summary: Resets the root of this model to null.
					this.root = null;
				},
				// =======================================================================
				// Methods for traversing hierarchy
				getRoot: function(onItem, onError){
					// summary:
				    //            Calls onItem with the root item for the tree, possibly a fabricated item.
				    //			  Any request for data that is sent to the server should also include
				    //			  the request parameters in addQueryParams. 
					//            Throws exception on error.
				},
				mayHaveChildren: function(/*Object*/ item){
				        // summary:
				        //            Tells if an item has or may have children.  Implementing logic here
				        //            avoids showing +/- expando icon for nodes that we know don't have children.
				        //            (For efficiency reasons we may not want to check if an element actually
				        //            has children until user clicks the expando node)
				        
				},
				getChildren: function(/*Object*/ parentItem, /*function(items)*/ onComplete, /*function*/ onError){
				        // summary:
				        // 			  Calls onComplete() with array of child items of given parent item, all loaded.
				        //			  Any request for data that is sent to the server should also include
				    	//			  the request parameters in addQueryParams. 
				        //            Throws exception on error.

				},
				// =======================================================================
				// Inspecting items
				getIdentity: function(/* item */ item){
				        // summary: returns identity for an item
				        return this.store.getIdentity(item);
				},
				getLabel: function(/*dojo.data.Item*/ item){
				        // summary: get the label for an item
				        return this.store.getLabel(item);
				},
				getParent: function(/*dojo.data.Item*/ item) {
					// summary: returns the parent item of this item argument
				},
				// =======================================================================
				// Write interface
				newItem: function(/* Object? */ args, /*Item?*/ parent){
				        // summary
				        //            Creates a new item.   See dojo.data.api.Write for details on args.
				},
				pasteItem: function(/*Item*/ childItem, /*Item*/ oldParentItem, /*Item*/ newParentItem, /*Item*/ nextSibling, /*Boolean?*/ extra){
				        // summary:
				        //            Move an item from one parent item to another or to another position under the same parent.
				        //            Used in drag & drop.
				        // childItem: Item to move.
				        // oldParentItem: Previous parent of item being moved.
				        // newParentItem: Item that the item being moved was dropped on.
				        // nextSiblingItem: Item that should become is the next sibling of the dropped item.  Null indicates
				        // 		dropping at the end of the list of children. 
				        // extra: Boolean flag that can be interpretted however desired by the implementing model.  Example
				        //		usages include a copy flag to indicate if the paste operation is a copy, or a flag to indicate
				        //		if the paste operation moves the child under the new item as a new child or next to the
				        //		item it was dropped on as a new sibling.

				},
				// =======================================================================
				// Callbacks
				onChange: function(/*dojo.data.Item*/ item){
				        // summary:
				        //            Callback whenever an item has changed, so that Tree
				        //            can update the label, icon, etc.   Note that changes
				        //            to an item's children or parent(s) will trigger an
				        //            onChildrenChange() so you can ignore those changes here.
				},
				onChildrenChange: function(/*dojo.data.Item*/ parent, /*dojo.data.Item[]*/ newChildrenList){
				        // summary: Callback to do notifications about new, updated, or deleted items.
				},
				onTreeChange: function(/*Item*/ childItem, /*Item*/ oldParentItem, /*Item*/ newParentItem, /*Item*/ nextSiblingItem) {
					// summary: Called when the tree model is changed through one of three scenarios.
					// 		1) An item is moved in the tree model.  This can be called 
					//			when an item is reparented or reordered within the same parent.  In both
					//			cases the nextSiblingItem refers to the next sibling of childItem, sharing
					//			its same newParentItem.
					//		2) A new item is inserted into the tree at a given parent.  In this case,
					//			the oldParentItem is null.
					//		3) An item is removed from the tree at a given parent.  In this case, the
					//			newParentItem and the nextSiblingItem is null.
					// childItem: Item to move.
					// oldParentItem: Item old parent of the childItem.
					// newParentItem: Item new parent of the childItem.  If this is the same as the
					//		oldParentItem, it indicates that the childItem is being reordered in
					//		the list of children under the parent.
					// nextSiblingItem: Item that is becoming the next sibling of the moved child item.  
					// 		Null indicates moving to the end of the list of children. 
				},				
				toString: function() {
					return "[TreeModel " + this.declaredClass + "]";
				}
			}
);

}

if(!dojo._hasResource["com.ibm.portal.data.PortalTreeModel"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.portal.data.PortalTreeModel"] = true;
dojo.provide( "com.ibm.portal.data.PortalTreeModel" );

dojo.require( "com.ibm.data.DataTreeModel" );


dojo.declare( "com.ibm.portal.data.PortalTreeModel",
			com.ibm.data.DataTreeModel,
			{
				
				filterHidden: false,
				
				parentAttr: "parent",
				childAttr: "childrenURI",
				
				childrenAttrs: ["children"],
				
				constructor: function() {
					if(this.filterHidden) this.addQueryParams["mdname"] = "com.ibm.portal.Hidden";
					this._notifyOn = true;
					this.connections = [];
					if(this.store.getFeatures()["dojo.data.api.Notification"]) {
						this.connections.concat([
							dojo.connect(this.store, "onNew", this, "_onNew"),
							dojo.connect(this.store, "onSet", this, "_onSet"),
							dojo.connect(this.store, "onDelete", this, "_onDelete")
						]);
					}
				},
				destroy: function() {
				        // summary: destroys this object, releasing connections to the store
				        dojo.forEach(this.connections, dojo.disconnect);
				},
				
				// =======================================================================
				// Methods for traversing hierarchy
				getRoot: function(onItem, onError){
					// summary:
				    //            Calls onItem with the root item for the tree, possibly a fabricated item.
					//            Throws exception on error.
					if(this.root) onItem(this.root);
					else {
						this.store.fetch({
							query: this._fixQuery(this.query),
							onComplete: dojo.hitch(this, function(items) {
								if(items.length == 0) throw new Error("No items returned by query for root node");
								else {
									this.root = items[0];
									onItem(this.root);
								}
							}),
							onError: onError
						});
					}
				},
				_fixQuery: function(/*String|Object*/ query) {
					// summary: Fixes a query to append the addQueryParams query parameters
					//		on this model to the query that's passed as an argument.
					// query: String|Object initial query to manipulate
					// returns: String fixed query after the addQueryParams have been added
					//		to it.
					if(!this.addQueryParams) return query;
					if(!dojo.isString(this.addQueryParams)) {
						this.addQueryParams = dojo.objectToQuery(this.addQueryParams);
					}
					if(dojo.isString(query)) {
						if(query.indexOf("?") > -1) {
							return query + "&" + this.addQueryParams;
						}
						else {
							return query + "?" + this.addQueryParams;
						}
					}
					else {
						return "?" + dojo.objectToQuery(query) + this.addQueryParams;
					}
				},
				mayHaveChildren: function(/*dojo.data.Item*/ item){
				        // summary
				        //            Tells if an item has or may have children.  Implementing logic here
				        //            avoids showing +/- expando icon for nodes that we know don't have children.
				        //            (For efficiency reasons we may not want to check if an element actually
				        //            has children until user clicks the expando node)
				        return item._children ? item._children.length > 0 : !!this.store.getValue(item, this.childAttr);
				},
				getChildren: function(/*dojo.data.Item*/ parentItem, /*function(items)*/ onComplete, /*function*/ onError){
				        // summary
				        //           Calls onComplete() with array of child items of given parent item, all loaded.
				        //            Throws exception on error.
				        var store = this.store;
				        var id = store.getIdentity(parentItem);
				        var parentAttr = this.parentAttr;
				        
				        if(!parentItem._children && !this.mayHaveChildren(parentItem)){
				        	parentItem._children = new Array();
				        }
				        if(parentItem._children) {
				        	onComplete(parentItem._children);
				        } 
				        else if((!parentItem._children || parentItem._children.length == 0) && this.mayHaveChildren(parentItem)) {
				        	//parentItem._children
				        	store.fetch({
				        		query: this._fixQuery(store.getValue(parentItem, this.childAttr, "")),
				        		queryOptions: {preventCache: true},
				        		onComplete: dojo.hitch(this, function(items) {
				        			parentItem._children = new Array();
				        			dojo.forEach(items, function(item){
				        				// only push the results whose parent has the same id as this parentItem
				        				if(store.getValue(item, parentAttr) == id) {
				        					if(this.filterHidden) {
				        						// if we're filtering hidden nodes, check the metadata
				        						var isHidden = store.getValue(item, "metadata[com.ibm.portal.Hidden]$");
				        						if(isHidden && (isHidden.toLowerCase() == "yes" || isHidden.toLowerCase() == "true")) {
				        							return;
				        						}
				        					}
				        					
				        					parentItem._children.push(item);
				        				}
				        			}, this);
				        			onComplete(parentItem._children);
				        		}),
				        		onError: function(errorData, request) {
				        			onError(errorData);
				        		}
				        	});
				        } 
				},
				// =======================================================================
				// Inspecting items
				getIdentity: function(/* item */ item){
				        // summary: returns identity for an item
				        return this.store.getIdentity(item);
				},
				getLabel: function(/*dojo.data.Item*/ item){
				        // summary: get the label for an item
				        return this.store.getLabel(item);
				},
				getParent: function(/*dojo.data.Item*/ item) {
					// summary: returns the parent item of this item argument; may return a stub if the parent
					// 		hasn't been loaded yet
					var pId = this.store.getValue(item, "parent");
					if(pId) {
						return this.store.getItem(pId);
					}
					else return null;
				},
				// =======================================================================
				// Write interface
				newItem: function(/* Object */ args, /*Item*/ parent){
				        // summary
				        //            Creates a new item.   See dojo.data.api.Write for details on args.
				        var parentInfo = {parent: parent, attribute: this.childrenAttrs[0]};
				        var item = this.store.newItem(args, parentInfo);
				        this.store.save({onComplete: args.onComplete, onError: args.onError, scope: args.scope});
				        return item;
				},
				pasteItem: function(/*Item*/ childItem, /*Item*/ oldParentItem, /*Item*/ newParentItem, /*Item*/ nextSiblingItem, /*Boolean*/ defer){
				        // summary:
				        //            Move an item from one parent item to another or to another position under the same parent.
				        //            Used in drag & drop.
				        // childItem: Item to move.
				        // oldParentItem: Previous parent of item being moved.
				        // newParentItem: New parent of the item being moved.
				        // nextSiblingItem: New next sibling item of this item is.  Can be null
				        //		to indicate that this item is at the end of a list of children.
				        // defer: Boolean flag to persist the change in the store, or defer persisting
				        //		till later.  True does not persist the change.  False persists the change
				        //		immediately.  If the change is not persisted, a call to the save function
				        //		will persist all pending changes in the model.
				        
				        this._notifyOn = false;
				        // turning off notifications while doing multiple updates... that way
				        // we can send one onChildrenChange event to all listeners with the proper
				        // list of children
				        var store = this.store;
				        var childId = store.getIdentity(childItem), 
				        	newParentId = store.getIdentity(newParentItem),
				        	oldParentId = store.getIdentity(oldParentItem),
				        	nextId = nextSiblingItem ? store.getIdentity(nextSiblingItem) : null;
				        if(childId == newParentId || childId == nextId) {
				        	// dropped on ourself... do nothing... as if this is possible somehow
				        	this._notifyOn = true;
				        	return;
				        }
				        else {
				        	
				        	if(oldParentId != newParentId || !nextSiblingItem) {
				        		store.setValue(childItem, "parent", newParentId);
				        	}
				        	
				        	if(nextId) {
				        		store.setValue(childItem, "next", nextId);
				        	}
				        	
							var onError = function(errors){
								dojo.forEach(errors, function(error){
									var message = error.message;
									var responseText = error.responseText;
									if(responseText.indexOf("EJPEK0020E") >= 0){ // error for insufficient permissions on drop
										bundle = dojo.i18n.getLocalization("com.ibm.bundles", "NavWidget");
										message = bundle["nav_invalid_drop_error"];
										responseText = bundle["nav_invalid_drop_msg"];
									}
									var statusMessage = new com.ibm.widgets.StatusMessage( "error", message, responseText );
									dojo.publish("/portal/status",[{message: statusMessage, uid: 'ibmPortalStatusBox'}]);
								});
							}
			        		if(!defer) store.save({onError:onError});
			        		this._notifyOn = true;
			        		
			        		if(oldParentId != newParentId) {
			        			// reparenting involves removing from the old and inserting into the new
				        		this._removeChildItem(oldParentItem, childItem);
				        		this._insertChildItem(newParentItem, childItem, nextSiblingItem, dojo.hitch(this, function(){
				        			this.onTreeChange(childItem, oldParentItem, newParentItem, nextSiblingItem);
				        		}));
				        	}
				        	else {
				        		// if we're not reparenting, then we can only be moving
				        		this._moveChildItem(newParentItem, childItem, nextSiblingItem, dojo.hitch(this, function(){
				        			this.onTreeChange(childItem, oldParentItem, newParentItem, nextSiblingItem);
				        		}));
				        	}
				        }
				},
				onTreeChange: function(/*Item*/ childItem, /*Item*/ oldParentItem, /*Item*/ newParentItem, /*Item*/ nextSiblingItem) {
					
				},
				_onDelete: function(/* Item */ deletedItem) {
					// summary: Callback handler for the store attached to this tree model to call
					//		when an item is deleted
					if(!this._notifyOn) return;
					if(deletedItem.parentId) {
						var parentItem = this.store.getItem(deletedItem.parentId);
						this._removeChildItem(parentItem, deletedItem, dojo.hitch(this, function(items) {
								this.onTreeChange(deletedItem, parentItem);
						}));
					}
				},
		
				_onNew: function(/* Item */ newItem, /* Object */ parentInfo) {
					// summary: Callback handler for the store attached to this tree model to call
					//		when an item is created 
					if(!this._notifyOn) return;
					if(!parentInfo || !parentInfo.item) return;
					this._insertChildItem(parentInfo.item, newItem, null, dojo.hitch(this, function(){
	        			this.onTreeChange(newItem, null, parentInfo.item);
	        		}));
					return;
					
					if(!parentInfo.item._children) {
						// never been retreived yet
						parentInfo.item._children = [newItem];
					}
					else {
						parentInfo.item._children.push(newItem);
					}
					this.getChildren(parentInfo.item, dojo.hitch(this, function(items) {
							this.onChildrenChange(parentInfo.item, items);
						})
					);
				},
		
				_onSet: function(/* Item */ item, /*String*/ attribute, /*Object | Array*/ oldValue, /*Object | Array*/ newValue) {
					// summary: Callback handler for the store attached to this tree model to call
					//		when an item is modified
					if(!this._notifyOn) return;
					if(attribute != "next" && oldValue == newValue) return;
					if(attribute == "parent") {
						// If the parent has been changed, refresh the old and new parent items
						var oldP = this.store.getItem(oldValue);
						if(this.store.isItemLoaded(oldP)) {
							this._removeChildItem(oldP, item);
						}
						else {
							this.store.loadItem({
								item: oldP,
								onItem: function(oldParent) {
									this._removeChildItem(oldParent, item);
								},
								scope: this
							});
						}
						
						
						var newP = this.store.getItem(newValue);
						if(this.store.isItemLoaded(newP)) {
							this._insertChildItem(newP, item);
						}
						else {
							this.store.loadItem({
								item: newP,
								onItem: function(newParent) {
									this._insertChildItem(newParent, item);
								},
								scope: this
							});
						}
					}
					else if(attribute == "next") {
						// If the item has been reordered within the same parent list of children, refresh
						// its parent
						var parentId = this.store.getValue(item, "parent");
						var parentItem = this.store.getItem(parentId);
						if(this.store.isItemLoaded(parentItem)) {
							this._moveChildItem(parentItem, item, newValue);
						}
						else {
							this.store.loadItem({
								item: parentItem,
								onItem: function(loadedParentItem) {
									this._moveChildItem(loadedParentItem, item, newValue);
								},
								scope: this
							});
						}
					}
					else {
						this.onChange(item);
					}
				},
				
				refreshItemChildren: function(/*Item*/ item, /*Function?*/ modifier) {
					item._children = null;
					var func = modifier ? modifier : function(items) {
							this.onChildrenChange(item, items);
						};
					this.getChildren(item, dojo.hitch(this, func));
				},
				_insertChildItem: function(/*Item*/parentItem, /*Item*/ item, /*Item*/ newNextSibling, /*Function*/callbackfn) {
					this.getChildren(parentItem, dojo.hitch(this, function(items) {
						// refresh the item children with a function that will add the item first
						if(!newNextSibling) {
							items.push(item);
						}
						else {
							var id = this.getIdentity(newNextSibling);
							for(var i = 0; i < items.length; i++) {
								if(this.getIdentity(items[i]) == id) {
									items.splice(i, 0, item);
									break;
								}
							}
						}
						if(callbackfn) callbackfn();
						this.onChildrenChange(parentItem, items);
					}));
				},
				_removeChildItem: function(/*Item*/parentItem, /*Item*/ item, /*Function*/callbackfn) {
					this.getChildren(parentItem, dojo.hitch(this, function(items) {
						var id = this.store.getIdentity(item);
						for(var i = 0; i < items.length; i++) {
							if(this.store.getIdentity(items[i]) == id) {
								items.splice(i,1);	// remove the item from the array
								break;	// break out of the loop since we already found ourselves
							}
						}
						if(callbackfn) callbackfn();
						this.onChildrenChange(parentItem, items);
					}));
				},
				_moveChildItem: function(/*Item*/parentItem, /*Item*/ item, /*String*/ newNextSibling, /*Function*/callbackfn) {
					this.getChildren(parentItem, dojo.hitch(this, function(items) {
						var id = this.store.getIdentity(item);
						var nextIndex = items.length - 1;
						for(var i = 0; i < items.length; i++) {
							if(this.store.getIdentity(items[i]) == id) {
								items.splice(i, 1);	// remove item from index i
								i--;
							}
							else if(newNextSibling && this.store.getIdentity(items[i]) == newNextSibling) {
								// insert item at index i before the existing item at that index without deleting it
								items.splice(i, 0, item);
								i++;
							}
						}
						if(!newNextSibling) {
							// if this is null, append the item to the end of the list
							items.push(item);
						}
						if(callbackfn) callbackfn();
						this.onChildrenChange(parentItem, items);
					}));
				},
				toString: function() {
					return "[TreeModel " + this.declaredClass + "]";
				}
			}
);

}

if(!dojo._hasResource["com.ibm.data.SelectionModel"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.data.SelectionModel"] = true;
dojo.provide("com.ibm.data.SelectionModel");

dojo.declare("com.ibm.data.SelectionModel",
	null,
	{
		// treeModel: An instance of a DataTreeModel which backs this SelectionModel
		treeModel: null,
		
		// selectionPath: Array of items in the DataTreeModel which represent the current selection path.
		//		Starts at the currently selected node and goes up the tree to the root.
		selectionPath: [],
		
		constructor: function(args) {
			dojo.mixin(this, args);
			this.modelConnection = dojo.connect(this.treeModel, "onTreeChange", this, "onModelTreeChange");
		},
		
		atLevel: function(level, fromRoot) {
			return this.selectionPath[fromRoot ? this.selectionPath.length - 1 - level : level];
		},
		getPath: function() {
			return this.selectionPath.slice();
		},
		
		onModelTreeChange: function(/*Item*/ childItem, /*Item*/ oldParentItem, /*Item*/ newParentItem, /*Item*/ nextSiblingItem) {
			if(oldParentItem != newParentItem 
					&& dojo.some(this.selectionPath, function(item){
						return item == childItem;
					}, this)) {
				this._calculateNewPath(this.selectionPath[0]);
				this.onSelectionPathChange(false);
			}
		},
		
		_calculateNewPath: function(lastSelected) {
			// the model is built from the top-down, so the model should already have
			// loaded all the ancestors of the lastSelected item so that model.getParent()
			// returns loaded items
			var cur = lastSelected;
			this.selectionPath.splice(0, this.selectionPath.length);
			while(cur) {
				this.selectionPath.push(cur);
				cur = this.treeModel.getParent(cur);
			}
		},
		
		onSelectionPathChange: function(/*Boolean*/ selectionChanged) {
			// summary: Event called when the selection path is updated.  This can occur when the
			//		selection model changes because the tree was restructured, changing the path
			//		from the currently selected node to the root by reparenting some nodes, or
			//		by actually changing the currently selected node in the tree.
			// selectionChanged: Boolean true if the currently selected node changed, false if the
			//		path changed but the currently selected node is the same.
		},
		
		changeSelection: function(/*item*/ newSelection) {
			// This line is commented out to allow Mashups to 
			// process the selected node after moving it using
			// the more actions menu
			//if(this.selectionPath[0] == newSelection) return;
			this._calculateNewPath(newSelection);
			this.onSelectionPathChange(true);
		}
	}
);

}

if(!dojo._hasResource["dojo.data.util.sorter"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.data.util.sorter"] = true;
dojo.provide("dojo.data.util.sorter");

dojo.data.util.sorter.basicComparator = function(	/*anything*/ a, 
													/*anything*/ b){
	//	summary:  
	//		Basic comparision function that compares if an item is greater or less than another item
	//	description:  
	//		returns 1 if a > b, -1 if a < b, 0 if equal.
	//		'null' values (null, undefined) are treated as larger values so that they're pushed to the end of the list.
	//		And compared to each other, null is equivalent to undefined.
	
	//null is a problematic compare, so if null, we set to undefined.
	//Makes the check logic simple, compact, and consistent
	//And (null == undefined) === true, so the check later against null
	//works for undefined and is less bytes.
	var r = -1;
	if(a === null){
		a = undefined;
	}
	if(b === null){
		b = undefined;
	}
	if(a == b){
		r = 0; 
	}else if(a > b || a == null){
		r = 1; 
	}
	return r; //int {-1,0,1}
};

dojo.data.util.sorter.createSortFunction = function(	/* attributes array */sortSpec,
														/*dojo.data.core.Read*/ store){
	//	summary:  
	//		Helper function to generate the sorting function based off the list of sort attributes.
	//	description:  
	//		The sort function creation will look for a property on the store called 'comparatorMap'.  If it exists
	//		it will look in the mapping for comparisons function for the attributes.  If one is found, it will
	//		use it instead of the basic comparator, which is typically used for strings, ints, booleans, and dates.
	//		Returns the sorting function for this particular list of attributes and sorting directions.
	//
	//	sortSpec: array
	//		A JS object that array that defines out what attribute names to sort on and whether it should be descenting or asending.
	//		The objects should be formatted as follows:
	//		{
	//			attribute: "attributeName-string" || attribute,
	//			descending: true|false;   // Default is false.
	//		}
	//	store: object
	//		The datastore object to look up item values from.
	//
	var sortFunctions=[];   

	function createSortFunction(attr, dir){
		return function(itemA, itemB){
			var a = store.getValue(itemA, attr);
			var b = store.getValue(itemB, attr);
			//See if we have a override for an attribute comparison.
			var comparator = null;
			if(store.comparatorMap){
				if(typeof attr !== "string"){
					 attr = store.getIdentity(attr);
				}
				comparator = store.comparatorMap[attr]||dojo.data.util.sorter.basicComparator;
			}
			comparator = comparator||dojo.data.util.sorter.basicComparator; 
			return dir * comparator(a,b); //int
		};
	}
	var sortAttribute;
	for(var i = 0; i < sortSpec.length; i++){
		sortAttribute = sortSpec[i];
		if(sortAttribute.attribute){
			var direction = (sortAttribute.descending) ? -1 : 1;
			sortFunctions.push(createSortFunction(sortAttribute.attribute, direction));
		}
	}

	return function(rowA, rowB){
		var i=0;
		while(i < sortFunctions.length){
			var ret = sortFunctions[i++](rowA, rowB);
			if(ret !== 0){
				return ret;//int
			}
		}
		return 0; //int  
	};  //  Function
};

}

if(!dojo._hasResource["dojo.data.util.simpleFetch"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.data.util.simpleFetch"] = true;
dojo.provide("dojo.data.util.simpleFetch");


dojo.data.util.simpleFetch.fetch = function(/* Object? */ request){
	//	summary:
	//		The simpleFetch mixin is designed to serve as a set of function(s) that can
	//		be mixed into other datastore implementations to accelerate their development.  
	//		The simpleFetch mixin should work well for any datastore that can respond to a _fetchItems() 
	//		call by returning an array of all the found items that matched the query.  The simpleFetch mixin
	//		is not designed to work for datastores that respond to a fetch() call by incrementally
	//		loading items, or sequentially loading partial batches of the result
	//		set.  For datastores that mixin simpleFetch, simpleFetch 
	//		implements a fetch method that automatically handles eight of the fetch()
	//		arguments -- onBegin, onItem, onComplete, onError, start, count, sort and scope
	//		The class mixing in simpleFetch should not implement fetch(),
	//		but should instead implement a _fetchItems() method.  The _fetchItems() 
	//		method takes three arguments, the keywordArgs object that was passed 
	//		to fetch(), a callback function to be called when the result array is
	//		available, and an error callback to be called if something goes wrong.
	//		The _fetchItems() method should ignore any keywordArgs parameters for
	//		start, count, onBegin, onItem, onComplete, onError, sort, and scope.  
	//		The _fetchItems() method needs to correctly handle any other keywordArgs
	//		parameters, including the query parameter and any optional parameters 
	//		(such as includeChildren).  The _fetchItems() method should create an array of 
	//		result items and pass it to the fetchHandler along with the original request object 
	//		-- or, the _fetchItems() method may, if it wants to, create an new request object 
	//		with other specifics about the request that are specific to the datastore and pass 
	//		that as the request object to the handler.
	//
	//		For more information on this specific function, see dojo.data.api.Read.fetch()
	request = request || {};
	if(!request.store){
		request.store = this;
	}
	var self = this;

	var _errorHandler = function(errorData, requestObject){
		if(requestObject.onError){
			var scope = requestObject.scope || dojo.global;
			requestObject.onError.call(scope, errorData, requestObject);
		}
	};

	var _fetchHandler = function(items, requestObject){
		var oldAbortFunction = requestObject.abort || null;
		var aborted = false;

		var startIndex = requestObject.start?requestObject.start:0;
		var endIndex   = (requestObject.count && (requestObject.count !== Infinity))?(startIndex + requestObject.count):items.length;

		requestObject.abort = function(){
			aborted = true;
			if(oldAbortFunction){
				oldAbortFunction.call(requestObject);
			}
		};

		var scope = requestObject.scope || dojo.global;
		if(!requestObject.store){
			requestObject.store = self;
		}
		if(requestObject.onBegin){
			requestObject.onBegin.call(scope, items.length, requestObject);
		}
		if(requestObject.sort){
			items.sort(dojo.data.util.sorter.createSortFunction(requestObject.sort, self));
		}
		if(requestObject.onItem){
			for(var i = startIndex; (i < items.length) && (i < endIndex); ++i){
				var item = items[i];
				if(!aborted){
					requestObject.onItem.call(scope, item, requestObject);
				}
			}
		}
		if(requestObject.onComplete && !aborted){
			var subset = null;
			if (!requestObject.onItem) {
				subset = items.slice(startIndex, endIndex);
			}
			requestObject.onComplete.call(scope, subset, requestObject);   
		}
	};
	this._fetchItems(request, _fetchHandler, _errorHandler);
	return request;	// Object
};

}

if(!dojo._hasResource["com.ibm.data.CatalogMixin"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.data.CatalogMixin"] = true;
// Datastores written for use in the content search widget must inherit from this class to make the mapItem and prepareQuery function available to the widget
// These functions are used to unify access to datastores, so the widget can  query and access items the same way for every source

dojo.provide("com.ibm.data.CatalogMixin");
dojo.declare("com.ibm.data.CatalogMixin", 
		null,
		{	
			searchable: true,
			
			mapItem: function(/*DatstoreItem*/item){
				// summary: Returns a map containing parameters for the given datastore item
				//		The keys must be: label, description, tags, rating, url, id, thumbnail
				//			- label, description, url, id and thumbnail are strings
				//			- tags is an array of strings
				//			- rating is a string that contains a number, note that decimal values are allowed
				//		Having all content search datastores create item maps with the same keys allows the widget to access information uniformly
				// 		If a datastore item does not have the same attributes for getValue as seen below, this function must be overridden
				//		If a datastore item does not have an appropriate parameter to  map to a key, that map entry can be omitted
				//		An example for a datastore item with a title, summary, rating and identifier:
				//			mapItem: function(/*DatastoreItem*/item){
				//				// does not include the "tags" and "url" keys
				//				var map = {};
				//				map["label"] = this.getValue(item, "title", "untitled");
				//				map["description"] = this.getValue(item, "summary", null);
				//				map["rating"] = this.getValue(item, "rating", "0.0");
				//				map["id"] = this.getValue(item, "identifier", null);
				//				map["thumbnail"] = this.getValue(item, "thumbnail", null);
				//				return map;
				//			}
				var map = {};
				map["label"] = this.getValue(item, "label", "untitled");
				map["description"] = this.getValue(item, "description", null);
				map["tags"] = this.getValues(item, "tags", null);
				map["rating"] = this.getValue(item, "rating", "0.0");
				map["url"] = this.getValue(item, "url", null);
				map["id"] = this.getValue(item, "id", null);
				map["thumbnail"] = this.getValue(item, "thumbnail", null);
				return map;
			},

			prepareQuery: function(/*Object*/keywordArgs) {
				// summary: User overridable function to modify the keywordArgs object used to fetch results from the back end
				//		Called after the keywordArgs.query property has been normalized to an object map but before any other processing has taken place to build the URL
				//		After this function is called, anything in the keywordArgs.query map is appended to the fetch URL in the form (?|&)<key1>=<value1> &<key2>=<value2> &<key3>=<value3> ...
				//		Can be used to extract other parts of the keywordArgs map to add properties to the query object that are dependent on back end implementation
				//		Properties of the query object that are not part of the fetch URL should be deleted
				//		The keywordArgs object is defined in dojo.data.api.Read.fetch and query will be an object containing the key "keywords" with an array of strings as a value
				//		An example for a feed URL containing "searchTerms", "startIndex" and "count" parameters:
				//			prepareQuery: function(/*Object*/keywordArgs) {
				//				if(keywordArgs.query.keywords) {
				//					// searchTerms is a comma separated list of search parameters
				//					keywordArgs.query.searchTerms = keywordArgs.query.keywords.join(",");
				//					delete keywordArgs.query.keywords;
				//				}
				//				if(keywordArgs.count) {
				//					keywordArgs.query.count = keywordArgs.count;
				//					if(keywordArgs.start == null) {
				//						keywordArgs.start = 0;
				//					}
				//					keywordArgs.query.startIndex = keywordArgs.start;
				//				}
				//			}
				return keywordArgs;
			},
			
			validateSelf: function(){
				// summary: validates this datastore, if it does not validate the source will not be used
				// returns true for validation and false otherwise
				return true;
			},
			
			getSourceLabel: function(){
				return false;
			}
});

}

if(!dojo._hasResource["com.ibm.portal.data.InstalledPortletStore"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.portal.data.InstalledPortletStore"] = true;
dojo.provide( "com.ibm.portal.data.InstalledPortletStore" );


dojo.require( "com.ibm.data.AtomFeedStore" );
dojo.require( "com.ibm.data.CatalogMixin" );

dojo.declare( "com.ibm.portal.data.InstalledPortletStore",
			[com.ibm.data.AtomFeedStore,com.ibm.data.CatalogMixin],
			{
				// itemClass: String the class used to represent items of this store
				itemClass: "com.ibm.portal.data.InstalledPortletItem",
				_loadFinished: false,
				_items: [],
				noIcons: true,
				
				constructor: function( /*Map*/ args ) {
					// summary: Creates a new instance of a com.ibm.portal.data.ContentModelStore
					// args: Map
					
					// URL basic format - /wps/[my]contenthandler?uri=pdl:all(&rep=compacat)?(&max-results=integer)?(&start-index=integer)?(&sort=created|lastmodified)(&order=asc|desc)
				},
				
				/********************************/
				/**                            			**/
				/**                           			 **/
				/**          catalog extension point 	 **/
				/**                           			 **/
				/**                            			**/
				/********************************/
				
				mapItem: function(/*DatstoreItem*/item){
					var map = {};
					map["label"] = this.getValue(item, "title", "untitled");
					map["description"] = this.getValue(item, "summary", "");
					map["id"] = this.getValue(item, "id", "");
					return map;
				},
			
				_fetchItems: function(/*Object*/ keywordArgs, /*Function*/ findCallback, /*Function*/ errorCallback){
					// summary: see dojo.data.util.simpleFetch
					//The _fetchItems() method should ignore any keywordArgs parameters for start, count, onBegin, onItem, onComplete, onError, sort, and scope, and only needs to handle queryOptions and query
					var me = this;
					var filter = function(requestArgs, arrayOfItems){ 
						
						var items = [];
						if(requestArgs.query){
							var keywordStrings = requestArgs.query.keywords;
							var ignoreCase = requestArgs.queryOptions ? requestArgs.queryOptions.ignoreCase : false; 
							
							// loop through the keywordStrings and push anything that isn't an empty string onto the keywords array
							var keywords = new Array();
							for(var i = 0; i < keywordStrings.length; i++){
								if(keywordStrings[i].length <= 0) continue;
								// make the keyword all lower case if we are doing a case insensitive search
								var keyword = (ignoreCase)?keywordStrings[i].toLowerCase():keywordStrings[i];
								keywords.push(keyword);
							}

							// loop through all the items in the store looking for matches
							for(var i = 0; i < arrayOfItems.length; ++i){
								var match = true;
								if(arrayOfItems[i] === null){
									match = false; 
								} else {
									// loop through each keyword and make sure the store item contains all of them to be a match
									for(var j = 0; j < keywords.length; j++){
										var title = me.getValue(arrayOfItems[i],"title","");
										if(ignoreCase) title = title.toLowerCase(); // make the title all lower case if we are doing a case insensitive search
										var summary = me.getValue(arrayOfItems[i],"summary","");
										if(ignoreCase) summary = summary.toLowerCase(); // make the summary all lower case if we are doing a case insensitive search
										// if the title AND summary both don't contain the keyword, the match is false
										if(title.indexOf(keywords[j]) == -1 && summary.indexOf(keywords[j]) == -1){
											match = false;
											break;
										}
									}
								}
								if(match) items.push(arrayOfItems[i]);
							}
							findCallback(items, requestArgs);
						} else 
							findCallback(arrayOfItems, requestArgs);
					};

					if(this._loadFinished){ 
						filter(keywordArgs, this._items);
					} else {  // the items in the store must be fetched and stored for the first and last time
						var args = arguments;  // create a reference to arguments
						var savedOnComplete = arguments[0].onComplete;  // save a reference to arguments' onComplete function
						// create a new onComplete function to pass to the inherited fetch function
						args[0].onComplete = function(items){  	args[0].onComplete = savedOnComplete; // restore the onComplete function for _fetchItems
																me._loadFinished = true; 
																me._items = items;	// store the items in the store
																filter(keywordArgs,items);
															};
						// retrieve all the store items using the inherited fetch function
						this.inherited("fetch",args);
					}
				}
});
dojo.extend(com.ibm.portal.data.InstalledPortletStore,dojo.data.util.simpleFetch);

dojo.declare( "com.ibm.portal.data.InstalledPortletItem",
			com.ibm.data.AtomEntryItem, 
			{
			}
);

}

if(!dojo._hasResource["com.ibm.portal.data.PumaStore"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.portal.data.PumaStore"] = true;
dojo.provide( "com.ibm.portal.data.PumaStore" );

dojo.require( "com.ibm.data.AtomFeedStore" );

dojo.declare( "com.ibm.portal.data.PumaStore",
			com.ibm.data.AtomFeedStore,
			{
				// namespaces: Map
				//		Map of namespaces used by the Puma feeds
				namespaces: dojo.mixin({}, com.ibm.data.AtomFeedStore.prototype.namespaces, {
		            "xhtml" : "http://www.w3.org/1999/xhtml",
		            "xs" : "http://www.w3.org/2001/XMLSchema-datatypes",
		            "um" : "http://www.ibm.com/xmlns/prod/websphere/um.xsd"
	        	}),
		        
		        // methodTunneling: Boolean specifies whether or not to tunnel DELETE and PUT requests
		        //		through POST requests with special headers and/or request parameters.  Set this to
		        //		true in environments where DELETE and PUT requests are blocked.
		        methodTunneling: false,
		        
		        // itemClass: String the class used to represent items of this store
				itemClass: "com.ibm.portal.data.PumaItem",
				
				constructor: function( /*Map*/ args ) {
					// summary: Creates a new instance of a this data store
					// args: Map
					//		The args map will be used to replace any default values of this store with the
					//		values specified in the args map.
					this._features['dojo.data.api.Identity'] = true;
				},
				
				handleConstructs: function(/*DOMNode*/ node, /*String*/ prop) {
					switch(prop) {
						case "PumaAttributeConstruct": return new com.ibm.portal.data.PumaAttributeConstruct(node);
						case "PumaProfileConstruct": return new com.ibm.portal.data.PumaProfileConstruct(node);
						default: return this.inherited(arguments);
					}
				},
				_buildUrl: function(keywordArgs, baseUrl) {
					// summary: Builds a url string from this store's base url and the
					// 		query argument.
					// keywordArgs: Object
					//		A request object map as sent to the fetch function
					// returns: String The constructed url.
					var ret = "";
					keywordArgs = this._prepareQuery(keywordArgs);
					var query = keywordArgs.query;
					var qStart = baseUrl.indexOf("?");
					var baseQuery = "";
					if(qStart > -1) {
						baseQuery = baseUrl.substring(qStart);
						baseUrl = baseUrl.substr(0, qStart);
					}
					if(baseQuery.length > 0 && baseQuery.charAt(baseQuery.length - 1) == "/") baseQuery = baseQuery.substr(0, baseQuery.length - 1);
					
					// append a / if it's necessary
					if((baseUrl.length > 0 && baseUrl.charAt(baseUrl.length - 1) != "/")
						|| baseUrl.length == 0) baseUrl += "/";
					
					switch(query.type) {
						case "userAttributes": baseUrl += "attributes/users/"; 
							break;
						case "groupAttributes": baseUrl += "attributes/groups/"; 
							break;
						case "userProfiles": baseUrl += "users/profiles/";
							break;
						case "groupProfiles": baseUrl += "groups/profiles/";
							break;
						case "currentProfile": baseUrl += "currentuser/profile/";
							break;
						case "groupMembership": baseUrl += "groupmembership/";
							break;
					}
					
					delete query.type;
					
					if(query.id) {
						baseUrl += id;
					}
					
					var queryPart = dojo.objectToQuery(query);
					
					ret = baseUrl + "?" + queryPart + baseQuery;
					
					return (this.modifyUrl(keywordArgs, ret));
				},
				modifyRequestArgs: function(ioArgs, request) {
					// see com.ibm.data.AtomFeedStore@modifyRequestArgs
					// 
					if(!ioArgs.headers) {
						ioArgs.headers = {};
					}
					ioArgs.headers["accept"] = "application/atom+xml";
					return ioArgs;
				},			
				fetchItemByIdentity: function(/* object */ keywordArgs){
					//	summary:
					//		Given the identity of an item, this method returns the item that has 
					//		that identity through the onItem callback.  Conforming implementations 
					//		should return null if there is no item with the given identity.  
					//		Implementations of fetchItemByIdentity() may sometimes return an item 
					//		from a local cache and may sometimes fetch an item from a remote server, 
					//
					// 	keywordArgs:
					//		An anonymous object that defines the item to locate and callbacks to invoke when the 
					//		item has been located and load has completed.  The format of the object is as follows:
					//		{
					//			identity: string|object,
					//			onItem: Function,
					//			onError: Function,
					//			scope: object
					//		}
					//	The *identity* parameter.
					//		The identity parameter is the identity of the item you wish to locate and load
					//		This attribute is required.  It should be a string or an object that toString() 
					//		can be called on.
					//		
					//	The *onItem* parameter.
					//		Function(item)
					//		The onItem parameter is the callback to invoke when the item has been loaded.  It takes only one
					//		parameter, the item located, or null if none found.
					//
					//	The *onError* parameter.
					//		Function(error)
					//		The onError parameter is the callback to invoke when the item load encountered an error.  It takes only one
					//		parameter, the error object
					//
					//	The *scope* parameter.
					//		If a scope object is provided, all of the callback functions (onItem, 
					//		onError, etc) will be invoked in the context of the scope object.
					//		In the body of the callback function, the value of the "this"
					//		keyword will be the scope object.   If no scope object is provided,
					//		the callback functions will be called in the context of dojo.global.
					//		For example, onItem.call(scope, item, request) vs. 
					//		onItem.call(dojo.global, item, request)
					var id = keywordArgs.identity;
					
					// our IDs may come in as urn:id:# and all we want is the # part
					if(id.indexOf(":") > -1) id = id.substring(id.lastIndexOf(":") + 1);
					var scope = keywordArgs.scope ? keywordArgs.scope : dojo.global;
					var args = {
						query: {
							id: id,
							collection: "ui.all"
						},
						onComplete: dojo.hitch(this, 
							function(items) {
								if(items.length == 0 && keywordArgs.onError) {
									keywordArgs.onError.call(scope, "No items returned matching identity " + id);
								}
								else {
									keywordArgs.onItem.call(scope, items[0]);
								}
							}
						)
					};
					if(keywordArgs.onError) args.onError = dojo.hitch(scope, keywordArgs.onError);

					return this.fetch(args);
				}
			}
);


dojo.declare( "com.ibm.portal.data.PumaItem",
			com.ibm.data.AtomEntryItem, 
			{
				// namespaces: Map
				//		Map of namespaces used by the Puma feeds
				namespaces: dojo.mixin({}, com.ibm.portal.data.PumaStore.prototype.namespaces),
				
		        attrMappings: dojo.mixin({}, com.ibm.data.AtomEntryItem.prototype.attrMappings, {
					pumaProfile: {xpath: "./atom:content/um:profile", targetName: "PumaProfileConstruct", type: "node"},
					pumaAttribute: {xpath: "./atom:content/um:profile/um:attribute'", targetName: "PumaAttributeConstruct", type: "node"},
					pumaAttribute$: {xpath: "./atom:content/um:profile/um:attribute[@name='${0}']", targetName: "PumaAttributeConstruct", type: "node"}
				})
			}
);

dojo.declare( "com.ibm.portal.data.PumaProfileConstruct",
			com.ibm.data._XmlConstruct,
			{
				namespaces: dojo.mixin({}, com.ibm.portal.data.PumaStore.prototype.namespaces),
				
		        constructor: function(/*DOMNode*/ root) {
					this.root = root;
				},
				handleConstructs: function(/*DOMNode*/ node, /*String*/ prop) {
					switch(prop) {
						case "PumaAttributeConstruct": return new com.ibm.portal.data.PumaAttributeConstruct(node);
						default: return this.inherited(arguments);
					}
				},
				getType: function() {
					// summary: Gets the type of this Puma Profile.
					// returns: String type.  Either user or group.
					return this._getAttribute(this.root, "type");
				},
				getIdentifier: function() {
					// summary: Gets the identifier of this Puma Profile.
					// returns: String identifier.
					return this._getAttribute(this.root, "identifier");
				},
				getPumaAttributes: function() {
					// summary: Gets an array of all the Puma Attributes in this Puma Profile.
					// returns: Array of PumaAttributeConstructs.
					var res = this._getNodesByXpath(this.root, "./um:attribute", "PumaAttributeConstruct");
					return res.value;
				},
				toString: function() {
					var ret = ["<", 
						this.__getClassName(), 
						" type=", 
						this.getType(), 
						" identifier='",
						this.getIdentifier(),
						"' >"].join('');
				}
			}
);

dojo.declare( "com.ibm.portal.data.PumaAttributeConstruct",
			com.ibm.data._XmlConstruct,
			{
				namespaces: dojo.mixin({}, com.ibm.portal.data.PumaStore.prototype.namespaces),
				
		        constructor: function(/*DOMNode*/ root) {
					this.root = root;
				},
				getName: function() {
					// summary: Gets the name of this Puma Attribute.
					// returns: String name.
					return this._getAttribute(this.root, "name");
				},
				getType: function() {
					// summary: Gets the type of this Puma Attribute which is an XmlSchema datatype.
					// returns: String type.
					return this._getAttribute(this.root, "type");
				},
				isMultiValued: function() {
					// summary: Returns true|false indicating if this Puma Attribute is multi-valued.
					// returns: Boolean indicating if this is multi-valued.
					var multiV = this._getAttribute(this.root, "multiValued");
					if(multiV) return multiV.toLowerCase() == "true";
					return false;
				},
				getValue: function() {
					// summary: Gets the first value of this Puma Attribute, which is the only value
					//		of a Puma Attribute that is not multi-valued.
					// returns: First value.
					var res = this._getNodeByXpath(this.root, "./um:attributeValue", "textContent");
					return res.value;
				},
				getValues: function() {
					// summary: Gets an array of the values of this Puma Attribute, which contains only
					//		one array object if the Puma Attribute is not multi-valued.
					// returns: Array of all values.
					var res = this._getNodesByXpath(this.root, "./um:attributeValue", "textContent");
					return res.value;
				},
				toString: function() {
					var ret = "<" + this.__getClassName() + " {" + this.getName() + "=";
					if(this.isMultiValued()) {
						var values = this.getValues();
						dojo.forEach(values, function(val, idx, arr){
							ret += val;
							if(idx < arr.length - 1) {
								ret += ",";
							}
						});
					}
					else {
						ret += this.getValue();
					}
					ret += "}>";
					return ret;
				}
			}
);

}

if(!dojo._hasResource["dojo.data.util.filter"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.data.util.filter"] = true;
dojo.provide("dojo.data.util.filter");

dojo.data.util.filter.patternToRegExp = function(/*String*/pattern, /*boolean?*/ ignoreCase){
	//	summary:  
	//		Helper function to convert a simple pattern to a regular expression for matching.
	//	description:
	//		Returns a regular expression object that conforms to the defined conversion rules.
	//		For example:  
	//			ca*   -> /^ca.*$/
	//			*ca*  -> /^.*ca.*$/
	//			*c\*a*  -> /^.*c\*a.*$/
	//			*c\*a?*  -> /^.*c\*a..*$/
	//			and so on.
	//
	//	pattern: string
	//		A simple matching pattern to convert that follows basic rules:
	//			* Means match anything, so ca* means match anything starting with ca
	//			? Means match single character.  So, b?b will match to bob and bab, and so on.
	//      	\ is an escape character.  So for example, \* means do not treat * as a match, but literal character *.
	//				To use a \ as a character in the string, it must be escaped.  So in the pattern it should be 
	//				represented by \\ to be treated as an ordinary \ character instead of an escape.
	//
	//	ignoreCase:
	//		An optional flag to indicate if the pattern matching should be treated as case-sensitive or not when comparing
	//		By default, it is assumed case sensitive.

	var rxp = "^";
	var c = null;
	for(var i = 0; i < pattern.length; i++){
		c = pattern.charAt(i);
		switch (c) {
			case '\\':
				rxp += c;
				i++;
				rxp += pattern.charAt(i);
				break;
			case '*':
				rxp += ".*"; break;
			case '?':
				rxp += "."; break;
			case '$':
			case '^':
			case '/':
			case '+':
			case '.':
			case '|':
			case '(':
			case ')':
			case '{':
			case '}':
			case '[':
			case ']':
				rxp += "\\"; //fallthrough
			default:
				rxp += c;
		}
	}
	rxp += "$";
	if(ignoreCase){
		return new RegExp(rxp,"mi"); //RegExp
	}else{
		return new RegExp(rxp,"m"); //RegExp
	}
	
};

}

if(!dojo._hasResource["dojo.data.ItemFileReadStore"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.data.ItemFileReadStore"] = true;
dojo.provide("dojo.data.ItemFileReadStore");





dojo.declare("dojo.data.ItemFileReadStore", null,{
	//	summary:
	//		The ItemFileReadStore implements the dojo.data.api.Read API and reads
	//		data from JSON files that have contents in this format --
	//		{ items: [
	//			{ name:'Kermit', color:'green', age:12, friends:['Gonzo', {_reference:{name:'Fozzie Bear'}}]},
	//			{ name:'Fozzie Bear', wears:['hat', 'tie']},
	//			{ name:'Miss Piggy', pets:'Foo-Foo'}
	//		]}
	//		Note that it can also contain an 'identifer' property that specified which attribute on the items 
	//		in the array of items that acts as the unique identifier for that item.
	//
	constructor: function(/* Object */ keywordParameters){
		//	summary: constructor
		//	keywordParameters: {url: String}
		//	keywordParameters: {data: jsonObject}
		//	keywordParameters: {typeMap: object)
		//		The structure of the typeMap object is as follows:
		//		{
		//			type0: function || object,
		//			type1: function || object,
		//			...
		//			typeN: function || object
		//		}
		//		Where if it is a function, it is assumed to be an object constructor that takes the 
		//		value of _value as the initialization parameters.  If it is an object, then it is assumed
		//		to be an object of general form:
		//		{
		//			type: function, //constructor.
		//			deserialize:	function(value) //The function that parses the value and constructs the object defined by type appropriately.
		//		}
	
		this._arrayOfAllItems = [];
		this._arrayOfTopLevelItems = [];
		this._loadFinished = false;
		this._jsonFileUrl = keywordParameters.url;
		this._jsonData = keywordParameters.data;
		this._datatypeMap = keywordParameters.typeMap || {};
		if(!this._datatypeMap['Date']){
			//If no default mapping for dates, then set this as default.
			//We use the dojo.date.stamp here because the ISO format is the 'dojo way'
			//of generically representing dates.
			this._datatypeMap['Date'] = {
											type: Date,
											deserialize: function(value){
												return dojo.date.stamp.fromISOString(value);
											}
										};
		}
		this._features = {'dojo.data.api.Read':true, 'dojo.data.api.Identity':true};
		this._itemsByIdentity = null;
		this._storeRefPropName = "_S";  // Default name for the store reference to attach to every item.
		this._itemNumPropName = "_0"; // Default Item Id for isItem to attach to every item.
		this._rootItemPropName = "_RI"; // Default Item Id for isItem to attach to every item.
		this._reverseRefMap = "_RRM"; // Default attribute for constructing a reverse reference map for use with reference integrity
		this._loadInProgress = false;	//Got to track the initial load to prevent duelling loads of the dataset.
		this._queuedFetches = [];
		if(keywordParameters.urlPreventCache !== undefined){
			this.urlPreventCache = keywordParameters.urlPreventCache?true:false;
		}
		if(keywordParameters.clearOnClose){
			this.clearOnClose = true;
		}
	},
	
	url: "",	// use "" rather than undefined for the benefit of the parser (#3539)

	data: null,	// define this so that the parser can populate it

	typeMap: null, //Define so parser can populate.
	
	//Parameter to allow users to specify if a close call should force a reload or not.
	//By default, it retains the old behavior of not clearing if close is called.  But
	//if set true, the store will be reset to default state.  Note that by doing this,
	//all item handles will become invalid and a new fetch must be issued.
	clearOnClose: false,

	//Parameter to allow specifying if preventCache should be passed to the xhrGet call or not when loading data from a url.  
	//Note this does not mean the store calls the server on each fetch, only that the data load has preventCache set as an option.
	//Added for tracker: #6072
	urlPreventCache: false,  

	_assertIsItem: function(/* item */ item){
		//	summary:
		//		This function tests whether the item passed in is indeed an item in the store.
		//	item: 
		//		The item to test for being contained by the store.
		if(!this.isItem(item)){ 
			throw new Error("dojo.data.ItemFileReadStore: Invalid item argument.");
		}
	},

	_assertIsAttribute: function(/* attribute-name-string */ attribute){
		//	summary:
		//		This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.
		//	attribute: 
		//		The attribute to test for being contained by the store.
		if(typeof attribute !== "string"){ 
			throw new Error("dojo.data.ItemFileReadStore: Invalid attribute argument.");
		}
	},

	getValue: function(	/* item */ item, 
						/* attribute-name-string */ attribute, 
						/* value? */ defaultValue){
		//	summary: 
		//		See dojo.data.api.Read.getValue()
		var values = this.getValues(item, attribute);
		return (values.length > 0)?values[0]:defaultValue; // mixed
	},

	getValues: function(/* item */ item, 
						/* attribute-name-string */ attribute){
		//	summary: 
		//		See dojo.data.api.Read.getValues()

		this._assertIsItem(item);
		this._assertIsAttribute(attribute);
		return item[attribute] || []; // Array
	},

	getAttributes: function(/* item */ item){
		//	summary: 
		//		See dojo.data.api.Read.getAttributes()
		this._assertIsItem(item);
		var attributes = [];
		for(var key in item){
			// Save off only the real item attributes, not the special id marks for O(1) isItem.
			if((key !== this._storeRefPropName) && (key !== this._itemNumPropName) && (key !== this._rootItemPropName) && (key !== this._reverseRefMap)){
				attributes.push(key);
			}
		}
		return attributes; // Array
	},

	hasAttribute: function(	/* item */ item,
							/* attribute-name-string */ attribute) {
		//	summary: 
		//		See dojo.data.api.Read.hasAttribute()
		return this.getValues(item, attribute).length > 0;
	},

	containsValue: function(/* item */ item, 
							/* attribute-name-string */ attribute, 
							/* anything */ value){
		//	summary: 
		//		See dojo.data.api.Read.containsValue()
		var regexp = undefined;
		if(typeof value === "string"){
			regexp = dojo.data.util.filter.patternToRegExp(value, false);
		}
		return this._containsValue(item, attribute, value, regexp); //boolean.
	},

	_containsValue: function(	/* item */ item, 
								/* attribute-name-string */ attribute, 
								/* anything */ value,
								/* RegExp?*/ regexp){
		//	summary: 
		//		Internal function for looking at the values contained by the item.
		//	description: 
		//		Internal function for looking at the values contained by the item.  This 
		//		function allows for denoting if the comparison should be case sensitive for
		//		strings or not (for handling filtering cases where string case should not matter)
		//	
		//	item:
		//		The data item to examine for attribute values.
		//	attribute:
		//		The attribute to inspect.
		//	value:	
		//		The value to match.
		//	regexp:
		//		Optional regular expression generated off value if value was of string type to handle wildcarding.
		//		If present and attribute values are string, then it can be used for comparison instead of 'value'
		return dojo.some(this.getValues(item, attribute), function(possibleValue){
			if(possibleValue !== null && !dojo.isObject(possibleValue) && regexp){
				if(possibleValue.toString().match(regexp)){
					return true; // Boolean
				}
			}else if(value === possibleValue){
				return true; // Boolean
			}
		});
	},

	isItem: function(/* anything */ something){
		//	summary: 
		//		See dojo.data.api.Read.isItem()
		if(something && something[this._storeRefPropName] === this){
			if(this._arrayOfAllItems[something[this._itemNumPropName]] === something){
				return true;
			}
		}
		return false; // Boolean
	},

	isItemLoaded: function(/* anything */ something){
		//	summary: 
		//		See dojo.data.api.Read.isItemLoaded()
		return this.isItem(something); //boolean
	},

	loadItem: function(/* object */ keywordArgs){
		//	summary: 
		//		See dojo.data.api.Read.loadItem()
		this._assertIsItem(keywordArgs.item);
	},

	getFeatures: function(){
		//	summary: 
		//		See dojo.data.api.Read.getFeatures()
		return this._features; //Object
	},

	getLabel: function(/* item */ item){
		//	summary: 
		//		See dojo.data.api.Read.getLabel()
		if(this._labelAttr && this.isItem(item)){
			return this.getValue(item,this._labelAttr); //String
		}
		return undefined; //undefined
	},

	getLabelAttributes: function(/* item */ item){
		//	summary: 
		//		See dojo.data.api.Read.getLabelAttributes()
		if(this._labelAttr){
			return [this._labelAttr]; //array
		}
		return null; //null
	},

	_fetchItems: function(	/* Object */ keywordArgs, 
							/* Function */ findCallback, 
							/* Function */ errorCallback){
		//	summary: 
		//		See dojo.data.util.simpleFetch.fetch()
		var self = this;
		var filter = function(requestArgs, arrayOfItems){
			var items = [];
			var i, key;
			if(requestArgs.query){
				var value;
				var ignoreCase = requestArgs.queryOptions ? requestArgs.queryOptions.ignoreCase : false; 

				//See if there are any string values that can be regexp parsed first to avoid multiple regexp gens on the
				//same value for each item examined.  Much more efficient.
				var regexpList = {};
				for(key in requestArgs.query){
					value = requestArgs.query[key];
					if(typeof value === "string"){
						regexpList[key] = dojo.data.util.filter.patternToRegExp(value, ignoreCase);
					}
				}

				for(i = 0; i < arrayOfItems.length; ++i){
					var match = true;
					var candidateItem = arrayOfItems[i];
					if(candidateItem === null){
						match = false;
					}else{
						for(key in requestArgs.query) {
							value = requestArgs.query[key];
							if (!self._containsValue(candidateItem, key, value, regexpList[key])){
								match = false;
							}
						}
					}
					if(match){
						items.push(candidateItem);
					}
				}
				findCallback(items, requestArgs);
			}else{
				// We want a copy to pass back in case the parent wishes to sort the array. 
				// We shouldn't allow resort of the internal list, so that multiple callers 
				// can get lists and sort without affecting each other.  We also need to
				// filter out any null values that have been left as a result of deleteItem()
				// calls in ItemFileWriteStore.
				for(i = 0; i < arrayOfItems.length; ++i){
					var item = arrayOfItems[i];
					if(item !== null){
						items.push(item);
					}
				}
				findCallback(items, requestArgs);
			}
		};

		if(this._loadFinished){
			filter(keywordArgs, this._getItemsArray(keywordArgs.queryOptions));
		}else{

			if(this._jsonFileUrl){
				//If fetches come in before the loading has finished, but while
				//a load is in progress, we have to defer the fetching to be 
				//invoked in the callback.
				if(this._loadInProgress){
					this._queuedFetches.push({args: keywordArgs, filter: filter});
				}else{
					this._loadInProgress = true;
					var getArgs = {
							url: self._jsonFileUrl, 
							handleAs: "json-comment-optional",
							preventCache: this.urlPreventCache
						};
					var getHandler = dojo.xhrGet(getArgs);
					getHandler.addCallback(function(data){
						try{
							self._getItemsFromLoadedData(data);
							self._loadFinished = true;
							self._loadInProgress = false;
							
							filter(keywordArgs, self._getItemsArray(keywordArgs.queryOptions));
							self._handleQueuedFetches();
						}catch(e){
							self._loadFinished = true;
							self._loadInProgress = false;
							errorCallback(e, keywordArgs);
						}
					});
					getHandler.addErrback(function(error){
						self._loadInProgress = false;
						errorCallback(error, keywordArgs);
					});

					//Wire up the cancel to abort of the request
					//This call cancel on the deferred if it hasn't been called
					//yet and then will chain to the simple abort of the
					//simpleFetch keywordArgs
					var oldAbort = null;
					if(keywordArgs.abort){
						oldAbort = keywordArgs.abort;
					}
					keywordArgs.abort = function(){
						var df = getHandler;
						if (df && df.fired === -1){
							df.cancel();
							df = null;
						}
						if(oldAbort){
							oldAbort.call(keywordArgs);
						}
					};
				}
			}else if(this._jsonData){
				try{
					this._loadFinished = true;
					this._getItemsFromLoadedData(this._jsonData);
					this._jsonData = null;
					filter(keywordArgs, this._getItemsArray(keywordArgs.queryOptions));
				}catch(e){
					errorCallback(e, keywordArgs);
				}
			}else{
				errorCallback(new Error("dojo.data.ItemFileReadStore: No JSON source data was provided as either URL or a nested Javascript object."), keywordArgs);
			}
		}
	},

	_handleQueuedFetches: function(){
		//	summary: 
		//		Internal function to execute delayed request in the store.
		//Execute any deferred fetches now.
		if (this._queuedFetches.length > 0) {
			for(var i = 0; i < this._queuedFetches.length; i++){
				var fData = this._queuedFetches[i];
				var delayedQuery = fData.args;
				var delayedFilter = fData.filter;
				if(delayedFilter){
					delayedFilter(delayedQuery, this._getItemsArray(delayedQuery.queryOptions)); 
				}else{
					this.fetchItemByIdentity(delayedQuery);
				}
			}
			this._queuedFetches = [];
		}
	},

	_getItemsArray: function(/*object?*/queryOptions){
		//	summary: 
		//		Internal function to determine which list of items to search over.
		//	queryOptions: The query options parameter, if any.
		if(queryOptions && queryOptions.deep) {
			return this._arrayOfAllItems; 
		}
		return this._arrayOfTopLevelItems;
	},

	close: function(/*dojo.data.api.Request || keywordArgs || null */ request){
		 //	summary: 
		 //		See dojo.data.api.Read.close()
		 if(this.clearOnClose && (this._jsonFileUrl !== "")){
			 //Reset all internalsback to default state.  This will force a reload
			 //on next fetch, but only if the data came from a url.  Passed in data
			 //means it should not clear the data.
			 this._arrayOfAllItems = [];
			 this._arrayOfTopLevelItems = [];
			 this._loadFinished = false;
			 this._itemsByIdentity = null;
			 this._loadInProgress = false;
			 this._queuedFetches = [];
		 }
	},

	_getItemsFromLoadedData: function(/* Object */ dataObject){
		//	summary:
		//		Function to parse the loaded data into item format and build the internal items array.
		//	description:
		//		Function to parse the loaded data into item format and build the internal items array.
		//
		//	dataObject:
		//		The JS data object containing the raw data to convery into item format.
		//
		// 	returns: array
		//		Array of items in store item format.
		
		// First, we define a couple little utility functions...
		var addingArrays = false;
		
		function valueIsAnItem(/* anything */ aValue){
			// summary:
			//		Given any sort of value that could be in the raw json data,
			//		return true if we should interpret the value as being an
			//		item itself, rather than a literal value or a reference.
			// example:
			// 	|	false == valueIsAnItem("Kermit");
			// 	|	false == valueIsAnItem(42);
			// 	|	false == valueIsAnItem(new Date());
			// 	|	false == valueIsAnItem({_type:'Date', _value:'May 14, 1802'});
			// 	|	false == valueIsAnItem({_reference:'Kermit'});
			// 	|	true == valueIsAnItem({name:'Kermit', color:'green'});
			// 	|	true == valueIsAnItem({iggy:'pop'});
			// 	|	true == valueIsAnItem({foo:42});
			var isItem = (
				(aValue !== null) &&
				(typeof aValue === "object") &&
				(!dojo.isArray(aValue) || addingArrays) &&
				(!dojo.isFunction(aValue)) &&
				(aValue.constructor == Object || dojo.isArray(aValue)) &&
				(typeof aValue._reference === "undefined") && 
				(typeof aValue._type === "undefined") && 
				(typeof aValue._value === "undefined")
			);
			return isItem;
		}
		
		var self = this;
		function addItemAndSubItemsToArrayOfAllItems(/* Item */ anItem){
			self._arrayOfAllItems.push(anItem);
			for(var attribute in anItem){
				var valueForAttribute = anItem[attribute];
				if(valueForAttribute){
					if(dojo.isArray(valueForAttribute)){
						var valueArray = valueForAttribute;
						for(var k = 0; k < valueArray.length; ++k){
							var singleValue = valueArray[k];
							if(valueIsAnItem(singleValue)){
								addItemAndSubItemsToArrayOfAllItems(singleValue);
							}
						}
					}else{
						if(valueIsAnItem(valueForAttribute)){
							addItemAndSubItemsToArrayOfAllItems(valueForAttribute);
						}
					}
				}
			}
		}

		this._labelAttr = dataObject.label;

		// We need to do some transformations to convert the data structure
		// that we read from the file into a format that will be convenient
		// to work with in memory.

		// Step 1: Walk through the object hierarchy and build a list of all items
		var i;
		var item;
		this._arrayOfAllItems = [];
		this._arrayOfTopLevelItems = dataObject.items;

		for(i = 0; i < this._arrayOfTopLevelItems.length; ++i){
			item = this._arrayOfTopLevelItems[i];
			if(dojo.isArray(item)){
				addingArrays = true;
			}
			addItemAndSubItemsToArrayOfAllItems(item);
			item[this._rootItemPropName]=true;
		}

		// Step 2: Walk through all the attribute values of all the items, 
		// and replace single values with arrays.  For example, we change this:
		//		{ name:'Miss Piggy', pets:'Foo-Foo'}
		// into this:
		//		{ name:['Miss Piggy'], pets:['Foo-Foo']}
		// 
		// We also store the attribute names so we can validate our store  
		// reference and item id special properties for the O(1) isItem
		var allAttributeNames = {};
		var key;

		for(i = 0; i < this._arrayOfAllItems.length; ++i){
			item = this._arrayOfAllItems[i];
			for(key in item){
				if (key !== this._rootItemPropName)
				{
					var value = item[key];
					if(value !== null){
						if(!dojo.isArray(value)){
							item[key] = [value];
						}
					}else{
						item[key] = [null];
					}
				}
				allAttributeNames[key]=key;
			}
		}

		// Step 3: Build unique property names to use for the _storeRefPropName and _itemNumPropName
		// This should go really fast, it will generally never even run the loop.
		while(allAttributeNames[this._storeRefPropName]){
			this._storeRefPropName += "_";
		}
		while(allAttributeNames[this._itemNumPropName]){
			this._itemNumPropName += "_";
		}
		while(allAttributeNames[this._reverseRefMap]){
			this._reverseRefMap += "_";
		}

		// Step 4: Some data files specify an optional 'identifier', which is 
		// the name of an attribute that holds the identity of each item. 
		// If this data file specified an identifier attribute, then build a 
		// hash table of items keyed by the identity of the items.
		var arrayOfValues;

		var identifier = dataObject.identifier;
		if(identifier){
			this._itemsByIdentity = {};
			this._features['dojo.data.api.Identity'] = identifier;
			for(i = 0; i < this._arrayOfAllItems.length; ++i){
				item = this._arrayOfAllItems[i];
				arrayOfValues = item[identifier];
				var identity = arrayOfValues[0];
				if(!this._itemsByIdentity[identity]){
					this._itemsByIdentity[identity] = item;
				}else{
					if(this._jsonFileUrl){
						throw new Error("dojo.data.ItemFileReadStore:  The json data as specified by: [" + this._jsonFileUrl + "] is malformed.  Items within the list have identifier: [" + identifier + "].  Value collided: [" + identity + "]");
					}else if(this._jsonData){
						throw new Error("dojo.data.ItemFileReadStore:  The json data provided by the creation arguments is malformed.  Items within the list have identifier: [" + identifier + "].  Value collided: [" + identity + "]");
					}
				}
			}
		}else{
			this._features['dojo.data.api.Identity'] = Number;
		}

		// Step 5: Walk through all the items, and set each item's properties 
		// for _storeRefPropName and _itemNumPropName, so that store.isItem() will return true.
		for(i = 0; i < this._arrayOfAllItems.length; ++i){
			item = this._arrayOfAllItems[i];
			item[this._storeRefPropName] = this;
			item[this._itemNumPropName] = i;
		}

		// Step 6: We walk through all the attribute values of all the items,
		// looking for type/value literals and item-references.
		//
		// We replace item-references with pointers to items.  For example, we change:
		//		{ name:['Kermit'], friends:[{_reference:{name:'Miss Piggy'}}] }
		// into this:
		//		{ name:['Kermit'], friends:[miss_piggy] } 
		// (where miss_piggy is the object representing the 'Miss Piggy' item).
		//
		// We replace type/value pairs with typed-literals.  For example, we change:
		//		{ name:['Nelson Mandela'], born:[{_type:'Date', _value:'July 18, 1918'}] }
		// into this:
		//		{ name:['Kermit'], born:(new Date('July 18, 1918')) } 
		//
		// We also generate the associate map for all items for the O(1) isItem function.
		for(i = 0; i < this._arrayOfAllItems.length; ++i){
			item = this._arrayOfAllItems[i]; // example: { name:['Kermit'], friends:[{_reference:{name:'Miss Piggy'}}] }
			for(key in item){
				arrayOfValues = item[key]; // example: [{_reference:{name:'Miss Piggy'}}]
				for(var j = 0; j < arrayOfValues.length; ++j) {
					value = arrayOfValues[j]; // example: {_reference:{name:'Miss Piggy'}}
					if(value !== null && typeof value == "object"){
						if(value._type && value._value){
							var type = value._type; // examples: 'Date', 'Color', or 'ComplexNumber'
							var mappingObj = this._datatypeMap[type]; // examples: Date, dojo.Color, foo.math.ComplexNumber, {type: dojo.Color, deserialize(value){ return new dojo.Color(value)}}
							if(!mappingObj){ 
								throw new Error("dojo.data.ItemFileReadStore: in the typeMap constructor arg, no object class was specified for the datatype '" + type + "'");
							}else if(dojo.isFunction(mappingObj)){
								arrayOfValues[j] = new mappingObj(value._value);
							}else if(dojo.isFunction(mappingObj.deserialize)){
								arrayOfValues[j] = mappingObj.deserialize(value._value);
							}else{
								throw new Error("dojo.data.ItemFileReadStore: Value provided in typeMap was neither a constructor, nor a an object with a deserialize function");
							}
						}
						if(value._reference){
							var referenceDescription = value._reference; // example: {name:'Miss Piggy'}
							if(!dojo.isObject(referenceDescription)){
								// example: 'Miss Piggy'
								// from an item like: { name:['Kermit'], friends:[{_reference:'Miss Piggy'}]}
								arrayOfValues[j] = this._itemsByIdentity[referenceDescription];
							}else{
								// example: {name:'Miss Piggy'}
								// from an item like: { name:['Kermit'], friends:[{_reference:{name:'Miss Piggy'}}] }
								for(var k = 0; k < this._arrayOfAllItems.length; ++k){
									var candidateItem = this._arrayOfAllItems[k];
									var found = true;
									for(var refKey in referenceDescription){
										if(candidateItem[refKey] != referenceDescription[refKey]){ 
											found = false; 
										}
									}
									if(found){ 
										arrayOfValues[j] = candidateItem; 
									}
								}
							}
							if(this.referenceIntegrity){
								var refItem = arrayOfValues[j];
								if(this.isItem(refItem)){
									this._addReferenceToMap(refItem, item, key);
								}
							}
						}else if(this.isItem(value)){
							//It's a child item (not one referenced through _reference).  
							//We need to treat this as a referenced item, so it can be cleaned up
							//in a write store easily.
							if(this.referenceIntegrity){
								this._addReferenceToMap(value, item, key);
							}
						}
					}
				}
			}
		}
	},

	_addReferenceToMap: function(/*item*/ refItem, /*item*/ parentItem, /*string*/ attribute){
		 //	summary:
		 //		Method to add an reference map entry for an item and attribute.
		 //	description:
		 //		Method to add an reference map entry for an item and attribute. 		 //
		 //	refItem:
		 //		The item that is referenced.
		 //	parentItem:
		 //		The item that holds the new reference to refItem.
		 //	attribute:
		 //		The attribute on parentItem that contains the new reference.
		 
		 //Stub function, does nothing.  Real processing is in ItemFileWriteStore.
	},

	getIdentity: function(/* item */ item){
		//	summary: 
		//		See dojo.data.api.Identity.getIdentity()
		var identifier = this._features['dojo.data.api.Identity'];
		if(identifier === Number){
			return item[this._itemNumPropName]; // Number
		}else{
			var arrayOfValues = item[identifier];
			if(arrayOfValues){
				return arrayOfValues[0]; // Object || String
			}
		}
		return null; // null
	},

	fetchItemByIdentity: function(/* Object */ keywordArgs){
		//	summary: 
		//		See dojo.data.api.Identity.fetchItemByIdentity()

		// Hasn't loaded yet, we have to trigger the load.
		var item;
		var scope;
		if(!this._loadFinished){
			var self = this;
			if(this._jsonFileUrl){

				if(this._loadInProgress){
					this._queuedFetches.push({args: keywordArgs});
				}else{
					this._loadInProgress = true;
					var getArgs = {
							url: self._jsonFileUrl, 
							handleAs: "json-comment-optional",
							preventCache: this.urlPreventCache
					};
					var getHandler = dojo.xhrGet(getArgs);
					getHandler.addCallback(function(data){
						var scope =  keywordArgs.scope?keywordArgs.scope:dojo.global;
						try{
							self._getItemsFromLoadedData(data);
							self._loadFinished = true;
							self._loadInProgress = false;
							item = self._getItemByIdentity(keywordArgs.identity);
							if(keywordArgs.onItem){
								keywordArgs.onItem.call(scope, item);
							}
							self._handleQueuedFetches();
						}catch(error){
							self._loadInProgress = false;
							if(keywordArgs.onError){
								keywordArgs.onError.call(scope, error);
							}
						}
					});
					getHandler.addErrback(function(error){
						self._loadInProgress = false;
						if(keywordArgs.onError){
							var scope =  keywordArgs.scope?keywordArgs.scope:dojo.global;
							keywordArgs.onError.call(scope, error);
						}
					});
				}

			}else if(this._jsonData){
				// Passed in data, no need to xhr.
				self._getItemsFromLoadedData(self._jsonData);
				self._jsonData = null;
				self._loadFinished = true;
				item = self._getItemByIdentity(keywordArgs.identity);
				if(keywordArgs.onItem){
					scope =  keywordArgs.scope?keywordArgs.scope:dojo.global;
					keywordArgs.onItem.call(scope, item);
				}
			} 
		}else{
			// Already loaded.  We can just look it up and call back.
			item = this._getItemByIdentity(keywordArgs.identity);
			if(keywordArgs.onItem){
				scope =  keywordArgs.scope?keywordArgs.scope:dojo.global;
				keywordArgs.onItem.call(scope, item);
			}
		}
	},

	_getItemByIdentity: function(/* Object */ identity){
		//	summary:
		//		Internal function to look an item up by its identity map.
		var item = null;
		if(this._itemsByIdentity){
			item = this._itemsByIdentity[identity];
		}else{
			item = this._arrayOfAllItems[identity];
		}
		if(item === undefined){
			item = null;
		}
		return item; // Object
	},

	getIdentityAttributes: function(/* item */ item){
		//	summary: 
		//		See dojo.data.api.Identity.getIdentifierAttributes()
		 
		var identifier = this._features['dojo.data.api.Identity'];
		if(identifier === Number){
			// If (identifier === Number) it means getIdentity() just returns
			// an integer item-number for each item.  The dojo.data.api.Identity
			// spec says we need to return null if the identity is not composed 
			// of attributes 
			return null; // null
		}else{
			return [identifier]; // Array
		}
	},
	
	_forceLoad: function(){
		//	summary: 
		//		Internal function to force a load of the store if it hasn't occurred yet.  This is required
		//		for specific functions to work properly.  
		var self = this;
		if(this._jsonFileUrl){
				var getArgs = {
					url: self._jsonFileUrl, 
					handleAs: "json-comment-optional",
					preventCache: this.urlPreventCache,
					sync: true
				};
			var getHandler = dojo.xhrGet(getArgs);
			getHandler.addCallback(function(data){
				try{
					//Check to be sure there wasn't another load going on concurrently 
					//So we don't clobber data that comes in on it.  If there is a load going on
					//then do not save this data.  It will potentially clobber current data.
					//We mainly wanted to sync/wait here.
					//TODO:  Revisit the loading scheme of this store to improve multi-initial
					//request handling.
					if(self._loadInProgress !== true && !self._loadFinished){
						self._getItemsFromLoadedData(data);
						self._loadFinished = true;
					}else if(self._loadInProgress){
						//Okay, we hit an error state we can't recover from.  A forced load occurred
						//while an async load was occurring.  Since we cannot block at this point, the best
						//that can be managed is to throw an error.
						throw new Error("dojo.data.ItemFileReadStore:  Unable to perform a synchronous load, an async load is in progress."); 
					}
				}catch(e){
					console.log(e);
					throw e;
				}
			});
			getHandler.addErrback(function(error){
				throw error;
			});
		}else if(this._jsonData){
			self._getItemsFromLoadedData(self._jsonData);
			self._jsonData = null;
			self._loadFinished = true;
		} 
	}
});
//Mix in the simple fetch implementation to this class.
dojo.extend(dojo.data.ItemFileReadStore,dojo.data.util.simpleFetch);

}

if(!dojo._hasResource["com.ibm.utilities"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.utilities"] = true;
/*
 * @author Ben
 */ 
dojo.provide("com.ibm.utilities");




com.ibm.utilities = {
	urlToProxyUrl: function ( /*String*/ url, /*String?*/ proxyURI ) {
		var ret = proxyURI ? proxyURI : "/proxy";
		var protocol = "http";
		var colon = url.indexOf('://');
		if(colon > -1) {
			protocol = url.substring(0, colon);
			url = url.substring(colon + 3);
		}
		url = url.replace(/:/g, '%3A');
		
		return ret + '/' + protocol + '/' + url;
	},
	withBaseUrl: function(/*String*/ relativeUrl) {
		// summary: Rewrites a relative url to include the base url that's present in
		//		the href attribute of the first base tag found in the document if one exists.
		//		If one does not exist, this returns the relative url argument unchanged.
		//		This is useful for fixing relative URLs in a document that includes a base
		//		url while using IE as it does not include base url calculations when dynamically
		//		changing href or src attributes on elements, or when modifying window.location
		//		properties.
		// relativeUrl: String url relative to the current host to rewrite
		if(relativeUrl.charAt(0) == '/') return relativeUrl;
		return com.ibm.utilities.baseUrl() + relativeUrl;
	},
	baseUrl: function() {
		// summary: Returns the base url used in the document for any relative url
		//		resolution.  This is retrieved by looking up the base tag in the document
		//		and returning its href attribute if it exists.  Otherwise, it simply
		//		returns the empty string.
		if(!this._baseUrl) {
			var base = dojo.doc.getElementsByTagName("base")[0];
			if(base) this._baseUrl = base.getAttribute("href");
			if(!this._baseUrl) this._baseUrl = "";
		}
		return this._baseUrl;
	},
	stripUrlFragment: function(/*String*/url) {
		// summary: Strips the fragment identifier from a url if one exists, returning
		//		the new url without any fragment identifiers.
		// url: String url to strip fragment identifiers
		var h = url.indexOf("#");
		if(h > -1) url = url.substr(0, h);
		return url;
	},
	actionIO: function(/*String*/ url, /*String*/ method) {
		if(url) {
			var form = dojo.doc.createElement("form");
			form.setAttribute("action", url);
			if(method) method = method.toLowerCase();
			switch(method) {
				case "get":
					form.setAttribute("method", "GET");
				case "post":
				case "delete":
				case "put":
					form.setAttribute("method", "POST");
					break;
				default:
			}
			dojo.body().appendChild(form);
			form.submit();
		}
	},
	refreshPage: function(){
		var url, hash = -1, bases = document.getElementsByTagName('base');
		if(bases.length > 0) url = bases[0].href;  // use url from base tag
		else {  // use current location with any hash removed
			url = top.location.href;
			hash = url.indexOf('#');
			if(dojo.isSafari < 4 && hash > -1)  // nothing but location.reload works in 
				window.location.reload();   // Safari when there is a hash in the url
			if(hash > -1)
				url = url.substring(0, hash);
		}
		window.location.assign(url);  // refresh without reloading static content
	}
};

(function(){
	// unique (arbitrary) boundary
	var boundary = new String("{EB2F8DA2-5B2C-F66A-CDD0-A2D42143F5AC}");
	var newL = new String("\r\n");
	var sep = new String("--");
	var startB = newL + sep + boundary + newL;			
	var endB = sep + boundary + sep + newL;
	
	// used to capture the header
	var headerBodySplitterRegx = new RegExp(newL + newL);
	var headerRegx= new RegExp(newL + "\s*([^\r]*)\s*", "mg");
	var headerPartsRegx = /\s*([^:]*):\s*(.+)/;
	
	// used to find the boundary
	var boundaryRegx = /boundary\s*=\s*\"?([^\"]*)\"?/;
	
	var partHandler = function(partArgs, responsePart, ioArgs) {
		// use a try-catch so any errors in callback execution don't
		// kill the processing of other parts... this behaves as
		// if each part were a separate request with its own async
		// callback
		try {
			if(responsePart instanceof Error) {
				if(partArgs.error) partArgs.error(responsePart, ioArgs);
			}
			else {
				try {
					if(partArgs.load) partArgs.load(responsePart, ioArgs);
				}
				catch(err) {
					if(partArgs.error) partArgs.error(err, ioArgs);
				}
			}
			// always call the handle function if it exists
			if(partArgs.handle) partArgs.handle(responsePart, ioArgs);
		} catch(err) {}
	};
	
	function xhrMime() {
		this.respHeaders = [];
		this.responseText = "";
		this.responseXML = null;
		this.status = 0;
		this.statusText = "";
		this.readyState = 0;
		this.onreadystatechange = function(){};
	}
	
	dojo.extend(xhrMime, {
		getResponseHeader: function(key) {
			key = key.toLowerCase();
			for(var i = 0, header; header = this.respHeaders[i], i < this.respHeaders.length; i++) {
				if(header[0].toLowerCase() == key) return header[1];
			}
			return null;
		},
		getAllResponseHeaders: function() {
			var str = "";
			for(var i = 0, header; header = this.respHeaders[i], i < this.respHeaders.length; i++) {
				str += header[0] + ": " + header[1];
				if(i < this.respHeaders.length - 1) {
					str += "\n";
				}
			}
			return str;
		},
		send: function(){},
		open: function(){},
		abort: function(){},
		setRequestHeader: function(){}
	});
	
	var unfoldHeaders = function(headerSection) {
		return headerSection.replace(/\r\n\s/mg, " ");
	}
	
	var defaultContentHandler = function(partArgs, partXhr) {
		var xmlPart = null;
		if(partArgs.handleAs == "xml") {
			// create document object from text string
			try {
				xmlPart = com.ibm.domUtilities.docFromString(partXhr.responseText);
			} catch(err) {}
		}
		partXhr.responseXML = xmlPart;
		// call the appropriate content handler for this part
		return dojo._contentHandlers[partArgs.handleAs](partXhr);
	}

	dojo.mixin(com.ibm.utilities, {
		handleMultiPartResponse: function(parts, response, ioArgs) {
			// Getting the Content-Type header from the response, and extract
			// the boundary string
			var boundMatch = ioArgs.xhr.getResponseHeader("Content-Type").match(boundaryRegx);
			if(!boundMatch) throw new Error("No boundary specified in Content-Type response header");
			var bound = boundMatch[1];
			// build a regx from the response boundary string used to split the parts
			var splitterRegx = new RegExp(newL + sep + bound, "mg");
			
			var respParts = response.split(splitterRegx);
			
			// if handleAs is xml, it comes as text so build it using the domUtilities
			
			// iterate through the response parts, handling the callbacks for each
			for(var i = 1, j = i - 1; i < respParts.length - 1; i++, j++) {
				var partXhr = new xhrMime(),
					part = respParts[i],
					header = null;
				headerRegx.lastIndex = 0;
				
				var partSections = part.split(headerBodySplitterRegx);
				var headerSection = unfoldHeaders(partSections[0]),
					bodySection = partSections[1];
				
				if(!bodySection) bodySection = "";
				
				// extract the headers for this part, stopping at the blank line
				while((header= headerRegx.exec(headerSection)) != null && (header[1].length > 0)) {
					var headerParts = header[1].match(headerPartsRegx);
					if(headerParts)	{
						partXhr.respHeaders.push([headerParts[1],headerParts[2]]);
					}
				}
				
				part = dojo.string.trim(bodySection);
				partXhr.responseText = part;
				
				if(ioArgs.args.partContentHandler) {
					part = ioArgs.args.partContentHandler(parts[j], partXhr, defaultContentHandler);
				}
				else {
					part = defaultContentHandler(parts[j], partXhr);
				}
				
				partHandler(parts[j], part, dojo.mixin({}, ioArgs, {xhr: partXhr}));
			}
		},
		
		multiPartXhr: function( /*String*/ method, /*dojo.__XhrArgs*/ args, /*Array*/ parts) {
			// summary: Sends a request with a multi-part body (and content type) to
			//		the server.  Uses dojo.xhr functions under the covers, so the args
			//		object has the same structure as what those functions expect.
			//		The main difference is that this function builds the raw post or put
			//		data automatically from the parts array.  Each item in the parts array
			//		is an object which is a subset of the dojo.__XhrArgs type.  The callbacks
			//		should be specified per part as this function will provide a general
			//		callback that parses the multi-part response and calls the callback
			//		associated with that response part provided in the parts array.
			// method: String specifying the HTTP method used.  Must be either POST or PUT.
			//		Default is POST.
			// args: dojo.__XhrArgs specifying how this XHR should be handled.  The following
			//		properties are not used since they do not make sense in this context -
			//			[form, handle, load, content, handleAs]
			//		The following are new args that are available for sending multiPart requests.
			//		{
			//			partContentHandler: function(partArgs, partXhr, defaultContentHandler){} optional 
			// 				function to handle response parts after they've been split and parsed enabling a 
			// 				caller to modify the part response body or the XHR mime associated with the part, 
			// 				returns the response associated with this part in some format, potentially modified
			//				by this handler function
			//			preHandle: function(response, ioArgs){} callback called before the parts
			//				callbacks are called
			//			postHandle: function(response, ioArgs){} callback called after the parts
			//				callbacks have been called
			//
			//		}
			// parts: Array the multiple parts to use to build the multi-part request body.
			//		Each item in the array should be an object with these properties -
			//			{
			//				headers: Object key-value map which is used to write out a
			//					section at the top of this part in the form key: value.
			//					Example could be Content-Type of this part of the multi-part
			//					request.
			//				data: String text to write out the body of this part
			//				load: function(response, ioArgs){} callback called where
			// 					the response body is the body of the part associated this
			//					request part
			//				error: function(response, ioArgs){} callback called when
			//					a failure occurs either in the transmission or from the
			//					server
			//				handle: function(response, ioArgs){} callback called at the
			//					end of this request with either the response or an error
			//					if one occured
			//				handleAs: String value indicating how the response body of this
			//					part should be handled
			//			}
			// returns: Deferred object which can be used to attach additional callbacks to
			
			var body = "",
				headersStr = null;
			dojo.forEach(parts, function(part){
				part.handleAs = part.handleAs ? part.handleAs.toLowerCase() : "text";
				headersStr = "";
				for(var x in part.headers) {
					headersStr += x + ": " + part.headers[x] + newL;
				}
				body += startB + headersStr + newL;
				if(part.data && part.data.length > 0) body += part.data + newL;
			});
			
			body += endB;
			
			// if method is PUT, leave it be; otherwise set it to POST
			if(method.toUpperCase() != "PUT") method = "POST";
			
			args.headers = dojo.mixin({}, args.headers, {
				"Content-type": 'multipart/mixed; boundary="' + boundary + '"'
			});
			
			var xhrArgs = dojo.mixin({}, args, {
				load: function(response, ioArgs) {
					if(args.preHandle) args.preHandle(response, ioArgs);
					com.ibm.utilities.handleMultiPartResponse(parts, response, ioArgs);
					if(args.postHandle) args.postHandle(response, ioArgs);
				}, 
				error: function(response, ioArgs) {
					if(args.preHandle) args.preHandle(response, ioArgs);
					dojo.forEach(parts, function(part){
						partHandler(part, response, ioArgs, null);
					});
					if(args.error) args.error(response, ioArgs);
					if(args.postHandle) args.postHandle(response, ioArgs);
				},
				handleAs: "text",
				form: null,
				content: null,
				postData: null,
				putData: null
			});
			
			xhrArgs[method.toLowerCase() + "Data"] = body;
			
			return dojo.xhr(method, xhrArgs, true);
		}
	});
})();

}

if(!dojo._hasResource["com.ibm.data.ProxyHelper"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.data.ProxyHelper"] = true;
dojo.provide( "com.ibm.data.ProxyHelper" );

dojo.require( "com.ibm.utilities" );

dojo.declare( "com.ibm.data.ProxyHelper",
			null,
			{
				// proxyURI: String
				//		URI to the proxy servlet.
				proxyURI: "",
				
				urlThroughProxy: function(/*String*/ url) {
					return com.ibm.utilities.urlToProxyUrl(url ? url : "", this.proxyURI);
				}
			}
);

}

if(!dojo._hasResource["com.ibm.data.JsonStore"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.data.JsonStore"] = true;
// A json store that can be used for the customize shelf
// dojo.data.ItemFileReadstore already is a JSON store, this store extends it and overwrites the _fetchItems function to do an AND instead of an OR search for the given keywords
// it also adds support for passing in parameters for an nls bundle and keywords

dojo.provide("com.ibm.data.JsonStore");







dojo.declare("com.ibm.data.JsonStore", 
		[dojo.data.ItemFileReadStore, com.ibm.data.ProxyHelper, com.ibm.data.CatalogMixin],
		{	
			nlsBundle: null,
		
			_getItemsFromLoadedData: function(/* Object */ dataObject){
				this.shelfBundle = dojo.i18n.getLocalization("com.ibm.bundles", "Shelf");
				
				var localizationPackageName = dataObject.localizationPackageName;
				var localizationBundleName = dataObject.localizationBundleName;
				if(localizationPackageName && localizationBundleName){
					this.nlsBundle = dojo.i18n.getLocalization(localizationPackageName, localizationBundleName);
				}
				this.inherited("_getItemsFromLoadedData",arguments);
			},
			
			mapItem: function(/*DatstoreItem*/item){
				var map = {};
				
				var label = this.getValue(item, "label", null);
				map["label"] = this.nlsBundle && this.nlsBundle[label] ? this.nlsBundle[label] : label;
				if(!map.label) map.label = this.shelfBundle["add_content_untitled"];
				
				var description = this.getValue(item, "description", null);
				map["description"] = this.nlsBundle && this.nlsBundle[description] ? this.nlsBundle[description] : description;
				
				map["url"] = this.getValue(item, "url", null);
				
				map["id"] = this.getValue(item, "id", null);
				
				map["thumbnail"] = this.getValue(item, "thumbnail", null);
				
				var help = this.getValue(item, "help", null);
				map["help"] = this.nlsBundle && this.nlsBundle[help] ? this.nlsBundle[help] : help;
				
				return map;
			},
		
			_fetchItems: function(/*Object*/ keywordArgs, /*Function*/ findCallback, /*Function*/ errorCallback){
				var self = this;
				var filter = function(requestArgs, arrayOfItems){
					
					var items = [];
					if(requestArgs.query){
						var filterKeywords = requestArgs.query.keywords;
						var ignoreCase = requestArgs.queryOptions ? requestArgs.queryOptions.ignoreCase : false; 
					
						var regexpList = {};
						for(var i = 0; i < filterKeywords.length; i++){
							var currFilter = filterKeywords[i];
							if(typeof currFilter === "string"){
								regexpList[currFilter] = dojo.data.util.filter.patternToRegExp("*"+currFilter+"*", ignoreCase);
							}
						}

						for(var i = 0; i < arrayOfItems.length; ++i){
							var match = true;
							var candidateItem = arrayOfItems[i];
							if(candidateItem === null){
								match = false; 
							} else {
								for(var j = 0; j < filterKeywords.length; j++){
									currFilter = filterKeywords[j];
									if(!self._containsValue(candidateItem, 'label', currFilter, regexpList[currFilter]) 
											&& !self._containsValue(candidateItem, 'description', currFilter, regexpList[currFilter])){
										match = false;
									}
								}
							}
							
							if(match){
								items.push(candidateItem);
							}
						}
						findCallback(items, requestArgs);
					} else {
						for(var i = 0; i < arrayOfItems.length; ++i){
							var item = arrayOfItems[i];
							if(item !== null){
								items.push(item);
							}
						}
						findCallback(items, requestArgs);
					}
			};

			if(this._loadFinished){
				filter(keywordArgs, this._getItemsArray(keywordArgs.queryOptions));
			} else {

				if(this._jsonFileUrl){
					if(this._loadInProgress){
						this._queuedFetches.push({args: keywordArgs, filter: filter});
					} else {
						this._loadInProgress = true;
						var getArgs = {
								url: self._jsonFileUrl, 
								handleAs: "json-comment-optional"
						};
						var getHandler = dojo.xhrGet(getArgs);
						getHandler.addCallback(function(data){
							try{
								self._getItemsFromLoadedData(data);
								self._loadFinished = true;
								self._loadInProgress = false;
				
								filter(keywordArgs, self._getItemsArray(keywordArgs.queryOptions));
								self._handleQueuedFetches();
							}catch(e){
								self._loadFinished = true;
								self._loadInProgress = false;
								errorCallback(e, keywordArgs);
							}
						});
						getHandler.addErrback(function(error){
							self._loadInProgress = false;
							errorCallback(error, keywordArgs);
						});
					}
				} else if(this._jsonData){
					try{
						this._loadFinished = true;
						this._getItemsFromLoadedData(this._jsonData);
						this._jsonData = null;
						filter(keywordArgs, this._getItemsArray(keywordArgs.queryOptions));
					}catch(e){
						errorCallback(e, keywordArgs);
					}
				} else {
					errorCallback(new Error("dojo.data.ItemFileReadStore: No JSON source data was provided as either URL or a nested Javascript object."), keywordArgs);
				}
			}
		}
});

}

if(!dojo._hasResource["dijit.form.TextBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.TextBox"] = true;
dojo.provide("dijit.form.TextBox");



dojo.declare(
	"dijit.form.TextBox",
	dijit.form._FormValueWidget,
	{
		//	summary:
		//		A base class for textbox form inputs

		//	trim: Boolean
		//		Removes leading and trailing whitespace if true.  Default is false.
		trim: false,

		//	uppercase: Boolean
		//		Converts all characters to uppercase if true.  Default is false.
		uppercase: false,

		//	lowercase: Boolean
		//		Converts all characters to lowercase if true.  Default is false.
		lowercase: false,

		//	propercase: Boolean
		//		Converts the first character of each word to uppercase if true.
		propercase: false,

		//	maxLength: String
		//		HTML INPUT tag maxLength declaration.
		maxLength: "",

		templateString:"<input class=\"dijit dijitReset dijitLeft\" dojoAttachPoint='textbox,focusNode'\n\tdojoAttachEvent='onmouseenter:_onMouse,onmouseleave:_onMouse'\n\tautocomplete=\"off\" type=\"${type}\" ${nameAttrSetting}\n\t/>\n",
		baseClass: "dijitTextBox",

		attributeMap: dojo.delegate(dijit.form._FormValueWidget.prototype.attributeMap, {
			maxLength: "focusNode" 
		}),

		_getValueAttr: function(){
			// summary:
			//		Hook so attr('value') works as we like.
			// description:
			//		For `dijit.form.TextBox` this basically returns the value of the <input>.
			//
			//		For `dijit.form.MappedTextBox` subclasses, which have both
			//		a "displayed value" and a separate "submit value",
			//		This treats the "displayed value" as the master value, computing the
			//		submit value from it via this.parse().
			return this.parse(this.attr('displayedValue'), this.constraints);
		},

		_setValueAttr: function(value, /*Boolean?*/ priorityChange, /*String?*/ formattedValue){
			// summary:
			//		Hook so attr('value', ...) works.
			//
			// description: 
			//		Sets the value of the widget to "value" which can be of
			//		any type as determined by the widget.
			//
			// value:
			//		The visual element value is also set to a corresponding,
			//		but not necessarily the same, value.
			//
			// formattedValue:
			//		If specified, used to set the visual element value,
			//		otherwise a computed visual value is used.
			//
			// priorityChange:
			//		If true, an onChange event is fired immediately instead of 
			//		waiting for the next blur event.

			var filteredValue;
			if(value !== undefined){
				// TODO: this is calling filter() on both the display value and the actual value.
				// I added a comment to the filter() definition about this, but it should be changed.
				filteredValue = this.filter(value);
				if(typeof formattedValue != "string"){
					if(filteredValue !== null && ((typeof filteredValue != "number") || !isNaN(filteredValue))){
						formattedValue = this.filter(this.format(filteredValue, this.constraints));
					}else{ formattedValue = ''; }
				}
			}
			if(formattedValue != null && formattedValue != undefined && ((typeof formattedValue) != "number" || !isNaN(formattedValue)) && this.textbox.value != formattedValue){
				this.textbox.value = formattedValue;
			}
			this.inherited(arguments, [filteredValue, priorityChange]);
		},

		// displayedValue: String
		//		For subclasses like ComboBox where the displayed value
		//		(ex: Kentucky) and the serialized value (ex: KY) are different,
		//		this represents the displayed value.
		//
		//		Setting 'displayedValue' through attr('displayedValue', ...)
		//		updates 'value', and vice-versa.  Othewise 'value' is updated
		//		from 'displayedValue' periodically, like onBlur etc.
		//
		//		TODO: move declaration to MappedTextBox?
		//		Problem is that ComboBox references displayedValue,
		//		for benefit of FilteringSelect.
		displayedValue: "",

		getDisplayedValue: function(){
			// summary:
			//		Deprecated.   Use attr('displayedValue') instead.
			// tags:
			//		deprecated
			dojo.deprecated(this.declaredClass+"::getDisplayedValue() is deprecated. Use attr('displayedValue') instead.", "", "2.0");
			return this.attr('displayedValue');
		},

		_getDisplayedValueAttr: function(){
			// summary:
			//		Hook so attr('displayedValue') works.
			// description:
			//		Returns the displayed value (what the user sees on the screen),
			// 		after filtering (ie, trimming spaces etc.).
			//
			//		For some subclasses of TextBox (like ComboBox), the displayed value
			//		is different from the serialized value that's actually 
			//		sent to the server (see dijit.form.ValidationTextBox.serialize)
			
			return this.filter(this.textbox.value);
		},

		setDisplayedValue: function(/*String*/value){
			// summary:
			//		Deprecated.   Use attr('displayedValue', ...) instead.
			// tags:
			//		deprecated
			dojo.deprecated(this.declaredClass+"::setDisplayedValue() is deprecated. Use attr('displayedValue', ...) instead.", "", "2.0");
			this.attr('displayedValue', value);
		},
			
		_setDisplayedValueAttr: function(/*String*/value){
			// summary:
			//		Hook so attr('displayedValue', ...) works.
			//	description: 
			//		Sets the value of the visual element to the string "value".
			//		The widget value is also set to a corresponding,
			//		but not necessarily the same, value.

			if(value === null || value === undefined){ value = '' }
			else if(typeof value != "string"){ value = String(value) }
			this.textbox.value = value;
			this._setValueAttr(this.attr('value'), undefined, value);
		},

		format: function(/* String */ value, /* Object */ constraints){
			// summary:
			//		Replacable function to convert a value to a properly formatted string.
			// tags:
			//		protected extension
			return ((value == null || value == undefined) ? "" : (value.toString ? value.toString() : value));
		},

		parse: function(/* String */ value, /* Object */ constraints){
			// summary:
			//		Replacable function to convert a formatted string to a value
			// tags:
			//		protected extension

			return value;	// String
		},

		_refreshState: function(){
			// summary:
			//		After the user types some characters, etc., this method is
			//		called to check the field for validity etc.  The base method
			//		in `dijit.form.TextBox` does nothing, but subclasses override.
			// tags:
			//		protected
		},

		_onInput: function(e){
			if(e && e.type && /key/i.test(e.type) && e.keyCode){
				switch(e.keyCode){
					case dojo.keys.SHIFT:
					case dojo.keys.ALT:
					case dojo.keys.CTRL:
					case dojo.keys.TAB:
						return;
				}
			}
			if(this.intermediateChanges){
				var _this = this;
				// the setTimeout allows the key to post to the widget input box
				setTimeout(function(){ _this._handleOnChange(_this.attr('value'), false); }, 0);
			}
			this._refreshState();
		},

		postCreate: function(){
			// setting the value here is needed since value="" in the template causes "undefined"
			// and setting in the DOM (instead of the JS object) helps with form reset actions
			this.textbox.setAttribute("value", this.textbox.value); // DOM and JS values shuld be the same
			this.inherited(arguments);
			if(dojo.isMoz || dojo.isOpera){
				this.connect(this.textbox, "oninput", this._onInput);
			}else{
				this.connect(this.textbox, "onkeydown", this._onInput);
				this.connect(this.textbox, "onkeyup", this._onInput);
				this.connect(this.textbox, "onpaste", this._onInput);
				this.connect(this.textbox, "oncut", this._onInput);
			}

			/*#5297:if(this.srcNodeRef){
				dojo.style(this.textbox, "cssText", this.style);
				this.textbox.className += " " + this["class"];
			}*/
			this._layoutHack();
		},

		_blankValue: '', // if the textbox is blank, what value should be reported
		filter: function(val){
			// summary:
			//		Auto-corrections (such as trimming) that are applied to textbox
			//		value on blur or form submit.
			// description:
			//		For MappedTextBox subclasses, this is called twice
			// 			- once with the display value
			//			- once the value as set/returned by attr('value', ...)
			//		and attr('value'), ex: a Number for NumberTextBox.
			//
			//		In the latter case it does corrections like converting null to NaN.  In
			//		the former case the NumberTextBox.filter() method calls this.inherited()
			//		to execute standard trimming code in TextBox.filter().
			//
			//		TODO: break this into two methods in 2.0
			//
			// tags:
			//		protected extension
			if(val === null){ return this._blankValue; }
			if(typeof val != "string"){ return val; }
			if(this.trim){
				val = dojo.trim(val);
			}
			if(this.uppercase){
				val = val.toUpperCase();
			}
			if(this.lowercase){
				val = val.toLowerCase();
			}
			if(this.propercase){
				val = val.replace(/[^\s]+/g, function(word){
					return word.substring(0,1).toUpperCase() + word.substring(1);
				});
			}
			return val;
		},

		_setBlurValue: function(){
			this._setValueAttr(this.attr('value'), true);
		},

		_onBlur: function(e){
			if(this.disabled){ return; }
			this._setBlurValue();
			this.inherited(arguments);
		},

		_onFocus: function(e){
			if(this.disabled){ return; }
			this._refreshState();
			this.inherited(arguments);
		},

		reset: function(){
			// Overrides dijit._FormWidget.reset().
			// Additionally resets the displayed textbox value to ''
			this.textbox.value = '';
			this.inherited(arguments);
		}
	}
);

dijit.selectInputText = function(/*DomNode*/element, /*Number?*/ start, /*Number?*/ stop){
	// summary:
	//		Select text in the input element argument, from start (default 0), to stop (default end).

	// TODO: use functions in _editor/selection.js?
	var _window = dojo.global;
	var _document = dojo.doc;
	element = dojo.byId(element);
	if(isNaN(start)){ start = 0; }
	if(isNaN(stop)){ stop = element.value ? element.value.length : 0; }
	element.focus();
	if(_document["selection"] && dojo.body()["createTextRange"]){ // IE
		if(element.createTextRange){
			var range = element.createTextRange();
			with(range){
				collapse(true);
				moveStart("character", start);
				moveEnd("character", stop);
				select();
			}
		}
	}else if(_window["getSelection"]){
		var selection = _window.getSelection();	// TODO: unused, remove
		// FIXME: does this work on Safari?
		if(element.setSelectionRange){
			element.setSelectionRange(start, stop);
		}
	}
};

}

if(!dojo._hasResource["dijit.Tooltip"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.Tooltip"] = true;
dojo.provide("dijit.Tooltip");




dojo.declare(
	"dijit._MasterTooltip",
	[dijit._Widget, dijit._Templated],
	{
		// summary:
		//		Internal widget that holds the actual tooltip markup,
		//		which occurs once per page.
		//		Called by Tooltip widgets which are just containers to hold
		//		the markup
		// tags:
		//		protected

		// duration: Integer
		//		Milliseconds to fade in/fade out
		duration: dijit.defaultDuration,

		templateString:"<div class=\"dijitTooltip dijitTooltipLeft\" id=\"dojoTooltip\">\n\t<div class=\"dijitTooltipContainer dijitTooltipContents\" dojoAttachPoint=\"containerNode\" waiRole='alert'></div>\n\t<div class=\"dijitTooltipConnector\"></div>\n</div>\n",

		postCreate: function(){
			dojo.body().appendChild(this.domNode);

			this.bgIframe = new dijit.BackgroundIframe(this.domNode);

			// Setup fade-in and fade-out functions.
			this.fadeIn = dojo.fadeIn({ node: this.domNode, duration: this.duration, onEnd: dojo.hitch(this, "_onShow") });
			this.fadeOut = dojo.fadeOut({ node: this.domNode, duration: this.duration, onEnd: dojo.hitch(this, "_onHide") });

		},

		show: function(/*String*/ innerHTML, /*DomNode*/ aroundNode, /*String[]?*/ position){
			// summary:
			//		Display tooltip w/specified contents to right of specified node
			//		(To left if there's no space on the right, or if LTR==right)

			if(this.aroundNode && this.aroundNode === aroundNode){
				return;
			}

			if(this.fadeOut.status() == "playing"){
				// previous tooltip is being hidden; wait until the hide completes then show new one
				this._onDeck=arguments;
				return;
			}
			this.containerNode.innerHTML=innerHTML;

			// Firefox bug. when innerHTML changes to be shorter than previous
			// one, the node size will not be updated until it moves.
			this.domNode.style.top = (this.domNode.offsetTop + 1) + "px";

			// position the element and change CSS according to position[] (a list of positions to try)
			var align = {};
			var ltr = this.isLeftToRight();
			dojo.forEach( (position && position.length) ? position : dijit.Tooltip.defaultPosition, function(pos){
				switch(pos){
					case "after":				
						align[ltr ? "BR" : "BL"] = ltr ? "BL" : "BR";
						break;
					case "before":
						align[ltr ? "BL" : "BR"] = ltr ? "BR" : "BL";
						break;
					case "below":
						// first try to align left borders, next try to align right borders (or reverse for RTL mode)
						align[ltr ? "BL" : "BR"] = ltr ? "TL" : "TR";
						align[ltr ? "BR" : "BL"] = ltr ? "TR" : "TL";
						break;
					case "above":
					default:
						// first try to align left borders, next try to align right borders (or reverse for RTL mode)
						align[ltr ? "TL" : "TR"] = ltr ? "BL" : "BR";
						align[ltr ? "TR" : "TL"] = ltr ? "BR" : "BL";
						break;
				}
			});
			var pos = dijit.placeOnScreenAroundElement(this.domNode, aroundNode, align, dojo.hitch(this, "orient"));

			// show it
			dojo.style(this.domNode, "opacity", 0);
			this.fadeIn.play();
			this.isShowingNow = true;
			this.aroundNode = aroundNode;
		},

		orient: function(/* DomNode */ node, /* String */ aroundCorner, /* String */ tooltipCorner){
			// summary:
			//		Private function to set CSS for tooltip node based on which position it's in.
			//		This is called by the dijit popup code.
			// tags:
			//		protected

			node.className = "dijitTooltip " +
				{
					"BL-TL": "dijitTooltipBelow dijitTooltipABLeft",
					"TL-BL": "dijitTooltipAbove dijitTooltipABLeft",
					"BR-TR": "dijitTooltipBelow dijitTooltipABRight",
					"TR-BR": "dijitTooltipAbove dijitTooltipABRight",
					"BR-BL": "dijitTooltipRight",
					"BL-BR": "dijitTooltipLeft"
				}[aroundCorner + "-" + tooltipCorner];
		},

		_onShow: function(){
			// summary:
			//		Called at end of fade-in operation
			// tags:
			//		protected
			if(dojo.isIE){
				// the arrow won't show up on a node w/an opacity filter
				this.domNode.style.filter="";
			}
		},

		hide: function(aroundNode){
			// summary:
			//		Hide the tooltip
			if(this._onDeck && this._onDeck[1] == aroundNode){
				// this hide request is for a show() that hasn't even started yet;
				// just cancel the pending show()
				this._onDeck=null;
			}else if(this.aroundNode === aroundNode){
				// this hide request is for the currently displayed tooltip
				this.fadeIn.stop();
				this.isShowingNow = false;
				this.aroundNode = null;
				this.fadeOut.play();
			}else{
				// just ignore the call, it's for a tooltip that has already been erased
			}
		},

		_onHide: function(){
			// summary:
			//		Called at end of fade-out operation
			// tags:
			//		protected

			this.domNode.style.cssText="";	// to position offscreen again
			if(this._onDeck){
				// a show request has been queued up; do it now
				this.show.apply(this, this._onDeck);
				this._onDeck=null;
			}
		}

	}
);

dijit.showTooltip = function(/*String*/ innerHTML, /*DomNode*/ aroundNode, /*String[]?*/ position){
	// summary:
	//		Display tooltip w/specified contents in specified position.
	//		See description of dijit.Tooltip.defaultPosition for details on position parameter.
	//		If position is not specified then dijit.Tooltip.defaultPosition is used.
	if(!dijit._masterTT){ dijit._masterTT = new dijit._MasterTooltip(); }
	return dijit._masterTT.show(innerHTML, aroundNode, position);
};

dijit.hideTooltip = function(aroundNode){
	// summary:
	//		Hide the tooltip
	if(!dijit._masterTT){ dijit._masterTT = new dijit._MasterTooltip(); }
	return dijit._masterTT.hide(aroundNode);
};

dojo.declare(
	"dijit.Tooltip",
	dijit._Widget,
	{
		// summary
		//		Pops up a tooltip (a help message) when you hover over a node.

		// label: String
		//		Text to display in the tooltip.
		//		Specified as innerHTML when creating the widget from markup.
		label: "",

		// showDelay: Integer
		//		Number of milliseconds to wait after hovering over/focusing on the object, before
		//		the tooltip is displayed.
		showDelay: 400,

		// connectId: [const] String[]
		//		Id's of domNodes to attach the tooltip to.
		//		When user hovers over any of the specified dom nodes, the tooltip will appear.
		//
		//		Note: Currently connectId can only be specified on initialization, it cannot
		//		be changed via attr('connectId', ...)
		//
		//		Note: in 2.0 this will be renamed to connectIds for less confusion.
		connectId: [],

		// position: String[]
		//		See description of `dijit.Tooltip.defaultPosition` for details on position parameter.
		position: [],

		_setConnectIdAttr: function(ids){
			// TODO: erase old conections

			this._connectNodes = [];

			// TODO: rename connectId to connectIds for 2.0, and remove this code converting from string to array
			this.connectId = dojo.isArrayLike(ids) ? ids : [ids];
			
			dojo.forEach(this.connectId, function(id) {
				var node = dojo.byId(id);
				if (node) {
					this._connectNodes.push(node);
					dojo.forEach(["onMouseEnter", "onMouseLeave", "onFocus", "onBlur"], function(event){
						this.connect(node, event.toLowerCase(), "_"+event);
					}, this);
					if(dojo.isIE){
						// BiDi workaround
						node.style.zoom = 1;
					}
				}
			}, this);
		},

		postCreate: function(){	
			dojo.addClass(this.domNode,"dijitTooltipData");
		},

		_onMouseEnter: function(/*Event*/ e){
			// summary:
			//		Handler for mouseenter event on the target node
			// tags:
			//		private
			this._onHover(e);
		},

		_onMouseLeave: function(/*Event*/ e){
			// summary:
			//		Handler for mouseleave event on the target node
			// tags:
			//		private
			this._onUnHover(e);
		},

		_onFocus: function(/*Event*/ e){
			// summary:
			//		Handler for focus event on the target node
			// tags:
			//		private

			// TODO: this is dangerously named, as the dijit focus manager calls
			// _onFocus() on any widget that gets focus (whereas in this class we
			// are connecting onfocus on the *target* DOM node to this method

			this._focus = true;
			this._onHover(e);
			this.inherited(arguments);
		},
		
		_onBlur: function(/*Event*/ e){
			// summary:
			//		Handler for blur event on the target node
			// tags:
			//		private

			// TODO: rename; see above comment

			this._focus = false;
			this._onUnHover(e);
			this.inherited(arguments);
		},

		_onHover: function(/*Event*/ e){
			// summary:
			//		Despite the name of this method, it actually handles both hover and focus
			//		events on the target node, setting a timer to show the tooltip.
			// tags:
			//		private
			if(!this._showTimer){
				var target = e.target;
				this._showTimer = setTimeout(dojo.hitch(this, function(){this.open(target)}), this.showDelay);
			}
		},

		_onUnHover: function(/*Event*/ e){
			// summary:
			//		Despite the name of this method, it actually handles both mouseleave and blur
			//		events on the target node, hiding the tooltip.
			// tags:
			//		private

			// keep a tooltip open if the associated element still has focus (even though the
			// mouse moved away)
			if(this._focus){ return; }

			if(this._showTimer){
				clearTimeout(this._showTimer);
				delete this._showTimer;
			}
			this.close();
		},

		open: function(/*DomNode*/ target){
 			// summary:
			//		Display the tooltip; usually not called directly.
			// tags:
			//		private

			target = target || this._connectNodes[0];
			if(!target){ return; }

			if(this._showTimer){
				clearTimeout(this._showTimer);
				delete this._showTimer;
			}
			dijit.showTooltip(this.label || this.domNode.innerHTML, target, this.position);
			
			this._connectNode = target;
		},

		close: function(){
			// summary:
			//		Hide the tooltip or cancel timer for show of tooltip
			// tags:
			//		private

			if(this._connectNode){
				// if tooltip is currently shown
				dijit.hideTooltip(this._connectNode);
				delete this._connectNode;
			}
			if(this._showTimer){
				// if tooltip is scheduled to be shown (after a brief delay)
				clearTimeout(this._showTimer);
				delete this._showTimer;
			}
		},

		uninitialize: function(){
			this.close();
		}
	}
);

// dijit.Tooltip.defaultPosition: String[]
//		This variable controls the position of tooltips, if the position is not specified to
//		the Tooltip widget or *TextBox widget itself.  It's an array of strings with the following values:
//
//			* before: places tooltip to the left of the target node/widget, or to the right in
//			  the case of RTL scripts like Hebrew and Arabic
//			* after: places tooltip to the right of the target node/widget, or to the left in
//			  the case of RTL scripts like Hebrew and Arabic
//			* above: tooltip goes above target node
//			* below: tooltip goes below target node
//
//		The list is positions is tried, in order, until a position is found where the tooltip fits
//		within the viewport.
//
//		Be careful setting this parameter.  A value of "above" may work fine until the user scrolls
//		the screen so that there's no room above the target node.   Nodes with drop downs, like
//		DropDownButton or FilteringSelect, are especially problematic, in that you need to be sure
//		that the drop down and tooltip don't overlap, even when the viewport is scrolled so that there
//		is only room below (or above) the target node, but not both.
dijit.Tooltip.defaultPosition = ["after", "before"];

}

if(!dojo._hasResource["dijit.form.ValidationTextBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.ValidationTextBox"] = true;
dojo.provide("dijit.form.ValidationTextBox");








/*=====
	dijit.form.ValidationTextBox.__Constraints = function(){
		// locale: String
		//		locale used for validation, picks up value from this widget's lang attribute
		// _flags_: anything
		//		various flags passed to regExpGen function
		this.locale = "";
		this._flags_ = "";
	}
=====*/

dojo.declare(
	"dijit.form.ValidationTextBox",
	dijit.form.TextBox,
	{
		// summary:
		//		Base class for textbox widgets with the ability to validate content of various types and provide user feedback.
		// tags:
		//		protected

		templateString:"<div class=\"dijit dijitReset dijitInlineTable dijitLeft\"\n\tid=\"widget_${id}\"\n\tdojoAttachEvent=\"onmouseenter:_onMouse,onmouseleave:_onMouse,onmousedown:_onMouse\" waiRole=\"presentation\"\n\t><div style=\"overflow:hidden;\"\n\t\t><div class=\"dijitReset dijitValidationIcon\"><br></div\n\t\t><div class=\"dijitReset dijitValidationIconText\">&Chi;</div\n\t\t><div class=\"dijitReset dijitInputField\"\n\t\t\t><input class=\"dijitReset\" dojoAttachPoint='textbox,focusNode' autocomplete=\"off\"\n\t\t\t${nameAttrSetting} type='${type}'\n\t\t/></div\n\t></div\n></div>\n",
		baseClass: "dijitTextBox",

		// required: Boolean
		//		User is required to enter data into this field.
		required: false,

		// promptMessage: String
		//		If defined, display this hint string immediately on focus to the textbox, if empty.
		//		Think of this like a tooltip that tells the user what to do, not an error message
		//		that tells the user what they've done wrong.
		//
		//		Message disappears when user starts typing.
		promptMessage: "",

		// invalidMessage: String
		// 		The message to display if value is invalid.
		invalidMessage: "$_unset_$", // read from the message file if not overridden

		// constraints: dijit.form.ValidationTextBox.__Constraints
		//		user-defined object needed to pass parameters to the validator functions
		constraints: {},

		// regExp: [extension protected] String
		//		regular expression string used to validate the input
		//		Do not specify both regExp and regExpGen
		regExp: ".*",

		regExpGen: function(/*dijit.form.ValidationTextBox.__Constraints*/constraints){
			// summary:
			//		Overridable function used to generate regExp when dependent on constraints.
			//		Do not specify both regExp and regExpGen.
			// tags:
			//		extension protected
			return this.regExp;     // String
		},

		// state: [readonly] String
		//		Shows current state (ie, validation result) of input (Normal, Warning, or Error)
		state: "",

		// tooltipPosition: String[]
		//		See description of `dijit.Tooltip.defaultPosition` for details on this parameter.
		tooltipPosition: [],

		_setValueAttr: function(){
			// summary:
			//		Hook so attr('value', ...) works.
			this.inherited(arguments);
			this.validate(this._focused);
		},

		validator: function(/*anything*/value, /*dijit.form.ValidationTextBox.__Constraints*/constraints){
			// summary:
			//		Overridable function used to validate the text input against the regular expression.
			// tags:
			//		protected
			return (new RegExp("^(?:" + this.regExpGen(constraints) + ")"+(this.required?"":"?")+"$")).test(value) &&
				(!this.required || !this._isEmpty(value)) &&
				(this._isEmpty(value) || this.parse(value, constraints) !== undefined); // Boolean
		},

		_isValidSubset: function(){
			// summary:
			//		Returns true if the value is either already valid or could be made valid by appending characters.
			//		This is used for validation while the user [may be] still typing.
			return this.textbox.value.search(this._partialre) == 0;
		},

		isValid: function(/*Boolean*/ isFocused){
			// summary:
			//		Tests if value is valid.
			//		Can override with your own routine in a subclass.
			// tags:
			//		protected
			return this.validator(this.textbox.value, this.constraints);
		},

		_isEmpty: function(value){
			// summary:
			//		Checks for whitespace
			return /^\s*$/.test(value); // Boolean
		},

		getErrorMessage: function(/*Boolean*/ isFocused){
			// summary:
			//		Return an error message to show if appropriate
			// tags:
			//		protected
			return this.invalidMessage; // String
		},

		getPromptMessage: function(/*Boolean*/ isFocused){
			// summary:
			//		Return a hint message to show when widget is first focused
			// tags:
			//		protected
			return this.promptMessage; // String
		},

		_maskValidSubsetError: true,
		validate: function(/*Boolean*/ isFocused){
			// summary:
			//		Called by oninit, onblur, and onkeypress.
			// description:
			//		Show missing or invalid messages if appropriate, and highlight textbox field.
			// tags:
			//		protected
			var message = "";
			var isValid = this.disabled || this.isValid(isFocused);
			if(isValid){ this._maskValidSubsetError = true; }
			var isValidSubset = !isValid && isFocused && this._isValidSubset();
			var isEmpty = this._isEmpty(this.textbox.value);
			this.state = (isValid || (!this._hasBeenBlurred && isEmpty) || isValidSubset) ? "" : "Error";
			if(this.state == "Error"){ this._maskValidSubsetError = false; }
			this._setStateClass();
			dijit.setWaiState(this.focusNode, "invalid", isValid ? "false" : "true");
			if(isFocused){
				if(isEmpty){
					message = this.getPromptMessage(true);
				}
				if(!message && (this.state == "Error" || (isValidSubset && !this._maskValidSubsetError))){
					message = this.getErrorMessage(true);
				}
			}
			this.displayMessage(message);
			return isValid;
		},

		// _message: String
		//		Currently displayed message
		_message: "",

		displayMessage: function(/*String*/ message){
			// summary:
			//		Overridable method to display validation errors/hints.
			//		By default uses a tooltip.
			// tags:
			//		extension
			if(this._message == message){ return; }
			this._message = message;
			dijit.hideTooltip(this.domNode);
			if(message){
				dijit.showTooltip(message, this.domNode, this.tooltipPosition);
			}
		},

		_refreshState: function(){
			// Overrides TextBox._refreshState()
			this.validate(this._focused);
			this.inherited(arguments);
		},

		//////////// INITIALIZATION METHODS ///////////////////////////////////////

		constructor: function(){
			this.constraints = {};
		},

		postMixInProperties: function(){
			this.inherited(arguments);
			this.constraints.locale = this.lang;
			this.messages = dojo.i18n.getLocalization("dijit.form", "validate", this.lang);
			if(this.invalidMessage == "$_unset_$"){ this.invalidMessage = this.messages.invalidMessage; }
			var p = this.regExpGen(this.constraints);
			this.regExp = p;
			var partialre = "";
			// parse the regexp and produce a new regexp that matches valid subsets
			// if the regexp is .* then there's no use in matching subsets since everything is valid
			if(p != ".*"){ this.regExp.replace(/\\.|\[\]|\[.*?[^\\]{1}\]|\{.*?\}|\(\?[=:!]|./g,
				function (re){
					switch(re.charAt(0)){
						case '{':
						case '+':
						case '?':
						case '*':
						case '^':
						case '$':
						case '|':
						case '(': partialre += re; break;
						case ")": partialre += "|$)"; break;
						 default: partialre += "(?:"+re+"|$)"; break;
					}
				}
			);}
			try{ // this is needed for now since the above regexp parsing needs more test verification
				"".search(partialre);
			}catch(e){ // should never be here unless the original RE is bad or the parsing is bad
				partialre = this.regExp;
				console.warn('RegExp error in ' + this.declaredClass + ': ' + this.regExp);
			} // should never be here unless the original RE is bad or the parsing is bad
			this._partialre = "^(?:" + partialre + ")$";
		},

		_setDisabledAttr: function(/*Boolean*/ value){
			this.inherited(arguments);	// call FormValueWidget._setDisabledAttr()
			if(this.valueNode){
				this.valueNode.disabled = value;
			}
			this._refreshState();
		},
		
		_setRequiredAttr: function(/*Boolean*/ value){
			this.required = value;
			dijit.setWaiState(this.focusNode,"required", value);
			this._refreshState();				
		},

		postCreate: function(){
			if(dojo.isIE){ // IE INPUT tag fontFamily has to be set directly using STYLE
				var s = dojo.getComputedStyle(this.focusNode);
				if(s){
					var ff = s.fontFamily;
					if(ff){
						this.focusNode.style.fontFamily = ff;
					}
				}
			}
			this.inherited(arguments);
		},

		reset:function(){
			// Overrides dijit.form.TextBox.reset() by also
			// hiding errors about partial matches
			this._maskValidSubsetError = true;
			this.inherited(arguments);
		}
	}
);

dojo.declare(
	"dijit.form.MappedTextBox",
	dijit.form.ValidationTextBox,
	{
		// summary:
		//		A dijit.form.ValidationTextBox subclass which provides a base class for widgets that have
		//		a visible formatted display value, and a serializable
		//		value in a hidden input field which is actually sent to the server.
		// description:
		//		The visible display may
		//		be locale-dependent and interactive.  The value sent to the server is stored in a hidden
		//		input field which uses the `name` attribute declared by the original widget.  That value sent
		//		to the server is defined by the dijit.form.MappedTextBox.serialize method and is typically
		//		locale-neutral.
		// tags:
		//		protected

		postMixInProperties: function(){
			this.inherited(arguments);
			
			// we want the name attribute to go to the hidden <input>, not the displayed <input>,
			// so override _FormWidget.postMixInProperties() setting of nameAttrSetting
			this.nameAttrSetting = "";
		},

		serialize: function(/*anything*/val, /*Object?*/options){
			// summary:
			//		Overridable function used to convert the attr('value') result to a canonical
			//		(non-localized) string.  For example, will print dates in ISO format, and
			//		numbers the same way as they are represented in javascript.
			// tags:
			//		protected extension
			return val.toString ? val.toString() : ""; // String
		},

		toString: function(){
			// summary:
			//		Returns widget as a printable string using the widget's value
			// tags:
			//		protected
			var val = this.filter(this.attr('value')); // call filter in case value is nonstring and filter has been customized
			return val != null ? (typeof val == "string" ? val : this.serialize(val, this.constraints)) : ""; // String
		},

		validate: function(){
			// Overrides `dijit.form.TextBox.validate`
			this.valueNode.value = this.toString();
			return this.inherited(arguments);
		},

		buildRendering: function(){
			// Overrides `dijit._Templated.buildRendering`

			this.inherited(arguments);

			// Create a hidden <input> node with the serialized value used for submit
			// (as opposed to the displayed value)
			this.valueNode = dojo.create("input", {
				style: { display: "none" },
				type: this.type,
				name: this.name
			}, this.textbox, "after");
		},

		_setDisabledAttr: function(/*Boolean*/ value){
			this.inherited(arguments);
			dojo.attr(this.valueNode, 'disabled', value);
		},

		reset:function(){
			// Overrides `dijit.form.ValidationTextBox.reset` to
			// reset the hidden textbox value to ''
			this.valueNode.value = '';
			this.inherited(arguments);
		}
	}
);

/*=====
	dijit.form.RangeBoundTextBox.__Constraints = function(){
		// min: Number
		//		Minimum signed value.  Default is -Infinity
		// max: Number
		//		Maximum signed value.  Default is +Infinity
		this.min = min;
		this.max = max;
	}
=====*/

dojo.declare(
	"dijit.form.RangeBoundTextBox",
	dijit.form.MappedTextBox,
	{
		// summary:
		//		Base class for textbox form widgets which defines a range of valid values.

		// rangeMessage: String
		//		The message to display if value is out-of-range
		rangeMessage: "",

		/*=====
		// constraints: dijit.form.RangeBoundTextBox.__Constraints
		constraints: {},
		======*/

		rangeCheck: function(/*Number*/ primitive, /*dijit.form.RangeBoundTextBox.__Constraints*/ constraints){
			// summary:
			//		Overridable function used to validate the range of the numeric input value.
			// tags:
			//		protected
			var isMin = "min" in constraints;
			var isMax = "max" in constraints;
			if(isMin || isMax){
				return (!isMin || this.compare(primitive,constraints.min) >= 0) &&
					(!isMax || this.compare(primitive,constraints.max) <= 0);
			}
			return true; // Boolean
		},

		isInRange: function(/*Boolean*/ isFocused){
			// summary:
			//		Tests if the value is in the min/max range specified in constraints
			// tags:
			//		protected
			return this.rangeCheck(this.attr('value'), this.constraints);
		},

		_isDefinitelyOutOfRange: function(){
			// summary:
			//		Returns true if the value is out of range and will remain
			//		out of range even if the user types more characters
			var val = this.attr('value');
			var isTooLittle = false;
			var isTooMuch = false;
			if("min" in this.constraints){
				var min = this.constraints.min;
				val = this.compare(val, ((typeof min == "number") && min >= 0 && val !=0)? 0 : min);
				isTooLittle = (typeof val == "number") && val < 0;
			}
			if("max" in this.constraints){
				var max = this.constraints.max;
				val = this.compare(val, ((typeof max != "number") || max > 0)? max : 0);
				isTooMuch = (typeof val == "number") && val > 0;
			}
			return isTooLittle || isTooMuch;
		},

		_isValidSubset: function(){
			// summary:
			//		Overrides `dijit.form.ValidationTextBox._isValidSubset`.
			//		Returns true if the input is syntactically valid, and either within
			//		range or could be made in range by more typing.
			return this.inherited(arguments) && !this._isDefinitelyOutOfRange();
		},

		isValid: function(/*Boolean*/ isFocused){
			// Overrides dijit.form.ValidationTextBox.isValid to check that the value is also in range.
			return this.inherited(arguments) &&
				((this._isEmpty(this.textbox.value) && !this.required) || this.isInRange(isFocused)); // Boolean
		},

		getErrorMessage: function(/*Boolean*/ isFocused){
			// Overrides dijit.form.ValidationTextBox.getErrorMessage to print "out of range" message if appropriate
			if(dijit.form.RangeBoundTextBox.superclass.isValid.call(this, false) && !this.isInRange(isFocused)){ return this.rangeMessage; } // String
			return this.inherited(arguments);
		},

		postMixInProperties: function(){
			this.inherited(arguments);
			if(!this.rangeMessage){
				this.messages = dojo.i18n.getLocalization("dijit.form", "validate", this.lang);
				this.rangeMessage = this.messages.rangeMessage;
			}
		},

		postCreate: function(){
			this.inherited(arguments);
			if(this.constraints.min !== undefined){
				dijit.setWaiState(this.focusNode, "valuemin", this.constraints.min);
			}
			if(this.constraints.max !== undefined){
				dijit.setWaiState(this.focusNode, "valuemax", this.constraints.max);
			}
		},
		
		_setValueAttr: function(/*Number*/ value, /*Boolean?*/ priorityChange){
			// summary:
			//		Hook so attr('value', ...) works.

			dijit.setWaiState(this.focusNode, "valuenow", value);
			this.inherited(arguments);
		}
	}
);

}

if(!dojo._hasResource["dijit.form.Button"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.Button"] = true;
dojo.provide("dijit.form.Button");




dojo.declare("dijit.form.Button",
	dijit.form._FormWidget,
	{
	// summary:
	//		Basically the same thing as a normal HTML button, but with special styling.
	// description:
	//		Buttons can display a label, an icon, or both.
	//		A label should always be specified (through innerHTML) or the label
	//		attribute.  It can be hidden via showLabel=false.
	// example:
	// |	<button dojoType="dijit.form.Button" onClick="...">Hello world</button>
	// 
	// example:
	// |	var button1 = new dijit.form.Button({label: "hello world", onClick: foo});
	// |	dojo.body().appendChild(button1.domNode);

	// label: HTML String
	//		Text to display in button.
	//		If the label is hidden (showLabel=false) then and no title has
	//		been specified, then label is also set as title attribute of icon.
	label: "",

	// showLabel: Boolean
	//		Set this to true to hide the label text and display only the icon.
	//		(If showLabel=false then iconClass must be specified.)
	//		Especially useful for toolbars.  
	//		If showLabel=true, the label will become the title (a.k.a. tooltip/hint) of the icon.
	//
	//		The exception case is for computers in high-contrast mode, where the label
	//		will still be displayed, since the icon doesn't appear.
	showLabel: true,

	// iconClass: String
	//		Class to apply to div in button to make it display an icon
	iconClass: "",

	// type: String
	//		Defines the type of button.  "button", "submit", or "reset".
	type: "button",

	baseClass: "dijitButton",

	templateString:"<span class=\"dijit dijitReset dijitLeft dijitInline\"\n\tdojoAttachEvent=\"ondijitclick:_onButtonClick,onmouseenter:_onMouse,onmouseleave:_onMouse,onmousedown:_onMouse\"\n\t><span class=\"dijitReset dijitRight dijitInline\"\n\t\t><span class=\"dijitReset dijitInline dijitButtonNode\"\n\t\t\t><button class=\"dijitReset dijitStretch dijitButtonContents\"\n\t\t\t\tdojoAttachPoint=\"titleNode,focusNode\" \n\t\t\t\t${nameAttrSetting} type=\"${type}\" value=\"${value}\" waiRole=\"button\" waiState=\"labelledby-${id}_label\"\n\t\t\t\t><span class=\"dijitReset dijitInline\" dojoAttachPoint=\"iconNode\" \n\t\t\t\t\t><span class=\"dijitReset dijitToggleButtonIconChar\">&#10003;</span \n\t\t\t\t></span \n\t\t\t\t><span class=\"dijitReset dijitInline dijitButtonText\" \n\t\t\t\t\tid=\"${id}_label\"  \n\t\t\t\t\tdojoAttachPoint=\"containerNode\"\n\t\t\t\t></span\n\t\t\t></button\n\t\t></span\n\t></span\n></span>\n",

	attributeMap: dojo.delegate(dijit.form._FormWidget.prototype.attributeMap, {
		label: { node: "containerNode", type: "innerHTML" },
		iconClass: { node: "iconNode", type: "class" }
	}),
		

	_onClick: function(/*Event*/ e){
		// summary:
		//		Internal function to handle click actions
		if(this.disabled || this.readOnly){
			return false;
		}
		this._clicked(); // widget click actions
		return this.onClick(e); // user click actions
	},

	_onButtonClick: function(/*Event*/ e){
		// summary:
		//		Handler when the user activates the button portion.
		//		If is activated via a keystroke, stop the event unless is submit or reset.
		if(e.type!='click' && !(this.type=="submit" || this.type=="reset")){
			dojo.stopEvent(e);
		}
		if(this._onClick(e) === false){ // returning nothing is same as true
			e.preventDefault(); // needed for checkbox
		}else if(this.type=="submit" && !this.focusNode.form){ // see if a nonform widget needs to be signalled
			for(var node=this.domNode; node.parentNode/*#5935*/; node=node.parentNode){
				var widget=dijit.byNode(node);
				if(widget && typeof widget._onSubmit == "function"){
					widget._onSubmit(e);
					break;
				}
			}
		}
	},

	_setValueAttr: function(/*String*/ value){
		// Verify that value cannot be set for BUTTON elements.
		var attr = this.attributeMap.value || '';
		if(this[attr.node||attr||'domNode'].tagName == 'BUTTON'){
			// On IE, setting value actually overrides innerHTML, so disallow for everyone for consistency
			if(value != this.value){
				console.debug('Cannot change the value attribute on a Button widget.');
			}
		}
	},

	_fillContent: function(/*DomNode*/ source){
		// Overrides _Templated._fillcContent().
		// If button label is specified as srcNodeRef.innerHTML rather than
		// this.params.label, handle it here.
		if(source && !("label" in this.params)){
			this.attr('label', source.innerHTML);
		}
	},

	postCreate: function(){
		if (this.showLabel == false){
			dojo.addClass(this.containerNode,"dijitDisplayNone");
		}
		dojo.setSelectable(this.focusNode, false);
		this.inherited(arguments);
	},

	onClick: function(/*Event*/ e){
		// summary:
		//		Callback for when button is clicked.
		//		If type="submit", return true to perform submit, or false to cancel it.
		// type:
		//		callback
		return true;		// Boolean
	},

	_clicked: function(/*Event*/ e){
		// summary:
		//		Internal overridable function for when the button is clicked
	},

	setLabel: function(/*String*/ content){
		// summary:
		//		Deprecated.  Use attr('label', ...) instead.
		dojo.deprecated("dijit.form.Button.setLabel() is deprecated.  Use attr('label', ...) instead.", "", "2.0");
		this.attr("label", content);
	},
	_setLabelAttr: function(/*String*/ content){
		// summary:
		//		Hook for attr('label', ...) to work.
		// description:
		//		Set the label (text) of the button; takes an HTML string.
		this.containerNode.innerHTML = this.label = content;
		this._layoutHack();
		if (this.showLabel == false && !this.params.title){
			this.titleNode.title = dojo.trim(this.containerNode.innerText || this.containerNode.textContent || '');
		}
	}		
});


dojo.declare("dijit.form.DropDownButton", [dijit.form.Button, dijit._Container], {
	// summary:
	//		A button with a drop down
	//
	// example:
	// |	<button dojoType="dijit.form.DropDownButton" label="Hello world">
	// |		<div dojotype="dijit.Menu">...</div>
	// |	</button>
	//
	// example:
	// |	var button1 = new dijit.form.DropDownButton({ label: "hi", dropDown: new dijit.Menu(...) });
	// |	dojo.body().appendChild(button1);
	// 	
	
	baseClass : "dijitDropDownButton",

	templateString:"<span class=\"dijit dijitReset dijitLeft dijitInline\"\n\tdojoAttachEvent=\"onmouseenter:_onMouse,onmouseleave:_onMouse,onmousedown:_onMouse,onclick:_onDropDownClick,onkeydown:_onDropDownKeydown,onblur:_onDropDownBlur,onkeypress:_onKey\"\n\t><span class='dijitReset dijitRight dijitInline'\n\t\t><span class='dijitReset dijitInline dijitButtonNode'\n\t\t\t><button class=\"dijitReset dijitStretch dijitButtonContents\" \n\t\t\t\t${nameAttrSetting} type=\"${type}\" value=\"${value}\"\n\t\t\t\tdojoAttachPoint=\"focusNode,titleNode\" \n\t\t\t\twaiRole=\"button\" waiState=\"haspopup-true,labelledby-${id}_label\"\n\t\t\t\t><span class=\"dijitReset dijitInline\" \n\t\t\t\t\tdojoAttachPoint=\"iconNode\"\n\t\t\t\t></span\n\t\t\t\t><span class=\"dijitReset dijitInline dijitButtonText\"  \n\t\t\t\t\tdojoAttachPoint=\"containerNode,popupStateNode\" \n\t\t\t\t\tid=\"${id}_label\"\n\t\t\t\t></span\n\t\t\t\t><span class=\"dijitReset dijitInline dijitArrowButtonInner\">&thinsp;</span\n\t\t\t\t><span class=\"dijitReset dijitInline dijitArrowButtonChar\">&#9660;</span\n\t\t\t></button\n\t\t></span\n\t></span\n></span>\n",

	_fillContent: function(){
		// Overrides Button._fillContent().
		//
		// My inner HTML contains both the button contents and a drop down widget, like
		// <DropDownButton>  <span>push me</span>  <Menu> ... </Menu> </DropDownButton>
		// The first node is assumed to be the button content. The widget is the popup.

		if(this.srcNodeRef){ // programatically created buttons might not define srcNodeRef
			//FIXME: figure out how to filter out the widget and use all remaining nodes as button
			//	content, not just nodes[0]
			var nodes = dojo.query("*", this.srcNodeRef);
			dijit.form.DropDownButton.superclass._fillContent.call(this, nodes[0]);

			// save pointer to srcNode so we can grab the drop down widget after it's instantiated
			this.dropDownContainer = this.srcNodeRef;
		}
	},

	startup: function(){
		if(this._started){ return; }

		// the child widget from srcNodeRef is the dropdown widget.  Insert it in the page DOM,
		// make it invisible, and store a reference to pass to the popup code.
		if(!this.dropDown){
			var dropDownNode = dojo.query("[widgetId]", this.dropDownContainer)[0];
			this.dropDown = dijit.byNode(dropDownNode);
			delete this.dropDownContainer;
		}
		dijit.popup.prepare(this.dropDown.domNode);

		this.inherited(arguments);
	},

	destroyDescendants: function(){
		if(this.dropDown){
			this.dropDown.destroyRecursive();
			delete this.dropDown;
		}
		this.inherited(arguments);
	},

	_onArrowClick: function(/*Event*/ e){
		// summary:
		//		Handler for when the user mouse clicks on menu popup node
		if(this.disabled || this.readOnly){ return; }
		this._toggleDropDown();
	},

	_onDropDownClick: function(/*Event*/ e){
		// on Firefox 2 on the Mac it is possible to fire onclick
		// by pressing enter down on a second element and transferring
		// focus to the DropDownButton;
		// we want to prevent opening our menu in this situation
		// and only do so if we have seen a keydown on this button;
		// e.detail != 0 means that we were fired by mouse
		var isMacFFlessThan3 = dojo.isFF && dojo.isFF < 3
			&& navigator.appVersion.indexOf("Macintosh") != -1;
		if(!isMacFFlessThan3 || e.detail != 0 || this._seenKeydown){
			this._onArrowClick(e);
		}
		this._seenKeydown = false;
	},

	_onDropDownKeydown: function(/*Event*/ e){
		this._seenKeydown = true;
	},

	_onDropDownBlur: function(/*Event*/ e){
		this._seenKeydown = false;
	},

	_onKey: function(/*Event*/ e){
		// summary:
		//		Handler when the user presses a key on drop down widget
		if(this.disabled || this.readOnly){ return; }
		if(e.charOrCode == dojo.keys.DOWN_ARROW){
			if(!this.dropDown || this.dropDown.domNode.style.visibility=="hidden"){
				dojo.stopEvent(e);
				this._toggleDropDown();
			}
		}
	},

	_onBlur: function(){
		// summary:
		//		Called magically when focus has shifted away from this widget and it's dropdown
		this._closeDropDown();
		// don't focus on button.  the user has explicitly focused on something else.
		this.inherited(arguments);
	},

	_toggleDropDown: function(){
		// summary:
		//		Toggle the drop-down widget; if it is up, close it; if not, open it.
		if(this.disabled || this.readOnly){ return; }
		dijit.focus(this.popupStateNode);
		var dropDown = this.dropDown;
		if(!dropDown){ return; }
		if(!this._opened){
			// If there's an href, then load that first, so we don't get a flicker
			if(dropDown.href && !dropDown.isLoaded){
				var self = this;
				var handler = dojo.connect(dropDown, "onLoad", function(){
					dojo.disconnect(handler);
					self._openDropDown();
				});
				dropDown.refresh();
				return;
			}else{
				this._openDropDown();
			}
		}else{
			this._closeDropDown();
		}
	},

	_openDropDown: function(){
		var dropDown = this.dropDown;
		var oldWidth=dropDown.domNode.style.width;
		var self = this;

		dijit.popup.open({
			parent: this,
			popup: dropDown,
			around: this.domNode,
			orient:
				// TODO: add user-defined positioning option, like in Tooltip.js
				this.isLeftToRight() ? {'BL':'TL', 'BR':'TR', 'TL':'BL', 'TR':'BR'}
				: {'BR':'TR', 'BL':'TL', 'TR':'BR', 'TL':'BL'},
			onExecute: function(){
				self._closeDropDown(true);
			},
			onCancel: function(){
				self._closeDropDown(true);
			},
			onClose: function(){
				dropDown.domNode.style.width = oldWidth;
				self.popupStateNode.removeAttribute("popupActive");
				self._opened = false;
			}
		});
		if(this.domNode.offsetWidth > dropDown.domNode.offsetWidth){
			var adjustNode = null;
			if(!this.isLeftToRight()){
				adjustNode = dropDown.domNode.parentNode;
				var oldRight = adjustNode.offsetLeft + adjustNode.offsetWidth;
			}
			// make menu at least as wide as the button
			dojo.marginBox(dropDown.domNode, {w: this.domNode.offsetWidth});
			if(adjustNode){
				adjustNode.style.left = oldRight - this.domNode.offsetWidth + "px";
			}
		}
		this.popupStateNode.setAttribute("popupActive", "true");
		this._opened=true;
		if(dropDown.focus){
			dropDown.focus();
		}
		// TODO: set this.checked and call setStateClass(), to affect button look while drop down is shown
	},
	
	_closeDropDown: function(/*Boolean*/ focus){
		if(this._opened){
			dijit.popup.close(this.dropDown);
			if(focus){ this.focus(); }
			this._opened = false;			
		}
	}
});

dojo.declare("dijit.form.ComboButton", dijit.form.DropDownButton, {
	// summary:
	//		A combination button and drop-down button.
	//		Users can click one side to "press" the button, or click an arrow
	//		icon to display the drop down.
	//
	// example:
	// |	<button dojoType="dijit.form.ComboButton" onClick="...">
	// |		<span>Hello world</span>
	// |		<div dojoType="dijit.Menu">...</div>
	// |	</button>
	//
	// example:
	// |	var button1 = new dijit.form.ComboButton({label: "hello world", onClick: foo, dropDown: "myMenu"});
	// |	dojo.body().appendChild(button1.domNode);
	// 

	templateString:"<table class='dijit dijitReset dijitInline dijitLeft'\n\tcellspacing='0' cellpadding='0' waiRole=\"presentation\"\n\t><tbody waiRole=\"presentation\"><tr waiRole=\"presentation\"\n\t\t><td class=\"dijitReset dijitStretch dijitButtonContents dijitButtonNode\"\n\t\t\tdojoAttachEvent=\"ondijitclick:_onButtonClick,onmouseenter:_onMouse,onmouseleave:_onMouse,onmousedown:_onMouse\"  dojoAttachPoint=\"titleNode\"\n\t\t\twaiRole=\"button\" waiState=\"labelledby-${id}_label\"\n\t\t\t><div class=\"dijitReset dijitInline\" dojoAttachPoint=\"iconNode\" waiRole=\"presentation\"></div\n\t\t\t><div class=\"dijitReset dijitInline dijitButtonText\" id=\"${id}_label\" dojoAttachPoint=\"containerNode\" waiRole=\"presentation\"></div\n\t\t></td\n\t\t><td class='dijitReset dijitRight dijitButtonNode dijitArrowButton dijitDownArrowButton'\n\t\t\tdojoAttachPoint=\"popupStateNode,focusNode\"\n\t\t\tdojoAttachEvent=\"ondijitclick:_onArrowClick, onkeypress:_onKey,onmouseenter:_onMouse,onmouseleave:_onMouse\"\n\t\t\tstateModifier=\"DownArrow\"\n\t\t\ttitle=\"${optionsTitle}\" ${nameAttrSetting}\n\t\t\twaiRole=\"button\" waiState=\"haspopup-true\"\n\t\t\t><div class=\"dijitReset dijitArrowButtonInner\" waiRole=\"presentation\">&thinsp;</div\n\t\t\t><div class=\"dijitReset dijitArrowButtonChar\" waiRole=\"presentation\">&#9660;</div\n\t\t></td\n\t></tr></tbody\n></table>\n",

	attributeMap: dojo.mixin(dojo.clone(dijit.form.Button.prototype.attributeMap), {
		id:"",
		tabIndex: ["focusNode", "titleNode"]
	}),

	// optionsTitle: String
	//		Text that describes the options menu (accessibility)
	optionsTitle: "",

	baseClass: "dijitComboButton",

	_focusedNode: null,

	postCreate: function(){
		this.inherited(arguments);
		this._focalNodes = [this.titleNode, this.popupStateNode];
		dojo.forEach(this._focalNodes, dojo.hitch(this, function(node){
			if(dojo.isIE){
				this.connect(node, "onactivate", this._onNodeFocus);
				this.connect(node, "ondeactivate", this._onNodeBlur);
			}else{
				this.connect(node, "onfocus", this._onNodeFocus);
				this.connect(node, "onblur", this._onNodeBlur);
			}
		}));
	},

	focusFocalNode: function(node){
		// summary:
		//		Focus the focal node node.
		// description:
		//		Called by _KeyNavContainer for (when example) this button is in a toolbar.
		// tags:
		//		protected
		this._focusedNode = node;
		dijit.focus(node);
	},

	hasNextFocalNode: function(){
		// summary:
		//		Returns true if this widget has no node currently
		//		focused or if there is a node following the focused one.
		//		False is returned if the last node has focus.
		// description:
		//		Called by _KeyNavContainer for (when example) this button is in a toolbar.
		// tags:
		//		protected
		return this._focusedNode !== this.getFocalNodes()[1];
	},

	focusNext: function(){
		// summary:
		//		Focus the focal node following the current node with focus,
		//		or the first one if no node currently has focus.
		// description:
		//		Called by _KeyNavContainer for (when example) this button is in a toolbar.
		// tags:
		//		protected
		this._focusedNode = this.getFocalNodes()[this._focusedNode ? 1 : 0];
		dijit.focus(this._focusedNode);
	},

	hasPrevFocalNode: function(){
		// summary:
		//		Returns true if this widget has no node currently
		//		focused or if there is a node before the focused one.
		//		False is returned if the first node has focus.
		// description:
		//		Called by _KeyNavContainer for (when example) this button is in a toolbar.
		// tags:
		//		protected
		return this._focusedNode !== this.getFocalNodes()[0];
	},

	focusPrev: function(){
		// summary:
		//		Focus the focal node before the current node with focus
		//		or the last one if no node currently has focus.
		// description:
		//		Called by _KeyNavContainer for (when example) this button is in a toolbar.
		// tags:
		//		protected
		this._focusedNode = this.getFocalNodes()[this._focusedNode ? 0 : 1];
		dijit.focus(this._focusedNode);
	},

	getFocalNodes: function(){
		// summary:
		//		Returns an array of focal nodes for this widget.
		// description:
		//		Called by _KeyNavContainer for (when example) this button is in a toolbar.
		// tags:
		//		protected
		return this._focalNodes;
	},

	_onNodeFocus: function(evt){
		this._focusedNode = evt.currentTarget;
		var fnc = this._focusedNode == this.focusNode ? "dijitDownArrowButtonFocused" : "dijitButtonContentsFocused";
		dojo.addClass(this._focusedNode, fnc);
	},

	_onNodeBlur: function(evt){
		var fnc = evt.currentTarget == this.focusNode ? "dijitDownArrowButtonFocused" : "dijitButtonContentsFocused";
		dojo.removeClass(evt.currentTarget, fnc);
	},

	_onBlur: function(){
		this.inherited(arguments);
		this._focusedNode = null;
	}
});

dojo.declare("dijit.form.ToggleButton", dijit.form.Button, {
	// summary:
	//		A button that can be in two states (checked or not).
	//		Can be base class for things like tabs or checkbox or radio buttons

	baseClass: "dijitToggleButton",

	// checked: Boolean
	//		Corresponds to the native HTML <input> element's attribute.
	//		In markup, specified as "checked='checked'" or just "checked".
	//		True if the button is depressed, or the checkbox is checked,
	//		or the radio button is selected, etc.
	checked: false,

	attributeMap: dojo.mixin(dojo.clone(dijit.form.Button.prototype.attributeMap),
		{checked:"focusNode"}),

	_clicked: function(/*Event*/ evt){
		this.attr('checked', !this.checked);
	},

	_setCheckedAttr: function(/*Boolean*/ value){
		this.checked = value;
		dojo.attr(this.focusNode || this.domNode, "checked", value);
		dijit.setWaiState(this.focusNode || this.domNode, "pressed", value);
		this._setStateClass();		
		this._handleOnChange(value, true);
	},

	setChecked: function(/*Boolean*/ checked){
		// summary:
		//		Deprecated.   Use attr('checked', true/false) instead.
		dojo.deprecated("setChecked("+checked+") is deprecated. Use attr('checked',"+checked+") instead.", "", "2.0");
		this.attr('checked', checked);
	},
	
	reset: function(){
		// summary:
		//		Reset the widget's value to what it was at initialization time

		this._hasBeenBlurred = false;

		// set checked state to original setting
		this.attr('checked', this.params.checked || false);
	}
});

}

if(!dojo._hasResource["dijit.InlineEditBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.InlineEditBox"] = true;
dojo.provide("dijit.InlineEditBox");










dojo.declare("dijit.InlineEditBox",
	dijit._Widget,
	{
	// summary:
	//		An element with in-line edit capabilitites
	//
	// description:
	//		Behavior for an existing node (`<p>`, `<div>`, `<span>`, etc.) so that
	// 		when you click it, an editor shows up in place of the original
	//		text.  Optionally, Save and Cancel button are displayed below the edit widget.
	//		When Save is clicked, the text is pulled from the edit
	//		widget and redisplayed and the edit widget is again hidden.
	//		By default a plain Textarea widget is used as the editor (or for
	//		inline values a TextBox), but you can specify an editor such as
	//		dijit.Editor (for editing HTML) or a Slider (for adjusting a number).
	//		An edit widget must support the following API to be used:
	//			- displayedValue or value as initialization parameter,
	//			and available through attr('displayedValue') / attr('value')
	//			- void focus()
	//			- DOM-node focusNode = node containing editable text

	// editing: [readonly] Boolean
	//		Is the node currently in edit mode?
	editing: false,

	// autoSave: Boolean
	//		Changing the value automatically saves it; don't have to push save button
	//		(and save button isn't even displayed)
	autoSave: true,

	// buttonSave: String
	//		Save button label
	buttonSave: "",

	// buttonCancel: String
	//		Cancel button label
	buttonCancel: "",

	// renderAsHtml: Boolean
	//		Set this to true if the specified Editor's value should be interpreted as HTML
	//		rather than plain text (ex: `dijit.Editor`)
	renderAsHtml: false,

	// editor: String
	//		Class name for Editor widget
	editor: "dijit.form.TextBox",

	// editorParams: Object
	//		Set of parameters for editor, like {required: true}
	editorParams: {},

	onChange: function(value){
		// summary:
		//		Set this handler to be notified of changes to value.
		// tags:
		//		callback
	},
	
	onCancel: function(){
		// summary:
		//		Set this handler to be notified when editing is cancelled.
		// tags:
		//		callback
	},

	// width: String
	//		Width of editor.  By default it's width=100% (ie, block mode).
	width: "100%",

	// value: String
	//		The display value of the widget in read-only mode
	value: "",

	// noValueIndicator: [const] String
	//		The text that gets displayed when there is no value (so that the user has a place to click to edit)
	noValueIndicator: "<span style='font-family: wingdings; text-decoration: underline;'>&nbsp;&nbsp;&nbsp;&nbsp;&#x270d;&nbsp;&nbsp;&nbsp;&nbsp;</span>",

	constructor: function(){
		// summary:
		//		Sets up private arrays etc.
		// tags:
		//		private
		this.editorParams = {};
	},

	postMixInProperties: function(){
		this.inherited(arguments);

		// save pointer to original source node, since Widget nulls-out srcNodeRef
		this.displayNode = this.srcNodeRef;

		// connect handlers to the display node
		var events = {
			ondijitclick: "_onClick",
			onmouseover: "_onMouseOver",
			onmouseout: "_onMouseOut",
			onfocus: "_onMouseOver",
			onblur: "_onMouseOut"			
		};
		for(var name in events){
			this.connect(this.displayNode, name, events[name]);
		}
		dijit.setWaiRole(this.displayNode, "button");
		if(!this.displayNode.getAttribute("tabIndex")){
			this.displayNode.setAttribute("tabIndex", 0);
		}

		this.attr('value', this.value || this.displayNode.innerHTML);
	},

	setDisabled: function(/*Boolean*/ disabled){
		// summary:
		//		Deprecated.   Use attr('disable', ...) instead.
		// tags:
		//		deprecated
		dojo.deprecated("dijit.InlineEditBox.setDisabled() is deprecated.  Use attr('disabled', bool) instead.", "", "2.0");
		this.attr('disabled', disabled);
	},
	_setDisabledAttr: function(/*Boolean*/ disabled){
		// summary: 
		//		Hook to make attr("disabled", ...) work.
		//		Set disabled state of widget.
		this.disabled = disabled;
		dijit.setWaiState(this.domNode, "disabled", disabled);
	},

	_onMouseOver: function(){
		// summary:
		//		Handler for onmouseover event.
		// tags:
		//		private
		dojo.addClass(this.displayNode, this.disabled ? "dijitDisabledClickableRegion" : "dijitClickableRegion");
	},

	_onMouseOut: function(){
		// summary:
		//		Handler for onmouseout event.
		// tags:
		//		private
		dojo.removeClass(this.displayNode, this.disabled ? "dijitDisabledClickableRegion" : "dijitClickableRegion");
	},

	_onClick: function(/*Event*/ e){
		// summary:
		//		Handler for onclick event.
		// tags:
		//		private
		if(this.disabled){ return; }
		if(e){ dojo.stopEvent(e); }
		this._onMouseOut();

		// Since FF gets upset if you move a node while in an event handler for that node...
		setTimeout(dojo.hitch(this, "edit"), 0);
	},

	edit: function(){
		// summary:
		//		Display the editor widget in place of the original (read only) markup.
		// tags:
		//		private

		if(this.disabled || this.editing){ return; }
		this.editing = true;

		var editValue = 
				(this.renderAsHtml ?
				this.value :
				this.value.replace(/\s*\r?\n\s*/g,"").replace(/<br\/?>/gi,"\n").replace(/&gt;/g,">").replace(/&lt;/g,"<").replace(/&amp;/g,"&").replace(/&quot;/g,"\""));

		// Placeholder for edit widget
		// Put place holder (and eventually editWidget) before the display node so that it's positioned correctly
		// when Calendar dropdown appears, which happens automatically on focus.
		var placeholder = dojo.create("span", null, this.domNode, "before");

		var ew = this.editWidget = new dijit._InlineEditor({
			value: dojo.trim(editValue),
			autoSave: this.autoSave,
			buttonSave: this.buttonSave,
			buttonCancel: this.buttonCancel,
			renderAsHtml: this.renderAsHtml,
			editor: this.editor,
			editorParams: this.editorParams,
			sourceStyle: dojo.getComputedStyle(this.displayNode),
			save: dojo.hitch(this, "save"),
			cancel: dojo.hitch(this, "cancel"),
			width: this.width
		}, placeholder);

		// to avoid screen jitter, we first create the editor with position:absolute, visibility:hidden,
		// and then when it's finished rendering, we switch from display mode to editor
		var ews = ew.domNode.style;
		this.displayNode.style.display="none";
		ews.position = "static";
		ews.visibility = "visible";

		// Replace the display widget with edit widget, leaving them both displayed for a brief time so that
		// focus can be shifted without incident.  (browser may needs some time to render the editor.)
		this.domNode = ew.domNode;
		setTimeout(function(){
			ew.focus();
			ew._resetValue = ew.getValue();
		}, 100);
	},

	_showText: function(/*Boolean*/ focus){
		// summary:
		//		Revert to display mode, and optionally focus on display node
		// tags:
		//		private

		// display the read-only text and then quickly hide the editor (to avoid screen jitter)
		this.displayNode.style.display="";
		var ew = this.editWidget;
		var ews = ew.domNode.style;
		ews.position="absolute";
		ews.visibility="hidden";

		this.domNode = this.displayNode;

		if(focus){
			dijit.focus(this.displayNode);
		}
		ews.display = "none";
		// give the browser some time to render the display node and then shift focus to it
		// and hide the edit widget before garbage collecting the edit widget
		setTimeout(function(){
			ew.destroy();
			delete ew;
			if(dojo.isIE){
				// messing with the DOM tab order can cause IE to focus the body - so restore
				dijit.focus(dijit.getFocus());
			}
		}, 1000); // no hurry - wait for things to quiesce
	},

	save: function(/*Boolean*/ focus){
		// summary:
		//		Save the contents of the editor and revert to display mode.
		// focus: Boolean
		//		Focus on the display mode text
		// tags:
		//		private
		if(this.disabled || !this.editing){ return; }
		this.editing = false;

		var value = this.editWidget.getValue() + "";
		this.attr('value', this.renderAsHtml? value
			: value.replace(/&/gm, "&amp;").replace(/</gm, "&lt;").replace(/>/gm, "&gt;").replace(/"/gm, "&quot;").replace(/\n/g, "<br>")
		);

		// tell the world that we have changed
		this.onChange(value);

		this._showText(focus);	
	},

	setValue: function(/*String*/ val){
		// summary:
		//		Deprecated.   Use attr('value', ...) instead.
		// tags:
		//		deprecated
		dojo.deprecated("dijit.InlineEditBox.setValue() is deprecated.  Use attr('value', ...) instead.", "", "2.0");
		return this.attr("value", val);
	},
	_setValueAttr: function(/*String*/ val){
		// summary:
		// 		Hook to make attr("value", ...) work.
		//		Inserts specified HTML value into this node, or an "input needed" character if node is blank.
		this.value = val;
		this.displayNode.innerHTML = dojo.trim(val) || this.noValueIndicator;
	},

	getValue: function(){
		// summary:
		//		Deprecated.   Use attr('value') instead.
		// tags:
		//		deprecated
		dojo.deprecated("dijit.InlineEditBox.getValue() is deprecated.  Use attr('value') instead.", "", "2.0");
		return this.attr("value");
	},

	cancel: function(/*Boolean*/ focus){
		// summary:
		//		Revert to display mode, discarding any changes made in the editor
		// tags:
		//		private

		this.editing = false;
		
		// tell the world that we have no changes
		this.onCancel();
		
		this._showText(focus);
	}
});

dojo.declare(
	"dijit._InlineEditor",
	 [dijit._Widget, dijit._Templated],
{
	// summary:
	// 		Internal widget used by InlineEditBox, displayed when in editing mode
	//		to display the editor and maybe save/cancel buttons.  Calling code should
	//		connect to save/cancel methods to detect when editing is finished
	//
	//		Has mainly the same parameters as InlineEditBox, plus these values:
	//
	// style: Object
	//		Set of CSS attributes of display node, to replicate in editor
	//
	// value: String
	//		Value as an HTML string or plain text string, depending on renderAsHTML flag

	templateString:"<span dojoAttachPoint=\"editNode\" waiRole=\"presentation\" style=\"position: absolute; visibility:hidden\" class=\"dijitReset dijitInline\"\n\tdojoAttachEvent=\"onkeypress: _onKeyPress\" \n\t><span dojoAttachPoint=\"editorPlaceholder\"></span\n\t><span dojoAttachPoint=\"buttonContainer\"\n\t\t><button class='saveButton' dojoAttachPoint=\"saveButton\" dojoType=\"dijit.form.Button\" dojoAttachEvent=\"onClick:save\" disabled=\"true\" label=\"${buttonSave}\"></button\n\t\t><button class='cancelButton' dojoAttachPoint=\"cancelButton\" dojoType=\"dijit.form.Button\" dojoAttachEvent=\"onClick:cancel\" label=\"${buttonCancel}\"></button\n\t></span\n></span>\n",
	widgetsInTemplate: true,

	postMixInProperties: function(){
		this.inherited(arguments);
		this.messages = dojo.i18n.getLocalization("dijit", "common", this.lang);
		dojo.forEach(["buttonSave", "buttonCancel"], function(prop){
			if(!this[prop]){ this[prop] = this.messages[prop]; }
		}, this);
	},

	postCreate: function(){
		// Create edit widget in place in the template
		var cls = dojo.getObject(this.editor);

		// Copy the style from the source
		// Don't copy ALL properties though, just the necessary/applicable ones
		var srcStyle = this.sourceStyle;
		var editStyle = "line-height:" + srcStyle.lineHeight + ";";
		dojo.forEach(["Weight","Family","Size","Style"], function(prop){
			editStyle += "font-"+prop+":"+srcStyle["font"+prop]+";";
		}, this);
		dojo.forEach(["marginTop","marginBottom","marginLeft", "marginRight"], function(prop){
			this.domNode.style[prop] = srcStyle[prop];
		}, this);
		if(this.width=="100%"){
			// block mode
			editStyle += "width:100%;";
			this.domNode.style.display = "block";
		}else{
			// inline-block mode
			editStyle += "width:" + (this.width + (Number(this.width)==this.width ? "px" : "")) + ";";
		}
		this.editorParams.style = editStyle;
		this.editorParams[ "displayedValue" in cls.prototype ? "displayedValue" : "value"] = this.value;
		var ew = this.editWidget = new cls(this.editorParams, this.editorPlaceholder);

		this.connect(ew, "onChange", "_onChange");

		// Monitor keypress on the edit widget.   Note that edit widgets do a stopEvent() on ESC key (to
		// prevent Dialog from closing when the user just wants to revert the value in the edit widget),
		// so this is the only way we can see the key press event.
		this.connect(ew, "onKeyPress", "_onKeyPress");
		this.connect(ew, "onKeyUp", "_onKeyPress"); // in case ESC was eaten but changed value

		if(this.autoSave){
			this.buttonContainer.style.display="none";
		}
	},

	destroy: function(){
		this.editWidget.destroy();
		this.inherited(arguments);
	},

	getValue: function(){
		// summary:
		//		Return the [display] value of the edit widget
		var ew = this.editWidget;
		return ew.attr("displayedValue" in ew ? "displayedValue" : "value");
	},

	_onKeyPress: function(e){
		// summary:
		//		Handler for keypress in the edit box (see template).
		// description:
		//		For autoSave widgets, if Esc/Enter, call cancel/save.
		//		For non-autoSave widgets, enable save button if the text value is
		//		different than the original value.
		// tags:
		//		private

		if(this._exitInProgress){
			return;
		}
		if(this.autoSave){
			if(e.altKey || e.ctrlKey){ return; }
			// If Enter/Esc pressed, treat as save/cancel.
			if(e.charOrCode == dojo.keys.ESCAPE){
				dojo.stopEvent(e);
				this._exitInProgress = true;
				this.cancel(true);
			}else if(e.charOrCode == dojo.keys.ENTER && this.editWidget.focusNode.tagName == "INPUT"){
				dojo.stopEvent(e);
				this._exitInProgress = true;
				this.save(true);
			}else if(e.charOrCode === dojo.keys.TAB){
				this._exitInProgress = true;
				// allow the TAB to change focus before we mess with the DOM: #6227
				// Expounding by request:
				// 	The current focus is on the edit widget input field.
				//	save() will hide and destroy this widget.
				//	We want the focus to jump from the currently hidden
				//	displayNode, but since it's hidden, it's impossible to
				//	unhide it, focus it, and then have the browser focus
				//	away from it to the next focusable element since each
				//	of these events is asynchronous and the focus-to-next-element
				//	is already queued.
				//	So we allow the browser time to unqueue the move-focus event 
				//	before we do all the hide/show stuff.
				setTimeout(dojo.hitch(this, "save", false), 0);
			}
		}else{
			var _this = this;
			// Delay before calling getValue().
			// The delay gives the browser a chance to update the native value.
			setTimeout(
				function(){
					_this._onChange(); // handle save button
				}, 100);
		}
	},

	_onBlur: function(){
		// summary:
		//		Called when focus moves outside the editor
		// tags:
		//		private

		this.inherited(arguments);
		if(this._exitInProgress){
			// when user clicks the "save" button, focus is shifted back to display text, causing this
			// function to be called, but in that case don't do anything
			return;
		}
		if(this.autoSave){
			this._exitInProgress = true;
			if(this.getValue() == this._resetValue){
				this.cancel(false);
			}else{
				this.save(false);
			}
		}
	},

	_onChange: function(){
		// summary:
		//		Called when the underlying widget fires an onChange event,
		//		which means that the user has finished entering the value
		// tags:
		//		private

		if(this._exitInProgress){
			// TODO: the onChange event might happen after the return key for an async widget
			// like FilteringSelect.  Shouldn't be deleting the edit widget on end-of-edit
			return;
		}
		if(this.autoSave){
			this._exitInProgress = true;
			this.save(true);
		}else{
			// in case the keypress event didn't get through (old problem with Textarea that has been fixed
			// in theory) or if the keypress event comes too quickly and the value inside the Textarea hasn't
			// been updated yet)
			this.saveButton.attr("disabled", (this.getValue() == this._resetValue) || !this.enableSave());
		}
	},
	
	enableSave: function(){
		// summary:
		//		User overridable function returning a Boolean to indicate
		// 		if the Save button should be enabled or not - usually due to invalid conditions
		// tags:
		//		extension
		return this.editWidget.isValid ? this.editWidget.isValid() : true;
	},

	focus: function(){
		// summary:
		//		Focus on the edit widget.
		this.editWidget.focus();
		dijit.selectInputText(this.editWidget.focusNode);
	}
});

}

if(!dojo._hasResource["dojo.html"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.html"] = true;
dojo.provide("dojo.html");

// the parser might be needed..
 

(function(){ // private scope, sort of a namespace

	// idCounter is incremented with each instantiation to allow asignment of a unique id for tracking, logging purposes
	var idCounter = 0; 

	dojo.html._secureForInnerHtml = function(/*String*/ cont){
		// summary:
		//		removes !DOCTYPE and title elements from the html string.
		// 
		//		khtml is picky about dom faults, you can't attach a style or <title> node as child of body
		//		must go into head, so we need to cut out those tags
		//	cont:
		//		An html string for insertion into the dom
		//	
		return cont.replace(/(?:\s*<!DOCTYPE\s[^>]+>|<title[^>]*>[\s\S]*?<\/title>)/ig, ""); // String
	};

/*====
	dojo.html._emptyNode = function(node){
		// summary:
		//		removes all child nodes from the given node
		//	node: DOMNode
		//		the parent element
	};
=====*/
	dojo.html._emptyNode = dojo.empty;

	dojo.html._setNodeContent = function(/* DomNode */ node, /* String|DomNode|NodeList */ cont, /* Boolean? */ shouldEmptyFirst){
		// summary:
		//		inserts the given content into the given node
		//		overlaps similiar functionality in dijit.layout.ContentPane._setContent
		//	node:
		//		the parent element
		//	content:
		//		the content to be set on the parent element. 
		//		This can be an html string, a node reference or a NodeList, dojo.NodeList, Array or other enumerable list of nodes
		// shouldEmptyFirst
		//		if shouldEmptyFirst is true, the node will first be emptied of all content before the new content is inserted
		//		defaults to false
		if(shouldEmptyFirst){
			dojo.html._emptyNode(node); 
		}

		if(typeof cont == "string"){
			// there's some hoops to jump through before we can set innerHTML on the would-be parent element. 
	
			// rationale for this block:
			// if node is a table derivate tag, some browsers dont allow innerHTML on those
			// TODO: <select>, <dl>? what other elements will give surprises if you naively set innerHTML?
			
			var pre = '', post = '', walk = 0, name = node.nodeName.toLowerCase();
			switch(name){
				case 'tr':
					pre = '<tr>'; post = '</tr>';
					walk += 1;//fallthrough
				case 'tbody': case 'thead':// children of THEAD is of same type as TBODY
					pre = '<tbody>' + pre; post += '</tbody>';
					walk += 1;// falltrough
				case 'table':
					pre = '<table>' + pre; post += '</table>';
					walk += 1;
					break;
			}
			if(walk){
				var n = node.ownerDocument.createElement('div');
				n.innerHTML = pre + cont + post;
				do{
					n = n.firstChild;
				}while(--walk);
				// now we can safely add the child nodes...
				dojo.forEach(n.childNodes, function(n){
					node.appendChild(n.cloneNode(true));
				});
			}else{
				// innerHTML the content as-is into the node (element)
				// should we ever support setting content on non-element node types? 
				// e.g. text nodes, comments, etc.?
				node.innerHTML = cont;
			}

		}else{
			// DomNode or NodeList
			if(cont.nodeType){ // domNode (htmlNode 1 or textNode 3)
				node.appendChild(cont);
			}else{// nodelist or array such as dojo.Nodelist
				dojo.forEach(cont, function(n){
					node.appendChild(n.cloneNode(true));
				});
			}
		}
		// return DomNode
		return node;
	};

	// we wrap up the content-setting operation in a object
	dojo.declare("dojo.html._ContentSetter", null, 
		{
			// node: DomNode|String
			//		An node which will be the parent element that we set content into
			node: "",

			// content: String|DomNode|DomNode[]
			//		The content to be placed in the node. Can be an HTML string, a node reference, or a enumerable list of nodes
			content: "",
			
			// id: String?
			//		Usually only used internally, and auto-generated with each instance 
			id: "",

			// cleanContent: Boolean
			//		Should the content be treated as a full html document, 
			//		and the real content stripped of <html>, <body> wrapper before injection
			cleanContent: false,
			
			// extractContent: Boolean
			//		Should the content be treated as a full html document, and the real content stripped of <html>, <body> wrapper before injection
			extractContent: false,

			// parseContent: Boolean
			//		Should the node by passed to the parser after the new content is set
			parseContent: false,
			
			// lifecyle methods
			constructor: function(/* Object */params, /* String|DomNode */node){
				//	summary:
				//		Provides a configurable, extensible object to wrap the setting on content on a node
				//		call the set() method to actually set the content..
 
				// the original params are mixed directly into the instance "this"
				dojo.mixin(this, params || {});

				// give precedence to params.node vs. the node argument
				// and ensure its a node, not an id string
				node = this.node = dojo.byId( this.node || node );
	
				if(!this.id){
					this.id = [
						"Setter",
						(node) ? node.id || node.tagName : "", 
						idCounter++
					].join("_");
				}

				if(! (this.node || node)){
					new Error(this.declaredClass + ": no node provided to " + this.id);
				}
			},
			set: function(/* String|DomNode|NodeList? */ cont, /* Object? */ params){
				// summary:
				//		front-end to the set-content sequence 
				//	cont:
				//		An html string, node or enumerable list of nodes for insertion into the dom
				//		If not provided, the object's content property will be used
				if(undefined !== cont){
					this.content = cont;
				}
				// in the re-use scenario, set needs to be able to mixin new configuration
				if(params){
					this._mixin(params);
				}

				this.onBegin();
				this.setContent();
				this.onEnd();

				return this.node;
			},
			setContent: function(){
				// summary:
				//		sets the content on the node 

				var node = this.node; 
				if(!node) {
					console.error("setContent given no node");
				}
				try{
					node = dojo.html._setNodeContent(node, this.content);
				}catch(e){
					// check if a domfault occurs when we are appending this.errorMessage
					// like for instance if domNode is a UL and we try append a DIV
	
					// FIXME: need to allow the user to provide a content error message string
					var errMess = this.onContentError(e); 
					try{
						node.innerHTML = errMess;
					}catch(e){
						console.error('Fatal ' + this.declaredClass + '.setContent could not change content due to '+e.message, e);
					}
				}
				// always put back the node for the next method
				this.node = node; // DomNode
			},
			
			empty: function() {
				// summary
				//	cleanly empty out existing content

				// destroy any widgets from a previous run
				// NOTE: if you dont want this you'll need to empty 
				// the parseResults array property yourself to avoid bad things happenning
				if(this.parseResults && this.parseResults.length) {
					dojo.forEach(this.parseResults, function(w) {
						if(w.destroy){
							w.destroy();
						}
					});
					delete this.parseResults;
				}
				// this is fast, but if you know its already empty or safe, you could 
				// override empty to skip this step
				dojo.html._emptyNode(this.node);
			},
	
			onBegin: function(){
				// summary
				//		Called after instantiation, but before set(); 
				//		It allows modification of any of the object properties 
				//		- including the node and content provided - before the set operation actually takes place
				//		This default implementation checks for cleanContent and extractContent flags to 
				//		optionally pre-process html string content
				var cont = this.content;
	
				if(dojo.isString(cont)){
					if(this.cleanContent){
						cont = dojo.html._secureForInnerHtml(cont);
					}
  
					if(this.extractContent){
						var match = cont.match(/<body[^>]*>\s*([\s\S]+)\s*<\/body>/im);
						if(match){ cont = match[1]; }
					}
				}

				// clean out the node and any cruft associated with it - like widgets
				this.empty();
				
				this.content = cont;
				return this.node; /* DomNode */
			},
	
			onEnd: function(){
				// summary
				//		Called after set(), when the new content has been pushed into the node
				//		It provides an opportunity for post-processing before handing back the node to the caller
				//		This default implementation checks a parseContent flag to optionally run the dojo parser over the new content
				if(this.parseContent){
					// populates this.parseResults if you need those..
					this._parse();
				}
				return this.node; /* DomNode */
			},
	
			tearDown: function(){
				// summary
				//		manually reset the Setter instance if its being re-used for example for another set()
				// description
				//		tearDown() is not called automatically. 
				//		In normal use, the Setter instance properties are simply allowed to fall out of scope
				//		but the tearDown method can be called to explicitly reset this instance.
				delete this.parseResults; 
				delete this.node; 
				delete this.content; 
			},
  
			onContentError: function(err){
				return "Error occured setting content: " + err; 
			},
			
			_mixin: function(params){
				// mix properties/methods into the instance
				// TODO: the intention with tearDown is to put the Setter's state 
				// back to that of the original constructor (vs. deleting/resetting everything regardless of ctor params)
				// so we could do something here to move the original properties aside for later restoration
				var empty = {}, key;
				for(key in params){
					if(key in empty){ continue; }
					// TODO: here's our opportunity to mask the properties we dont consider configurable/overridable
					// .. but history shows we'll almost always guess wrong
					this[key] = params[key]; 
				}
			},
			_parse: function(){
				// summary: 
				//		runs the dojo parser over the node contents, storing any results in this.parseResults
				//		Any errors resulting from parsing are passed to _onError for handling

				var rootNode = this.node;
				try{
					// store the results (widgets, whatever) for potential retrieval
					this.parseResults = dojo.parser.parse(rootNode, true);
				}catch(e){
					this._onError('Content', e, "Error parsing in _ContentSetter#"+this.id);
				}
			},
  
			_onError: function(type, err, consoleText){
				// summary:
				//		shows user the string that is returned by on[type]Error
				//		overide/implement on[type]Error and return your own string to customize
				var errText = this['on' + type + 'Error'].call(this, err);
				if(consoleText){
					console.error(consoleText, err);
				}else if(errText){ // a empty string won't change current content
					dojo.html._setNodeContent(this.node, errText, true);
				}
			}
	}); // end dojo.declare()

	dojo.html.set = function(/* DomNode */ node, /* String|DomNode|NodeList */ cont, /* Object? */ params){
			// summary:
			//		inserts (replaces) the given content into the given node. dojo.place(cont, node, "only")
			//		may be a better choice for simple HTML insertion.
			// description:
			//		Unless you need to use the params capabilities of this method, you should use
			//		dojo.place(cont, node, "only"). dojo.place() has more robust support for injecting
			//		an HTML string into the DOM, but it only handles inserting an HTML string as DOM
			//		elements, or inserting a DOM node. dojo.place does not handle NodeList insertions
			//		or the other capabilities as defined by the params object for this method.
			//	node:
			//		the parent element that will receive the content
			//	cont:
			//		the content to be set on the parent element. 
			//		This can be an html string, a node reference or a NodeList, dojo.NodeList, Array or other enumerable list of nodes
			//	params: 
			//		Optional flags/properties to configure the content-setting. See dojo.html._ContentSetter
			//	example:
			//		A safe string/node/nodelist content replacement/injection with hooks for extension
			//		Example Usage: 
			//		dojo.html.set(node, "some string"); 
			//		dojo.html.set(node, contentNode, {options}); 
			//		dojo.html.set(node, myNode.childNodes, {options}); 
		if(undefined == cont){
			console.warn("dojo.html.set: no cont argument provided, using empty string");
			cont = "";
		}	
		if(!params){
			// simple and fast
			return dojo.html._setNodeContent(node, cont, true);
		}else{ 
			// more options but slower
			// note the arguments are reversed in order, to match the convention for instantiation via the parser
			var op = new dojo.html._ContentSetter(dojo.mixin( 
					params, 
					{ content: cont, node: node } 
			));
			return op.set();
		}
	};
})();

}

if(!dojo._hasResource["dijit.layout.ContentPane"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout.ContentPane"] = true;
dojo.provide("dijit.layout.ContentPane");



	// for dijit.layout.marginBox2contentBox()






dojo.declare(
	"dijit.layout.ContentPane", dijit._Widget,
{
	// summary:
	//		A widget that acts as a container for mixed HTML and widgets, and includes an Ajax interface
	// description:
	//		A widget that can be used as a standalone widget
	//		or as a baseclass for other widgets
	//		Handles replacement of document fragment using either external uri or javascript
	//		generated markup or DOM content, instantiating widgets within that content.
	//		Don't confuse it with an iframe, it only needs/wants document fragments.
	//		It's useful as a child of LayoutContainer, SplitContainer, or TabContainer.
	//		But note that those classes can contain any widget as a child.
	// example:
	//		Some quick samples:
	//		To change the innerHTML use .attr('content', '<b>new content</b>')
	//
	//		Or you can send it a NodeList, .attr('content', dojo.query('div [class=selected]', userSelection))
	//		please note that the nodes in NodeList will copied, not moved
	//
	//		To do a ajax update use .attr('href', url)

	// href: String
	//		The href of the content that displays now.
	//		Set this at construction if you want to load data externally when the
	//		pane is shown.	(Set preload=true to load it immediately.)
	//		Changing href after creation doesn't have any effect; use attr('href', ...);
	href: "",

/*=====
	// content: String || DomNode || NodeList || dijit._Widget
	//		The innerHTML of the ContentPane.
	//		Note that the initialization parameter / argument to attr("content", ...)
	//		can be a String, DomNode, Nodelist, or _Widget.
	content: "",
=====*/

	// extractContent: Boolean
	//		Extract visible content from inside of <body> .... </body>.
	//		I.e., strip <html> and <head> (and it's contents) from the href
	extractContent: false,

	// parseOnLoad: Boolean
	//		Parse content and create the widgets, if any.
	parseOnLoad:	true,

	// preventCache: Boolean
	//		Prevent caching of data from href's by appending a timestamp to the href.
	preventCache:	false,

	// preload: Boolean
	//		Force load of data on initialization even if pane is hidden.
	preload: false,

	// refreshOnShow: Boolean
	//		Refresh (re-download) content when pane goes from hidden to shown
	refreshOnShow: false,

	// loadingMessage: String
	//		Message that shows while downloading
	loadingMessage: "<span class='dijitContentPaneLoading'>${loadingState}</span>", 

	// errorMessage: String
	//		Message that shows if an error occurs
	errorMessage: "<span class='dijitContentPaneError'>${errorState}</span>", 

	// isLoaded: [readonly] Boolean
	//		True if the ContentPane has data in it, either specified
	//		during initialization (via href or inline content), or set
	//		via attr('content', ...) / attr('href', ...)
	//
	//		False if it doesn't have any content, or if ContentPane is
	//		still in the process of downloading href.
	isLoaded: false,

	baseClass: "dijitContentPane",

	// doLayout: Boolean
	//		- false - don't adjust size of children
	//		- true - if there is a single visible child widget, set it's size to
	//				however big the ContentPane is
	doLayout: true,

	// ioArgs: Object
	//		Parameters to pass to xhrGet() request, for example:
	// |	<div dojoType="dijit.layout.ContentPane" href="./bar" ioArgs="{timeout: 500}">
	ioArgs: {},

	// isContainer: [protected] Boolean
	//		Just a flag indicating that this widget will call resize() on
	//		its children.   _LayoutWidget based widgets check for
	//
	//	|		if(!this.getParent || !this.getParent()){
	//
	//		and if getParent() returns false because !parent.isContainer,
	//		then they resize themselves on initialization.
	isContainer: true,

	postMixInProperties: function(){
		this.inherited(arguments);
		var messages = dojo.i18n.getLocalization("dijit", "loading", this.lang);
		this.loadingMessage = dojo.string.substitute(this.loadingMessage, messages);
		this.errorMessage = dojo.string.substitute(this.errorMessage, messages);
		
		// Detect if we were initialized with data
		if(!this.href && this.srcNodeRef && this.srcNodeRef.innerHTML){
			this.isLoaded = true;
		}
	},

	buildRendering: function(){
		// Overrides Widget.buildRendering().
		// Since we have no template we need to set this.containerNode ourselves.
		// For subclasses of ContentPane do have a template, does nothing.
		this.inherited(arguments);
		if(!this.containerNode){
			// make getDescendants() work
			this.containerNode = this.domNode;
		}
	},

	postCreate: function(){
		// remove the title attribute so it doesn't show up when hovering
		// over a node
		this.domNode.title = "";

		if (!dojo.attr(this.domNode,"role")){
			dijit.setWaiRole(this.domNode, "group");
		}

		dojo.addClass(this.domNode, this.baseClass);
	},

	startup: function(){
		// summary:
		//		See `dijit.layout._LayoutWidget.startup` for description.
		//		Although ContentPane doesn't extend _LayoutWidget, it does implement
		//		the same API.
		if(this._started){ return; }

		if(this.isLoaded){
			dojo.forEach(this.getChildren(), function(child){
				child.startup();
			});

			// If we have static content in the content pane (specified during
			// initialization) then we need to do layout now... unless we are
			// a child of a TabContainer etc. in which case wait until the TabContainer
			// calls resize() on us.
			if(this.doLayout){
				this._checkIfSingleChild();
			}
			if(!this._singleChild || !dijit._Contained.prototype.getParent.call(this)){
				this._scheduleLayout();
			}
		}
		
		// If we have an href then check if we should load it now
		this._loadCheck();

		this.inherited(arguments);
	},

	_checkIfSingleChild: function(){
		// summary:
		//		Test if we have exactly one visible widget as a child,
		//		and if so assume that we are a container for that widget,
		//		and should propogate startup() and resize() calls to it.
		//		Skips over things like data stores since they aren't visible.

		var childNodes = dojo.query(">", this.containerNode),
			childWidgetNodes = childNodes.filter(function(node){
				return dojo.hasAttr(node, "dojoType") || dojo.hasAttr(node, "widgetId");
			}),
			candidateWidgets = dojo.filter(childWidgetNodes.map(dijit.byNode), function(widget){
				return widget && widget.domNode && widget.resize;
			});

		if(
			// all child nodes are widgets
			childNodes.length == childWidgetNodes.length &&

			// all but one are invisible (like dojo.data)
			candidateWidgets.length == 1
		){
			this._singleChild = candidateWidgets[0];
		}else{
			delete this._singleChild;
		}
	},

	setHref: function(/*String|Uri*/ href){
		// summary:
		//		Deprecated.   Use attr('href', ...) instead.
		dojo.deprecated("dijit.layout.ContentPane.setHref() is deprecated. Use attr('href', ...) instead.", "", "2.0");
		return this.attr("href", href);
	},
	_setHrefAttr: function(/*String|Uri*/ href){
		// summary:
		//		Hook so attr("href", ...) works.
		// description:
		//		Reset the (external defined) content of this pane and replace with new url
		//		Note: It delays the download until widget is shown if preload is false.
		//	href:
		//		url to the page you want to get, must be within the same domain as your mainpage

		// Cancel any in-flight requests (an attr('href') will cancel any in-flight attr('href', ...))
		this.cancel();

		this.href = href;

		// _setHrefAttr() is called during creation and by the user, after creation.
		// only in the second case do we actually load the URL; otherwise it's done in startup()
		if(this._created && (this.preload || this._isShown())){
			// we return result of refresh() here to avoid code dup. in dojox.layout.ContentPane
			return this.refresh();
		}else{
			// Set flag to indicate that href needs to be loaded the next time the
			// ContentPane is made visible
			this._hrefChanged = true;
		}
	},

	setContent: function(/*String|DomNode|Nodelist*/data){
		// summary:
		//		Deprecated.   Use attr('content', ...) instead.
		dojo.deprecated("dijit.layout.ContentPane.setContent() is deprecated.  Use attr('content', ...) instead.", "", "2.0");
		this.attr("content", data);
	},
	_setContentAttr: function(/*String|DomNode|Nodelist*/data){
		// summary:
		//		Hook to make attr("content", ...) work.
		//		Replaces old content with data content, include style classes from old content
		//	data:
		//		the new Content may be String, DomNode or NodeList
		//
		//		if data is a NodeList (or an array of nodes) nodes are copied
		//		so you can import nodes from another document implicitly

		// clear href so we can't run refresh and clear content
		// refresh should only work if we downloaded the content
		this.href = "";

		// Cancel any in-flight requests (an attr('content') will cancel any in-flight attr('href', ...))
		this.cancel();

		this._setContent(data || "");

		this._isDownloaded = false; // mark that content is from a attr('content') not an attr('href')
	},
	_getContentAttr: function(){
		// summary:
		//		Hook to make attr("content") work
		return this.containerNode.innerHTML;
	},

	cancel: function(){
		// summary:
		//		Cancels an in-flight download of content
		if(this._xhrDfd && (this._xhrDfd.fired == -1)){
			this._xhrDfd.cancel();
		}
		delete this._xhrDfd; // garbage collect
	},

	uninitialize: function(){
		if(this._beingDestroyed){
			this.cancel();
		}
	},

	destroyRecursive: function(/*Boolean*/ preserveDom){
		// summary:
		//		Destroy the ContentPane and its contents

		// if we have multiple controllers destroying us, bail after the first
		if(this._beingDestroyed){
			return;
		}
		this._beingDestroyed = true;
		this.inherited(arguments);
	},

	resize: function(size){
		// summary:
		//		See `dijit.layout._LayoutWidget.resize` for description.
		//		Although ContentPane doesn't extend _LayoutWidget, it does implement
		//		the same API.

		dojo.marginBox(this.domNode, size);

		// Compute content box size in case we [later] need to size child
		// If either height or width wasn't specified by the user, then query node for it.
		// But note that setting the margin box and then immediately querying dimensions may return
		// inaccurate results, so try not to depend on it.
		var node = this.containerNode,
			mb = dojo.mixin(dojo.marginBox(node), size||{});

		var cb = (this._contentBox = dijit.layout.marginBox2contentBox(node, mb));

		// If we have a single widget child then size it to fit snugly within my borders
		if(this._singleChild && this._singleChild.resize){
			// note: if widget has padding this._contentBox will have l and t set,
			// but don't pass them to resize() or it will doubly-offset the child
			this._singleChild.resize({w: cb.w, h: cb.h});
		}
	},

	_isShown: function(){
		// summary:
		//		Returns true if the content is currently shown
		if("open" in this){
			return this.open;		// for TitlePane, etc.
		}else{
			var node = this.domNode;
			return (node.style.display != 'none')  && (node.style.visibility != 'hidden') && !dojo.hasClass(node, "dijitHidden");
		}
	},

	_onShow: function(){
		// summary:
		//		Called when the ContentPane is made visible
		// description:
		//		For a plain ContentPane, this is called on initialization, from startup().
		//		If the ContentPane is a hidden pane of a TabContainer etc., then it's
		//		called whever the pane is made visible.
		//
		//		Does processing necessary, including href download and layout/resize of
		//		child widget(s)

		if(this._needLayout){
			// If a layout has been scheduled for when we become visible, do it now
			this._layoutChildren();
		}

		// Do lazy-load of URL
		this._loadCheck();

		// call onShow, if we have one
		if(this.onShow){
			this.onShow();
		}
	},

	_loadCheck: function(){
		// summary:
		//		Call this to load href contents if necessary.
		// description:
		//		Call when !ContentPane has been made visible [from prior hidden state],
		//		or href has been changed, or on startup, etc.

		if(
			(this.href && !this._xhrDfd) &&		// if there's an href that isn't already being loaded
			(!this.isLoaded || this._hrefChanged || this.refreshOnShow) && 	// and we need a [re]load
			(this.preload || this._isShown())	// and now is the time to [re]load
		){
			delete this._hrefChanged;
			this.refresh();
		}
	},

	refresh: function(){
		// summary:
		//		[Re]download contents of href and display
		// description:
		//		1. cancels any currently in-flight requests
		//		2. posts "loading..." message
		//		3. sends XHR to download new data

		// cancel possible prior inflight request
		this.cancel();

		// display loading message
		this._setContent(this.onDownloadStart(), true);

		var self = this;
		var getArgs = {
			preventCache: (this.preventCache || this.refreshOnShow),
			url: this.href,
			handleAs: "text"
		};
		if(dojo.isObject(this.ioArgs)){
			dojo.mixin(getArgs, this.ioArgs);
		}

		var hand = (this._xhrDfd = (this.ioMethod || dojo.xhrGet)(getArgs));

		hand.addCallback(function(html){
			try{
				self._isDownloaded = true;
				self._setContent(html, false);
				self.onDownloadEnd();
			}catch(err){
				self._onError('Content', err); // onContentError
			}
			delete self._xhrDfd;
			return html;
		});

		hand.addErrback(function(err){
			if(!hand.canceled){
				// show error message in the pane
				self._onError('Download', err); // onDownloadError
			}
			delete self._xhrDfd;
			return err;
		});
	},

	_onLoadHandler: function(data){
		// summary:
		//		This is called whenever new content is being loaded
		this.isLoaded = true;
		try{
			this.onLoad(data);			
		}catch(e){
			console.error('Error '+this.widgetId+' running custom onLoad code: ' + e.message);
		}
	},

	_onUnloadHandler: function(){
		// summary:
		//		This is called whenever the content is being unloaded
		this.isLoaded = false;
		try{
			this.onUnload();
		}catch(e){
			console.error('Error '+this.widgetId+' running custom onUnload code: ' + e.message);
		}
	},

	destroyDescendants: function(){
		// summary:
		//		Destroy all the widgets inside the ContentPane and empty containerNode

		// Make sure we call onUnload (but only when the ContentPane has real content)
		if(this.isLoaded){
			this._onUnloadHandler();
		}

		// Even if this.isLoaded == false there might still be a "Loading..." message
		// to erase, so continue...

		// For historical reasons we need to delete all widgets under this.containerNode,
		// even ones that the user has created manually.
		var setter = this._contentSetter;
		dojo.forEach(this.getChildren(), function(widget){
			if(widget.destroyRecursive){
				widget.destroyRecursive();
			}
		});
		if(setter){
			// Most of the widgets in setter.parseResults have already been destroyed, but
			// things like Menu that have been moved to <body> haven't yet
			dojo.forEach(setter.parseResults, function(widget){
				if(widget.destroyRecursive && widget.domNode && widget.domNode.parentNode == dojo.body()){
					widget.destroyRecursive();
				}
			});
			delete setter.parseResults;
		}
		
		// And then clear away all the DOM nodes
		dojo.html._emptyNode(this.containerNode);
	},

	_setContent: function(cont, isFakeContent){
		// summary: 
		//		Insert the content into the container node

		// first get rid of child widgets
		this.destroyDescendants();

		// Delete any state information we have about current contents
		delete this._singleChild;

		// dojo.html.set will take care of the rest of the details
		// we provide an overide for the error handling to ensure the widget gets the errors 
		// configure the setter instance with only the relevant widget instance properties
		// NOTE: unless we hook into attr, or provide property setters for each property, 
		// we need to re-configure the ContentSetter with each use
		var setter = this._contentSetter; 
		if(! (setter && setter instanceof dojo.html._ContentSetter)) {
			setter = this._contentSetter = new dojo.html._ContentSetter({
				node: this.containerNode,
				_onError: dojo.hitch(this, this._onError),
				onContentError: dojo.hitch(this, function(e){
					// fires if a domfault occurs when we are appending this.errorMessage
					// like for instance if domNode is a UL and we try append a DIV
					var errMess = this.onContentError(e);
					try{
						this.containerNode.innerHTML = errMess;
					}catch(e){
						console.error('Fatal '+this.id+' could not change content due to '+e.message, e);
					}
				})/*,
				_onError */
			});
		};

		var setterParams = dojo.mixin({
			cleanContent: this.cleanContent, 
			extractContent: this.extractContent, 
			parseContent: this.parseOnLoad 
		}, this._contentSetterParams || {});
		
		dojo.mixin(setter, setterParams); 

		setter.set( (dojo.isObject(cont) && cont.domNode) ? cont.domNode : cont );

		// setter params must be pulled afresh from the ContentPane each time
		delete this._contentSetterParams;

		if(!isFakeContent){
			dojo.forEach(this.getChildren(), function(child){
				child.startup();
			});

			if(this.doLayout){
				this._checkIfSingleChild();
			}

			// Call resize() on each of my child layout widgets,
			// or resize() on my single child layout widget...
			// either now (if I'm currently visible)
			// or when I become visible
			this._scheduleLayout();
			
			this._onLoadHandler(cont);
		}
	},

	_onError: function(type, err, consoleText){
		// shows user the string that is returned by on[type]Error
		// overide on[type]Error and return your own string to customize
		var errText = this['on' + type + 'Error'].call(this, err);
		if(consoleText){
			console.error(consoleText, err);
		}else if(errText){// a empty string won't change current content
			this._setContent(errText, true);
		}
	},
	
	_scheduleLayout: function(){
		// summary:
		//		Call resize() on each of my child layout widgets, either now
		//		(if I'm currently visible) or when I become visible
		if(this._isShown()){
			this._layoutChildren();
		}else{
			this._needLayout = true;
		}
	},

	_layoutChildren: function(){
		// summary:
		//		Since I am a Container widget, each of my children expects me to
		//		call resize() or layout() on them.
		// description:
		//		Should be called on initialization and also whenever we get new content
		//		(from an href, or from attr('content', ...))... but deferred until
		//		the ContentPane is visible

		if(this._singleChild && this._singleChild.resize){
			var cb = this._contentBox || dojo.contentBox(this.containerNode);
			this._singleChild.resize({w: cb.w, h: cb.h});
		}else{
			// All my child widgets are independently sized (rather than matching my size),
			// but I still need to call resize() on each child to make it layout.
			dojo.forEach(this.getChildren(), function(widget){
				if(widget.resize){
					widget.resize();
				}
			});
		}
		delete this._needLayout;
	},

	// EVENT's, should be overide-able
	onLoad: function(data){
		// summary:
		//		Event hook, is called after everything is loaded and widgetified
		// tags:
		//		callback
	},

	onUnload: function(){
		// summary:
		//		Event hook, is called before old content is cleared
		// tags:
		//		callback
	},

	onDownloadStart: function(){
		// summary:
		//		Called before download starts.
		// description:
		//		The string returned by this function will be the html
		//		that tells the user we are loading something.
		//		Override with your own function if you want to change text.
		// tags:
		//		extension
		return this.loadingMessage;
	},

	onContentError: function(/*Error*/ error){
		// summary:
		//		Called on DOM faults, require faults etc. in content.
		//
		//		In order to display an error message in the pane, return
		//		the error message from this method, as an HTML string.
		//
		//		By default (if this method is not overriden), it returns
		//		nothing, so the error message is just printed to the console.
		// tags:
		//		extension
	},

	onDownloadError: function(/*Error*/ error){
		// summary:
		//		Called when download error occurs.
		//
		//		In order to display an error message in the pane, return
		//		the error message from this method, as an HTML string.
		//
		//		Default behavior (if this method is not overriden) is to display
		//		the error message inside the pane.
		// tags:
		//		extension
		return this.errorMessage;
	},

	onDownloadEnd: function(){
		// summary:
		//		Called when download is finished.
		// tags:
		//		callback
	}
});

}

if(!dojo._hasResource["dijit.form._FormMixin"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form._FormMixin"] = true;
dojo.provide("dijit.form._FormMixin");

dojo.declare("dijit.form._FormMixin", null,
	{
	// summary:
	//		Mixin for containers of form widgets (i.e. widgets that represent a single value
	//		and can be children of a <form> node or dijit.form.Form widget)
	// description:
	//		Can extract all the form widgets
	//		values and combine them into a single javascript object, or alternately
	//		take such an object and set the values for all the contained
	//		form widgets

/*=====
    // value: Object
	//		Name/value hash for each form element.
	//		If there are multiple elements w/the same name, value is an array,
	//		unless they are radio buttons in which case value is a scalar since only
	//		one can be checked at a time.
	//
	//		If the name is a dot separated list (like a.b.c.d), it's a nested structure.
	//		Only works on widget form elements.
	// example:
	//	| { name: "John Smith", interests: ["sports", "movies"] }
=====*/
	
	//	TODO:
	//	* Repeater
	//	* better handling for arrays.  Often form elements have names with [] like
	//	* people[3].sex (for a list of people [{name: Bill, sex: M}, ...])
	//
	//	

		reset: function(){
			dojo.forEach(this.getDescendants(), function(widget){
				if(widget.reset){
					widget.reset();
				}
			});
		},

		validate: function(){
			// summary: returns if the form is valid - same as isValid - but
			//			provides a few additional (ui-specific) features.
			//			1 - it will highlight any sub-widgets that are not
			//				valid
			//			2 - it will call focus() on the first invalid 
			//				sub-widget
			var didFocus = false;
			return dojo.every(dojo.map(this.getDescendants(), function(widget){
				// Need to set this so that "required" widgets get their 
				// state set.
				widget._hasBeenBlurred = true;
				var valid = widget.disabled || !widget.validate || widget.validate();
				if (!valid && !didFocus) {
					// Set focus of the first non-valid widget
					dijit.scrollIntoView(widget.containerNode||widget.domNode);
					widget.focus();
					didFocus = true;
				}
	 			return valid;
	 		}), function(item) { return item; });
		},
	
		setValues: function(val){
			dojo.deprecated(this.declaredClass+"::setValues() is deprecated. Use attr('value', val) instead.", "", "2.0");
			return this.attr('value', val);
		},
		_setValueAttr: function(/*object*/obj){
			// summary: Fill in form values from according to an Object (in the format returned by attr('value'))

			// generate map from name --> [list of widgets with that name]
			var map = { };
			dojo.forEach(this.getDescendants(), function(widget){
				if(!widget.name){ return; }
				var entry = map[widget.name] || (map[widget.name] = [] );
				entry.push(widget);
			});

			for(var name in map){
				if(!map.hasOwnProperty(name)){
					continue;
				}
				var widgets = map[name],						// array of widgets w/this name
					values = dojo.getObject(name, false, obj);	// list of values for those widgets

				if(values===undefined){
					continue;
				}
				if(!dojo.isArray(values)){
					values = [ values ];
				}
				if(typeof widgets[0].checked == 'boolean'){
					// for checkbox/radio, values is a list of which widgets should be checked
					dojo.forEach(widgets, function(w, i){
						w.attr('value', dojo.indexOf(values, w.value) != -1);
					});
				}else if(widgets[0]._multiValue){
					// it takes an array (e.g. multi-select)
					widgets[0].attr('value', values);
				}else{
					// otherwise, values is a list of values to be assigned sequentially to each widget
					dojo.forEach(widgets, function(w, i){
						w.attr('value', values[i]);
					});					
				}
			}

			/***
			 * 	TODO: code for plain input boxes (this shouldn't run for inputs that are part of widgets)

			dojo.forEach(this.containerNode.elements, function(element){
				if (element.name == ''){return};	// like "continue"	
				var namePath = element.name.split(".");
				var myObj=obj;
				var name=namePath[namePath.length-1];
				for(var j=1,len2=namePath.length;j<len2;++j){
					var p=namePath[j - 1];
					// repeater support block
					var nameA=p.split("[");
					if (nameA.length > 1){
						if(typeof(myObj[nameA[0]]) == "undefined"){
							myObj[nameA[0]]=[ ];
						} // if

						nameIndex=parseInt(nameA[1]);
						if(typeof(myObj[nameA[0]][nameIndex]) == "undefined"){
							myObj[nameA[0]][nameIndex] = { };
						}
						myObj=myObj[nameA[0]][nameIndex];
						continue;
					} // repeater support ends

					if(typeof(myObj[p]) == "undefined"){
						myObj=undefined;
						break;
					};
					myObj=myObj[p];
				}

				if (typeof(myObj) == "undefined"){
					return;		// like "continue"
				}
				if (typeof(myObj[name]) == "undefined" && this.ignoreNullValues){
					return;		// like "continue"
				}

				// TODO: widget values (just call attr('value', ...) on the widget)

				switch(element.type){
					case "checkbox":
						element.checked = (name in myObj) &&
							dojo.some(myObj[name], function(val){ return val==element.value; });
						break;
					case "radio":
						element.checked = (name in myObj) && myObj[name]==element.value;
						break;
					case "select-multiple":
						element.selectedIndex=-1;
						dojo.forEach(element.options, function(option){
							option.selected = dojo.some(myObj[name], function(val){ return option.value == val; });
						});
						break;
					case "select-one":
						element.selectedIndex="0";
						dojo.forEach(element.options, function(option){
							option.selected = option.value == myObj[name];
						});
						break;
					case "hidden":
					case "text":
					case "textarea":
					case "password":
						element.value = myObj[name] || "";
						break;
				}
	  		});
	  		*/
		},

		getValues: function(){
			dojo.deprecated(this.declaredClass+"::getValues() is deprecated. Use attr('value') instead.", "", "2.0");
			return this.attr('value');
		},
		_getValueAttr: function(){
			// summary:
			// 		Returns Object representing form values.
			// description:
			//		Returns name/value hash for each form element.
			//		If there are multiple elements w/the same name, value is an array,
			//		unless they are radio buttons in which case value is a scalar since only
			//		one can be checked at a time.
			//
			//		If the name is a dot separated list (like a.b.c.d), creates a nested structure.
			//		Only works on widget form elements.
			// example:
			//		| { name: "John Smith", interests: ["sports", "movies"] }

			// get widget values
			var obj = { };
			dojo.forEach(this.getDescendants(), function(widget){
				var name = widget.name;
				if(!name||widget.disabled){ return; }

				// Single value widget (checkbox, radio, or plain <input> type widget
				var value = widget.attr('value');

				// Store widget's value(s) as a scalar, except for checkboxes which are automatically arrays
				if(typeof widget.checked == 'boolean'){
					if(/Radio/.test(widget.declaredClass)){
						// radio button
						if(value !== false){
							dojo.setObject(name, value, obj);
						}else{
							// give radio widgets a default of null
							value = dojo.getObject(name, false, obj);
							if(value === undefined){
								dojo.setObject(name, null, obj);
							}
						}
					}else{
						// checkbox/toggle button
						var ary=dojo.getObject(name, false, obj);
						if(!ary){
							ary=[];
							dojo.setObject(name, ary, obj);
						}
						if(value !== false){
							ary.push(value);
						}
					}
				}else{
					// plain input
					dojo.setObject(name, value, obj);
				}
			});

			/***
			 * code for plain input boxes (see also dojo.formToObject, can we use that instead of this code?
			 * but it doesn't understand [] notation, presumably)
			var obj = { };
			dojo.forEach(this.containerNode.elements, function(elm){
				if (!elm.name)	{
					return;		// like "continue"
				}
				var namePath = elm.name.split(".");
				var myObj=obj;
				var name=namePath[namePath.length-1];
				for(var j=1,len2=namePath.length;j<len2;++j){
					var nameIndex = null;
					var p=namePath[j - 1];
					var nameA=p.split("[");
					if (nameA.length > 1){
						if(typeof(myObj[nameA[0]]) == "undefined"){
							myObj[nameA[0]]=[ ];
						} // if
						nameIndex=parseInt(nameA[1]);
						if(typeof(myObj[nameA[0]][nameIndex]) == "undefined"){
							myObj[nameA[0]][nameIndex] = { };
						}
					} else if(typeof(myObj[nameA[0]]) == "undefined"){
						myObj[nameA[0]] = { }
					} // if

					if (nameA.length == 1){
						myObj=myObj[nameA[0]];
					} else{
						myObj=myObj[nameA[0]][nameIndex];
					} // if
				} // for

				if ((elm.type != "select-multiple" && elm.type != "checkbox" && elm.type != "radio") || (elm.type=="radio" && elm.checked)){
					if(name == name.split("[")[0]){
						myObj[name]=elm.value;
					} else{
						// can not set value when there is no name
					}
				} else if (elm.type == "checkbox" && elm.checked){
					if(typeof(myObj[name]) == 'undefined'){
						myObj[name]=[ ];
					}
					myObj[name].push(elm.value);
				} else if (elm.type == "select-multiple"){
					if(typeof(myObj[name]) == 'undefined'){
						myObj[name]=[ ];
					}
					for (var jdx=0,len3=elm.options.length; jdx<len3; ++jdx){
						if (elm.options[jdx].selected){
							myObj[name].push(elm.options[jdx].value);
						}
					}
				} // if
				name=undefined;
			}); // forEach
			***/
			return obj;
		},

		// TODO: ComboBox might need time to process a recently input value.  This should be async?
	 	isValid: function(){
	 		// summary:
	 		//		Returns true if all of the widgets are valid
	 		
	 		// This also populate this._invalidWidgets[] array with list of invalid widgets...
	 		// TODO: put that into separate function?   It's confusing to have that as a side effect
	 		// of a method named isValid().

			this._invalidWidgets = dojo.filter(this.getDescendants(), function(widget){
				return !widget.disabled && widget.isValid && !widget.isValid();
	 		});
			return !this._invalidWidgets.length;
		},
		
		
		onValidStateChange: function(isValid){
			// summary:
			//		Stub function to connect to if you want to do something
			//		(like disable/enable a submit button) when the valid 
			//		state changes on the form as a whole.
		},
		
		_widgetChange: function(widget){
			// summary:
			//		Connected to a widget's onChange function - update our 
			//		valid state, if needed.
			var isValid = this._lastValidState;
			if(!widget || this._lastValidState===undefined){
				// We have passed a null widget, or we haven't been validated
				// yet - let's re-check all our children
				// This happens when we connect (or reconnect) our children
				isValid = this.isValid();
				if(this._lastValidState===undefined){
					// Set this so that we don't fire an onValidStateChange 
					// the first time
					this._lastValidState = isValid;
				}
			}else if(widget.isValid){
				this._invalidWidgets = dojo.filter(this._invalidWidgets||[], function(w){
					return (w != widget);
				}, this);
				if(!widget.isValid() && !widget.attr("disabled")){
					this._invalidWidgets.push(widget);
				}
				isValid = (this._invalidWidgets.length === 0);
			}
			if (isValid !== this._lastValidState){
				this._lastValidState = isValid;
				this.onValidStateChange(isValid);
			}
		},
		
		connectChildren: function(){
			// summary:
			//		Connects to the onChange function of all children to
			//		track valid state changes.  You can call this function
			//		directly, ex. in the event that you programmatically
			//		add a widget to the form *after* the form has been
			//		initialized.
			dojo.forEach(this._changeConnections, dojo.hitch(this, "disconnect"));
			var _this = this;
			
			// we connect to validate - so that it better reflects the states
			// of the widgets - also, we only connect if it has a validate
			// function (to avoid too many unneeded connections)
			var conns = this._changeConnections = [];
			dojo.forEach(dojo.filter(this.getDescendants(),
				function(item){ return item.validate; }
			),
			function(widget){
				// We are interested in whenever the widget is validated - or
				// whenever the disabled attribute on that widget is changed
				conns.push(_this.connect(widget, "validate", 
									dojo.hitch(_this, "_widgetChange", widget)));
				conns.push(_this.connect(widget, "_setDisabledAttr", 
									dojo.hitch(_this, "_widgetChange", widget)));
			});

			// Call the widget change function to update the valid state, in 
			// case something is different now.
			this._widgetChange(null);
		},
		
		startup: function(){
			this.inherited(arguments);
			// Initialize our valid state tracking.  Needs to be done in startup
			// because it's not guaranteed that our children are initialized 
			// yet.
			this._changeConnections = [];
			this.connectChildren();
		}
	});

}

if(!dojo._hasResource["dijit.form.Form"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.Form"] = true;
dojo.provide("dijit.form.Form");





dojo.declare(
	"dijit.form.Form",
	[dijit._Widget, dijit._Templated, dijit.form._FormMixin],
	{
		// summary:
		//		Widget corresponding to HTML form tag, for validation and serialization
		//
		// example:
		//	|	<form dojoType="dijit.form.Form" id="myForm">
		//	|		Name: <input type="text" name="name" />
		//	|	</form>
		//	|	myObj = {name: "John Doe"};
		//	|	dijit.byId('myForm').attr('value', myObj);
		//	|
		//	|	myObj=dijit.byId('myForm').attr('value');

		// HTML <FORM> attributes

		// name: String?
		//		Name of form for scripting.
		name: "",

		// action: String?
		//		Server-side form handler.
		action: "",

		// method: String?
		//		HTTP method used to submit the form, either "GET" or "POST".
		method: "",

		// encType: String?
		//		Encoding type for the form, ex: application/x-www-form-urlencoded.
		encType: "",

		// accept-charset: String?
		//		List of supported charsets.
		"accept-charset": "",

		// accept: String?
		//		List of MIME types for file upload.
		accept: "",

		// target: String?
		//		Target frame for the document to be opened in.
		target: "",

		templateString: "<form dojoAttachPoint='containerNode' dojoAttachEvent='onreset:_onReset,onsubmit:_onSubmit' ${nameAttrSetting}></form>",

		attributeMap: dojo.delegate(dijit._Widget.prototype.attributeMap, {
			action: "", 
			method: "", 
			encType: "", 
			"accept-charset": "", 
			accept: "", 
			target: ""
		}),

		postMixInProperties: function(){
			// Setup name=foo string to be referenced from the template (but only if a name has been specified)
			// Unfortunately we can't use attributeMap to set the name due to IE limitations, see #8660
			this.nameAttrSetting = this.name ? ("name='" + this.name + "'") : "";
			this.inherited(arguments);
		},

		execute: function(/*Object*/ formContents){
			// summary:
			//		Deprecated: use submit()
			// tags:
			//		deprecated
		},

		onExecute: function(){
			// summary:
			//		Deprecated: use onSubmit()
			// tags:
			//		deprecated
		},

		_setEncTypeAttr: function(/*String*/ value){
			this.encType = value;
			dojo.attr(this.domNode, "encType", value);
			if(dojo.isIE){ this.domNode.encoding = value; }
		},

		postCreate: function(){
			// IE tries to hide encType
			// TODO: this code should be in parser, not here.
			if(dojo.isIE && this.srcNodeRef && this.srcNodeRef.attributes){
				var item = this.srcNodeRef.attributes.getNamedItem('encType');
				if(item && !item.specified && (typeof item.value == "string")){
					this.attr('encType', item.value);
				}
			}
			this.inherited(arguments);
		},

		onReset: function(/*Event?*/ e){
			// summary:
			//		Callback when user resets the form. This method is intended
			//		to be over-ridden. When the `reset` method is called
			//		programmatically, the return value from `onReset` is used
			//		to compute whether or not resetting should proceed
			// tags:
			//		callback
			return true; // Boolean
		},

		_onReset: function(e){
			// create fake event so we can know if preventDefault() is called
			var faux = {
				returnValue: true, // the IE way
				preventDefault: function(){  // not IE
							this.returnValue = false;
						},
				stopPropagation: function(){}, currentTarget: e.currentTarget, target: e.target
			};
			// if return value is not exactly false, and haven't called preventDefault(), then reset
			if(!(this.onReset(faux) === false) && faux.returnValue){
				this.reset();
			}
			dojo.stopEvent(e);
			return false;
		},

		_onSubmit: function(e){
			var fp = dijit.form.Form.prototype;
			// TODO: remove this if statement beginning with 2.0
			if(this.execute != fp.execute || this.onExecute != fp.onExecute){
				dojo.deprecated("dijit.form.Form:execute()/onExecute() are deprecated. Use onSubmit() instead.", "", "2.0");
				this.onExecute();
				this.execute(this.getValues());
			}
			if(this.onSubmit(e) === false){ // only exactly false stops submit
				dojo.stopEvent(e);
			}
		},
		
		onSubmit: function(/*Event?*/e){ 
			// summary:
			//		Callback when user submits the form.
			// description:
			//		This method is intended to be over-ridden, but by default it checks and
			//		returns the validity of form elements. When the `submit`
			//		method is called programmatically, the return value from
			//		`onSubmit` is used to compute whether or not submission
			//		should proceed
			// tags:
			//		extension

			return this.isValid(); // Boolean
		},

		submit: function(){
			// summary:
			//		programmatically submit form if and only if the `onSubmit` returns true
			if(!(this.onSubmit() === false)){
				this.containerNode.submit();
			}
		}
	}
);

}

if(!dojo._hasResource["dijit.form.CheckBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.CheckBox"] = true;
dojo.provide("dijit.form.CheckBox");



dojo.declare(
	"dijit.form.CheckBox",
	dijit.form.ToggleButton,
	{
		// summary:
		// 		Same as an HTML checkbox, but with fancy styling.
		//
		// description:
		// User interacts with real html inputs.
		// On onclick (which occurs by mouse click, space-bar, or
		// using the arrow keys to switch the selected radio button),
		// we update the state of the checkbox/radio.
		//
		// There are two modes:
		//   1. High contrast mode
		//   2. Normal mode
		// In case 1, the regular html inputs are shown and used by the user.
		// In case 2, the regular html inputs are invisible but still used by
		// the user. They are turned quasi-invisible and overlay the background-image.

		templateString:"<div class=\"dijitReset dijitInline\" waiRole=\"presentation\"\n\t><input\n\t \t${nameAttrSetting} type=\"${type}\" ${checkedAttrSetting}\n\t\tclass=\"dijitReset dijitCheckBoxInput\"\n\t\tdojoAttachPoint=\"focusNode\"\n\t \tdojoAttachEvent=\"onmouseover:_onMouse,onmouseout:_onMouse,onclick:_onClick\"\n/></div>\n",

		baseClass: "dijitCheckBox",

		// type: [private] String
		//		type attribute on <input> node.
		//		Overrides `dijit.form.Button.type`.   Users should not change this value.
		type: "checkbox",

		// value: String
		//		As an initialization parameter, equivalent to value field on normal checkbox
		//		(if checked, the value is passed as the value when form is submitted).
		//
		//		However, attr('value') will return either the string or false depending on
		//		whether or not the checkbox is checked.
		//
		//		attr('value', string) will check the checkbox and change the value to the
		//		specified string
		//
		//		attr('value', boolean) will change the checked state.
		value: "on",

		_setValueAttr: function(/*String or Boolean*/ newValue){
			// summary:
			//		Handler for value= attribute to constructor, and also calls to
			//		attr('value', val).
			// description:
			//		During initialization, just saves as attribute to the <input type=checkbox>.
			//		
			//		After initialization,
			//		when passed a boolean, controls whether or not the CheckBox is checked.
			//		If passed a string, changes the value attribute of the CheckBox (the one
			//		specified as "value" when the CheckBox was constructed (ex: <input
			//		dojoType="dijit.CheckBox" value="chicken">)
			if(typeof newValue == "string"){
				this.value = newValue;
				dojo.attr(this.focusNode, 'value', newValue);
				newValue = true;
			}
			if(this._created){
				this.attr('checked', newValue);
			}
		},
		_getValueAttr: function(){
			// summary:
			//		Hook so attr('value') works.
			// description:
			//		If the CheckBox is checked, returns the value attribute.
			//		Otherwise returns false.
			return (this.checked ? this.value : false);
		},

		postMixInProperties: function(){
			if(this.value == ""){
				this.value = "on";
			}

			// Need to set initial checked state as part of template, so that form submit works.
			// dojo.attr(node, "checked", bool) doesn't work on IEuntil node has been attached
			// to <body>, see #8666
			this.checkedAttrSetting = this.checked ? "checked" : "";

			this.inherited(arguments);
		},
		
		 _fillContent: function(/*DomNode*/ source){
			// Override Button::_fillContent() since it doesn't make sense for CheckBox,
			// since CheckBox doesn't even have a container
		},

		reset: function(){
			// Override ToggleButton.reset()

			this._hasBeenBlurred = false;

			this.attr('checked', this.params.checked || false);

			// Handle unlikely event that the <input type=checkbox> value attribute has changed
			this.value = this.params.value || "on";
			dojo.attr(this.focusNode, 'value', this.value);
		},
		
		_onFocus: function(){
			if(this.id){
				dojo.query("label[for='"+this.id+"']").addClass("dijitFocusedLabel");
			}
		},

		_onBlur: function(){
			if(this.id){
				dojo.query("label[for='"+this.id+"']").removeClass("dijitFocusedLabel");
			}
		}
	}
);

dojo.declare(
	"dijit.form.RadioButton",
	dijit.form.CheckBox,
	{
		// summary:
		// 		Same as an HTML radio, but with fancy styling.

		type: "radio",
		baseClass: "dijitRadio",

		_setCheckedAttr: function(/*Boolean*/ value){
			// If I am being checked then have to deselect currently checked radio button
			this.inherited(arguments);
			if(!this._created){ return; }
			if(value){
				var _this = this;
				// search for radio buttons with the same name that need to be unchecked
				dojo.query("INPUT[type=radio]", this.focusNode.form||dojo.doc).forEach( // can't use name= since dojo.query doesn't support [] in the name
					function(inputNode){
						if(inputNode.name == _this.name && inputNode != _this.focusNode && inputNode.form == _this.focusNode.form){
							var widget = dijit.getEnclosingWidget(inputNode);
							if(widget && widget.checked){
								widget.attr('checked', false);
							}
						}
					}
				);
			}
		},

		_clicked: function(/*Event*/ e){
			if(!this.checked){
				this.attr('checked', true);
			}
		}
	}
);

}

if(!dojo._hasResource["com.ibm.widgets.InlineEditorWrapper"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.widgets.InlineEditorWrapper"] = true;
dojo.provide("com.ibm.widgets.InlineEditorWrapper");






// mix this into any other widget to get wrapped inline editor support with an optional popup
// advanced editor
dojo.declare("com.ibm.widgets.InlineEditorWrapper",
			null,
			{
				embeddedEditorWidget: "dijit.form.TextBox",
				embeddedEditorParams: {},
				
				popupWidget: "com.ibm.widgets.InlineEditorPopup",
				popupParams: {},
				
				postMixInProperties: function() {
					this.inherited(arguments);
					this.popupParams = dojo.mixin({}, this.popupParams);
				},
				
				postCreate: function() {
					this.inherited(arguments);
					if(!this._supportingWidgets) this._supportingWidgets = [];
					
					this._supportingWidgets.push(this.editor = new com.ibm.widgets.WrappedInlineEditBox({
						value: this.label,
						title: this.title,
						editor: this.embeddedEditorWidget,
						editorParams: this.embeddedEditorParams,
						canExit: dojo.hitch(this, function(){
							if(this.popupFocused || (this.editorFocused && !this.editor._wantsFocus)) {
								this.editor.editWidget._exitInProgress = false;
								return false;
							}
							return true;
						}),
						saveIsValid: function() {
							if(this.disabled || !this.editing || me.popupFocused || (
								this.editWidget.editWidget &&
								this.editWidget.editWidget.validate &&
								!this.editWidget.editWidget.validate()
								)) {
									this.editWidget._exitInProgress = false;
									return false;
							}
							return true;
						}
					}, this.editor));
					
					var _save = this.editor.save;
					var me = this;
					
					var _edit = dojo.hitch(this.editor, this.editor.edit);
					this.editor.edit = dojo.hitch(this, function() {
						this.editor.attr("value", this.defaultValue);
						_edit();
						
						// disable popup for checking private or public
						//this.editorPopup = this._getPopup();
						if(this.editorPopup) {
							this.editorPopup.attr("value", this.popupDefaultValue);
							dijit.popup.open({
								parent: this,
								popup: this.editorPopup,
								around: this.domNode,
								onCancel: dojo.hitch(this, this.editor.cancel),
								onClose: function(){ }
							});
						}
					});
					
					this.connect(this.editor, "onChange", "_onChange");
					this.connect(this.editor, "onCancel", "_onCancel");
					this.connect(this.editor, "edit", "onEdit");
				},
				_getPopup: function() {
					if(this.editorPopup) return this.editorPopup;
					if(!this.popupWidget) return null;
					var cls = dojo.getObject(this.popupWidget);
					if(cls) {
						this.editorPopup = new cls(this.popupParams);
						dijit.popup.prepare(this.editorPopup.domNode);
						this.editorPopup.startup();
						this.popupDefaultValue = this.editorPopup.attr("value");
						this.connect(this.editorPopup, "onFocus", function() {
							this.popupFocused = true;
							this.editorFocused = false;
						});
						this.connect(this.editorPopup, "onBlur", function() {
							this.popupFocused = false;
							setTimeout(dojo.hitch(this, function(){
								if(!this.editorFocused && this.editor.editWidget) {
									this.editor.editWidget._onBlur();
								}
							}),50);
						});
						this.connect(this.editor, "onFocus", function(){
							this.editorFocused = true;
							this.popupFocused = false;
						});
						this.connect(this.editor, "onBlur", function(){
							this.editorFocused = false;
						});
						
						return this.editorPopup;
					}
					return null;
				},
				startup: function() {
					this.editor.startup();
				},
				isEditing: function() {
					return this.editor && this.editor.editing;
				},
				_onChange: function(value) {
					// change the value back to its default, and call onChange with the
					// saved value
					this.editor.attr("value", this.label);
					var compositeValue = {label: value};
					if(this.editorPopup) {
						compositeValue = dojo.mixin(this.editorPopup.attr("value"), compositeValue);
						dijit.popup.close(this.editorPopup);
					}
					this.onChange(compositeValue, this.editor._wantsFocus);
				},
				onChange: function(value, focus) {
					// summary: Extension point for getting notifications about when this editor
					//		changes values.
					// value: New value of the inline editor
					// focus: Boolean indicating whether or not focus should stay on the inline editor
					//		usually because the ENTER key was pressed to save the value as opposed to
					//		an onblur event.
				},
				_onCancel: function() {
					this.editor.attr("value", this.label);
					if(this.editorPopup) dijit.popup.close(this.editorPopup);
					this.onCancel(this.editor._wantsFocus);
				},
				onCancel: function(focus) {
					// summary: Extension point for getting notifications about when this editor
					//		is canceled during an edit operation.
				},
				onEdit: function() {
					// summary: Extension point for getting notifications about when this editor
					//		goes into edit mode.
				}
			}
);

dojo.declare("com.ibm.widgets.WrappedInlineEditBox",
	dijit.InlineEditBox,
	{
		waitTime: 50,
		
		_wantsFocus: false,
		
		constructor: function() {
			this._connections = [];
		},
		canExit: function() {
			return true;
		},
		waitToExit: function(fname, argsArray) {
			setTimeout(dojo.hitch(this, function(){
				if(this.canExit() && this[fname + "IsValid"]()) {
					dijit.InlineEditBox.prototype[fname].apply(this, argsArray);
					this._wantsFocus = false;
				}
			}), this.waitTime);
		},
		saveIsValid: function() {
			return true;
		},
		cancelIsValid: function() {
			return true;
		},
		save: function(focus) {
			this._wantsFocus = focus;
			this.waitToExit("save", arguments);
		},
		cancel: function(focus) {
			this._wantsFocus = focus;
			this.waitToExit("cancel", arguments);
		},
		edit: function() {
			this.inherited(arguments);
			this._wantsFocus = false;
			var ew = this.editWidget;
			this._connections.push(dojo.connect(ew, "focus", this, "onFocus"));
			this._connections.push(dojo.connect(ew.editWidget, "onFocus", this, "onFocus"));
			this._connections.push(dojo.connect(ew, "onBlur", this, "onBlur"));
			var destroyConnection = dojo.connect(ew.editWidget, "destroy", this, function(){
				dojo.forEach(this._connections, dojo.disconnect);
				dojo.disconnect(destroyConnection);
			});
		}
	}
);

dojo.declare("com.ibm.widgets.InlineEditorPopup",
	dijit.layout.ContentPane,
	{
		"class": "inlineEditorPopup",
		
		content: 
			'<form dojoType="dijit.form.Form" encType="multipart/form-data" action="" method="POST" onSubmit="return false;" onReset="return false;">'
				+'<input name="isPrivate" checked="checked" dojoType="dijit.form.CheckBox">'
				+'<label for="isPrivate">Make this my private page</label>'
			+'</form>',

		onFocus: function() {
			
		},
			
		_getValueAttr: function() {
			var childWidgets = dojo.query("> [widgetId]", this.containerNode).map(dijit.byNode);
			if(childWidgets.length > 0)	return childWidgets[0].attr("value");
			return null;
		},
		_setValueAttr: function(value) {
			var childWidgets = dojo.query("> [widgetId]", this.containerNode).map(dijit.byNode);
			if(childWidgets.length > 0)	childWidgets[0].attr("value", value);
		}
	}
);

}

if(!dojo._hasResource["dijit._KeyNavContainer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._KeyNavContainer"] = true;
dojo.provide("dijit._KeyNavContainer");


dojo.declare("dijit._KeyNavContainer",
	[dijit._Container],
	{

		// summary:
		//		A _Container with keyboard navigation of its children.
		// description:
		//		To use this mixin, call connectKeyNavHandlers() in
		//		postCreate() and call startupKeyNavChildren() in startup().
		//		It provides normalized keyboard and focusing code for Container
		//		widgets.
/*=====
		// focusedChild: [protected] Widget
		//		The currently focused child widget, or null if there isn't one
		focusedChild: null,
=====*/

		// tabIndex: Integer
		//		Tab index of the container; same as HTML tabindex attribute.
		//		Note then when user tabs into the container, focus is immediately
		//		moved to the first item in the container.
		tabIndex: "0",


		_keyNavCodes: {},

		connectKeyNavHandlers: function(/*dojo.keys[]*/ prevKeyCodes, /*dojo.keys[]*/ nextKeyCodes){
			// summary:
			//		Call in postCreate() to attach the keyboard handlers
			//		to the container.
			// preKeyCodes: dojo.keys[]
			//		Key codes for navigating to the previous child.
			// nextKeyCodes: dojo.keys[]
			//		Key codes for navigating to the next child.
			// tags:
			//		protected

			var keyCodes = this._keyNavCodes = {};
			var prev = dojo.hitch(this, this.focusPrev);
			var next = dojo.hitch(this, this.focusNext);
			dojo.forEach(prevKeyCodes, function(code){ keyCodes[code] = prev; });
			dojo.forEach(nextKeyCodes, function(code){ keyCodes[code] = next; });
			this.connect(this.domNode, "onkeypress", "_onContainerKeypress");
			this.connect(this.domNode, "onfocus", "_onContainerFocus");
		},

		startupKeyNavChildren: function(){
			// summary:
			//		Call in startup() to set child tabindexes to -1
			// tags:
			//		protected
			dojo.forEach(this.getChildren(), dojo.hitch(this, "_startupChild"));
		},

		addChild: function(/*Widget*/ widget, /*int?*/ insertIndex){
			// summary:
			//		Add a child to our _Container
			dijit._KeyNavContainer.superclass.addChild.apply(this, arguments);
			this._startupChild(widget);
		},

		focus: function(){
			// summary:
			//		Default focus() implementation: focus the first child.
			this.focusFirstChild();
		},

		focusFirstChild: function(){
			// summary:
			//		Focus the first focusable child in the container.
			// tags:
			//		protected
			this.focusChild(this._getFirstFocusableChild());
		},

		focusNext: function(){
			// summary:
			//		Focus the next widget or focal node (for widgets
			//		with multiple focal nodes) within this container.
			// tags:
			//		protected
			if(this.focusedChild && this.focusedChild.hasNextFocalNode
					&& this.focusedChild.hasNextFocalNode()){
				this.focusedChild.focusNext();
				return;
			}
			var child = this._getNextFocusableChild(this.focusedChild, 1);
			if(child.getFocalNodes){
				this.focusChild(child, child.getFocalNodes()[0]);
			}else{
				this.focusChild(child);
			}
		},

		focusPrev: function(){
			// summary:
			//		Focus the previous widget or focal node (for widgets
			//		with multiple focal nodes) within this container.
			// tags:
			//		protected
			if(this.focusedChild && this.focusedChild.hasPrevFocalNode
					&& this.focusedChild.hasPrevFocalNode()){
				this.focusedChild.focusPrev();
				return;
			}
			var child = this._getNextFocusableChild(this.focusedChild, -1);
			if(child.getFocalNodes){
				var nodes = child.getFocalNodes();
				this.focusChild(child, nodes[nodes.length-1]);
			}else{
				this.focusChild(child);
			}
		},

		focusChild: function(/*Widget*/ widget, /*Node?*/ node){
			// summary:
			//		Focus widget. Optionally focus 'node' within widget.
			// tags:
			//		protected
			if(widget){
				if(this.focusedChild && widget !== this.focusedChild){
					this._onChildBlur(this.focusedChild);
				}
				this.focusedChild = widget;
				if(node && widget.focusFocalNode){
					widget.focusFocalNode(node);
				}else{
					widget.focus();
				}
			}
		},

		_startupChild: function(/*Widget*/ widget){
			// summary:
			//		Set tabindex="-1" on focusable widgets so that we
			// 		can focus them programmatically and by clicking.
			//		Connect focus and blur handlers.
			// tags:
			//		private
			if(widget.getFocalNodes){
				dojo.forEach(widget.getFocalNodes(), function(node){
					dojo.attr(node, "tabindex", -1);
					this._connectNode(node);
				}, this);
			}else{
				var node = widget.focusNode || widget.domNode;
				if(widget.isFocusable()){
					dojo.attr(node, "tabindex", -1);
				}
				this._connectNode(node);
			}
		},

		_connectNode: function(/*Element*/ node){
			// summary:
			//		Monitor focus and blur events on the node
			// tags:
			//		private
			this.connect(node, "onfocus", "_onNodeFocus");
			this.connect(node, "onblur", "_onNodeBlur");
		},

		_onContainerFocus: function(evt){
			// summary:
			//		Handler for when the container gets focus
			// description:
			//		Initially the container itself has a tabIndex, but when it gets
			//		focus, switch focus to first child...
			// tags:
			//		private

			// Note that we can't use _onFocus() because switching focus from the
			// _onFocus() handler confuses the focus.js code
			// (because it causes _onFocusNode() to be called recursively)

			// focus bubbles on Firefox,
			// so just make sure that focus has really gone to the container
			if(evt.target !== this.domNode){ return; }

			this.focusFirstChild();
			
			// and then remove the container's tabIndex,
			// so that tab or shift-tab will go to the fields after/before
			// the container, rather than the container itself
			dojo.removeAttr(this.domNode, "tabIndex");
		},

		_onBlur: function(evt){
			// When focus is moved away the container, and it's descendant (popup) widgets,
			// then restore the container's tabIndex so that user can tab to it again.
			// Note that using _onBlur() so that this doesn't happen when focus is shifted
			// to one of my child widgets (typically a popup)
			if(this.tabIndex){
				dojo.attr(this.domNode, "tabindex", this.tabIndex);
			}
			// TODO: this.inherited(arguments);
		},

		_onContainerKeypress: function(evt){
			// summary:
			//		When a key is pressed, if it's an arrow key etc. then
			//		it's handled here.
			// tags:
			//		private
			if(evt.ctrlKey || evt.altKey){ return; }
			var func = this._keyNavCodes[evt.charOrCode];
			if(func){
				func();
				dojo.stopEvent(evt);
			}
		},

		_onNodeFocus: function(evt){
			// summary:
			//		Handler for onfocus event on a child node
			// tags:
			//		private

			// record the child that has been focused
			var widget = dijit.getEnclosingWidget(evt.target);
			if(widget && widget.isFocusable()){
				this.focusedChild = widget;
			}
			dojo.stopEvent(evt);
		},

		_onNodeBlur: function(evt){
			// summary:
			//		Handler for onblur event on a child node
			// tags:
			//		private
			dojo.stopEvent(evt);
		},

		_onChildBlur: function(/*Widget*/ widget){
			// summary:
			//		Called when focus leaves a child widget to go
			//		to a sibling widget.
			// tags:
			//		protected
		},

		_getFirstFocusableChild: function(){
			// summary:
			//		Returns first child that can be focused
			return this._getNextFocusableChild(null, 1);
		},

		_getNextFocusableChild: function(child, dir){
			// summary:
			//		Returns the next or previous focusable child, compared
			//		to "child"
			// child: Widget
			//		The current widget
			// dir: Integer
			//		* 1 = after
			//		* -1 = before
			if(child){
				child = this._getSiblingOfChild(child, dir);
			}
			var children = this.getChildren();
			for(var i=0; i < children.length; i++){
				if(!child){
					child = children[(dir>0) ? 0 : (children.length-1)];
				}
				if(child.isFocusable()){
					return child;
				}
				child = this._getSiblingOfChild(child, dir);
			}
			// no focusable child found
			return null;
		}
	}
);

}

if(!dojo._hasResource["com.ibm.widgets.TabBar"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.widgets.TabBar"] = true;
dojo.provide( "com.ibm.widgets.TabBar" );






/*
 * Provides Menu widgets using OneUI structure and styles by subclassing dijit.Menu widgets
 * and modifying the templates
 */


dojo.declare( "com.ibm.widgets.TabBar",
			[dijit._Widget, dijit._Templated, dijit._KeyNavContainer],
			{
				// summary: 
				//		Holds a set of tabs in a bar widget.  Provides logic to manage popups
				// 		for each tab (specified by the 'popup' property of the tab widget) if
				//		present.
				
				// class: String class applied to the root node in this widget
				"class": "lotusTabContainer",
				
				// tabListClass: String class applied to the unorderered list node in this 
				// 		widget
				tabListClass: "lotusTabs",
				
				// tabClass: String the class passed in as the class of each tab widget
				//		that is added as a child to this tab bar.  If empty or null, the
				//		tab widget will assume whatever its default class is.
				tabClass: "lotusTab",
				
				// tagWidget: String the name of the widget class to instantiate for each
				//		tab in this tab bar.  Alternatively, simply calling the addChild
				//		function with any widget as the argument will add that widget to
				//		this tab bar, although it may not look appropriate.
				tabWidget: "com.ibm.widgets.Tab",
				
				// tabStrip: Boolean indicating if an additional CSS class is applied to the
				//		root DOM node of this widget which has the value of the class+"Strip"
				//		Example - class = "lotusTabContainer", with tabStrip = true, an additional
				//		class "lotusTabContainerStrip" is added as well.
				tabStrip: false,
				
				tabIndex: "0",
				
				templateString: '<div tabIndex="${tabIndex}" class="${class}" waiRole="navigation" dojoAttachPoint="focusNode">'
									+'<ul class="${tabListClass}" waiRole="tablist" dojoAttachPoint="containerNode,tabList" dojoAttachEvent="onkeypress:_onKeyPress"></ul>'
								+'</div>',
				
				attributeMap: dojo.mixin(dojo.clone(dijit._Widget.prototype.attributeMap), {
					tabListClass: {node: "containerNode", type: "class" }
				}),
				
				_setClassAttr: function(/*String*/ value){
					this["class"] = value;
					this.domNode["className"] = value;
				},
				
				postCreate: function() {
					this.inherited(arguments);
					if(this.tabStrip) dojo.addClass(this.tabList, this["class"] + "Strip");
					var ltr = this.isLeftToRight(),
						k = dojo.keys;
					this.connectKeyNavHandlers(
						ltr ? [k.LEFT_ARROW] : [k.RIGHT_ARROW],
						ltr ? [k.RIGHT_ARROW] : [k.LEFT_ARROW]
					);
				},
				
				startup: function() {
					this.startupKeyNavChildren();
					this.inherited(arguments);
				},
				
				_fillContent: function(/*DomNode*/ source){
					var dest = this.containerNode;
					if(source && dest) {
						var nodes = dojo.query("> ul", source);
						if(nodes.length > 0) {
							this.preloaded = true;
							this.tabListClass = nodes[0]["className"];
							this.containerNode["className"] = this.tabListClass;
							source = nodes[0];
						}
					}
					return this.inherited(arguments);
				},
				
				_onKeyPress: function(evt){
					if(evt.ctrlKey || evt.altKey) return;
					switch(evt.charOrCode) {
						 case dojo.keys.DOWN_ARROW:
						 	this._moveToPopup(evt);
						 	dojo.stopEvent(evt);
						 	break;
					}	
				},
				_onNodeBlur: function(evt){
					// when focus leaves a child,
					// reinstate the container's tabindex
					/*
					var item = dijit.getEnclosingWidget(evt.target);
					this._onChildBlur(item);
					*/
					this._startCloseTimer();
					this.inherited(arguments);
				},
				_onChildBlur: function(item) {
					if(item.popup) dijit.popup.close(item.popup);
					item._blur();
				},
				_moveToPopup: function(/*Event*/ evt){
					if(this.focusedChild && this.focusedChild.popup && !this.focusedChild.disabled) {
						this._openPopup(this.focusedChild, true);
					}
				},
				_moveToNextPopup: function() {
					this.focusNext();
				},
				_openPopup: function(item, focus) {
					var popup = item.popup;
					if(!popup) return false;
					if(this.currentPopup == popup) {
						if(focus && popup.focus) {
							popup.focus();
						}
						return false;
					}
					var me = this;
					var ori = {'BL':'TL', 'TL':'BL'};
					if (!this.isLeftToRight())
					{
						ori = {'BR':'TR', 'TR':'BR'};
					}
					dijit.popup.open({
						parent: this,
						popup: popup,
						orient: ori,
						around: item.domNode,
						onCancel: function() {
							if(popup.close) popup.close();
							else dijit.popup.close(popup);
							item.focus();
							me.currentPopup = null;
						},
						onClose: function() {
							me.currentPopup = null;
						}
					});
					
					this.currentPopup = popup;
					
					if(focus && popup.focus) {
						popup.focus();
					}
					
					return true;
				},
				
				_closePopup: function() {
					if(this.currentPopup) {
						if(this.currentPopup.close) this.currentPopup.close();
						else dijit.popup.close(this.currentPopup);
					}
					this.currentPopup = null;
				},
				
				_startCloseTimer: function() {
					if(this.currentPopup) {
						if(this.currentPopup._startCloseTimer) {
							// the popup supports the _startCloseTimer function, call it
							this.currentPopup._startCloseTimer();
						}
						else {
							// if it does not, close it immediately
							this._closePopup();
						}
					}
				},
				
				_stopCloseTimer: function() {
					if(this.currentPopup && this.currentPopup._stopCloseTimer) {
						this.currentPopup._stopCloseTimer();
					}
				},
				_onItemAccent: function(child, focus) {
					if(child.attr("disabled")) return;
					// stop any close timers
					this._stopCloseTimer();
					if(this.currentPopup) {
						if(this.currentPopup.canClose && !this.currentPopup.canClose()) return;
						if(this.currentPopup != child.popup) {
							// close the existing popup if it's not the one associated with hovered item
							// close it immediately without allowing any animation or effect so that
							// the new menu that's being opened will display correctly
							dijit.popup.close(this.currentPopup);
						}
					}
					// open the hovered item popup
					this._openPopup(child, focus);
				},
				onItemFocus: function(child) {
					//this._onItemAccent(child, false);
				},
				onItemClick: function(child, evt) {
					if(child.attr("disabled")) return;
					child.onClick(evt);
				},
				onItemHover: function(child, evt) {
					this._onItemAccent(child, false);
				},
				onItemUnhover: function(item) {
					this._startCloseTimer();
				}
			}
);

dojo.declare( "com.ibm.widgets._TabBase",
			[dijit._Widget, dijit._Templated, dijit._Contained],
			{
				"class": "lotusTab",
				_setDisabledAttr: function(/*Boolean*/ value){
					this.disabled = value;
					dojo[value ? "addClass" : "removeClass"](this.domNode, "disabled");
					dijit.setWaiState(this.focusNode, 'disabled', value ? 'true' : 'false');
				},
				_setClassAttr: function(/*String*/ value){
					this["class"] = value;
					this.domNode["className"] = value;
				},
				focus: function(){
					dijit.focus(this.focusNode);
				},
				onFocus: function() {
					this.getParent().onItemFocus(this);
				},
				_onHover: function(evt) {
					this.getParent().onItemHover(this, evt);
				},
				_onUnhover: function(evt) {
					this.getParent().onItemUnhover(this, evt);
				},
				_blur: function() {
					// called by parent to perform any blur action on this item
				}
			}
);

dojo.declare( "com.ibm.widgets.Tab",
			com.ibm.widgets._TabBase,
			{
				iconClass: "",
				href: "",
				label: "",
				
				templateString:"<li class=\"${class}\" dojoAttachEvent=\"onclick:_onClick,onmouseenter:_onHover,onmouseleave:_onUnhover\"\n\t><div waiRole=\"presentation\" dojoAttachPoint=\"containerNode\"\n\t\t><span class=\"dragHandle\" waiRole=\"presentation\" dojoAttachPoint=\"dndHandleNode\"\n\t\t\t><span class=\"dragHandleInner\" waiRole=\"presentation\"\n\t\t\t\t><img dojoAttachPoint=\"iconNode\" alt=\"\" src=\"${_blankGif}\" waiRole=\"presentation\" \n\t\t\t\t/><span waiRole=\"presentation\" class=\"dragHandleA11y\">|</span\n\t\t\t></span\n\t\t></span\n\t\t><a dojoAttachPoint=\"focusNode,linkNode,labelNode\" href=\"javascript:;\" onclick=\"javascript:return false;\" waiRole=\"menuitem\"></a\n\t\t><span class=\"modelHasChildrenIcon\" waiRole=\"presentation\" dojoAttachPoint=\"hasChildrenIconNode\"\n\t\t\t><img src=\"${_blankGif}\" alt=\"\" waiRole=\"presentation\" class=\"dijitArrowButtonInner\"\n\t\t\t/><span waiRole=\"presentation\" class=\"dijitArrowButtonChar\">&#9660;</span\n\t\t></span\n\t\t><div class=\"dndMagicZone\" waiRole=\"presentation\"\n\t\t></div\n\t></div\n></li>\n",
								
				attributeMap: dojo.mixin(dojo.clone(dijit._Widget.prototype.attributeMap), {
					label: {node: "labelNode", type: "innerHTML"},
					href: {node: "linkNode", type: "attribute"},
					iconClass: {node: "iconNode", type: "class" }
				}),
				_setDndHandleAttr: function(value) {
					this.dndHandle = value;
					dojo[value ? "addClass" : "removeClass"](this.dndHandleNode, "dojoDndHandle");
				},
				postCreate: function() {
					this.inherited(arguments);
					if(this.popup) {
						this.setPopup(this.popup);
					}
				},
				
				_fillContent: function(/*DomNode*/ source){
					var dest = this.containerNode;
					var handled = false;
					if(source && dest) {
						var nodes = dojo.query("a", source);
						if(nodes.length > 0) {
							handled = true;
							this.linkNode.setAttribute("href", nodes[0].getAttribute("href"));
							while(nodes[0].hasChildNodes()) {
								this.linkNode.appendChild(nodes[0].firstChild);
							}
						}
					}
					if(!handled) return this.inherited(arguments);
				},
				
				setPopup: function(popup) {
					this.popup = popup;
					this.popup.anchor = this;
					this.popup.startup();
					dijit.setWaiState(this.linkNode, "haspopup", "true");
				},
				destroyPopup: function() {
					if(this.popup) {
						this.popup.destroyRecursive();
						delete this.popup;
						dijit.setWaiState(this.linkNode, "haspopup", "false");
					}
				},
				destroyDescendants: function() {
					this.destroyPopup();
					this.inherited(arguments);
				},
				
				startup: function() {
					this.inherited(arguments);
					if(this.popup) this.popup.startup();
				},
				_onClick: function(evt) {
					var p = this.getParent();
					if(p) {
						p.onItemClick(this, evt);
						dojo.stopEvent(evt);
					}
				},
				onClick: function(evt) {
					
				}
			}
);


dojo.declare( "com.ibm.widgets.ShowEditorTab",
			com.ibm.widgets._TabBase,
			{
				"class": "showEditorTab",
				templateString:	'<li class="${class}" waiRole="menuitem" dojoAttachPoint="containerNode" dojoAttachEvent="onclick:onClick">'
									+'<a dojoAttachPoint="focusNode" class="tabLabel" onclick="javascript:return false;" href="javascript:void(0);">${label}</a>'
								+'</li>',

				
				postCreate: function() {
					this.inherited(arguments);
					dojo.setSelectable(this.domNode, true);
					if(this.popupWidget) {
						var cls = dojo.getObject(this.popupWidget);
						this.popup = new cls(this.popupParams);
						this.connect(this.popup, "onChange", "onChange");
						this.connect(this.popup, "onCancel", "onCancel");
						this.connect(this.popup, "focus", "onEdit");
					}
				},
				onFocus: function() {
					
				},
				onChange: function(value) {
					
				},
				onCancel: function() {
					
				},
				onEdit: function() {
					
				},
				onClick: function(evt) {
					if (this.popup){
						// Check if there is a page manager and bring up the save changes dialog.
						if (typeof ibmPortalConfig != "undefined" && typeof ibmPortalConfig.savePageManager != "undefined" && typeof ibmPortalConfig.savePageManager.leavePage != "undefined") {
							var dialog = this.popup;
							var dialogOpen = function() { dialog.focus(); };
							ibmPortalConfig.savePageManager.leavePage(dialogOpen);
						}
						else {
							this.popup.focus();
						}
					}
				}
			}
);

dojo.declare( "com.ibm.widgets.EditorTab",
			[com.ibm.widgets._TabBase, com.ibm.widgets.InlineEditorWrapper],
			{
				templateString:"<li class=\"inlineEditor ${class}\" waiRole=\"presentation\" dojoAttachPoint=\"containerNode\" dojoAttachEvent=\"onclick:onClick,onmouseenter:_onHover,onmouseleave:_onUnhover\"\n\t><div\n\t\t><a dojoAttachPoint=\"editor,focusNode\" href=\"javascript:;\" class=\"tabLabel\" waiRole=\"tab\" onclick=\"javascript:return false;\">${label}</a\n\t></div\n></li>\n",
				
				"class": "lotusTab",
				
				postCreate: function() {
					this.inherited(arguments);
					dojo.setSelectable(this.domNode, true);
				}	
			}
);

}

if(!dojo._hasResource["dijit.MenuItem"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.MenuItem"] = true;
dojo.provide("dijit.MenuItem");





dojo.declare("dijit.MenuItem",
		[dijit._Widget, dijit._Templated, dijit._Contained],
		{
		// summary:
		//		A line item in a Menu Widget

		// Make 3 columns
		// icon, label, and expand arrow (BiDi-dependent) indicating sub-menu
		templateString:"<tr class=\"dijitReset dijitMenuItem\" dojoAttachPoint=\"focusNode\" waiRole=\"menuitem\" tabIndex=\"-1\"\n\t\tdojoAttachEvent=\"onmouseenter:_onHover,onmouseleave:_onUnhover,ondijitclick:_onClick\">\n\t<td class=\"dijitReset\" waiRole=\"presentation\">\n\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitMenuItemIcon\" dojoAttachPoint=\"iconNode\">\n\t</td>\n\t<td class=\"dijitReset dijitMenuItemLabel\" colspan=\"2\" dojoAttachPoint=\"containerNode\"></td>\n\t<td class=\"dijitReset dijitMenuItemAccelKey\" style=\"display: none\" dojoAttachPoint=\"accelKeyNode\"></td>\n\t<td class=\"dijitReset dijitMenuArrowCell\" waiRole=\"presentation\">\n\t\t<div dojoAttachPoint=\"arrowWrapper\" style=\"visibility: hidden\">\n\t\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitMenuExpand\">\n\t\t\t<span class=\"dijitMenuExpandA11y\">+</span>\n\t\t</div>\n\t</td>\n</tr>\n",

		attributeMap: dojo.delegate(dijit._Widget.prototype.attributeMap, {
			label: { node: "containerNode", type: "innerHTML" },
			iconClass: { node: "iconNode", type: "class" }
		}),

		// label: String
		//		Menu text
		label: '',

		// iconClass: String
		//		Class to apply to DOMNode to make it display an icon.
		iconClass: "",

		// accelKey: String
		//		Text for the accelerator (shortcut) key combination.
		//		Note that although Menu can display accelerator keys there
		//		is no infrastructure to actually catch and execute these
		//		accelerators.
		accelKey: "",

		// disabled: Boolean
		//		If true, the menu item is disabled.
		//		If false, the menu item is enabled.
		disabled: false,

		_fillContent: function(/*DomNode*/ source){
			// If button label is specified as srcNodeRef.innerHTML rather than
			// this.params.label, handle it here.
			if(source && !("label" in this.params)){
				this.attr('label', source.innerHTML);
			}
		},

		postCreate: function(){
			dojo.setSelectable(this.domNode, false);
			dojo.attr(this.containerNode, "id", this.id+"_text");
			dijit.setWaiState(this.domNode, "labelledby", this.id+"_text");
		},

		_onHover: function(){
			// summary:
			//		Handler when mouse is moved onto menu item
			// tags:
			//		protected
			dojo.addClass(this.domNode, 'dijitMenuItemHover');
			this.getParent().onItemHover(this);
		},

		_onUnhover: function(){
			// summary:
			//		Handler when mouse is moved off of menu item,
			//		possibly to a child menu, or maybe to a sibling
			//		menuitem or somewhere else entirely.
			// tags:
			//		protected

			// if we are unhovering the currently selected item
			// then unselect it
			dojo.removeClass(this.domNode, 'dijitMenuItemHover');
			this.getParent().onItemUnhover(this);
		},

		_onClick: function(evt){
			// summary:
			//		Internal handler for click events on MenuItem.
			// tags:
			//		private
			this.getParent().onItemClick(this, evt);
			dojo.stopEvent(evt);
		},

		onClick: function(/*Event*/ evt){
			// summary:
			//		User defined function to handle clicks
			// tags:
			//		callback
		},

		focus: function(){
			// summary:
			//		Focus on this MenuItem
			try{
				dijit.focus(this.focusNode);
			}catch(e){
				// this throws on IE (at least) in some scenarios
			}
		},

		_onFocus: function(){
			// summary:
			//		This is called by the focus manager when focus
			//		goes to this MenuItem or a child menu.
			// tags:
			//		protected
			this._setSelected(true);

			// TODO: this.inherited(arguments);
		},

		_setSelected: function(selected){
			// summary:
			//		Indicate that this node is the currently selected one
			// tags:
			//		private

			/***
			 * TODO: remove this method and calls to it, when _onBlur() is working for MenuItem.
			 * Currently _onBlur() gets called when focus is moved from the MenuItem to a child menu.
			 * That's not supposed to happen, but the problem is:
			 * In order to allow dijit.popup's getTopPopup() to work,a sub menu's popupParent
			 * points to the parent Menu, bypassing the parent MenuItem... thus the
			 * MenuItem is not in the chain of active widgets and gets a premature call to
			 * _onBlur()
			 */
			
			dojo.toggleClass(this.domNode, "dijitMenuItemSelected", selected);
		},

		setLabel: function(/*String*/ content){
			// summary:
			//		Deprecated.   Use attr('label', ...) instead.
			// tags:
			//		deprecated
			dojo.deprecated("dijit.MenuItem.setLabel() is deprecated.  Use attr('label', ...) instead.", "", "2.0");
			this.attr("label", content);
		},

		setDisabled: function(/*Boolean*/ disabled){
			// summary:
			//		Deprecated.   Use attr('disabled', bool) instead.
			// tags:
			//		deprecated
			dojo.deprecated("dijit.Menu.setDisabled() is deprecated.  Use attr('disabled', bool) instead.", "", "2.0");
			this.attr('disabled', disabled);
		},
		_setDisabledAttr: function(/*Boolean*/ value){
			// summary:
			//		Hook for attr('disabled', ...) to work.
			//		Enable or disable this menu item.
			this.disabled = value;
			dojo[value ? "addClass" : "removeClass"](this.domNode, 'dijitMenuItemDisabled');
			dijit.setWaiState(this.focusNode, 'disabled', value ? 'true' : 'false');
		},
		_setAccelKeyAttr: function(/*String*/ value){
			// summary:
			//		Hook for attr('accelKey', ...) to work.
			//		Set accelKey on this menu item.
			this.accelKey=value;

			this.accelKeyNode.style.display=value?"":"none";
			this.accelKeyNode.innerHTML=value;
			//have to use colSpan to make it work in IE
			dojo.attr(this.containerNode,'colSpan',value?"1":"2");
		}
	});

}

if(!dojo._hasResource["dijit.PopupMenuItem"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.PopupMenuItem"] = true;
dojo.provide("dijit.PopupMenuItem");



dojo.declare("dijit.PopupMenuItem",
		dijit.MenuItem,
		{
		_fillContent: function(){
			// summary: 
			//		When Menu is declared in markup, this code gets the menu label and
			//		the popup widget from the srcNodeRef.
			// description:
			//		srcNodeRefinnerHTML contains both the menu item text and a popup widget
			//		The first part holds the menu item text and the second part is the popup
			// example: 
			// |	<div dojoType="dijit.PopupMenuItem">
			// |		<span>pick me</span>
			// |		<popup> ... </popup>
			// |	</div>
			// tags:
			//		protected

			if(this.srcNodeRef){
				var nodes = dojo.query("*", this.srcNodeRef);
				dijit.PopupMenuItem.superclass._fillContent.call(this, nodes[0]);

				// save pointer to srcNode so we can grab the drop down widget after it's instantiated
				this.dropDownContainer = this.srcNodeRef;
			}
		},

		startup: function(){
			if(this._started){ return; }
			this.inherited(arguments);

			// we didn't copy the dropdown widget from the this.srcNodeRef, so it's in no-man's
			// land now.  move it to dojo.doc.body.
			if(!this.popup){
				var node = dojo.query("[widgetId]", this.dropDownContainer)[0];
				this.popup = dijit.byNode(node);
			}
			dojo.body().appendChild(this.popup.domNode);

			this.popup.domNode.style.display="none";
			if(this.arrowWrapper){
				dojo.style(this.arrowWrapper, "visibility", "");
			}
			dijit.setWaiState(this.focusNode, "haspopup", "true");
		},
		
		destroyDescendants: function(){
			if(this.popup){
				this.popup.destroyRecursive();
				delete this.popup;
			}
			this.inherited(arguments);
		}
	});


}

if(!dojo._hasResource["dijit.CheckedMenuItem"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.CheckedMenuItem"] = true;
dojo.provide("dijit.CheckedMenuItem");



dojo.declare("dijit.CheckedMenuItem",
		dijit.MenuItem,
		{
		// summary:
		//		A checkbox-like menu item for toggling on and off
		
		templateString:"<tr class=\"dijitReset dijitMenuItem\" dojoAttachPoint=\"focusNode\" waiRole=\"menuitemcheckbox\" tabIndex=\"-1\"\n\t\tdojoAttachEvent=\"onmouseenter:_onHover,onmouseleave:_onUnhover,ondijitclick:_onClick\">\n\t<td class=\"dijitReset\" waiRole=\"presentation\">\n\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitMenuItemIcon dijitCheckedMenuItemIcon\" dojoAttachPoint=\"iconNode\">\n\t\t<span class=\"dijitCheckedMenuItemIconChar\">&#10003;</span>\n\t</td>\n\t<td class=\"dijitReset dijitMenuItemLabel\" colspan=\"2\" dojoAttachPoint=\"containerNode,labelNode\"></td>\n\t<td class=\"dijitReset dijitMenuItemAccelKey\" style=\"display: none\" dojoAttachPoint=\"accelKeyNode\"></td>\n\t<td class=\"dijitReset dijitMenuArrowCell\" waiRole=\"presentation\">\n\t</td>\n</tr>\n",

		// checked: Boolean
		//		Our checked state
		checked: false,
		_setCheckedAttr: function(/*Boolean*/ checked){
			// summary:
			//		Hook so attr('checked', bool) works.
			//		Sets the class and state for the check box.
			dojo.toggleClass(this.domNode, "dijitCheckedMenuItemChecked", checked);
			dijit.setWaiState(this.domNode, "checked", checked);
			this.checked = checked;
		},

		onChange: function(/*Boolean*/ checked){
			// summary:
			//		User defined function to handle check/uncheck events
			// tags:
			//		callback
		},

		_onClick: function(/*Event*/ e){
			// summary:
			//		Clicking this item just toggles its state
			// tags:
			//		private
			if(!this.disabled){
				this.attr("checked", !this.checked);
				this.onChange(this.checked);
			}
			this.inherited(arguments);
		}
	});

}

if(!dojo._hasResource["dijit.MenuSeparator"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.MenuSeparator"] = true;
dojo.provide("dijit.MenuSeparator");





dojo.declare("dijit.MenuSeparator",
		[dijit._Widget, dijit._Templated, dijit._Contained],
		{
		// summary:
		//		A line between two menu items

		templateString:"<tr class=\"dijitMenuSeparator\">\n\t<td colspan=\"4\">\n\t\t<div class=\"dijitMenuSeparatorTop\"></div>\n\t\t<div class=\"dijitMenuSeparatorBottom\"></div>\n\t</td>\n</tr>\n",

		postCreate: function(){
			dojo.setSelectable(this.domNode, false);
		},
		
		isFocusable: function(){
			// summary:
			//		Override to always return false
			// tags:
			//		protected

			return false; // Boolean
		}
	});


}

if(!dojo._hasResource["dijit.Menu"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.Menu"] = true;
dojo.provide("dijit.Menu");





dojo.declare("dijit._MenuBase",
	[dijit._Widget, dijit._Templated, dijit._KeyNavContainer],
{
	// summary:
	//		Base class for Menu and MenuBar

	// parentMenu: [readonly] Widget
	//		pointer to menu that displayed me
	parentMenu: null,

	// popupDelay: Integer
	//		number of milliseconds before hovering (without clicking) causes the popup to automatically open.
	popupDelay: 500,

	startup: function(){
		if(this._started){ return; }

		dojo.forEach(this.getChildren(), function(child){ child.startup(); });
		this.startupKeyNavChildren();

		this.inherited(arguments);
	},

	onExecute: function(){
		// summary:
		//		Attach point for notification about when a menu item has been executed.
		//		This is an internal mechanism used for Menus to signal to their parent to
		//		close them, because they are about to execute the onClick handler.   In
		//		general developers should not attach to or override this method.
		// tags:
		//		protected
	},

	onCancel: function(/*Boolean*/ closeAll){
		// summary:
		//		Attach point for notification about when the user cancels the current menu
		//		This is an internal mechanism used for Menus to signal to their parent to
		//		close them.  In general developers should not attach to or override this method.
		// tags:
		//		protected
	},

	_moveToPopup: function(/*Event*/ evt){
		// summary:
		//		This handles the right arrow key (left arrow key on RTL systems),
		//		which will either open a submenu, or move to the next item in the
		//		ancestor MenuBar
		// tags:
		//		private

		if(this.focusedChild && this.focusedChild.popup && !this.focusedChild.disabled){
			this.focusedChild._onClick(evt);
		}else{
			var topMenu = this._getTopMenu();
			if(topMenu && topMenu._isMenuBar){
				topMenu.focusNext();
			}
		}
	},

	onItemHover: function(/*MenuItem*/ item){
		// summary:
		//		Called when cursor is over a MenuItem.
		// tags:
		//		protected

		// Don't do anything unless user has "activated" the menu by:
		//		1) clicking it
		//		2) tabbing into it
		//		3) opening it from a parent menu (which automatically focuses it)
		if(this.isActive){
			this.focusChild(item);
	
			if(this.focusedChild.popup && !this.focusedChild.disabled && !this.hover_timer){
				this.hover_timer = setTimeout(dojo.hitch(this, "_openPopup"), this.popupDelay);
			}
		}
	},

	_onChildBlur: function(item){
		// summary:
		//		Called when a child MenuItem becomes inactive because focus
		//		has been removed from the MenuItem *and* it's descendant menus.
		// tags:
		//		private

		item._setSelected(false);

		// Close all popups that are open and descendants of this menu
		dijit.popup.close(item.popup);
		this._stopPopupTimer();
	},

	onItemUnhover: function(/*MenuItem*/ item){
		// summary:
		//		Callback fires when mouse exits a MenuItem
		// tags:
		//		protected
		if(this.isActive){
			this._stopPopupTimer();
		}
	},

	_stopPopupTimer: function(){
		// summary:
		//		Cancels the popup timer because the user has stop hovering
		//		on the MenuItem, etc.
		// tags:
		//		private
		if(this.hover_timer){
			clearTimeout(this.hover_timer);
			this.hover_timer = null;
		}
	},

	_getTopMenu: function(){
		// summary:
		//		Returns the top menu in this chain of Menus
		// tags:
		//		private
		for(var top=this; top.parentMenu; top=top.parentMenu);
		return top;
	},

	onItemClick: function(/*Widget*/ item, /*Event*/ evt){
		// summary:
		//		Handle clicks on an item.
		// tags:
		//		private
		if(item.disabled){ return false; }

		this.focusChild(item);

		if(item.popup){
			if(!this.is_open){
				this._openPopup();
			}
		}else{
			// before calling user defined handler, close hierarchy of menus
			// and restore focus to place it was when menu was opened
			this.onExecute();

			// user defined handler for click
			item.onClick(evt);
		}
	},

	_openPopup: function(){
		// summary:
		//		Open the popup to the side of/underneath the current menu item
		// tags:
		//		protected

		this._stopPopupTimer();
		var from_item = this.focusedChild;
		var popup = from_item.popup;

		if(popup.isShowingNow){ return; }
		popup.parentMenu = this;
		var self = this;
		dijit.popup.open({
			parent: this,
			popup: popup,
			around: from_item.domNode,
			orient: this._orient || (this.isLeftToRight() ? 
									{'TR': 'TL', 'TL': 'TR', 'BR': 'BL', 'BL': 'BR'} : 
									{'TL': 'TR', 'TR': 'TL', 'BL': 'BR', 'BR': 'BL'}),
			onCancel: function(){
				// called when the child menu is canceled
				dijit.popup.close(popup);
				from_item.focus();	// put focus back on my node
				self.currentPopup = null;
			},
			onExecute: dojo.hitch(this, "_onDescendantExecute")
		});

		this.currentPopup = popup;

		if(popup.focus){
			// If user is opening the popup via keyboard (right arrow, or down arrow for MenuBar),
			// if the cursor happens to collide with the popup, it will generate an onmouseover event
			// even though the mouse wasn't moved.   Use a setTimeout() to call popup.focus so that
			// our focus() call overrides the onmouseover event, rather than vice-versa.  (#8742)
			setTimeout(dojo.hitch(popup, "focus"), 0);
		}
	},

	onOpen: function(/*Event*/ e){
		// summary:
		//		Callback when this menu is opened.
		//		This is called by the popup manager as notification that the menu
		//		was opened.
		// tags:
		//		private

		this.isShowingNow = true;
	},

	onClose: function(){
		// summary:
		//		Callback when this menu is closed.
		//		This is called by the popup manager as notification that the menu
		//		was closed.
		// tags:
		//		private

		this._stopPopupTimer();
		this.parentMenu = null;
		this.isShowingNow = false;
		this.currentPopup = null;
		if(this.focusedChild){
			this._onChildBlur(this.focusedChild);
			this.focusedChild = null;
		}
	},

	_onFocus: function(){
		// summary:
		//		Called when this Menu gets focus from:
		//			1) clicking it
		//			2) tabbing into it
		//			3) being opened by a parent menu.
		//		This is not called just from mouse hover.
		// tags:
		//		protected
		this.isActive = true;
		dojo.addClass(this.domNode, "dijitMenuActive");
		dojo.removeClass(this.domNode, "dijitMenuPassive");
		this.inherited(arguments);
	},
	
	_onBlur: function(){
		// summary:
		//		Called when focus is moved away from this Menu and it's submenus.
		// tags:
		//		protected
		this.isActive = false;
		dojo.removeClass(this.domNode, "dijitMenuActive");
		dojo.addClass(this.domNode, "dijitMenuPassive");

		// If user blurs/clicks away from a MenuBar (or always visible Menu), then close all popped up submenus etc.
		this.onClose();

		this.inherited(arguments);
	},

	_onDescendantExecute: function(){
		// summary:
		//		Called when submenu is clicked.  Close hierarchy of menus.
		// tags:
		//		private
		this.onClose();
	}
});

dojo.declare("dijit.Menu",
	dijit._MenuBase,
	{
	// summary
	//		A context menu you can assign to multiple elements

	// TODO: most of the code in here is just for context menu (right-click menu)
	// support.  In retrospect that should have been a separate class (dijit.ContextMenu).
	// Split them for 2.0

	constructor: function(){
		this._bindings = [];
	},

	templateString:"<table class=\"dijit dijitMenu dijitMenuPassive dijitReset dijitMenuTable\" waiRole=\"menu\" tabIndex=\"${tabIndex}\" dojoAttachEvent=\"onkeypress:_onKeyPress\">\n\t<tbody class=\"dijitReset\" dojoAttachPoint=\"containerNode\"></tbody>\n</table>\n",

	// targetNodeIds: [const] String[]
	//		Array of dom node ids of nodes to attach to.
	//		Fill this with nodeIds upon widget creation and it becomes context menu for those nodes.
	targetNodeIds: [],

	// contextMenuForWindow: [const] Boolean
	//		If true, right clicking anywhere on the window will cause this context menu to open.
	//		If false, must specify targetNodeIds.
	contextMenuForWindow: false,

	// leftClickToOpen: [const] Boolean
	//		If true, menu will open on left click instead of right click, similiar to a file menu.
	leftClickToOpen: false,
	
	// _contextMenuWithMouse: [private] Boolean
	//		Used to record mouse and keyboard events to determine if a context
	//		menu is being opened with the keyboard or the mouse.
	_contextMenuWithMouse: false,

	postCreate: function(){
		if(this.contextMenuForWindow){
			this.bindDomNode(dojo.body());
		}else{
			// TODO: should have _setTargetNodeIds() method to handle initialization and a possible
			// later attr('targetNodeIds', ...) call.   There's also a problem that targetNodeIds[]
			// gets stale after calls to bindDomNode()/unBindDomNode() as it still is just the original list (see #9610)
			dojo.forEach(this.targetNodeIds, this.bindDomNode, this);
		}
		var k = dojo.keys, l = this.isLeftToRight();
		this._openSubMenuKey = l ? k.RIGHT_ARROW : k.LEFT_ARROW;
		this._closeSubMenuKey = l ? k.LEFT_ARROW : k.RIGHT_ARROW;
		this.connectKeyNavHandlers([k.UP_ARROW], [k.DOWN_ARROW]);
	},

	_onKeyPress: function(/*Event*/ evt){
		// summary:
		//		Handle keyboard based menu navigation.
		// tags:
		//		protected

		if(evt.ctrlKey || evt.altKey){ return; }

		switch(evt.charOrCode){
			case this._openSubMenuKey:
				this._moveToPopup(evt);
				dojo.stopEvent(evt);
				break;
			case this._closeSubMenuKey:
				if(this.parentMenu){
					if(this.parentMenu._isMenuBar){
						this.parentMenu.focusPrev();
					}else{
						this.onCancel(false);
					}
				}else{
					dojo.stopEvent(evt);
				}
				break;
		}
	},

	// thanks burstlib!
	_iframeContentWindow: function(/* HTMLIFrameElement */iframe_el){
		// summary:
		//		Returns the window reference of the passed iframe
		// tags:
		//		private
		var win = dijit.getDocumentWindow(this._iframeContentDocument(iframe_el)) ||
			// Moz. TODO: is this available when defaultView isn't?
			this._iframeContentDocument(iframe_el)['__parent__'] ||
			(iframe_el.name && dojo.doc.frames[iframe_el.name]) || null;
		return win;	//	Window
	},

	_iframeContentDocument: function(/* HTMLIFrameElement */iframe_el){
		// summary:
		//		Returns a reference to the document object inside iframe_el
		// tags:
		//		protected
		var doc = iframe_el.contentDocument // W3
			|| (iframe_el.contentWindow && iframe_el.contentWindow.document) // IE
			|| (iframe_el.name && dojo.doc.frames[iframe_el.name] && dojo.doc.frames[iframe_el.name].document)
			|| null;
		return doc;	//	HTMLDocument
	},

	bindDomNode: function(/*String|DomNode*/ node){
		// summary:
		//		Attach menu to given node
		node = dojo.byId(node);

		var cn;	// Connect node

		// Support context menus on iframes.   Rather than binding to the iframe itself we need
		// to bind to the <body> node inside the iframe.
		if(node.tagName.toLowerCase() == "iframe"){
			var iframe = node,
				win = this._iframeContentWindow(iframe);
			cn = dojo.withGlobal(win, dojo.body);
		}else{
			// to capture these events at the top level,
			// attach to document, not body
			cn = (node == dojo.body() ? dojo.doc : node);
		}

		// "binding" is the object to track our connection to the node (ie, the parameter to bindDomNode())
		var binding = {
			node: cn,
			iframe: iframe
		};
		node[this.id] = this._bindings.push(binding);

		// Setup the connections to monitor click etc., unless we are connecting to an iframe which hasn't finished
		// loading yet, in which case we need to wait for the onload event first, and then connect
		var doConnects = dojo.hitch(this, function(cn){
			return [
				dojo.connect(cn, (this.leftClickToOpen)?"onclick":"oncontextmenu", this, function(evt){
					this._openMyself(evt, cn, iframe);
				}),
				dojo.connect(cn, "onkeydown", this, "_contextKey"),
				dojo.connect(cn, "onmousedown", this, "_contextMouse")
			];
		});
		binding.connects = cn ? doConnects(cn) : [];

		if(iframe){
			// Setup handler to [re]bind to the iframe when the contents are initially loaded,
			// and every time the contents change.
			// Need to do this b/c we are actually binding to the iframe's <body> node.
			// Note: can't use dojo.connect(), see #9609.
			
			binding.onloadHandler = dojo.hitch(this, function(){
				// want to remove old connections, but IE throws exceptions when trying to
				// access the <body> node because it's already gone, or at least in a state of limbo

				var win = this._iframeContentWindow(iframe);
					cn = dojo.withGlobal(win, dojo.body);
				binding.connects = doConnects(cn);
			});
			if(iframe.addEventListener){
				iframe.addEventListener("load", binding.onloadHandler, false);
			}else{
				iframe.attachEvent("onload", binding.onloadHandler);
			}
		}
	},

	unBindDomNode: function(/*String|DomNode*/ nodeName){
		// summary:
		//		Detach menu from given node

		var node;
		try {
			node = dojo.byId(nodeName);
		}catch(e){
			// On IE the dojo.byId() call will get an exception if the attach point was
			// the <body> node of an <iframe> that has since been reloaded (and thus the
			// <body> node is in a limbo state of destruction.
			return;
		}

		if(node && node[this.id]){
			var bid = node[this.id]-1, b = this._bindings[bid];
			dojo.forEach(b.connects, dojo.disconnect);

			// Remove listener for iframe onload events
			var iframe = b.iframe;
			if(iframe){
				if(iframe.removeEventListener){
					iframe.removeEventListener("load", b.onloadHandler, false);
				}else{
					iframe.detachEvent("onload", b.onloadHandler);
				}
			}

			delete this._bindings[bid];
		}
	},

	_contextKey: function(e){
		// summary:
		//		Code to handle popping up editor using F10 key rather than mouse
		// tags:
		//		private
		this._contextMenuWithMouse = false;
		if(e.keyCode == dojo.keys.F10){
			dojo.stopEvent(e);
			if(e.shiftKey && e.type=="keydown"){
				// FF: copying the wrong property from e will cause the system
				// context menu to appear in spite of stopEvent. Don't know
				// exactly which properties cause this effect.
				var _e = { target: e.target, pageX: e.pageX, pageY: e.pageY };
				_e.preventDefault = _e.stopPropagation = function(){};
				// IE: without the delay, focus work in "open" causes the system
				// context menu to appear in spite of stopEvent.
				window.setTimeout(dojo.hitch(this, function(){ this._openMyself(_e); }), 1);
			}
		}
	},

	_contextMouse: function(e){
		// summary:
		//		Helper to remember when we opened the context menu with the mouse instead
		//		of with the keyboard
		// tags:
		//		private
		this._contextMenuWithMouse = true;
	},

	_openMyself: function(/*Event*/ e, /*DomNode?*/ node, /*DomNode?*/ iframe){
		// summary:
		//		Internal function for opening myself when the user
		//		does a right-click or something similar.
		// node:
		//		The node that is being clicked
		// iframe:
		//		If an <iframe> is being clicked, iframe points to that iframe and node
		//		points to the iframe's body.
		// tags:
		//		private

		if(this.leftClickToOpen&&e.button>0){
			return;
		}
		dojo.stopEvent(e);

		// Get coordinates.
		// If we are opening the menu with the mouse or on safari open
		// the menu at the mouse cursor
		// (Safari does not have a keyboard command to open the context menu
		// and we don't currently have a reliable way to determine
		// _contextMenuWithMouse on Safari)
		var x,y;
		if(dojo.isSafari || this._contextMenuWithMouse){
			x=e.pageX;
			y=e.pageY;
			
			if(iframe){
				// Event is on <body> node of an <iframe>, convert coordinates to match main document
				var od = e.target.ownerDocument,
					ifc = dojo.coords(iframe),
					win = this._iframeContentWindow(iframe),
					scroll = dojo.withGlobal(win, "_docScroll", dojo); 

				var cs = dojo.getComputedStyle(iframe),
					tp = dojo._toPixelValue,
					left = (dojo.isIE && dojo.isQuirks ? 0 : tp(iframe, cs.paddingLeft)) + (dojo.isIE && dojo.isQuirks ? tp(iframe, cs.borderLeftWidth) : 0) + tp(iframe, cs.marginLeft),
					top = (dojo.isIE && dojo.isQuirks ? 0 : tp(iframe, cs.paddingTop)) + (dojo.isIE && dojo.isQuirks ? tp(iframe, cs.borderTopWidth) : 0) + tp(iframe, cs.marginTop);

				x += ifc.l + left - scroll.x;
				y += ifc.t + top - scroll.y;
			}
		}else{
			// otherwise open near e.target
			var coords = dojo.coords(e.target, true);
			x = coords.x + 10;
			y = coords.y + 10;
		}

		var self=this;
		var savedFocus = dijit.getFocus(this);
		function closeAndRestoreFocus(){
			// user has clicked on a menu or popup
			dijit.focus(savedFocus);
			dijit.popup.close(self);
		}
		dijit.popup.open({
			popup: this,
			x: x,
			y: y,
			onExecute: closeAndRestoreFocus,
			onCancel: closeAndRestoreFocus,
			orient: this.isLeftToRight() ? 'L' : 'R'
		});
		this.focus();

		this._onBlur = function(){
			this.inherited('_onBlur', arguments);
			// Usually the parent closes the child widget but if this is a context
			// menu then there is no parent
			dijit.popup.close(this);
			// don't try to restore focus; user has clicked another part of the screen
			// and set focus there
		};
	},

	uninitialize: function(){
 		dojo.forEach(this._bindings, function(b){ if(b){ this.unBindDomNode(b.node); } }, this);
 		this.inherited(arguments);
	}
}
);

// Back-compat (TODO: remove in 2.0)






}

if(!dojo._hasResource["com.ibm.widgets.TimedMenu"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.widgets.TimedMenu"] = true;
dojo.provide("com.ibm.widgets.TimedMenu");

dojo.declare("com.ibm.widgets.TimedMenu",
			null,
			{
				_onHover: function() {
					this._enter();
				},
				_onUnhover: function() {
					this._exit();
				},
				_onNodeFocus: function(evt){
					this._enter();
					this.inherited(arguments);
				},
				_onNodeBlur: function(evt){
					this._exit();
					this.inherited(arguments);
				},
				_exit: function() {
					this._startCloseTimer();
					if(this.parentMenu && this.parentMenu._startCloseTimer) {
						// if we have a parent that has this function (ie, an instance of the same class),
						// tell it to start its timer too
						this.parentMenu._startCloseTimer();
					}
				},
				_enter: function() {
					this._stopCloseTimer();
				},
				_startCloseTimer: function() {
					// summary: Starts the timer to close this menu if it's not already set.
					//		Marks this menu to be closed and marks the parent menu to be closed too.
					if(!this._closeTimer) {
						this._isClosing = true;
						if(this.parentMenu) this.parentMenu._isClosing = true;
						if(this.closeDelay == 0) {
							this.close();
						} 
						else {
							this._closeTimer = setTimeout(dojo.hitch(this, function(){
								this._closeTimer = null;
								this.close();
							}), this.closeDelay);
						}
					}
				},
				_stopCloseTimer: function() {
					// summary: Stops the timer that closes this menu if it's set.
					//		Clears this menu from being closed and stops the parent
					//		from being closed if it exists.
					this._isClosing = false;
					if(this.parentMenu && this.parentMenu._stopCloseTimer) this.parentMenu._stopCloseTimer();
					if(this._closeTimer) {
						clearTimeout(this._closeTimer);
						this._closeTimer = null;
					}
				},
				canClose: function() {
					// summary: Indicates whether or not this menu can close right now.  Is
					//		used to keep menus from closing when they are editing or in other
					//		conditions.
					return true;
				},
				close: function() {
					// summary: Closes this menu upon the condition that the menu is still set for
					//		close when this is called (typically after some delay).  Will also
					//		call the parent's close function if it exists.
					if(this._isClosing && this.canClose())	{
						var parentMenu = this.parentMenu;
						this.closeAction();
						if(parentMenu && parentMenu.close) parentMenu.close();
					}
				},
				closeAction: function() {
					// summary: Closes this menu.  Can be overriden to animate the close operation or
					//		do something different.  Default is simply to close the menu.  Is called
					//		after delays have already been processed, so take care not to wait for
					//		the expected delay again unless that is the desired action.
					dijit.popup.close(this);
				}
			}
);

}

if(!dojo._hasResource["dojo.dnd.Container"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Container"] = true;
dojo.provide("dojo.dnd.Container");




/*
	Container states:
		""		- normal state
		"Over"	- mouse over a container
	Container item states:
		""		- normal state
		"Over"	- mouse over a container item
*/

dojo.declare("dojo.dnd.Container", null, {
	// summary: a Container object, which knows when mouse hovers over it, 
	//	and over which element it hovers
	
	// object attributes (for markup)
	skipForm: false,
	
	constructor: function(node, params){
		// summary: a constructor of the Container
		// node: Node: node or node's id to build the container on
		// params: Object: a dict of parameters, recognized parameters are:
		//	creator: Function: a creator function, which takes a data item, and returns an object like that:
		//		{node: newNode, data: usedData, type: arrayOfStrings}
		//	skipForm: Boolean: don't start the drag operation, if clicked on form elements
		//	dropParent: Node: node or node's id to use as the parent node for dropped items
		//		(must be underneath the 'node' parameter in the DOM)
		//	_skipStartup: Boolean: skip startup(), which collects children, for deferred initialization
		//		(this is used in the markup mode)
		this.node = dojo.byId(node);
		if(!params){ params = {}; }
		this.creator = params.creator || null;
		this.skipForm = params.skipForm;
		this.parent = params.dropParent && dojo.byId(params.dropParent);
		
		// class-specific variables
		this.map = {};
		this.current = null;

		// states
		this.containerState = "";
		dojo.addClass(this.node, "dojoDndContainer");
		
		// mark up children
		if(!(params && params._skipStartup)){
			this.startup();
		}

		// set up events
		this.events = [
			dojo.connect(this.node, "onmouseover", this, "onMouseOver"),
			dojo.connect(this.node, "onmouseout",  this, "onMouseOut"),
			// cancel text selection and text dragging
			dojo.connect(this.node, "ondragstart",   this, "onSelectStart"),
			dojo.connect(this.node, "onselectstart", this, "onSelectStart")
		];
	},
	
	// object attributes (for markup)
	creator: function(){},	// creator function, dummy at the moment
	
	// abstract access to the map
	getItem: function(/*String*/ key){
		// summary: returns a data item by its key (id)
		return this.map[key];	// Object
	},
	setItem: function(/*String*/ key, /*Object*/ data){
		// summary: associates a data item with its key (id)
		this.map[key] = data;
	},
	delItem: function(/*String*/ key){
		// summary: removes a data item from the map by its key (id)
		delete this.map[key];
	},
	forInItems: function(/*Function*/ f, /*Object?*/ o){
		// summary: iterates over a data map skipping members, which 
		//	are present in the empty object (IE and/or 3rd-party libraries).
		o = o || dojo.global;
		var m = this.map, e = dojo.dnd._empty;
		for(var i in m){
			if(i in e){ continue; }
			f.call(o, m[i], i, this);
		}
		return o;	// Object
	},
	clearItems: function(){
		// summary: removes all data items from the map
		this.map = {};
	},
	
	// methods
	getAllNodes: function(){
		// summary: returns a list (an array) of all valid child nodes
		return dojo.query("> .dojoDndItem", this.parent);	// NodeList
	},
	sync: function(){
		// summary: synch up the node list with the data map
		var map = {};
		this.getAllNodes().forEach(function(node){
			if(node.id){
				var item = this.getItem(node.id);
				if(item){
					map[node.id] = item;
					return;
				}
			}else{
				node.id = dojo.dnd.getUniqueId();
			}
			var type = node.getAttribute("dndType"),
				data = node.getAttribute("dndData");
			map[node.id] = {
				data: data || node.innerHTML,
				type: type ? type.split(/\s*,\s*/) : ["text"]
			};
		}, this);
		this.map = map;
		return this;	// self
	},
	insertNodes: function(data, before, anchor){
		// summary: inserts an array of new nodes before/after an anchor node
		// data: Array: a list of data items, which should be processed by the creator function
		// before: Boolean: insert before the anchor, if true, and after the anchor otherwise
		// anchor: Node: the anchor node to be used as a point of insertion
		if(!this.parent.firstChild){
			anchor = null;
		}else if(before){
			if(!anchor){
				anchor = this.parent.firstChild;
			}
		}else{
			if(anchor){
				anchor = anchor.nextSibling;
			}
		}
		if(anchor){
			for(var i = 0; i < data.length; ++i){
				var t = this._normalizedCreator(data[i]);
				this.setItem(t.node.id, {data: t.data, type: t.type});
				this.parent.insertBefore(t.node, anchor);
			}
		}else{
			for(var i = 0; i < data.length; ++i){
				var t = this._normalizedCreator(data[i]);
				this.setItem(t.node.id, {data: t.data, type: t.type});
				this.parent.appendChild(t.node);
			}
		}
		return this;	// self
	},
	destroy: function(){
		// summary: prepares the object to be garbage-collected
		dojo.forEach(this.events, dojo.disconnect);
		this.clearItems();
		this.node = this.parent = this.current = null;
	},

	// markup methods
	markupFactory: function(params, node){
		params._skipStartup = true;
		return new dojo.dnd.Container(node, params);
	},
	startup: function(){
		// summary: collects valid child items and populate the map
		
		// set up the real parent node
		if(!this.parent){
			// use the standard algorithm, if not assigned
			this.parent = this.node;
			if(this.parent.tagName.toLowerCase() == "table"){
				var c = this.parent.getElementsByTagName("tbody");
				if(c && c.length){ this.parent = c[0]; }
			}
		}
		this.defaultCreator = dojo.dnd._defaultCreator(this.parent);

		// process specially marked children
		this.sync();
	},

	// mouse events
	onMouseOver: function(e){
		// summary: event processor for onmouseover
		// e: Event: mouse event
		var n = e.relatedTarget;
		while(n){
			if(n == this.node){ break; }
			try{
				n = n.parentNode;
			}catch(x){
				n = null;
			}
		}
		if(!n){
			this._changeState("Container", "Over");
			this.onOverEvent();
		}
		n = this._getChildByEvent(e);
		if(this.current == n){ return; }
		if(this.current){ this._removeItemClass(this.current, "Over"); }
		if(n){ this._addItemClass(n, "Over"); }
		this.current = n;
	},
	onMouseOut: function(e){
		// summary: event processor for onmouseout
		// e: Event: mouse event
		for(var n = e.relatedTarget; n;){
			if(n == this.node){ return; }
			try{
				n = n.parentNode;
			}catch(x){
				n = null;
			}
		}
		if(this.current){
			this._removeItemClass(this.current, "Over");
			this.current = null;
		}
		this._changeState("Container", "");
		this.onOutEvent();
	},
	onSelectStart: function(e){
		// summary: event processor for onselectevent and ondragevent
		// e: Event: mouse event
		if(!this.skipForm || !dojo.dnd.isFormElement(e)){
			dojo.stopEvent(e);
		}
	},
	
	// utilities
	onOverEvent: function(){
		// summary: this function is called once, when mouse is over our container
	},
	onOutEvent: function(){
		// summary: this function is called once, when mouse is out of our container
	},
	_changeState: function(type, newState){
		// summary: changes a named state to new state value
		// type: String: a name of the state to change
		// newState: String: new state
		var prefix = "dojoDnd" + type;
		var state  = type.toLowerCase() + "State";
		//dojo.replaceClass(this.node, prefix + newState, prefix + this[state]);
		dojo.removeClass(this.node, prefix + this[state]);
		dojo.addClass(this.node, prefix + newState);
		this[state] = newState;
	},
	_addItemClass: function(node, type){
		// summary: adds a class with prefix "dojoDndItem"
		// node: Node: a node
		// type: String: a variable suffix for a class name
		dojo.addClass(node, "dojoDndItem" + type);
	},
	_removeItemClass: function(node, type){
		// summary: removes a class with prefix "dojoDndItem"
		// node: Node: a node
		// type: String: a variable suffix for a class name
		dojo.removeClass(node, "dojoDndItem" + type);
	},
	_getChildByEvent: function(e){
		// summary: gets a child, which is under the mouse at the moment, or null
		// e: Event: a mouse event
		var node = e.target;
		if(node){
			for(var parent = node.parentNode; parent; node = parent, parent = node.parentNode){
				if(parent == this.parent && dojo.hasClass(node, "dojoDndItem")){ return node; }
			}
		}
		return null;
	},
	_normalizedCreator: function(item, hint){
		// summary: adds all necessary data to the output of the user-supplied creator function
		var t = (this.creator || this.defaultCreator).call(this, item, hint);
		if(!dojo.isArray(t.type)){ t.type = ["text"]; }
		if(!t.node.id){ t.node.id = dojo.dnd.getUniqueId(); }
		dojo.addClass(t.node, "dojoDndItem");
		return t;
	}
});

dojo.dnd._createNode = function(tag){
	// summary: returns a function, which creates an element of given tag 
	//	(SPAN by default) and sets its innerHTML to given text
	// tag: String: a tag name or empty for SPAN
	if(!tag){ return dojo.dnd._createSpan; }
	return function(text){	// Function
		return dojo.create(tag, {innerHTML: text});	// Node
	};
};

dojo.dnd._createTrTd = function(text){
	// summary: creates a TR/TD structure with given text as an innerHTML of TD
	// text: String: a text for TD
	var tr = dojo.create("tr");
	dojo.create("td", {innerHTML: text}, tr);
	return tr;	// Node
};

dojo.dnd._createSpan = function(text){
	// summary: creates a SPAN element with given text as its innerHTML
	// text: String: a text for SPAN
	return dojo.create("span", {innerHTML: text});	// Node
};

// dojo.dnd._defaultCreatorNodes: Object: a dicitionary, which maps container tag names to child tag names
dojo.dnd._defaultCreatorNodes = {ul: "li", ol: "li", div: "div", p: "div"};

dojo.dnd._defaultCreator = function(node){
	// summary: takes a parent node, and returns an appropriate creator function
	// node: Node: a container node
	var tag = node.tagName.toLowerCase();
	var c = tag == "tbody" || tag == "thead" ? dojo.dnd._createTrTd :
			dojo.dnd._createNode(dojo.dnd._defaultCreatorNodes[tag]);
	return function(item, hint){	// Function
		var isObj = item && dojo.isObject(item), data, type, n;
		if(isObj && item.tagName && item.nodeType && item.getAttribute){
			// process a DOM node
			data = item.getAttribute("dndData") || item.innerHTML;
			type = item.getAttribute("dndType");
			type = type ? type.split(/\s*,\s*/) : ["text"];
			n = item;	// this node is going to be moved rather than copied
		}else{
			// process a DnD item object or a string
			data = (isObj && item.data) ? item.data : item;
			type = (isObj && item.type) ? item.type : ["text"];
			n = (hint == "avatar" ? dojo.dnd._createSpan : c)(String(data));
		}
		n.id = dojo.dnd.getUniqueId();
		return {node: n, data: data, type: type};
	};
};

}

if(!dojo._hasResource["dojo.dnd.Selector"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Selector"] = true;
dojo.provide("dojo.dnd.Selector");




/*
	Container item states:
		""			- an item is not selected
		"Selected"	- an item is selected
		"Anchor"	- an item is selected, and is an anchor for a "shift" selection
*/

dojo.declare("dojo.dnd.Selector", dojo.dnd.Container, {
	// summary: a Selector object, which knows how to select its children
	
	constructor: function(node, params){
		// summary: a constructor of the Selector
		// node: Node: node or node's id to build the selector on
		// params: Object: a dict of parameters, recognized parameters are:
		//	singular: Boolean
		//		allows selection of only one element, if true
		//		the rest of parameters are passed to the container
		//	autoSync: Boolean
		//		autosynchronizes the source with its list of DnD nodes,
		//		false by default
		if(!params){ params = {}; }
		this.singular = params.singular;
		this.autoSync = params.autoSync;
		// class-specific variables
		this.selection = {};
		this.anchor = null;
		this.simpleSelection = false;
		// set up events
		this.events.push(
			dojo.connect(this.node, "onmousedown", this, "onMouseDown"),
			dojo.connect(this.node, "onmouseup",   this, "onMouseUp"));
	},
	
	// object attributes (for markup)
	singular: false,	// is singular property
	
	// methods
	getSelectedNodes: function(){
		// summary: returns a list (an array) of selected nodes
		var t = new dojo.NodeList();
		var e = dojo.dnd._empty;
		for(var i in this.selection){
			if(i in e){ continue; }
			t.push(dojo.byId(i));
		}
		return t;	// Array
	},
	selectNone: function(){
		// summary: unselects all items
		return this._removeSelection()._removeAnchor();	// self
	},
	selectAll: function(){
		// summary: selects all items
		this.forInItems(function(data, id){
			this._addItemClass(dojo.byId(id), "Selected");
			this.selection[id] = 1;
		}, this);
		return this._removeAnchor();	// self
	},
	deleteSelectedNodes: function(){
		// summary: deletes all selected items
		var e = dojo.dnd._empty;
		for(var i in this.selection){
			if(i in e){ continue; }
			var n = dojo.byId(i);
			this.delItem(i);
			dojo.destroy(n);
		}
		this.anchor = null;
		this.selection = {};
		return this;	// self
	},
	forInSelectedItems: function(/*Function*/ f, /*Object?*/ o){
		// summary: iterates over selected items,
		// see dojo.dnd.Container.forInItems() for details
		o = o || dojo.global;
		var s = this.selection, e = dojo.dnd._empty;
		for(var i in s){
			if(i in e){ continue; }
			f.call(o, this.getItem(i), i, this);
		}
	},
	sync: function(){
		// summary: synch up the node list with the data map
		
		dojo.dnd.Selector.superclass.sync.call(this);
		
		// fix the anchor
		if(this.anchor){
			if(!this.getItem(this.anchor.id)){
				this.anchor = null;
			}
		}
		
		// fix the selection
		var t = [], e = dojo.dnd._empty;
		for(var i in this.selection){
			if(i in e){ continue; }
			if(!this.getItem(i)){
				t.push(i);
			}
		}
		dojo.forEach(t, function(i){
			delete this.selection[i];
		}, this);
		
		return this;	// self
	},
	insertNodes: function(addSelected, data, before, anchor){
		// summary: inserts new data items (see Container's insertNodes method for details)
		// addSelected: Boolean: all new nodes will be added to selected items, if true, no selection change otherwise
		// data: Array: a list of data items, which should be processed by the creator function
		// before: Boolean: insert before the anchor, if true, and after the anchor otherwise
		// anchor: Node: the anchor node to be used as a point of insertion
		var oldCreator = this._normalizedCreator;
		this._normalizedCreator = function(item, hint){
			var t = oldCreator.call(this, item, hint);
			if(addSelected){
				if(!this.anchor){
					this.anchor = t.node;
					this._removeItemClass(t.node, "Selected");
					this._addItemClass(this.anchor, "Anchor");
				}else if(this.anchor != t.node){
					this._removeItemClass(t.node, "Anchor");
					this._addItemClass(t.node, "Selected");
				}
				this.selection[t.node.id] = 1;
			}else{
				this._removeItemClass(t.node, "Selected");
				this._removeItemClass(t.node, "Anchor");
			}
			return t;
		};
		dojo.dnd.Selector.superclass.insertNodes.call(this, data, before, anchor);
		this._normalizedCreator = oldCreator;
		return this;	// self
	},
	destroy: function(){
		// summary: prepares the object to be garbage-collected
		dojo.dnd.Selector.superclass.destroy.call(this);
		this.selection = this.anchor = null;
	},

	// markup methods
	markupFactory: function(params, node){
		params._skipStartup = true;
		return new dojo.dnd.Selector(node, params);
	},

	// mouse events
	onMouseDown: function(e){
		// summary: event processor for onmousedown
		// e: Event: mouse event
		if(this.autoSync){ this.sync(); }
		if(!this.current){ return; }
		if(!this.singular && !dojo.dnd.getCopyKeyState(e) && !e.shiftKey && (this.current.id in this.selection)){
			this.simpleSelection = true;
			if(e.button === dojo.dnd._lmb){
				// accept the left button and stop the event
				// for IE we don't stop event when multiple buttons are pressed
				dojo.stopEvent(e);
			}
			return;
		}
		if(!this.singular && e.shiftKey){
			if(!dojo.dnd.getCopyKeyState(e)){
				this._removeSelection();
			}
			var c = this.getAllNodes();
			if(c.length){
				if(!this.anchor){
					this.anchor = c[0];
					this._addItemClass(this.anchor, "Anchor");
				}
				this.selection[this.anchor.id] = 1;
				if(this.anchor != this.current){
					var i = 0;
					for(; i < c.length; ++i){
						var node = c[i];
						if(node == this.anchor || node == this.current){ break; }
					}
					for(++i; i < c.length; ++i){
						var node = c[i];
						if(node == this.anchor || node == this.current){ break; }
						this._addItemClass(node, "Selected");
						this.selection[node.id] = 1;
					}
					this._addItemClass(this.current, "Selected");
					this.selection[this.current.id] = 1;
				}
			}
		}else{
			if(this.singular){
				if(this.anchor == this.current){
					if(dojo.dnd.getCopyKeyState(e)){
						this.selectNone();
					}
				}else{
					this.selectNone();
					this.anchor = this.current;
					this._addItemClass(this.anchor, "Anchor");
					this.selection[this.current.id] = 1;
				}
			}else{
				if(dojo.dnd.getCopyKeyState(e)){
					if(this.anchor == this.current){
						delete this.selection[this.anchor.id];
						this._removeAnchor();
					}else{
						if(this.current.id in this.selection){
							this._removeItemClass(this.current, "Selected");
							delete this.selection[this.current.id];
						}else{
							if(this.anchor){
								this._removeItemClass(this.anchor, "Anchor");
								this._addItemClass(this.anchor, "Selected");
							}
							this.anchor = this.current;
							this._addItemClass(this.current, "Anchor");
							this.selection[this.current.id] = 1;
						}
					}
				}else{
					if(!(this.current.id in this.selection)){
						this.selectNone();
						this.anchor = this.current;
						this._addItemClass(this.current, "Anchor");
						this.selection[this.current.id] = 1;
					}
				}
			}
		}
		dojo.stopEvent(e);
	},
	onMouseUp: function(e){
		// summary: event processor for onmouseup
		// e: Event: mouse event
		if(!this.simpleSelection){ return; }
		this.simpleSelection = false;
		this.selectNone();
		if(this.current){
			this.anchor = this.current;
			this._addItemClass(this.anchor, "Anchor");
			this.selection[this.current.id] = 1;
		}
	},
	onMouseMove: function(e){
		// summary: event processor for onmousemove
		// e: Event: mouse event
		this.simpleSelection = false;
	},
	
	// utilities
	onOverEvent: function(){
		// summary: this function is called once, when mouse is over our container
		this.onmousemoveEvent = dojo.connect(this.node, "onmousemove", this, "onMouseMove");
	},
	onOutEvent: function(){
		// summary: this function is called once, when mouse is out of our container
		dojo.disconnect(this.onmousemoveEvent);
		delete this.onmousemoveEvent;
	},
	_removeSelection: function(){
		// summary: unselects all items
		var e = dojo.dnd._empty;
		for(var i in this.selection){
			if(i in e){ continue; }
			var node = dojo.byId(i);
			if(node){ this._removeItemClass(node, "Selected"); }
		}
		this.selection = {};
		return this;	// self
	},
	_removeAnchor: function(){
		if(this.anchor){
			this._removeItemClass(this.anchor, "Anchor");
			this.anchor = null;
		}
		return this;	// self
	}
});

}

if(!dojo._hasResource["dojo.dnd.autoscroll"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.autoscroll"] = true;
dojo.provide("dojo.dnd.autoscroll");

dojo.dnd.getViewport = function(){
	// summary: returns a viewport size (visible part of the window)

	// FIXME: need more docs!!
	var d = dojo.doc, dd = d.documentElement, w = window, b = dojo.body();
	if(dojo.isMozilla){
		return {w: dd.clientWidth, h: w.innerHeight};	// Object
	}else if(!dojo.isOpera && w.innerWidth){
		return {w: w.innerWidth, h: w.innerHeight};		// Object
	}else if (!dojo.isOpera && dd && dd.clientWidth){
		return {w: dd.clientWidth, h: dd.clientHeight};	// Object
	}else if (b.clientWidth){
		return {w: b.clientWidth, h: b.clientHeight};	// Object
	}
	return null;	// Object
};

dojo.dnd.V_TRIGGER_AUTOSCROLL = 32;
dojo.dnd.H_TRIGGER_AUTOSCROLL = 32;

dojo.dnd.V_AUTOSCROLL_VALUE = 16;
dojo.dnd.H_AUTOSCROLL_VALUE = 16;

dojo.dnd.autoScroll = function(e){
	// summary:
	//		a handler for onmousemove event, which scrolls the window, if
	//		necesary
	// e: Event:
	//		onmousemove event

	// FIXME: needs more docs!
	var v = dojo.dnd.getViewport(), dx = 0, dy = 0;
	if(e.clientX < dojo.dnd.H_TRIGGER_AUTOSCROLL){
		dx = -dojo.dnd.H_AUTOSCROLL_VALUE;
	}else if(e.clientX > v.w - dojo.dnd.H_TRIGGER_AUTOSCROLL){
		dx = dojo.dnd.H_AUTOSCROLL_VALUE;
	}
	if(e.clientY < dojo.dnd.V_TRIGGER_AUTOSCROLL){
		dy = -dojo.dnd.V_AUTOSCROLL_VALUE;
	}else if(e.clientY > v.h - dojo.dnd.V_TRIGGER_AUTOSCROLL){
		dy = dojo.dnd.V_AUTOSCROLL_VALUE;
	}
	window.scrollBy(dx, dy);
};

dojo.dnd._validNodes = {"div": 1, "p": 1, "td": 1};
dojo.dnd._validOverflow = {"auto": 1, "scroll": 1};

dojo.dnd.autoScrollNodes = function(e){
	// summary:
	//		a handler for onmousemove event, which scrolls the first avaialble
	//		Dom element, it falls back to dojo.dnd.autoScroll()
	// e: Event:
	//		onmousemove event

	// FIXME: needs more docs!
	for(var n = e.target; n;){
		if(n.nodeType == 1 && (n.tagName.toLowerCase() in dojo.dnd._validNodes)){
			var s = dojo.getComputedStyle(n);
			if(s.overflow.toLowerCase() in dojo.dnd._validOverflow){
				var b = dojo._getContentBox(n, s), t = dojo._abs(n, true);
				//console.log(b.l, b.t, t.x, t.y, n.scrollLeft, n.scrollTop);
				var w = Math.min(dojo.dnd.H_TRIGGER_AUTOSCROLL, b.w / 2), 
					h = Math.min(dojo.dnd.V_TRIGGER_AUTOSCROLL, b.h / 2),
					rx = e.pageX - t.x, ry = e.pageY - t.y, dx = 0, dy = 0;
				if(dojo.isWebKit || dojo.isOpera){
					// FIXME: this code should not be here, it should be taken into account 
					// either by the event fixing code, or the dojo._abs()
					// FIXME: this code doesn't work on Opera 9.5 Beta
					rx += dojo.body().scrollLeft, ry += dojo.body().scrollTop;
				}
				if(rx > 0 && rx < b.w){
					if(rx < w){
						dx = -w;
					}else if(rx > b.w - w){
						dx = w;
					}
				}
				//console.log("ry =", ry, "b.h =", b.h, "h =", h);
				if(ry > 0 && ry < b.h){
					if(ry < h){
						dy = -h;
					}else if(ry > b.h - h){
						dy = h;
					}
				}
				var oldLeft = n.scrollLeft, oldTop = n.scrollTop;
				n.scrollLeft = n.scrollLeft + dx;
				n.scrollTop  = n.scrollTop  + dy;
				if(oldLeft != n.scrollLeft || oldTop != n.scrollTop){ return; }
			}
		}
		try{
			n = n.parentNode;
		}catch(x){
			n = null;
		}
	}
	dojo.dnd.autoScroll(e);
};

}

if(!dojo._hasResource["dojo.dnd.Avatar"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Avatar"] = true;
dojo.provide("dojo.dnd.Avatar");



dojo.declare("dojo.dnd.Avatar", null, {
	// summary: an object, which represents transferred DnD items visually
	// manager: Object: a DnD manager object

	constructor: function(manager){
		this.manager = manager;
		this.construct();
	},

	// methods
	construct: function(){
		// summary: a constructor function;
		//	it is separate so it can be (dynamically) overwritten in case of need
		this.isA11y = dojo.hasClass(dojo.body(),"dijit_a11y");
		var a = dojo.create("table", {
				"class": "dojoDndAvatar",
				style: {
					position: "absolute",
					zIndex:   "1999",
					margin:   "0px"
				}
			}),
			source = this.manager.source, node,
			b = dojo.create("tbody", null, a),
			tr = dojo.create("tr", null, b),
			td = dojo.create("td", null, tr),
			icon = this.isA11y ? dojo.create("span", {
						id : "a11yIcon",
						innerHTML : this.manager.copy ? '+' : "<"
					}, td) : null,
			span = dojo.create("span", {
				innerHTML: source.generateText ? this._generateText() : ""
			}, td),
			k = Math.min(5, this.manager.nodes.length), i = 0;
		// we have to set the opacity on IE only after the node is live
		dojo.attr(tr, {
			"class": "dojoDndAvatarHeader",
			style: {opacity: 0.9}
		});
		for(; i < k; ++i){
			if(source.creator){
				// create an avatar representation of the node
				node = source._normalizedCreator(source.getItem(this.manager.nodes[i].id).data, "avatar").node;
			}else{
				// or just clone the node and hope it works
				node = this.manager.nodes[i].cloneNode(true);
				if(node.tagName.toLowerCase() == "tr"){
					// insert extra table nodes
					var table = dojo.create("table"),
						tbody = dojo.create("tbody", null, table);
					tbody.appendChild(node);
					node = table;
				}
			}
			node.id = "";
			tr = dojo.create("tr", null, b);
			td = dojo.create("td", null, tr);
			td.appendChild(node);
			dojo.attr(tr, {
				"class": "dojoDndAvatarItem",
				style: {opacity: (9 - i) / 10}
			});
		}
		this.node = a;
	},
	destroy: function(){
		// summary: a desctructor for the avatar, called to remove all references so it can be garbage-collected
		dojo.destroy(this.node);
		this.node = false;
	},
	update: function(){
		// summary: updates the avatar to reflect the current DnD state
		dojo[(this.manager.canDropFlag ? "add" : "remove") + "Class"](this.node, "dojoDndAvatarCanDrop");
		if (this.isA11y){
			var icon = dojo.byId("a11yIcon");
			var text = '+';   // assume canDrop && copy
			if (this.manager.canDropFlag && !this.manager.copy) {
				text = '< '; // canDrop && move 
			}else if (!this.manager.canDropFlag && !this.manager.copy) {
				text = "o"; //!canDrop && move
			}else if(!this.manager.canDropFlag){
				text = 'x';  // !canDrop && copy
			}
			icon.innerHTML=text;
		}
		// replace text
		dojo.query(("tr.dojoDndAvatarHeader td span" +(this.isA11y ? " span" : "")), this.node).forEach(
			function(node){
				node.innerHTML = this._generateText();
			}, this);
	},
	_generateText: function(){
		// summary: generates a proper text to reflect copying or moving of items
		return this.manager.nodes.length.toString();
	}
});

}

if(!dojo._hasResource["dojo.dnd.Manager"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Manager"] = true;
dojo.provide("dojo.dnd.Manager");





dojo.declare("dojo.dnd.Manager", null, {
	// summary: the manager of DnD operations (usually a singleton)
	constructor: function(){
		this.avatar  = null;
		this.source = null;
		this.nodes = [];
		this.copy  = true;
		this.target = null;
		this.canDropFlag = false;
		this.events = [];
	},

	// avatar's offset from the mouse
	OFFSET_X: 16,
	OFFSET_Y: 16,
	
	// methods
	overSource: function(source){
		// summary: called when a source detected a mouse-over conditiion
		// source: Object: the reporter
		if(this.avatar){
			this.target = (source && source.targetState != "Disabled") ? source : null;
			this.canDropFlag = Boolean(this.target);
			this.avatar.update();
		}
		dojo.publish("/dnd/source/over", [source]);
	},
	outSource: function(source){
		// summary: called when a source detected a mouse-out conditiion
		// source: Object: the reporter
		if(this.avatar){
			if(this.target == source){
				this.target = null;
				this.canDropFlag = false;
				this.avatar.update();
				dojo.publish("/dnd/source/over", [null]);
			}
		}else{
			dojo.publish("/dnd/source/over", [null]);
		}
	},
	startDrag: function(source, nodes, copy){
		// summary: called to initiate the DnD operation
		// source: Object: the source which provides items
		// nodes: Array: the list of transferred items
		// copy: Boolean: copy items, if true, move items otherwise
		this.source = source;
		this.nodes  = nodes;
		this.copy   = Boolean(copy); // normalizing to true boolean
		this.avatar = this.makeAvatar();
		dojo.body().appendChild(this.avatar.node);
		dojo.publish("/dnd/start", [source, nodes, this.copy]);
		this.events = [
			dojo.connect(dojo.doc, "onmousemove", this, "onMouseMove"),
			dojo.connect(dojo.doc, "onmouseup",   this, "onMouseUp"),
			dojo.connect(dojo.doc, "onkeydown",   this, "onKeyDown"),
			dojo.connect(dojo.doc, "onkeyup",     this, "onKeyUp"),
			// cancel text selection and text dragging
			dojo.connect(dojo.doc, "ondragstart",   dojo.stopEvent),
			dojo.connect(dojo.body(), "onselectstart", dojo.stopEvent)
		];
		var c = "dojoDnd" + (copy ? "Copy" : "Move");
		dojo.addClass(dojo.body(), c); 
	},
	canDrop: function(flag){
		// summary: called to notify if the current target can accept items
		var canDropFlag = Boolean(this.target && flag);
		if(this.canDropFlag != canDropFlag){
			this.canDropFlag = canDropFlag;
			this.avatar.update();
		}
	},
	stopDrag: function(){
		// summary: stop the DnD in progress
		dojo.removeClass(dojo.body(), "dojoDndCopy");
		dojo.removeClass(dojo.body(), "dojoDndMove");
		dojo.forEach(this.events, dojo.disconnect);
		this.events = [];
		this.avatar.destroy();
		this.avatar = null;
		this.source = this.target = null;
		this.nodes = [];
	},
	makeAvatar: function(){
		// summary: makes the avatar, it is separate to be overwritten dynamically, if needed
		return new dojo.dnd.Avatar(this);
	},
	updateAvatar: function(){
		// summary: updates the avatar, it is separate to be overwritten dynamically, if needed
		this.avatar.update();
	},
	
	// mouse event processors
	onMouseMove: function(e){
		// summary: event processor for onmousemove
		// e: Event: mouse event
		var a = this.avatar;
		if(a){
			dojo.dnd.autoScrollNodes(e);
			//dojo.dnd.autoScroll(e);
			var s = a.node.style;
			s.left = (e.pageX + this.OFFSET_X) + "px";
			s.top  = (e.pageY + this.OFFSET_Y) + "px";
			var copy = Boolean(this.source.copyState(dojo.dnd.getCopyKeyState(e)));
			if(this.copy != copy){ 
				this._setCopyStatus(copy);
			}
		}
	},
	onMouseUp: function(e){
		// summary: event processor for onmouseup
		// e: Event: mouse event
		if(this.avatar){
			if(this.target && this.canDropFlag){
				var copy = Boolean(this.source.copyState(dojo.dnd.getCopyKeyState(e))),
				params = [this.source, this.nodes, copy, this.target];
				dojo.publish("/dnd/drop/before", params);
				dojo.publish("/dnd/drop", params);
			}else{
				dojo.publish("/dnd/cancel");
			}
			this.stopDrag();
		}
	},
	
	// keyboard event processors
	onKeyDown: function(e){
		// summary: event processor for onkeydown:
		//	watching for CTRL for copy/move status, watching for ESCAPE to cancel the drag
		// e: Event: keyboard event
		if(this.avatar){
			switch(e.keyCode){
				case dojo.keys.CTRL:
					var copy = Boolean(this.source.copyState(true));
					if(this.copy != copy){ 
						this._setCopyStatus(copy);
					}
					break;
				case dojo.keys.ESCAPE:
					dojo.publish("/dnd/cancel");
					this.stopDrag();
					break;
			}
		}
	},
	onKeyUp: function(e){
		// summary: event processor for onkeyup, watching for CTRL for copy/move status
		// e: Event: keyboard event
		if(this.avatar && e.keyCode == dojo.keys.CTRL){
			var copy = Boolean(this.source.copyState(false));
			if(this.copy != copy){ 
				this._setCopyStatus(copy);
			}
		}
	},
	
	// utilities
	_setCopyStatus: function(copy){
		// summary: changes the copy status
		// copy: Boolean: the copy status
		this.copy = copy;
		this.source._markDndStatus(this.copy);
		this.updateAvatar();
		dojo.removeClass(dojo.body(), "dojoDnd" + (this.copy ? "Move" : "Copy"));
		dojo.addClass(dojo.body(), "dojoDnd" + (this.copy ? "Copy" : "Move"));
	}
});

// summary: the manager singleton variable, can be overwritten, if needed
dojo.dnd._manager = null;

dojo.dnd.manager = function(){
	// summary: returns the current DnD manager, creates one if it is not created yet
	if(!dojo.dnd._manager){
		dojo.dnd._manager = new dojo.dnd.Manager();
	}
	return dojo.dnd._manager;	// Object
};

}

if(!dojo._hasResource["dojo.dnd.Source"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Source"] = true;
dojo.provide("dojo.dnd.Source");




/*
	Container property:
		"Horizontal"- if this is the horizontal container
	Source states:
		""			- normal state
		"Moved"		- this source is being moved
		"Copied"	- this source is being copied
	Target states:
		""			- normal state
		"Disabled"	- the target cannot accept an avatar
	Target anchor state:
		""			- item is not selected
		"Before"	- insert point is before the anchor
		"After"		- insert point is after the anchor
*/

/*=====
dojo.dnd.__SourceArgs = function(){
	//	summary:
	//		a dict of parameters for DnD Source configuration. Note that any
	//		property on Source elements may be configured, but this is the
	//		short-list
	//	isSource: Boolean?
	//		can be used as a DnD source. Defaults to true.
	//	accept: Array?
	//		list of accepted types (text strings) for a target; defaults to
	//		["text"]
	//	autoSync: Boolean
	//		if true refreshes the node list on every operation; false by default
	//	copyOnly: Boolean?
	//		copy items, if true, use a state of Ctrl key otherwise,
	//		see selfCopy and selfAccept for more details
	//	delay: Number
	//		the move delay in pixels before detecting a drag; 0 by default
	//	horizontal: Boolean?
	//		a horizontal container, if true, vertical otherwise or when omitted
	//	selfCopy: Boolean?
	//		copy items by default when dropping on itself,
	//		false by default, works only if copyOnly is true
	//	selfAccept: Boolean?
	//		accept its own items when copyOnly is true,
	//		true by default, works only if copyOnly is true
	//	withHandles: Boolean?
	//		allows dragging only by handles, false by default
	//  generateText: Boolean?
	//		generate text node for drag and drop, true by default
	this.isSource = isSource;
	this.accept = accept;
	this.autoSync = autoSync;
	this.copyOnly = copyOnly;
	this.delay = delay;
	this.horizontal = horizontal;
	this.selfCopy = selfCopy;
	this.selfAccept = selfAccept;
	this.withHandles = withHandles;
	this.genertateText = true;
}
=====*/

dojo.declare("dojo.dnd.Source", dojo.dnd.Selector, {
	// summary: a Source object, which can be used as a DnD source, or a DnD target
	
	// object attributes (for markup)
	isSource: true,
	horizontal: false,
	copyOnly: false,
	selfCopy: false,
	selfAccept: true,
	skipForm: false,
	withHandles: false,
	autoSync: false,
	delay: 0, // pixels
	accept: ["text"],
	generateText: true,
	
	constructor: function(/*DOMNode|String*/node, /*dojo.dnd.__SourceArgs?*/params){
		// summary: 
		//		a constructor of the Source
		// node:
		//		node or node's id to build the source on
		// params: 
		//		any property of this class may be configured via the params
		//		object which is mixed-in to the `dojo.dnd.Source` instance
		dojo.mixin(this, dojo.mixin({}, params));
		var type = this.accept;
		if(type.length){
			this.accept = {};
			for(var i = 0; i < type.length; ++i){
				this.accept[type[i]] = 1;
			}
		}
		// class-specific variables
		this.isDragging = false;
		this.mouseDown = false;
		this.targetAnchor = null;
		this.targetBox = null;
		this.before = true;
		this._lastX = 0;
		this._lastY = 0;
		// states
		this.sourceState  = "";
		if(this.isSource){
			dojo.addClass(this.node, "dojoDndSource");
		}
		this.targetState  = "";
		if(this.accept){
			dojo.addClass(this.node, "dojoDndTarget");
		}
		if(this.horizontal){
			dojo.addClass(this.node, "dojoDndHorizontal");
		}
		// set up events
		this.topics = [
			dojo.subscribe("/dnd/source/over", this, "onDndSourceOver"),
			dojo.subscribe("/dnd/start",  this, "onDndStart"),
			dojo.subscribe("/dnd/drop",   this, "onDndDrop"),
			dojo.subscribe("/dnd/cancel", this, "onDndCancel")
		];
	},
	
	// methods
	checkAcceptance: function(source, nodes){
		// summary: checks, if the target can accept nodes from this source
		// source: Object: the source which provides items
		// nodes: Array: the list of transferred items
		if(this == source){
			return !this.copyOnly || this.selfAccept;
		}
		for(var i = 0; i < nodes.length; ++i){
			var type = source.getItem(nodes[i].id).type;
			// type instanceof Array
			var flag = false;
			for(var j = 0; j < type.length; ++j){
				if(type[j] in this.accept){
					flag = true;
					break;
				}
			}
			if(!flag){
				return false;	// Boolean
			}
		}
		return true;	// Boolean
	},
	copyState: function(keyPressed, self){
		// summary: Returns true, if we need to copy items, false to move.
		//		It is separated to be overwritten dynamically, if needed.
		// keyPressed: Boolean: the "copy" was pressed
		// self: Boolean?: optional flag, which means that we are about to drop on itself
		
		if(keyPressed){ return true; }
		if(arguments.length < 2){
			self = this == dojo.dnd.manager().target;
		}
		if(self){
			if(this.copyOnly){
				return this.selfCopy;
			}
		}else{
			return this.copyOnly;
		}
		return false;	// Boolean
	},
	destroy: function(){
		// summary: prepares the object to be garbage-collected
		dojo.dnd.Source.superclass.destroy.call(this);
		dojo.forEach(this.topics, dojo.unsubscribe);
		this.targetAnchor = null;
	},

	// markup methods
	markupFactory: function(params, node){
		params._skipStartup = true;
		return new dojo.dnd.Source(node, params);
	},

	// mouse event processors
	onMouseMove: function(e){
		// summary: event processor for onmousemove
		// e: Event: mouse event
		if(this.isDragging && this.targetState == "Disabled"){ return; }
		dojo.dnd.Source.superclass.onMouseMove.call(this, e);
		var m = dojo.dnd.manager();
		if(this.isDragging){
			// calculate before/after
			var before = false;
			if(this.current){
				if(!this.targetBox || this.targetAnchor != this.current){
					this.targetBox = {
						xy: dojo.coords(this.current, true),
						w: this.current.offsetWidth,
						h: this.current.offsetHeight
					};
				}
				if(this.horizontal){
					before = (e.pageX - this.targetBox.xy.x) < (this.targetBox.w / 2);
				}else{
					before = (e.pageY - this.targetBox.xy.y) < (this.targetBox.h / 2);
				}
			}
			if(this.current != this.targetAnchor || before != this.before){
				this._markTargetAnchor(before);
				m.canDrop(!this.current || m.source != this || !(this.current.id in this.selection));
			}
		}else{
			if(this.mouseDown && this.isSource &&
					(Math.abs(e.pageX - this._lastX) > this.delay || Math.abs(e.pageY - this._lastY) > this.delay)){
				var nodes = this.getSelectedNodes();
				if(nodes.length){
					m.startDrag(this, nodes, this.copyState(dojo.dnd.getCopyKeyState(e), true));
				}
			}
		}
	},
	onMouseDown: function(e){
		// summary: event processor for onmousedown
		// e: Event: mouse event
		if(!this.mouseDown && this._legalMouseDown(e) && (!this.skipForm || !dojo.dnd.isFormElement(e))){
			this.mouseDown = true;
			this._lastX = e.pageX;
			this._lastY = e.pageY;
			dojo.dnd.Source.superclass.onMouseDown.call(this, e);
		}
	},
	onMouseUp: function(e){
		// summary: event processor for onmouseup
		// e: Event: mouse event
		if(this.mouseDown){
			this.mouseDown = false;
			dojo.dnd.Source.superclass.onMouseUp.call(this, e);
		}
	},
	
	// topic event processors
	onDndSourceOver: function(source){
		// summary: topic event processor for /dnd/source/over, called when detected a current source
		// source: Object: the source which has the mouse over it
		if(this != source){
			this.mouseDown = false;
			if(this.targetAnchor){
				this._unmarkTargetAnchor();
			}
		}else if(this.isDragging){
			var m = dojo.dnd.manager();
			m.canDrop(this.targetState != "Disabled" && (!this.current || m.source != this || !(this.current.id in this.selection)));
		}
	},
	onDndStart: function(source, nodes, copy){
		// summary: topic event processor for /dnd/start, called to initiate the DnD operation
		// source: Object: the source which provides items
		// nodes: Array: the list of transferred items
		// copy: Boolean: copy items, if true, move items otherwise
		if(this.autoSync){ this.sync(); }
		if(this.isSource){
			this._changeState("Source", this == source ? (copy ? "Copied" : "Moved") : "");
		}
		var accepted = this.accept && this.checkAcceptance(source, nodes);
		this._changeState("Target", accepted ? "" : "Disabled");
		if(this == source){
			dojo.dnd.manager().overSource(this);
		}
		this.isDragging = true;
	},
	onDndDrop: function(source, nodes, copy, target){
		// summary: topic event processor for /dnd/drop, called to finish the DnD operation
		// source: Object: the source which provides items
		// nodes: Array: the list of transferred items
		// copy: Boolean: copy items, if true, move items otherwise
		// target: Object: the target which accepts items
		if(this == target){
			// this one is for us => move nodes!
			this.onDrop(source, nodes, copy);
		}
		this.onDndCancel();
	},
	onDndCancel: function(){
		// summary: topic event processor for /dnd/cancel, called to cancel the DnD operation
		if(this.targetAnchor){
			this._unmarkTargetAnchor();
			this.targetAnchor = null;
		}
		this.before = true;
		this.isDragging = false;
		this.mouseDown = false;
		this._changeState("Source", "");
		this._changeState("Target", "");
	},
	
	// local events
	onDrop: function(source, nodes, copy){
		// summary: called only on the current target, when drop is performed
		// source: Object: the source which provides items
		// nodes: Array: the list of transferred items
		// copy: Boolean: copy items, if true, move items otherwise
		
		if(this != source){
			this.onDropExternal(source, nodes, copy);
		}else{
			this.onDropInternal(nodes, copy);
		}
	},
	onDropExternal: function(source, nodes, copy){
		// summary: called only on the current target, when drop is performed
		//	from an external source
		// source: Object: the source which provides items
		// nodes: Array: the list of transferred items
		// copy: Boolean: copy items, if true, move items otherwise
		
		var oldCreator = this._normalizedCreator;
		// transferring nodes from the source to the target
		if(this.creator){
			// use defined creator
			this._normalizedCreator = function(node, hint){
				return oldCreator.call(this, source.getItem(node.id).data, hint);
			};
		}else{
			// we have no creator defined => move/clone nodes
			if(copy){
				// clone nodes
				this._normalizedCreator = function(node, hint){
					var t = source.getItem(node.id);
					var n = node.cloneNode(true);
					n.id = dojo.dnd.getUniqueId();
					return {node: n, data: t.data, type: t.type};
				};
			}else{
				// move nodes
				this._normalizedCreator = function(node, hint){
					var t = source.getItem(node.id);
					source.delItem(node.id);
					return {node: node, data: t.data, type: t.type};
				};
			}
		}
		this.selectNone();
		if(!copy && !this.creator){
			source.selectNone();
		}
		this.insertNodes(true, nodes, this.before, this.current);
		if(!copy && this.creator){
			source.deleteSelectedNodes();
		}
		this._normalizedCreator = oldCreator;
	},
	onDropInternal: function(nodes, copy){
		// summary: called only on the current target, when drop is performed
		//	from the same target/source
		// nodes: Array: the list of transferred items
		// copy: Boolean: copy items, if true, move items otherwise
		
		var oldCreator = this._normalizedCreator;
		// transferring nodes within the single source
		if(this.current && this.current.id in this.selection){
			// do nothing
			return;
		}
		if(copy){
			if(this.creator){
				// create new copies of data items
				this._normalizedCreator = function(node, hint){
					return oldCreator.call(this, this.getItem(node.id).data, hint);
				};
			}else{
				// clone nodes
				this._normalizedCreator = function(node, hint){
					var t = this.getItem(node.id);
					var n = node.cloneNode(true);
					n.id = dojo.dnd.getUniqueId();
					return {node: n, data: t.data, type: t.type};
				};
			}
		}else{
			// move nodes
			if(!this.current){
				// do nothing
				return;
			}
			this._normalizedCreator = function(node, hint){
				var t = this.getItem(node.id);
				return {node: node, data: t.data, type: t.type};
			};
		}
		this._removeSelection();
		this.insertNodes(true, nodes, this.before, this.current);
		this._normalizedCreator = oldCreator;
	},
	onDraggingOver: function(){
		// summary: called during the active DnD operation, when items
		// are dragged over this target, and it is not disabled
	},
	onDraggingOut: function(){
		// summary: called during the active DnD operation, when items
		// are dragged away from this target, and it is not disabled
	},
	
	// utilities
	onOverEvent: function(){
		// summary: this function is called once, when mouse is over our container
		dojo.dnd.Source.superclass.onOverEvent.call(this);
		dojo.dnd.manager().overSource(this);
		if(this.isDragging && this.targetState != "Disabled"){
			this.onDraggingOver();
		}
	},
	onOutEvent: function(){
		// summary: this function is called once, when mouse is out of our container
		dojo.dnd.Source.superclass.onOutEvent.call(this);
		dojo.dnd.manager().outSource(this);
		if(this.isDragging && this.targetState != "Disabled"){
			this.onDraggingOut();
		}
	},
	_markTargetAnchor: function(before){
		// summary: assigns a class to the current target anchor based on "before" status
		// before: Boolean: insert before, if true, after otherwise
		if(this.current == this.targetAnchor && this.before == before){ return; }
		if(this.targetAnchor){
			this._removeItemClass(this.targetAnchor, this.before ? "Before" : "After");
		}
		this.targetAnchor = this.current;
		this.targetBox = null;
		this.before = before;
		if(this.targetAnchor){
			this._addItemClass(this.targetAnchor, this.before ? "Before" : "After");
		}
	},
	_unmarkTargetAnchor: function(){
		// summary: removes a class of the current target anchor based on "before" status
		if(!this.targetAnchor){ return; }
		this._removeItemClass(this.targetAnchor, this.before ? "Before" : "After");
		this.targetAnchor = null;
		this.targetBox = null;
		this.before = true;
	},
	_markDndStatus: function(copy){
		// summary: changes source's state based on "copy" status
		this._changeState("Source", copy ? "Copied" : "Moved");
	},
	_legalMouseDown: function(e){
		// summary: checks if user clicked on "approved" items
		// e: Event: mouse event
		
		// accept only the left mouse button
		if(!dojo.dnd._isLmbPressed(e)){ return false; }
		
		if(!this.withHandles){ return true; }
		
		// check for handles
		for(var node = e.target; node && node !== this.node; node = node.parentNode){
			if(dojo.hasClass(node, "dojoDndHandle")){ return true; }
			if(dojo.hasClass(node, "dojoDndItem")){ break; }
		}
		return false;	// Boolean
	}
});

dojo.declare("dojo.dnd.Target", dojo.dnd.Source, {
	// summary: a Target object, which can be used as a DnD target
	
	constructor: function(node, params){
		// summary: a constructor of the Target --- see the Source constructor for details
		this.isSource = false;
		dojo.removeClass(this.node, "dojoDndSource");
	},

	// markup methods
	markupFactory: function(params, node){
		params._skipStartup = true;
		return new dojo.dnd.Target(node, params);
	}
});

dojo.declare("dojo.dnd.AutoSource", dojo.dnd.Source, {
	// summary: a source, which syncs its DnD nodes by default
	
	constructor: function(node, params){
		// summary: a constructor of the AutoSource --- see the Source constructor for details
		this.autoSync = true;
	},

	// markup methods
	markupFactory: function(params, node){
		params._skipStartup = true;
		return new dojo.dnd.AutoSource(node, params);
	}
});

}

if(!dojo._hasResource["com.ibm.dnd.CustomManagerSource"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.dnd.CustomManagerSource"] = true;
dojo.provide("com.ibm.dnd.CustomManagerSource");



dojo.declare("com.ibm.dnd.CustomManagerMixin",
	null,
	{
		// summary: An extension of the dojo.dnd.Source base module which provides 
		//		automatic declarative support for overriding properties on the dnd
		//		manager dynamically when a drag operation originates from this source.
		//		All properties that are overriden are reset back to their original
		//		values once the drag operation ends, regardless of the target or
		//		the outcome.  Customizing the dnd manager from a dnd Source is easily
		//		done by extending this module and overriding the managerOverrides
		//		map in the extension.
		
		// managerOverrides: Object
		//		Map of properties to override in the dojo.dnd.Manager instance returned
		//		by dojo.dnd.manager() when onMouseDown occurs in this dnd Source.
		//		The properties defined here will override the same properties in the
		//		dnd manager, and then reset back to what they were before after the
		//		drag operation ends.
		managerOverrides: {},
		
		_partialMixin: function(tgt, src, map) {
			// summary: Performs a partial, simple mixin from the src to the tgt as defined
			// 		by the map.  For each property defined in map, it sets the value of 
			// 		that property in tgt to the value of that same property in src.
			for(var p in map) {
				tgt[p] = src[p];
			}
			return tgt;
		},
		
		_changeManager: function() {
			// only fix once
			if(!this._mgr) {
				this.mgrProps = {};
				this._mgr = dojo.dnd.manager();
				this._partialMixin(this.mgrProps, this._mgr, this.managerOverrides);
				dojo.mixin(this._mgr, this.managerOverrides);
				this._mgrFixConn = dojo.connect(dojo.doc, "onmouseup", this, "_fixManager");
			}
		},
		_fixManager: function() {
			if(this._mgrFixConn) {
				dojo.disconnect(this._mgrFixConn);
				this._mgrFixConn = null;
			}
			if(this._mgr) {
				dojo.mixin(this._mgr, this.mgrProps);
				this.mgrProps = {};
			}
			// reset
			this._mgr = null;
		},
		onMouseDown: function(e){
			// summary: Plugin to change the dojo.dnd manager instance using the dynamic
			//		hot replace/fix paradigm.
			this._changeManager();
			this.inherited(arguments);
		},
		destroy: function() {
			// safety if for some reason we get destroyed before fixing the manager
			if(this._mgrFixConn) dojo.disconnect(this._mgrFixConn);
			this._mgrFixConn = null;
			this.inherited(arguments);
		}
	}
);

dojo.declare("com.ibm.dnd.CustomManagerSource",
	[dojo.dnd.Source, com.ibm.dnd.CustomManagerMixin],
	{
		
		
	}
);

dojo.declare("com.ibm.dnd.CustomManagerAutoSource",
	[dojo.dnd.AutoSource, com.ibm.dnd.CustomManagerMixin],
	{
		
		
	}
);

}

if(!dojo._hasResource["com.ibm.dnd.PageAvatar"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.dnd.PageAvatar"] = true;
dojo.provide("com.ibm.dnd.PageAvatar");

dojo.declare("com.ibm.dnd.PageAvatar", dojo.dnd.Avatar, {
	construct: function(){
		// summary: constructs the avatar for page tabs, 
		//          opacity for the avatar is applied by the 
		//          class assigned during creator
		var div = dojo.doc.createElement("div");
		div.style.position = "absolute";
		div.style.zIndex = 1999;
		div.style.margin = "0px";
		var source = this.manager.source, node;
		// create an avatar representation of the node
		// Portal only allows 1 page tab to be dragged, 
		// so it is known to use the first item in the array
		node = source._normalizedCreator(source.getItem(this.manager.nodes[0].id).data, "avatar").node;
		node.id = "";
		div.appendChild(node);
		this.node = div;
	}
});

}

if(!dojo._hasResource["com.ibm.dnd.ModeledSource"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.dnd.ModeledSource"] = true;
dojo.provide("com.ibm.dnd.ModeledSource");

/*
 * A ModeledSource is a dnd Source which provides dnd operational support to a modeled widget.
 * Can be extended to provide different drop actions, as well as drop zones, depending on the
 * type of data being dragged around.  
 * Examples:
 * 	1) Dragging items of the same type around simply creates drop zones around other objects 
 * 		in a heirarchy or list.  Dropping them reorders those items in the modeled heirarchy.
 *  2) Dragging items of different types onto other items creates drop zones on top of the
 * 		items themselves, representing actions where a certain type of data is applied to a
 * 		different type of data.
 */




dojo.declare("com.ibm.dnd.ModeledSource",
	com.ibm.dnd.CustomManagerSource,
	{
		managerOverrides: {
			OFFSET_X: 1,
			OFFSET_Y: 1,
			makeAvatar: function(){
				return new com.ibm.dnd.PageAvatar(this);
			}
		},
		model: null,
		item: null,
		isBidi: false,
		constructor: function(/*DOMNode|String*/node, /*dojo.dnd.__SourceArgs?*/params) {
			if(this.withHandles) {
				dojo.addClass(node, "dndHasHandles");
			}
			if(typeof(ibmPortalConfig) != "undefined") this.isBidi = ibmPortalConfig.isRTL;
			else if(typeof(ibmConfig) != "undefined") this.isBidi = ibmConfig.isBidi;
		},
		onDrop: function(source, nodes, copy) {
			// summary: Called when a drop action occurs in this container
			var targetWidget = dijit.getEnclosingWidget(this.current),
			nextSibling = null,
			newParentItem = null;
			
			if(dojo.hasClass(this.current, "dojoDndItemChild")){
				newParentItem = targetWidget.item;
			}else{
				newParentItem = targetWidget.getParent().item;

				if(this.current) {
					var afterClass = (this.isBidi && this.horizontal) ? "dojoDndItemBefore" : "dojoDndItemAfter";
					
					if(dojo.hasClass(this.current, afterClass)) {
						targetWidget = targetWidget.getNextSibling();
						while(targetWidget && dojo.hasClass(targetWidget.domNode, "dojoDndItemAnchor")) {
							targetWidget = targetWidget.getNextSibling();
						}
					}
					if(targetWidget) nextSibling = targetWidget.item;
				}
			}
			
			setTimeout(dojo.hitch(this, function() {
				dojo.forEach(nodes, function(node){
					var childWidget = dijit.getEnclosingWidget(node),
						childItem = childWidget.item,
						prevParentItem = childWidget.getParent().item;	
					this.model.pasteItem(childItem, prevParentItem, newParentItem, copy, nextSibling);
				}, this);
			}), 50);
		},
		// mouse event processors
		onMouseMove: function(e){
			// summary: event processor for onmousemove
			// e: Event: mouse event
			if(this.isDragging && this.targetState == "Disabled"){ return; }
			dojo.dnd.Source.superclass.onMouseMove.call(this, e);
			var m = dojo.dnd.manager();
			if(this.isDragging){
				dojo.forEach(this.draggingItems, function(item){
					if(item.popup.isShowingNow){
						dijit.popup.close(item.popup);
						this._removeItemClass(this.current, "Over");
						dojo.removeClass(this.current, "dijitMenuItemHover");
					}
				}, this);
				
				// calculate before/after
				var before = false;
				if(this.current){
					
					if(!this.targetBox || this.targetAnchor != this.current){
						this.targetBox = {
							xy: dojo.coords(this.current, true),
							w: this.current.offsetWidth,
							h: this.current.offsetHeight
						};
					}

					if(this.horizontal){
						//before = (e.pageX - this.targetBox.xy.x) < (this.targetBox.w / 2);
						if((e.pageX - this.targetBox.xy.x) < (this.targetBox.w * 0.25)){
							before = "Before";
						}else if((e.pageX - this.targetBox.xy.x) > (this.targetBox.w * 0.75)){
							before = "After";
						}else{
							before = "Child";
						}
						
					}else{
						//before = (e.pageY - this.targetBox.xy.y) < (this.targetBox.h / 2);
						if((e.pageY - this.targetBox.xy.y) < (this.targetBox.h * 0.25)){
							before = "Before";
						}else if((e.pageY - this.targetBox.xy.y) > (this.targetBox.h * 0.75)){
							before = "After";
						}else{
							before = "Child";
						}
						
					}
				}
				if(this.current != this.targetAnchor || before != this.before){
					this._markTargetAnchor(before);
					m.canDrop(!this.current || m.source != this || !(this.current.id in this.selection));
				}
			}else{
				if(this.mouseDown && this.isSource &&
						(Math.abs(e.pageX - this._lastX) > this.delay || Math.abs(e.pageY - this._lastY) > this.delay)){
					var nodes = this.getSelectedNodes();
					if(nodes.length){
						m.startDrag(this, nodes, this.copyState(dojo.dnd.getCopyKeyState(e), true));
					}
				}
			}
		},
		_markTargetAnchor: function(before){
			// summary: assigns a class to the current target anchor based on "before" status
			// before: Boolean: insert before, if true, after otherwise
			if(this.current == this.targetAnchor && this.before == before){ return; }
			if(this.targetAnchor){
				this._removeItemClass(this.targetAnchor, this.before);
			}
			this.targetAnchor = this.current;
			this.targetBox = null;
			this.before = before;
			if(this.targetAnchor){
				this._addItemClass(this.targetAnchor, this.before);
			}
		},
		_unmarkTargetAnchor: function(){
			// summary: removes a class of the current target anchor based on "before" status
			if(!this.targetAnchor){ return; }
			this._removeItemClass(this.targetAnchor, this.before);
			this.targetAnchor = null;
			this.targetBox = null;
			this.before = true;
		},
		onDndStart: function(source, nodes, copy){
			this.draggingItems = new Array();
			dojo.forEach(nodes, function(node){
				var widget = dijit.getEnclosingWidget(node);
				if(widget && widget.popup){
					this.draggingItems.push(widget);
					this._removeItemClass(widget.popup, "Over");
					dijit.popup.close(widget.popup);
				}
			}, this);
			
			this.inherited(arguments);
			dojo.addClass(this.node, "isDragging");
		},
		onDndCancel: function(){
			this.inherited(arguments);
			dojo.removeClass(this.node, "isDragging");
		},
		destroy: function() {
			this.inherited(arguments);
			this.model = this.node = this.current = this.item = null;
		}
	}
);

}

if(!dojo._hasResource["com.ibm.widgets.TreeModeled"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.widgets.TreeModeled"] = true;
dojo.provide( "com.ibm.widgets.TreeModeled" );

dojo.require( "com.ibm.dnd.ModeledSource" );
 
/*
 * This module provides a simple API for creating a widget that is built from a data set through
 * some API.  Examples include but are not limited to the tree model API used by dijit.Tree and
 * the dojo.data API.  This module can be mixed in to other widgets that use data to build their
 * representations.
 */

dojo.declare( "com.ibm.widgets._DataBacked",
			null,
			{
				// _loaded: Boolean flag indicates whether or not this data backed widget has loaded
				//		its data yet
				_loaded: false,
				
				// _loading: Boolean flag indicates whether or not this data backed widget is currently
				//		loading its data
				_loading: false,
				
				load: function() {
					// summary: Loads the data used to build the implementing widget.  Subclasses should
					//		ensure that the _onLoad and _onLoading functions are called so that listeners
					//		to the onLoad and onLoading functions can receive proper notifications.
				},
				
				reload: function() {
					// summary: Reload a widget's data set in order to (optionally) rebuild
					//		the widget's representation.  Not all subclasses may support this.
				},
				_onLoad: function() {
					// implementations should call this internal function not the public one
					this._loaded = true;
					this._loading = false;
					this.onLoad();
				},
				_onLoading: function() {
					// implementations should call this internal function not the public one
					this._loading = true;
					this.onLoading();
				},
				
				onLoad: function() {
					// summary: Extension point called when data loading is finished regardless
					// 		of success or error.
				},
				onLoading: function() {
					// summary: Extension point called when data loading begins.
					
				}
			}
);


dojo.declare( "com.ibm.widgets.TreeModeled",
			com.ibm.widgets._DataBacked,
			{
				// summary:
				//		Mixin used for widgets that are built using a data model to represent
				//		data in some visual way.  Listens to model notifications of change events
				//		in order to update the representation of the model data in the widget.
				//		To use this mixin, call initializeModelWidget() in postCreate()
				//		and startupModelWidget() in startup().  They must also mixin the 
				// 		dijit._Container mixin or subclass an widget that already mixes it in.
				
				// model: Object which is an implementation	of the com.ibm.data.DataTreeModel
				// 		APIs.
				model: null,
				
				// item: Object the root item of this widget whose children will 
				//		populate the tabs in this widget.  Must be provided to root
				//		this widget at some point in the model.
				item: null,
				
				// items: Map of the widgets representing the children items of item retrieved 
				// 		from the model.  Keys are item ids and values are the widgets representing
				//		the items.
				items: null,
				
				// levels: Number of levels to recurse down the model when creating widget
				//		representations of the model.  Default is Infinity, indicating 
				// 		no maximum depth, which will continue to create representations of 
				// 		descendants all the	way down the tree model.  Implementations should
				//		handle this accordingly when creating new children.
				levels: Infinity,
				
				// level: Number the level of the current modeled widget in a heirarchy of modeled
				//		widgets.
				level: 0,
				
				// dndEnabled: Boolean indicates whether or not this widget should allow dnd operations
				dndEnabled: false,
				
				// dndClass: String class used to create a DND source object for this modeled widget
				dndClass: "com.ibm.dnd.ModeledSource",
				
				// dndAccept: Array of dnd types that this widget accepts
				dndAccept: null,
				
				// dndType: Array indicating the dndType(s) of items represented in this
				//		modeled widget.
				dndType: null,
				
				// dndCreator: Function dnd creator function
				dndCreator: null,
				
				// dndSingular: Boolean to determine if multiple items can be dragged
				//		simultaneously or not
				dndSingular: true,
				
				// dndDelay: Number of pixels to use as a delay before triggering a dnd operation
				dndDelay: 0,
				
				// dndHorizontal: Boolean indicating if this model widget should use horizontal dnd
				//		operations.  Default is false.
				dndHorizontal: false,
				
				// loadingIndicatorWidget: String name of widget class used to represent the loading state of this 
				// 		modeled widget.  By default, it is displayed as a child of this widget while children 
				// 		are being loaded, and is then removed after loading has completed.
				loadingIndicatorWidget: "",
				
				// showInlineEditor: Boolean indicating whether or not to show an inline editor widget 
				// 		somewhere in this modeled widget.  Implementations are free to handle this
				// 		however they please.  One example use case is to provide a means of creating 
				// 		new data in a data backed widget through an inline editor.  Inline editor
				//		onchange events are propagated to the onInlineEditorChange function with the
				//		parentItem and the new value passed as arguments.
				showInlineEditor: false,
				
				// inlineEditorWidget: String name of widget class to use to instantiate the inline
				//		editor of this data backed widget.  Must implement onChange, onCancel, and onEdit
				// 		events for the inline editor.  The com.ibm.widgets.InlineEditorWrapper mixin
				//		provides prebuilt logic for these handlers and can be mixed into other widgets
				//		that will contain the editor.
				inlineEditorWidget: "",
				
				// inlineEditorTitle: String title to display on hover over the inline editor
				//		while in edit mode
				inlineEditorTitle: "",
				
				// inlineEditorLabel: String default label to display in inline editor
				// 		when not in edit mode 
				inlineEditorLabel: "",
				
				// inlineEditorLabel: String default value to display in inline editor when going into
				// 		edit mode
				inlineEditorDefaultValue: "",
				
				// embeddedEditorWidget: Widget class used to instantiate the embedded inline editor
				//		used inside this modeled widget
				embeddedEditorWidget: "dijit.form.TextBox",
				
				// embeddedEditorParams: Object set of parameters used when instantiating the embedded
				//		inline editor widget, like {required: true} or {constraints: {}}
				embeddedEditorParams: {},
				
				embeddedEditorPopup: "com.ibm.widgets.InlineEditorPopup",
				embeddedEditorPopupParams: {},
								
				constructor: function() {
					this.embeddedEditorParams = {};
					this.embeddedEditorPopupParams = {};
					this.items = {};
				},
				
				initializeModelWidget: function() {
					this.connect(this.model, "onTreeChange", "onModelTreeChange");
					this.connect(this.model, "onChange", "onModelChange");
					this.connect(this.model, "onChildrenChange", "onModelChildrenChange");
					
					if(!this.preloaded) {
						var loaderCls = dojo.getObject(this.loadingIndicatorWidget);
						if(loaderCls) {
							this.loadingIndicator = new loaderCls();
						}
					}
					
					if(this.showInlineEditor) {
						this.connect(this, "onLoad", "setupInlineEditor");
					}
					
					if(!dojo.isArray(this.dndAccept)) this.dndAccept = [this.dndAccept];
					this._dndParams = {
						model: this.model,
						item: this.item,
						skipForm: true,
						accept: this.dndAccept || [],
						singular: this.dndSingular,
						creator: this.dndCreator,
						delay: this.dndDelay,
						horizontal: this.dndHorizontal,
						dropParent: this.containerNode
					};
					
					if(this.dndEnabled && !this.preloaded) {
						this.setupDnd();	// not set up when preloaded, called after preload processing
					}
					
					this._draggingNodes = [];
				},
				
				startupModelWidget: function() {
					if(!this.preloaded && this.loadingIndicator) this.addChild(this.loadingIndicator);
				},
				
				setupInlineEditor: function() {
					if(!this.inlineEditor) {
						var editorCls = dojo.getObject(this.inlineEditorWidget);
						if(editorCls) {
							this.inlineEditor = new editorCls({
								label: this.inlineEditorLabel,
								title: this.inlineEditorTitle,
								defaultValue: this.inlineEditorDefaultValue,
								embeddedEditorWidget: this.embeddedEditorWidget,
								embeddedEditorParams: this.embeddedEditorParams,
								popupWidget: this.embeddedEditorPopup,
								popupParams: this.embeddedEditorPopupParams
							});
							
							this.connect(this.inlineEditor, "onChange", "_onInlineEditorChange");
							this.connect(this.inlineEditor, "onCancel", "onInlineEditorCancel");
							this.connect(this.inlineEditor, "onEdit", "onInlineEdit");
							this.addChild(this.inlineEditor);
						}
					}
				},
				
				setupDnd: function() {
					// summary: Called during postCreate to setup dnd operations for this widget.
					//		Subclasses may override for customized behavior.
					if(!this.dndSource) {
						this.dndEnabled = true;
						var cls = dojo.getObject(this.dndClass);
						this.dndSource = new cls(this.domNode, this._dndParams);
						this._dndConnects = [];
						this._dndConnects.push(this.connect(this.dndSource, "onDraggingOver", "onDraggingOver"));
						this._dndConnects.push(this.connect(this.dndSource, "onDraggingOut", "onDraggingOut"));
						this._dndConnects.push(this.connect(this.dndSource, "onDndStart", "onDndStart"));
						this._dndConnects.push(this.connect(this.dndSource, "onDndCancel", "onDndCancel"));
					}
					dojo.forEach(this.getChildren(), function(child){
						child.attr("dndStatus", true);
					}, this);
				},
				disableDnd: function() {
					this._disableLocalDnd();
					dojo.forEach(this.getChildren(), function(child){
						child.attr("dndStatus", false);
					}, this);
				},
				_disableLocalDnd: function() {
					if(this.dndSource) {
						this.dndEnabled = false;
						dojo.forEach(this._dndConnects, this.disconnect, this);
						this._dndConnects = [];
						this.dndSource.destroy();
						this.dndSource = null;
					}
				},
				destroy: function() {
					this._disableLocalDnd();
					this.inherited(arguments);
				},
				getInheritableParameters: function(item) {
					// summary: Returns an object map of parameters to use when constructing the
					//		widget representation of the next level of the model.  Subclasses
					//		can extend this and provide additional properties or override ones
					//		set here.  Much of this is boilerplate, so it's often easiest to
					//		call this.inherited(arguments) and then modify the result before
					//		returning.
					// item: Current item to use as the root of the next level in the model.
					return {
						item: item,
						model: this.model, 
						level: this.level + 1,
						levels: this.levels,
						showInlineEditor: this.showInlineEditor,
						inlineEditorLabel: this.inlineEditorLabel,
						inlineEditorTitle: this.inlineEditorTitle,
						inlineEditorDefaultValue: this.inlineEditorDefaultValue,
						embeddedEditorWidget: this.embeddedEditorWidget,
						embeddedEditorParams: dojo.mixin({}, this.embeddedEditorParams),
						embeddedEditorPopup: this.embeddedEditorPopup,
						embeddedEditorPopupParams: dojo.mixin({}, this.embeddedEditorPopupParams),
						dndCreator: this.dndCreator,
						dndEnabled: this.dndEnabled,
						dndAccept: this.dndAccept,
						dndSingular: this.dndSingular,
						dndDelay: this.dndDelay,
						dndType: this.dndType,
						onModelItemClick: this.onModelItemClick,
						setupInlineEditor: this.setupInlineEditor,
						seedPreloadedData: this.seedPreloadedData
					};
				},
				createItemRep: function(item) {
					// summary: Subclasses should implement this function to create a widget representation of
					//		a data item in the model which is a child of the item backing this widget.  Each
					//		representation created here should mixin dijit._Contained as they will be children
					//		of this widget.  They also must support the dndHandle attribute getter/setter to set 
					// 		and get a boolean value indicating whether or not a	dnd handle should be used on the item.
					// item: Object item in the model backing this widget
				},
				handlePreloaded: function() {
					// summary: Plugin point for overrides that handle instantiation of this widget where data
					//		has been provided in the contents of the of the widget itself.
					this.domNode.removeAttribute("item");
					dojo.forEach(this.getChildren(), function(wij){
						this.items[this.model.getIdentity(wij.item)] = wij;
						this._flagChildForDnd(wij);
						this._flagChildHasChildren(wij);
						wij.domNode.removeAttribute("item");
					}, this);
				},
				seedPreloadedData: function() {
					// summary: Called when a widget is instantiated with preloaded data.  Override this to
					//		parse the data and do any processing such as seeding the model or store with the
					//		data found in the widget source point.
				},
				load: function() {
					// summary: Loads the children of this widget's item property from the model, and 
					// 		creates widgets	to represent each child item.  Can be overriden by subclasses 
					// 		to provide customized behavior.
					// returns: Boolean indicating whether or not this widget had any children to load.
					//		In either case, the onLoad and onLoading events are still fired.
					if(this._loaded || this._loading || !this.item) return false;	// already loaded, in process, or n/a
					if(this.preloaded) {
						this.seedPreloadedData();
						this.handlePreloaded();
						if(this.showInlineEditor){
							this.setupInlineEditor();
						}
						if(this.dndEnabled) {
							this.setupDnd();	// not set up when preloaded
						}
						return false;
					}
					if(!this.model.mayHaveChildren(this.item)) {
						if(this.loadingIndicator) this.removeChild(this.loadingIndicator);
						this._onLoading();
						this._onLoad();
						return false;
					}
					this._onLoading();
					this.model.getChildren(this.item, 
						dojo.hitch(this, function(items) {
							if(this.loadingIndicator) this.removeChild(this.loadingIndicator);
							
							if(!this.showInlineEditor && this.inlineEditor != null){
									this.inlineEditor.destroy();
									this.inlineEditor = null;
							}else if(this.showInlineEditor && this.inlineEditor == null){
									this.setupInlineEditor();
							}
							
							var insIndex = 0;
							if(this.inlineEditor) insIndex = this.getIndexOfChild(this.inlineEditor);
							
							dojo.forEach(items, function(item){
								var childWidget = this._setupNewChild(item);
								this.items[this.model.getIdentity(item)] = childWidget;
								if(insIndex != null) this.addChild(childWidget, insIndex++);
								else this.addChild(childWidget);
							}, this);
							
							if(this.dndSource) this.dndSource.sync();
							this._onLoad();
						}),
						dojo.hitch(this, function(error) {
							if(this.loadingIndicator) this.removeChild(this.loadingIndicator);
							this._onLoad();
							this.onError(error);
						})
					);
					return true;
				},
				reload: function() {
					// summary: Reloads this widget's children by destroying the existing children
					//		that are backed by model items and then calling load again.
					if(this._loading) return false;
					this._loaded = false;
					var items = this.items;
					for(var id in items) {
						this.removeChild(items[id]);
						//items[id].destroyRecursive();
						delete items[id];
					}
					if(this.dndSource) this.dndSource.sync();
					if(this.loadingIndicator) this.addChild(this.loadingIndicator);
					this.preloaded = false;
					if(this.model.resolver) this.model.resolver.getValue(this.item, "children").reload();
					return this.load();
				},
				_flagChildForDnd: function(childWidget) {
					//if(this.dndEnabled) {
						dojo.addClass(childWidget.domNode, "dojoDndItem");
						childWidget.domNode.setAttribute("dndType", this.dndType);
						childWidget.domNode.setAttribute("dndData", this.model.getLabel(childWidget.item));
						childWidget.attr("dndHandle", this._dndParams.withHandles);
					//}
				},
				_flagChildHasChildren: function(childWidget) {
					if(!this.model.mayHaveChildren(childWidget.item) || this.levels == 0 || this.level >= this.levels) {
						childWidget.attr("hasChildren", false);
					} else {
						childWidget.attr("hasChildren", true);
					}
				},
				_setupNewChild: function(item) {
					var childWidget = this.createItemRep(item);
					childWidget.item = item;
					this._flagChildForDnd(childWidget);
					this._flagChildHasChildren(childWidget);
					return childWidget;
				},
				onError: function(error) {
					// summary: Called when there is an error loading this widget.
					// error: Error data indicating what failed during the process of retrieving the children
					//		of this widget's item from the model.
					console.error(error);
				},
				onItemCreate: function(childWidget, item) {
					// summary: Can be fired for child items when they are created perhaps after the widget creates 
					// 		some representation of the item before it was created on the server.
				},
				onModelRemoveChild: function(/*Item*/ childItem) {
					var childWidgets = this.getChildren();
					for(var i=0, wij; wij=childWidgets[i], i<childWidgets.length; i++) {
						if(wij.item == childItem) {
							delete this.items[this.model.getIdentity(childItem)];
							this.removeChild(wij);
							wij.destroyRecursive();
							for(var x in wij) {
								try {
									delete wij[x];
								}
								catch(e){
									wij[x] = null;
								}
							}
							if(this.dndSource) this.dndSource.sync();
							return;
						}
					}
				},
				onModelInsertChild: function(/*Item*/ childItem, /*Item*/ nextSiblingItem) {
					var childWidget = this._setupNewChild(childItem);
					var childWidgets = this.getChildren();
					var insIdx = null;
					if(nextSiblingItem) {
						for(var i=0, wij; wij=childWidgets[i], i<childWidgets.length; i++) {
							if(wij.item == nextSiblingItem) {
								insIdx = i;
								break;
							}
						}
					}
					else {
						insIdx = this.getIndexOfChild(this.inlineEditor)
					}
					this.animateInChild(childWidget, insIdx);
					if(!this.model.isCreated(childItem)) {
						if(this._editorChangedWithFocus) {
							setTimeout(function(){
								dijit.focus(childWidget.focusNode ? childWidget.focusNode : childWidget.domNode);
							},0);
						}
						this._editorChangedWithFocus = false;
						childWidget.attr("disabled", true);
						this.model.addOnCreate(childItem, dojo.hitch(this, function(){
							this.items[this.model.getIdentity(childItem)] = childWidget;
							childWidget.attr("disabled", false);
							this.onItemCreate(childWidget, childItem);
						}));
					}
					else {
						this.items[this.model.getIdentity(childItem)] = childWidget;
					}
					if(this.dndSource) this.dndSource.sync();
				},
				onModelReorderChild: function(/*Item*/childItem, /*Item*/nextSiblingItem) {
					var childWidgets = this.getChildren();
					var childWidget = null;
					for(var i=0, wij; wij=childWidgets[i], i<childWidgets.length; i++) {
						if(wij.item == childItem) {
							childWidget = wij;
							this.removeChild(childWidget);
							// remove the item from the childWidgets node-list too, since we process
							// using the childWidgets below
							childWidgets.splice(i, 1);
							break;
						}
					}
					
					var insIdx = null;
					if(nextSiblingItem) {
						for(var i=0, wij; wij=childWidgets[i], i<childWidgets.length; i++) {
							if(wij.item == nextSiblingItem) {
								insIdx = i;
								break;
							}
						}
					}
					else {
						insIdx = this.getIndexOfChild(this.inlineEditor);
					}
					this.animateInChild(childWidget, insIdx);
					if(this.dndSource) this.dndSource.sync();
				},
				onModelTreeChange: function(/*Item*/ childItem, /*Item*/ oldParentItem, /*Item*/ newParentItem, /*Item*/ nextSiblingItem) {
					// summary: Listens to changes in the tree model where a particular childItem is added, removed, or moved
					//		under a parent item in the tree.  Here are the semantics:
					//		1) If oldParentItem is non-null, the childItem used to be a child of the oldParentItem (and still
					//			may, depending upon the other conditions.  If it is null, then the childItem is being inserted
					//			into the tree under the newParentItem as a new created tree node.
					//		2) If newParentItem is non-null, the childItem is now a child of the newParentItem.  If newParentItem
					//			is null, then the item is being deleted from the tree altogether from under the oldParentItem.
					//			If newParentItem is equal to oldParentItem, then the childItem is being reordered among the list
					//			of children of its parent.
					//		3) If nextSiblingItem is non-null, then the item is being moved or inserted into the tree and the 
					//			nextSiblingItem is the next sibling of the childItem under its parent.
					// childItem: Item being operated on in the model.
					// oldParentItem: Item previous parent of the childItem
					// newParentItem: Item new parent of the childItem
					// nextSiblingItem: Item next sibling of the childItem
					var f = null;
					if(this.item == oldParentItem) {
						f = "onModelRemoveChild";
					}
					if(this.item == newParentItem) {
						f = f ? "onModelReorderChild" : "onModelInsertChild";
					}
					if(f) {
						this[f](childItem, nextSiblingItem);
						return true;
					}
					return false;
				},
				onModelChange: function(/*dojo.data.Item*/ item) {
					if(this.items[this.model.getIdentity(item)]) {
						// TODO: process the change
					}
					return false;
				},
				onModelChildrenChange: function(parentItem, children) {
					if(this.item != parentItem) {
						var parentId = this.model.getIdentity(parentItem), child = this.items[parentId];
						if(child) {
							this.handleChildChildrenChange(child, children || []);
						}
						return false;
					}
					// only handle the no-children case... all other updates to children are 
					// handled by the other callbacks
					if(this.anchor) {
						this.anchor.attr("hasChildren", children && children.length > 0);
					}
				},
				handleChildChildrenChange: function(child, children) {
					// summary: Called when a child that has no children gets children or when a child that has children
					//		loses all its children.
				},
				onModelItemClick: function(widget, item) {
					// summary: Extension point for getting notifications when users click
					//		a widget representing an item in this model.  By default, this
					//		is propogated to all cascading modeled widgets created by the
					//		model so that all descendants fire the same function.
					//		Implementations should ensure that any onclick event on a child 
					// 		widget representing	modeled data calls results in a call to this 
					// 		function with the appropriate arguments. 
				},
				onDraggingOver: function() {
					if(this.inlineEditor && this.dndSource.getAllNodes().length == 0) {
						// empty container... style the inlineEditor
						this.dndSource._addItemClass(this.inlineEditor.domNode, "Before");
					}
				},
				onDraggingOut: function() {
					if(this.inlineEditor && this.dndSource.getAllNodes().length == 0) {
						// empty container... style the inlineEditor
						this.dndSource._removeItemClass(this.inlineEditor.domNode, "Before");
					}
				},
				onDndStart: function(source, nodes, copy) {
					if(this.dndSource == source) {
						dojo.forEach(nodes, function(node){
							this._animateOut(node);
						}, this);
						this._draggingNodes = nodes;
					}
				},
				onDndCancel: function() {
					if(this.inlineEditor) this.dndSource._removeItemClass(this.inlineEditor.domNode, "Before");
					dojo.forEach(this._draggingNodes, function(node){
						this._animateIn(node);
					}, this);
					this._draggingNodes = [];
				},
				_animateIn: function(node) {
					if(node._animation) node._animation.stop(true);
					dojo.style(node, "display", "");
					var anim = dojo.fadeIn({
						node: node,
						duration: 500
					});
					if(dojo.isIE) {
						var filter = node.style.filter;
						anim.onEnd = function() {
							node._animation = null;
							node.style.filter = filter;
						}
					}
					node._animation = anim;
					anim.play();
					return anim;
				},
				_animateOut: function(node) {
					if(node._animation) node._animation.stop(true);
					var anim = dojo.fadeOut({
						node: node,
						duration: 500,
						onEnd: function() {
							node._animation = null;
							dojo.style(node, "display", "none");
						}
					});
					node._animation = anim;
					anim.play();
					return anim;
				},
				animateInChild: function(/*Widget*/ widget, /*int?*/ insertIndex) {
					// summary: Adds a child to this modeled widget but allows animation
					//		effects to display the new child.
					// returns: Animation object which has already been started on return.
					//		Returns null if no animation was used.
					var filter = null;
					if(dojo.isIE) {
						filter = widget.domNode.style.filter;
					}
					dojo.style(widget.domNode, "opacity", "0");
					(insertIndex >= 0) ? this.addChild(widget, insertIndex) : this.addChild(widget);
					var anim = this._animateIn(widget.domNode);
					// hack for IE to get filter exactly back to original before animation
					if(dojo.isIE) var conn = dojo.connect(anim, "onEnd", function(){
						widget.domNode.style.filter = filter;
						dojo.disconnect(conn);
					});
					return anim;
				},
				animateOutChild: function(/*Widget*/ widget) {
					// summary: Hides a child from this modeled widget but allows animation
					//		effects when hiding the child.  At the end of the animation,
					//		this removes the child.
					// returns: Animation object which has already been started on return.
					//		Returns null if no animation was used.
					var anim = this._animateOut(widget.domNode);
					dojo.connect(anim, "onEnd", this, function(){
						this.removeChild(widget);
					});
					return anim;
				},
				moveChild: function(/*Widget*/ widget, /*int?*/ newIndex) {
					this.removeChild(widget);
					this.animateInChild(widget, newIndex);
				},
				_onInlineEditorChange: function(value, focus) {
					this._editorChangedWithFocus = focus;
					this.onInlineEditorChange(value, this.item);
				},
				onInlineEditorChange: function(value, parentItem) {
					// summary: Override or connect to this function to get notifications of changes to
					//		this menu's inline editor (if one exists).  The default implementation calls 
					// 		the model's newItem function passing in an object of the form {title: newValue}
					//		as the first argument and the item of this widget as the parent in the second
					//		argument.
					// value: Object map of key-value pairs from the inline editor's composite value.
					// parentItem: Item which is root of the widget whose editor fired its onChange event.
					this.model.newItem(value, parentItem);
				},
				onInlineEditorCancel: function() {
					// summary: Override or connect to this function to get notified when the user cancels
					//		an edit operation in the inline editor.
				},
				onInlineEdit: function() {
					// summary: Override or connect to this function to get notified when the user starts
					//		an edit operation in the inline editor usually by clicking or entering the inline
					//		editor.
				}
			}
);

}

if(!dojo._hasResource["com.ibm.widgets.SelectionModeled"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.widgets.SelectionModeled"] = true;
dojo.provide("com.ibm.widgets.SelectionModeled");





dojo.declare( "com.ibm.widgets.SelectionModeled",
			com.ibm.widgets.TreeModeled,
			{
				// summary:
				//		Mixin for building widgets from a selection model, which is a list structure
				//		that represents a current selection in a model starting at the root and walking
				//		down a tree to the currently selected node.
				
				// level: Number the level of the current modeled widget in a heirarchy of modeled
				//		widgets.  This represents the level in the tree from the root where this
				//		widget is rooted.  From the selection model's point of view, it is the index
				//		into the reverse selection path (since that goes up the tree instead).
				level: 0,
				
				// selectionModel: An instance of the com.ibm.data.SelectionModel class representing
				//		a selection model.
				selectionModel: null,
				
				// selectedClass: String name of the CSS class to apply to a node that is in the
				//		selection path.
				selectedClass: "",
				
				// selectedChild: Child widget which is currently marked as selected, indicating that
				//		it is part of the selection model.
				selectedChild: null,
				
				// tiedToSelection: Boolean flag indicating if this widget is tied to the selection
				//		model at this level.  If this is true, then if the selection path changes
				//		at this level, this widget will reload itself completely to root itself
				//		at the new item in the selection path at this level.
				tiedToSelection: false,
				
				constructor: function(){
					this.bundle = dojo.i18n.getLocalization("com.ibm.bundles", "Theme");
					this.currentlySelected = this.bundle["currently_selected"];
				},
				postMixInProperties: function() {
					this.inherited(arguments);
					if(this.tiedToSelection) this.item = this.selectionModel.atLevel(this.level, true);
				},
				initializeModelWidget: function() {
					this.inherited(arguments);
					this.connect(this.selectionModel, "onSelectionPathChange", "_updateSelection");
				},
				_markSel: function(childWidget, value) {
					if(value) {
						if(this.selectedChild) this.markSelected(this.selectedChild, false);
						this.selectedChild = childWidget;
					}
					this.markSelected(childWidget, value);
				},
				markSelected: function(childWidget, value) { 
					// summary: Marks the childWidget as selected or unselected depending on the value.
					//		By default, adds/removes the selectedClass to the childWidget's domNode.
					dojo[value ? "addClass" : "removeClass"](childWidget.domNode, this.selectedClass);
					if(childWidget.labelNode){
						if(value){  
							// add a strong tag to a selected child widget
							var label = childWidget.labelNode.innerHTML,
								selectedLabel = "";
							dojo.empty(childWidget.labelNode);
							
							if(this.selectionModel.selectionPath[0] == childWidget.item){

								var hiddenText = dojo.create("span", {innerHTML: this.currentlySelected, className: "ibmPortalHiddenText"});
								var hiddenSpan = dojo.create("span");
								hiddenSpan.appendChild(hiddenText);
								selectedLabel = dojo.create("strong",{innerHTML:label+hiddenSpan.innerHTML});
							}else{
								selectedLabel = dojo.create("strong",{innerHTML:label});
							}
							
							childWidget.labelNode.appendChild(selectedLabel);
						} else { 
							// remove a strong tag from a unselected child widget
							var label = dojo.query("strong",childWidget.labelNode); 
							if(label[0]) childWidget.labelNode.innerHTML = label[0].innerHTML; 
						}
					}
				},
				_updateSelection: function() {
					var curLevelItem = this.selectionModel.atLevel(this.level, true),
						lastLevelItem = this.selectionModel.atLevel(this.level + 1, true);
					if(curLevelItem != null){
						if(this.tiedToSelection && this.model.getIdentity(this.item) != this.model.getIdentity(curLevelItem) ) {
							this.item = curLevelItem;
							this.reload();
						}
						else {
							var curLevelId = curLevelItem ? this.model.getIdentity(curLevelItem) : null,
								levelId = lastLevelItem ? this.model.getIdentity(lastLevelItem) : null;
							
							if(curLevelItem && curLevelId != levelId && this.items[curLevelId]) {
								this._markSel(this.items[curLevelId], false);
							}
							if(levelId && this.items[levelId]) {
								this._markSel(this.items[levelId], true);
							}
						}
					}
				},
				_setupNewChild: function(item) {
					var childWidget = this.inherited(arguments);
					if(this.selectionModel.atLevel(this.level + 1, true) == item) {
						this._markSel(childWidget, true);
					}
					return childWidget;
				},
				getInheritableParameters: function(item) {
					return dojo.mixin(this.inherited(arguments), {
						selectionModel: this.selectionModel,
						selectedClass: this.selectedClass
					});
				},
				onModelItemClick: function(widget, item) {
					// summary: Extension point for getting notifications when users click
					//		a widget representing an item in this model.  By default, this
					//		is propogated to all cascading modeled widgets created by the
					//		model so that all descendants fire the same function.
					//		Implementations should ensure that any onclick event on a child 
					// 		widget representing	modeled data calls results in a call to this 
					// 		function with the appropriate arguments. 
					//		For SelectionModeled widgets, this changes the current selection
					//		to the widget's item that was clicked.
					if(widget.disabled) return false;
					var id = this.model.getIdentity(item);
						thisSel = this.selectionModel.atLevel(this.level, true),
						thisSelId = thisSel ? this.model.getIdentity(thisSel) : null;
					if(thisSelId != id) {
						// didn't click the current selection
						this.selectionModel.changeSelection(item);
						return true;
					}
					return false;
				}
			}
);

}

if(!dojo._hasResource["com.ibm.widgets.DataMenu"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.widgets.DataMenu"] = true;
dojo.provide("com.ibm.widgets.DataMenu");

dojo.require( "dijit.Menu" );
dojo.require( "dijit.InlineEditBox" );
dojo.require( "com.ibm.widgets.TimedMenu" );
dojo.require( "com.ibm.widgets.SelectionModeled" );
dojo.require( "com.ibm.widgets.InlineEditorWrapper" );



dojo.declare( "com.ibm.widgets.DataMenu",
			[dijit.Menu, com.ibm.widgets.TimedMenu, com.ibm.widgets.SelectionModeled],
			{			
				"class": "lotusActionMenu",
				
				// loadingIndicatorWidget: String name of widget class used to represent the loading state of this 
				// 		modeled widget.  By default, it is displayed as a child of this widget while children 
				// 		are being loaded, and is then removed after loading has completed.
				loadingIndicatorWidget: "com.ibm.widgets.LoadingMenuItem",
				
				// inlineEditorWidget: String name of widget class to use to instantiate the inline
				//		editor of this data backed widget.
				inlineEditorWidget: "com.ibm.widgets.EditorMenuItem",
				
				// closeDelay: Number of milliseconds to wait before closing a menu when it 
				// 		loses focus or receives an unhover event
				closeDelay: 500,
				
				// level: Number indicating the number of ancestor menus in the model chain above
				//		this menu.  Default is 0, indicating that this is a top level menu.
				level: 0,
				
				postCreate: function() {
					this.inherited(arguments);
					var ltr = this.isLeftToRight(),
						k = dojo.keys;
					this._exitKey = ltr ? k.LEFT_ARROW : k.RIGHT_ARROW;
					this._openKey = ltr ? k.RIGHT_ARROW : k.LEFT_ARROW;
					if(this.embeddedEditorParams.tooltipPosition) {
						this.embeddedEditorParams.tooltipPosition = ["after", "before", "below"];
					}
					this.initializeModelWidget();
					this._dndParams.withHandles = true;
					dojo.addClass(this.domNode, this["class"]);
					dojo.addClass(this.domNode, "modeledDataMenu");
					this.connect(this, "onMouseEnter", "_onHover");
					this.connect(this, "onMouseLeave", "_onUnhover");
					
					this.domNode.setAttribute("cellSpacing", "0px");
					dojo.style(this.domNode, {
						borderCollapse: "separate",
						borderSpacing: "0px"
					});
				},
				
				startup: function() {
					this.inherited(arguments);
					this.startupModelWidget();
				},
				
				setupInlineEditor: function() {
					return;
				},
				
				setupDnd: function() {
					this._dndParams.withHandles = true;
					this.inherited(arguments);
				},
				getInheritableParameters: function(item) {
					return dojo.mixin(this.inherited(arguments), {
						parentMenu: this,
						closeDelay: this.closeDelay,
						popupDelay: this.popupDelay,
						"class": this["class"]
					});
				},
				_getPopup: function(item) {
					if(this.level < this.levels) {
						return new this.constructor(this.getInheritableParameters(item));
					}
					return null;
				},
				createItemRep: function(item) {
					var args = {
						iconClass: "dragHandleIcon", 
						label: com.ibm.domUtilities.encodeXML(this.model.getLabel(item)), 
						item: item
					};
					var cls = com.ibm.widgets.DataPopupMenuItem;
					
					if(this.model.mayHaveChildren(item) || this.showInlineEditor) {
						var popup = this._getPopup(item);
						if(popup) {
							args.popup = popup;
						}
					}
					
					var childWidget = new cls(args);
					return childWidget;
				},
				handleChildChildrenChange: function(child, children) {
					// summary: Called when a child that has no children gets children or when a child that has children
					//		loses all its children.
					if(children.length == 0) {
						// child lost all children, destroy its popup
						child.destroyPopup();
						child.attr("hasChildren", false);
					}
					else if(!child.popup){
						// child without children got new children, create its popup
						var popup = this._getPopup(child.item);
						if(popup) {
							child.setPopup(popup);
							child.attr("hasChildren", true);
							popup.load();
							this.onItemHover(child);
						}
					}
				},
				getTopAnchor: function() {
					if(this.anchor) { 
						var parent = this.anchor.getParent();
						return parent && parent.getTopAnchor ? parent.getTopAnchor() : this.anchor;
					}
					else return null;
				},
				_moveToPopup: function(/*Event*/ evt){
					if(this.focusedChild && this.focusedChild.popup && !this.focusedChild.disabled) {
						this._openPopup();
					}
					else {
						var topAnchor = this.getTopAnchor();
						if(topAnchor) {
							topAnchor.getParent().focusNext();
						}
					}
				},
				_onChildBlur: function(item) {
					// nobody else is checking this, and apparently when widgets are destroyed
					// and the dom destroyed too, this fails trying to blur a non-existing node
					if(!item || !item.domNode) return;
					return this.inherited(arguments);
				},
				onItemHover: function(/*Widget*/ item){
					// summary: Called when cursor is over a MenuItem
					if(!this.inlineEditor || !this.inlineEditor.isEditing()) {
						this.isActive = true;
						return this.inherited(arguments);
					}
				},
				onItemClick: function(/*Widget*/ child, /*Event*/ evt){
					// summary: user defined function to handle clicks on an item
					if(child.attr("disabled")) return false; 
					this.onExecute();
					child.onClick(evt);
					if(child.item) this.onModelItemClick(child, child.item);
				},
				_onKeyPress: function(/*Event*/ evt){
					if(this.inlineEditor 
							&& this.inlineEditor.isEditing() 
							&& dojo.isDescendant(evt.target, this.inlineEditor.domNode)) {
						return;
					}
					 
					if(evt.ctrlKey || evt.altKey) return;
					switch(evt.charOrCode) {
						case this._exitKey:
							if(this.parentMenu) {
								this.onCancel(false);
							}
							else {
								var topAnchor = this.getTopAnchor();
								if(topAnchor) {
									topAnchor.getParent().focusPrev();
								}
							}
							dojo.stopEvent(evt);
							break;
						case this._openKey:
						 	this._moveToPopup(evt);
						 	dojo.stopEvent(evt);
						 	break;
					}
				},
				canClose: function() {
					// summary: Indicates whether or not this menu can close right now.  Is
					//		used to keep menus from closing when they are editing or in other
					//		conditions.
					return !this.inlineEditor || (this.inlineEditor && !this.inlineEditor.isEditing());
				}
			}
);

dojo.declare( "com.ibm.widgets._DataMenuItem", 
			null, 
			{
				templateString: 
				 '<tr class="dijitReset dijitMenuItem" dojoAttachPoint="focusNode" waiRole="menuitem" tabIndex="-1"'
				+'dojoAttachEvent="onmouseenter:_onHover,onmouseleave:_onUnhover,ondijitclick:_onClick">'
				+'<td dojoAttachPoint="dndHandleNode" class="dijitReset dragHandle" waiRole="presentation">'
					+'<img dojoAttachPoint="iconNode" src="${_blankGif}" alt="" />'
					+'<span class="dragHandleA11y">|</span>'
				+'</td>'
				+'<td class="dijitReset dijitMenuItemLabel" dojoAttachPoint="containerNode"></td>'
				+'<td class="dijitReset dijitMenuArrowCell" waiRole="presentation">'
					+'<div class="modelHasChildrenIcon" dojoAttachPoint="arrowWrapper">'
						+'<div class="dijitMenuExpand"></div>'
						+'<span class="dijitMenuExpandA11y">+</span>'
					+'</div>'
				+'</td>'
				+'</tr>',
				
				_setDndHandleAttr: function(value) {
					this.dndHandle = value;
					dojo[value ? "addClass" : "removeClass"](this.dndHandleNode, "dojoDndHandle");
				},
				_setHasChildrenAttr: function(value) {
					this.hasChildren = value;
					dojo[value ? "addClass" : "removeClass"](this.domNode, "modelHasChildren");
				},
				_setDndStatusAttr: function(value) {
					this.dndStatus = value;
					if(this.popup) {
						this.popup[value ? "setupDnd" : "disableDnd"]();
					}
				},
				focus: function() {
					var parent = this.getParent();
					if(!parent.dndSource || !parent.dndSource.isDragging) {
						this.inherited(arguments);
					}
				}
			}
);

dojo.declare( "com.ibm.widgets.DataMenuItem",
			[dijit.MenuItem, com.ibm.widgets._DataMenuItem], 
			{
				
			}
);

dojo.declare( "com.ibm.widgets.DataPopupMenuItem",
			[dijit.MenuItem, com.ibm.widgets._DataMenuItem],
			{
				constructor: function() {
					this._popupConnects = null;
				},
				startup: function() {
					this.inherited(arguments);
					if(this.popup) {
						this.setPopup(this.popup);
					}
				},
				setPopup: function(popup) {
					this.popup = popup;
					this.popup.anchor = this;
					this._popupConnects = [
						this.connect(this.focusNode, "onfocus", "loadPopup"),
						this.connect(this.popup, "onLoading", "onLoading"),
						this.connect(this.popup, "onLoad", "onLoad")
					];
					this.popup.startup();
					if(this.arrowWrapper) {
						dojo.style(this.arrowWrapper, "visibility", "");
					}
					dijit.setWaiState(this.focusNode, "haspopup", "true");
				},
				destroyPopup: function() {
					if(this.popup) {
						dojo.forEach(this._popupConnects, this.disconnect, this);
						this._popupConnects = null;
						this.popup.destroyRecursive();
						delete this.popup;
						dijit.setWaiState(this.focusNode, "haspopup", "false");
					}
				},
				loadPopup: function() {
					if(this.popup) this.popup.load();
				},
				onLoad: function() {
					// fired when loading this menu item's popup is complete
				},
				onLoading: function() {
					// fired when loading this menu item's popup has started
				},
				_onHover: function() {
					this.loadPopup();
					this.inherited(arguments);
				},
				destroyDescendants: function() {
					this.destroyPopup();
					this.inherited(arguments);
				}
			}
);

dojo.declare( "com.ibm.widgets.LoadingMenuItem",
			dijit.MenuItem,
			{
				label: "Loading...",
				iconClass: "ibmLoading",
				
				postMixInProperties: function() {
					this.shelfBundle = dojo.i18n.getLocalization("com.ibm.bundles", "Shelf");
					this.label=this.shelfBundle["shelf_loading"];
				}
			}
);

dojo.declare( "com.ibm.widgets.EditorMenuItem",
			[dijit.MenuItem, com.ibm.widgets.InlineEditorWrapper],
			{
				templateString:
					 '<tr class="dijitReset dijitMenuItem inlineEditor lotusMenuSeparator" dojoAttachPoint="focusNode" waiRole="menuitem" tabIndex="-1"'
					+'dojoAttachEvent="onmouseenter:_onHover,onmouseleave:_onUnhover,onkeypress:_onKeyPress">'
					+'<td class="dijitReset" waiRole="presentation"><div class="dijitMenuItemIcon" dojoAttachPoint="iconNode"></div></td>'
					+'<td class="dijitReset dijitMenuItemLabel" dojoAttachPoint="containerNode"><span dojoAttachPoint="editor">${label}</span></td>'
					+'<td class="dijitReset dijitMenuArrowCell" waiRole="presentation"></td>'
					+'</tr>',
					
				attributeMap: dojo.mixin(dojo.clone(dijit.MenuItem.prototype.attributeMap), {
					label: {node: "editor", type: "innerHTML"}
				}),
				postCreate: function() {
					this.inherited(arguments);
					dojo.setSelectable(this.domNode, true);
				},
				focus: function() {
					var parent = this.getParent();
					if(!parent.dndSource || !parent.dndSource.isDragging) {
						this.inherited(arguments);
					}
				},
				_onKeyPress: function(evt) {
					if(!evt.ctrlKey && !evt.altKey && evt.charOrCode == dojo.keys.ENTER
						&& !this.isEditing()) {
						this.editor.edit();
						dojo.stopEvent(evt);
						return false;
					}
				}
			}
);

}

if(!dojo._hasResource["com.ibm.widgets.DataTabBar"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.widgets.DataTabBar"] = true;
dojo.provide( "com.ibm.widgets.DataTabBar" );

dojo.require( "com.ibm.widgets.TabBar" );
dojo.require( "com.ibm.widgets.DataMenu" );
dojo.require( "com.ibm.widgets.SelectionModeled" );




dojo.declare( "com.ibm.widgets.DataTabBar",
			[com.ibm.widgets.TabBar, com.ibm.widgets.SelectionModeled],
			{				
				// tagWidget: String the name of the widget class to instantiate for each
				//		tab in this tab bar.
				tabWidget: "com.ibm.widgets.DataTab",
				
				// menuWidget: String the name of the widget class to instantiate for each
				//		menu associated with the tabs.
				menuWidget: "com.ibm.widgets.DataMenu",
				
				// closeDelay: Number of milliseconds to wait before closing a menu when a tab
				//		and any of its menus are no longer hovered over
				closeDelay: 500,
				
				// openDelay: Number of milliseconds to wait before opening a menu when a tab
				//		is hovered over
				openDelay: 0,
				
				// dndHorizontal: Boolean indicating if this model widget should use horizontal dnd
				//		operations.  True for this widget.
				dndHorizontal: true,
				
				// loadingIndicatorWidget: String name of widget class used to represent the loading state of this 
				// 		modeled widget.  By default, it is displayed as a child of this widget while children 
				// 		are being loaded, and is then removed after loading has completed.
				loadingIndicatorWidget: "com.ibm.widgets.LoadingTab",
				
				// inlineEditorWidget: String name of widget class to use to instantiate the inline
				//		editor of this data backed widget.
				inlineEditorWidget: "com.ibm.widgets.ShowEditorTab",
				
				// showNestedInlineEditor: Boolean indicating whether or not to show the inline editor on 
				//		nested menus, cascading down the tree.  False does not show the inline editor for any
				//		while true shows it for all descendants.
				showNestedInlineEditor: false,
								
				postCreate: function() {
					this.inherited(arguments);
					this.initializeModelWidget();
					this._dndParams.withHandles = true;
					dojo.addClass(this.domNode, "modeledTabs");
					if(this.tabStrip) dojo.addClass(this.tabList, this["class"] + "Strip");
				},
				
				startup: function() {
					this.inherited(arguments);
					this.startupModelWidget();
					this.load();
				},
				
				getInheritableParameters: function(item) {
					return dojo.mixin(this.inherited(arguments), {
						closeDelay: this.closeDelay,
						popupDelay: this.popupDelay,
						showInlineEditor: this.showNestedInlineEditor
					});
				},
				handlePreloaded: function() {
					// summary: Plugin point for overrides that handle instantiation of this widget where data
					//		has been provided in the contents of the of the widget itself.
					dojo.forEach(this.getChildren(), function(wij){
						if(this.model.mayHaveChildren(wij.item) || this.showNestedInlineEditor) {
							var popup = this._getPopup(wij.item);
							if(popup) {
								wij.setPopup(popup);
								popup.startup();
							}
						}
					}, this);
					return this.inherited(arguments);
				},
				_getPopup: function(item) {
					if(this.level < this.levels) {
						var menuConstructor = dojo.getObject(this.menuWidget);
						return new menuConstructor(this.getInheritableParameters(item));
					}
					return null;
				},
				createItemRep: function(item) {
					var tabConstructor = dojo.getObject(this.tabWidget);
									
					var args = {
						label: com.ibm.domUtilities.encodeXML(this.model.getLabel(item)),
						iconClass: "dragHandleIcon",
						model: this.model,
						item: item
					};
					if(this.tabClass) {
						args["class"]= this.tabClass;
					}
					if(this.model.mayHaveChildren(item) || this.showNestedInlineEditor) {
						var popup = this._getPopup(item);
						if(popup) args.popup = popup;
					}
					
					var childWidget = new tabConstructor(args);
					childWidget.startup();
					
					// don't load the popup immediately
					// if(childWidget.popup) childWidget.popup.load(); 
					return childWidget; 
				},
				handleChildChildrenChange: function(child, children) {
					// summary: Called when a child that has no children gets children or when a child that has children
					//		loses all its children.
					if(!this.showNestedInlineEditor) {
						if(children.length == 0) {
							// child lost all children, destroy its popup
							child.destroyPopup();
							child.attr("hasChildren", false);
						}
						else if(!child.popup){
							// child without children got new children, create its popup
							var popup = this._getPopup(child.item);
							if(popup) {
								child.setPopup(popup);
								child.attr("hasChildren", true);
								popup.load();
								this.onItemHover(child);
							}
						}
					}
				},
				onItemFocus: function(child) {
					if(child.popup) child.popup.load();
					this.inherited(arguments);
				},
				onItemHover: function(child, evt) {
					if(child.popup) child.popup.load();
					this.inherited(arguments);
				},
				onItemClick: function(child, evt) {
					if(child.attr("disabled")) return false; 
					child.onClick(evt);
					if(child.item) this.onModelItemClick(child, child.item);
				}
			}
);

dojo.declare("com.ibm.widgets.DataTab",
			com.ibm.widgets.Tab,
			{
				_setHasChildrenAttr: function(value) {
					this.hasChildren = value;
					dojo[value ? "addClass" : "removeClass"](this.domNode, "modelHasChildren");
				},
				_setDndStatusAttr: function(value) {
					this.dndStatus = value;
					if(this.popup) {
						this.popup[value ? "setupDnd" : "disableDnd"]();
					}
				},
				item: null	// type is string so we can process parsed attributes as strings
			}
);

dojo.declare( "com.ibm.widgets.LoadingTab",
			com.ibm.widgets._TabBase,
			{
				templateString:"<li class=\"${class}\" waiRole=\"presentation\" dojoAttachPoint=\"containerNode\" dojoAttachEvent=\"onclick:onClick,onmouseenter:_onHover,onmouseleave:_onUnhover\"\n\t><div\n\t\t><img alt=\"\" dojoAttachPoint=\"iconNode\" src=\"${_blankGif}\" class=\"${iconClass}\"\n\t\t/><a dojoAttachPoint=\"labelNode,focusNode\" href=\"javascript:;\" class=\"tabLabel\" waiRole=\"tab\" onclick=\"javascript:return false;\">${label}</a\n\t></div\n></li>\n",
				
				"class": "loadingTab lotusTab",
				
				iconClass: "ibmLoading",
				
				label: "Loading...",
				
				postMixInProperties: function() {
					this.shelfBundle = dojo.i18n.getLocalization("com.ibm.bundles", "Shelf");
					this.label=this.shelfBundle["shelf_loading"];
				},
				
				attributeMap: dojo.mixin(dojo.clone(dijit._Widget.prototype.attributeMap), {
					label: {node: "labelNode", type: "innerHTML"},
					iconClass: {node: "iconNode", type: "class" }
				}),
				
				isFocusable: function() {
					// loading tabs are not focusable because they provide no actionable
					// content and are simply indicators of an unready or pending status
					return false;
				}
			}
);

}

if(!dojo._hasResource["com.ibm.widgets.NavigationWidget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.widgets.NavigationWidget"] = true;
dojo.provide( "com.ibm.widgets.NavigationWidget" );

dojo.require( "com.ibm.widgets.DataTabBar" );
dojo.require( "com.ibm.widgets.DataMenu" );



dojo.declare( "com.ibm.widgets.NavigationWidget",
		com.ibm.widgets.DataTabBar,
		{
			
			menuWidget: "com.ibm.widgets.NavigationMenu",
			
			"class": "lotusTabContainer",
			
			tabListClass: "lotusTabs",
			
			tabClass: "lotusTab",
			
			// selectedClass: String the class added to the tab widget which is the
			//		currently selected tab.
			selectedClass: "lotusSelected",
			
			// menuBaseClass: String class to set as the base class of submenus.
			menuBaseClass: "lotusActionMenu",
			
			nestedInlineEditorLabel: "",
			
			// emptyContentsInlineEditorLabel: String used to display the label on inline editor
			//		widgets in the popup menu widgets beneath this level in the model 
			// 		if there are no children at those nodes in the model.
			emptyContentsInlineEditorLabel: "",
			
			constructor: function() {
				this.bundle = dojo.i18n.getLocalization("com.ibm.bundles", "NavWidget");
				this.inlineEditorLabel = this.bundle["nav_new_page_label"];
				this.inlineEditorDefaultValue = this.bundle["nav_new_page_default_value"];
				this.nestedInlineEditorLabel = this.bundle["nav_new_page_nested_label"];
				this.emptyContentsInlineEditorLabel = this.bundle["nav_new_page_empty_nested_label"];
				this.inlineEditorTitle = this.bundle["nav_new_page_title"];
			},
			
			postMixInProperties: function() {
				this.inherited(arguments);
				if(!this.embeddedEditorParams.invalidMessage) this.embeddedEditorParams.invalidMessage = this.bundle["nav_new_page_invalid_message"];
				if(!this.embeddedEditorParams.promptMessage) this.embeddedEditorParams.promptMessage = this.bundle["nav_new_page_prompt_message"];
			},
			
			postCreate: function() {
				this.inherited(arguments);
				dijit.setWaiRole(this.containerNode, "menubar");
				if (dojo.isOpera)
				{
					this.connect(this, "onLoad", function(){
						dojo.query(".ibmPortalList").addContent(" ");
					});
				}
			},	
			
			getInheritableParameters: function(item) {
				return dojo.mixin(this.inherited(arguments), {
					inlineEditorLabel: this.nestedInlineEditorLabel,
					emptyContentsInlineEditorLabel: this.emptyContentsInlineEditorLabel,
					"class": this.menuBaseClass
					/*
					,animateOpen: function() {
						var box = dojo.marginBox(this.domNode);
						var origH = this.domNode.parentNode.style.height,
							origW = this.domNode.parentNode.style.width 
							origD = this.domNode.style.display;
						dojo.style(this.domNode, "display", "none");
						dojo.style(this.domNode.parentNode, {
							"width": box.w + "px"
						});
						
						dojo.addClass(this.domNode.parentNode, "bordered");
						
						var dur = 200, anim = null;
						dojo.animateProperty({
							node: this.domNode.parentNode, 
							duration: 150, 
							properties: {
								height: { start:'0', end: box.h, unit:"px" }
							}
						});

						anim.onEnd = dojo.hitch(this, function() {
							dojo.style(this.domNode.parentNode, "height", origH);
							dojo.removeClass(this.domNode.parentNode, "bordered");
							dojo.style(this.domNode, "display", origD);
						});
						anim.play();
					}
					*/
				});
			}
		}
);

dojo.declare( "com.ibm.widgets.NavigationMenu",
		com.ibm.widgets.DataMenu,
		{	
			// emptyContentsInlineEditorLabel: String used to display the label on inline editor
			//		widgets in this widget if there are no children at this node in the model.
			emptyContentsInlineEditorLabel: "",
			
			"class": "lotusActionMenu",
			
			constructor: function() {
				this.bundle = dojo.i18n.getLocalization("com.ibm.bundles", "NavWidget");
				this.inlineEditorLabel = this.bundle["nav_new_page_label"];
				this.inlineEditorDefaultValue = this.bundle["nav_new_page_default_value"];
				this.nestedInlineEditorLabel = this.bundle["nav_new_page_nested_label"];
				this.emptyContentsInlineEditorLabel = this.bundle["nav_new_page_empty_nested_label"];
				this.inlineEditorTitle = this.bundle["nav_new_page_title"];
			},
			
			postMixInProperties: function() {
				this.inherited(arguments);
				if(!this.embeddedEditorParams.invalidMessage) this.embeddedEditorParams.invalidMessage = this.bundle["nav_new_page_invalid_message"];
				if(!this.embeddedEditorParams.promptMessage) this.embeddedEditorParams.promptMessage = this.bundle["nav_new_page_prompt_message"];
			},
			
			postCreate: function() {
				this.inherited(arguments);
				dijit.setWaiRole(this.containerNode, "navigation");
				if(this.showInlineEditor && this.level == 1) {
					this.connect(this, "onLoad", function() {
						if(this.inlineEditor) {
							if(this.getChildren().length < 2) {
								this.inlineEditor.editor.attr("value", this.emptyContentsInlineEditorLabel);
							}
						}
					});
					this.connect(this, "onModelRemoveChild", function(parentItem, childItem) {
						if(this.item == parentItem && this.getChildren().length < 2) {
							this.inlineEditor.editor.attr("value", this.emptyContentsInlineEditorLabel);
						}
					});
					this.connect(this, "onModelInsertChild", function(parentItem, childItem, nextSibling) {
						if(this.item == parentItem) {
							this.inlineEditor.editor.attr("value", this.inlineEditorLabel);
						}
					});
				}
			},
			getInheritableParameters: function(item) {
				return dojo.mixin(this.inherited(arguments), {
					emptyContentsInlineEditorLabel: this.emptyContentsInlineEditorLabel
					/*
					,animateOpen: function() {
						var box = dojo.marginBox(this.domNode);
						var origH = this.domNode.parentNode.style.height,
							origW = this.domNode.parentNode.style.width 
							origD = this.domNode.style.display;
						dojo.style(this.domNode, "display", "none");
						dojo.style(this.domNode.parentNode, {
							"height": box.h + "px"
						});
						
						dojo.addClass(this.domNode.parentNode, "bordered");
						
						var dur = 200, anim = null;
						anim = dojo.animateProperty({
							node: this.domNode.parentNode, 
							duration: 150, 
							properties: {
								width: { start:'0', end: box.w, unit:"px" }
							}
						})

						anim.onEnd = dojo.hitch(this, function() {
							dojo.style(this.domNode.parentNode, "width", origW);
							dojo.removeClass(this.domNode.parentNode, "bordered");
							dojo.style(this.domNode, "display", origD);
						});
						anim.play();
					}
					*/
				});
			}
		}
);

}

if(!dojo._hasResource["com.ibm.widgets.Breadcrumbs"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.widgets.Breadcrumbs"] = true;
dojo.provide("com.ibm.widgets.Breadcrumbs");







dojo.declare("com.ibm.widgets.Breadcrumbs",
			[dijit._Widget, dijit._Templated],
			{
				model: null,				// a selection model on which to base the breadcrumb trail
				treeModel: null,			// the tree model backing the selection model 
				item: null,					// the currently selected item with in the model
				parent: null,				// the parent of item
				siblings: {},				// an associative array of item => DOM node pairs
				startLevel: null,			// the number of the level to start rendering the breadcrumbs at
				levels: Number.MAX_VALUE,	// the number of levels to render in the trail, Number.MAX_VALUE is used to represent all levels
				renderSiblings: true,		// true if siblings of the current selection should be rendered in the trail
				newSiblingText: "",			// text to display in the link to create a new sibling item
				newSiblingDefaultValue: "",
				embeddedEditorWidget: "dijit.form.TextBox",
				allowNew: true,				// true if a link should be rendered allowing the user to create a new sibling item
				newEditor: null,			// a dijit.form.ValidationTextBox to create new pages
				embeddedEditorParams: {},	// parameters for the dijit.form.ValidationTextBox
				introText: "",				// text to display before the trail begins
				listDOM: "ul",				// the type of DOM node that holds the trail links
				itemDOM: "li",				// the type of DOM node to act as a trail node
				containerClass: "",			// the class to put on the outer container div to the trail
				listClass: "",				// the CSS class to put on the container of the trail links
				ancestorClass: "",			// the CSS class to put on any ancestor nodes in the trail
				siblingClass: "",			// the CSS class to put on any sibling nodes in the trail
				newClass: "",				// the CSS class to put on the link to create a new item
				ancestorSeparator: " > ",	// the text separation to put between ancestor nodes
				siblingSeparator: " | ",	// the text separation to put between sibling nodes
				templateString: '<div dojoAttachPoint="focusNode" class="${containerClass}"><span dojoAttachPoint="introTextNode"></span><${listDOM} dojoAttachPoint="trail" class="${listClass}"></${listDOM}></div>',
					
				constructor: function() {
					this.bundle = dojo.i18n.getLocalization("com.ibm.bundles", "NavWidget");
					this.theme = dojo.i18n.getLocalization("com.ibm.bundles", "Theme");
					this.introText = this.bundle["breadcrumb_intro"];
					this.newSiblingText = this.bundle["breadcrumb_new_page_label"];			
					this.newSiblingDefaultValue = this.bundle["nav_new_page_default_value"];
					this.currentlySelected = this.theme["currently_selected"];
				},
				
				postMixInProperties: function() {
					this.inherited(arguments);
					if(!this.embeddedEditorParams.invalidMessage) this.embeddedEditorParams.invalidMessage = this.bundle["nav_new_page_invalid_message"];
					if(!this.embeddedEditorParams.promptMessage) this.embeddedEditorParams.promptMessage = this.bundle["nav_new_page_prompt_message"];
				},
				
				postCreate: function(){
					// summary: populate some of the class variables and set up listeners
					//this.parent = this.model.getParent(this.item);
					// set up listeners on the model for when an item is removed/inserted/moved
					this.treeModel = this.model.treeModel;
					this.connect(this.model, "onSelectionPathChange", "redraw");
					this.connect(this.treeModel, "onTreeChange", "onModelTreeChange");
				},
				
				startup: function() {
					this.inherited(arguments);
					// populate the breadcrumbtail
					this.draw();
				},
					
				draw: function(){
					// summary: populates the breadcrumb trail with ancestors and siblings (if specified) to the current item
					var path = this.model.getPath();
					this.parent = path[1];
					if(path.length - this.startLevel <= 1){
						this.introTextNode.innerHTML = "";
						return;
					}
					this.introTextNode.innerHTML = this.introText;
					for(var i = 1; i < path.length && i <= this.levels && i < (path.length - this.startLevel); i++) {
						this.createDomLink(path[i], this.ancestorClass, this.ancestorSeparator, this.trail.firstChild);
					}
					// retrieve and add the siblings to the current item
					if(this.renderSiblings){	
						this.siblings = [];
						this.shelfBundle = dojo.i18n.getLocalization("com.ibm.bundles", "Shelf");
						var loading = document.createTextNode(this.shelfBundle["shelf_loading"]);
						this.trail.appendChild(loading);
						this.treeModel.getChildren(path[1], dojo.hitch(this, function(siblings){
							this.trail.removeChild(loading);
							// render the current item
							this.createDomText(path[0], this.siblingClass, this.siblingSeparator, null);
							// render the siblings
							var curPageId = this.treeModel.getIdentity(path[0]);
							dojo.forEach(siblings, function(sibling) {  
								if(curPageId != this.treeModel.getIdentity(sibling)) 
									this.siblings.push({item: sibling, node: this.createDomLink(sibling, this.siblingClass, this.siblingSeparator, null)});
							}, this)
							this.createEditBox();
						}));
					} else { // do not add siblings
						this.createDomText(path[0], this.siblingClass, this.siblingSeparator, null);
						this.createEditBox();
					}
				},
				
				redraw: function(/*Boolean*/ selectionChanged) {
					this.trail.innerHTML = "";
					this.draw();
				},
				
				onModelTreeChange: function(/*Item*/ childItem, /*Item*/ oldParentItem, /*Item*/ newParentItem, /*Item*/ nextSiblingItem) {
					// summary: Listens to changes in the tree model where items are inserted, deleted, or moved within the tree.
					// 		This only cares about insertions and deletions under the current selection's parent node.
					var currentlySelectedItem = this.model.getPath()[0];
					if(oldParentItem != newParentItem && childItem != currentlySelectedItem) {
						if(this.parent == oldParentItem) {
							this.onModelRemoveChild(childItem);
						}
						else if(this.parent == newParentItem) {
							var isNew = (!oldParentItem)?true:false;
							this.onModelInsertChild(childItem, isNew);
						}
					}
				},
				
				onModelRemoveChild: function(/*Item*/childItem){
					// summary: Responds to events which cause a node to be removed from the current selection's parent node
					// 		in the model either by moving or deletion of an item.
					// childItem: the item that was deleted
					var path = this.model.getPath();
					if(path.length - this.startLevel <= 1) return;
					for(var i = 0; i < this.siblings.length; i++) {
						if(childItem == this.siblings[i].item) {
							this.trail.removeChild(this.siblings[i].node);
							delete this.siblings[i].item;
							delete this.siblings[i].node;
							this.siblings.splice(i, 1);						
							return;
						}
					}
				},
				
				onModelInsertChild: function(/*Item*/childItem,/*bool*/isNew){
					// summary: Responds to events which cause a node to be inserted under the current selection's parent
					// 		node in the model either by moving or creation of a new item. 
					// childItem: the new/moved item
					// isNew: true if the child is new, as opposed to having been moved from a different parent
					var path = this.model.getPath();
					if(path.length - this.startLevel <= 1) return;
					if(this.renderSiblings){ 
						// this.item has a new sibling
						// find the new item editor link and insert the new sibling item BEFORE this node
						var editor = this.newEditor;
						var insertBefore = (editor)?editor.domNode:null;
						var node = this.createDomLink(childItem,this.siblingClass,this.siblingSeparator,insertBefore);
						if(isNew) dojo.addClass(node,"disabled");
						this.siblings.push({item: childItem, node: node});
						
						if(!childItem.created) {
							setTimeout(function(){
								dijit.focus(node);
							},0);
							var conn = dojo.connect(childItem, "onCreate", this, function(){
								node.firstChild.href = top.location.href + "?uri=" + this.treeModel.getIdentity(childItem);
								dojo.removeClass(node,"disabled");
								dojo.disconnect(conn);
							});
						}
					}
				},
				
				createDomLink: function(item, className, separator, node){
					// summary: creates a DOM node in the breadcrumb trail with a link as inner html
					// item: the item for which to create the DOM node
					// className: the CSS class to put on the new DOM node
					// separator: a text separator to append after the item link
					// node: a DOM item before which to place the new DOM link, null to place it at the end of the list
					var domItem = document.createElement(this.itemDOM);
					dojo.addClass(domItem, className);
					var link = document.createElement("a");
					domItem.appendChild(link);
					domItem.appendChild(document.createTextNode(separator));
					link.appendChild(document.createTextNode(this.treeModel.getLabel(item)));
					var url = top.location.href;
					// check to see if url has reference anchors or parameters, and if so, then discard them
					if(url.indexOf('#') > -1)
						url = url.substring(0, url.indexOf('#'));
					if(url.indexOf('?') > -1)
						url = url.substring(0, url.indexOf('?'));
					link.href = url + "?uri=" + this.treeModel.getIdentity(item);
					this.trail.insertBefore(domItem, node);
					return domItem;
				},
				
				createDomText: function(item, className, separator, node){
					// summary: creates a DOM node in the breadcrumb trail with plain text inner html
					// item: the item for which to create the DOM node
					// className: the CSS class to put on the new DOM node
					// separator: a text separator to append after the item text
					// node: a DOM item before which to place the new DOM text, null to place it at the end of the list
					var domItem = document.createElement(this.itemDOM);
					dojo.addClass(domItem, className);
					var hiddenText = dojo.create("span", {innerHTML: this.currentlySelected, className: "ibmPortalHiddenText"});
					var hiddenSpan = dojo.create("span");
					hiddenSpan.appendChild(hiddenText);
					domItem.appendChild(document.createTextNode(this.treeModel.getLabel(item)));
					domItem.appendChild(hiddenText);
					domItem.appendChild(document.createTextNode(separator));
					this.trail.insertBefore(domItem, node);
					return domItem;
				},
				
				createEditBox: function(){
					// summary: creates a link to create a new sibling item iff this.allowNew is true
					if(this.allowNew){
						this.newEditor = new com.ibm.widgets.BreadcrumbsEditor({
							embeddedEditorWidget: this.embeddedEditorWidget,
							embeddedEditorParams: this.embeddedEditorParams,
							"class": this.newClass,
							label: this.newSiblingText,
							defaultValue: this.newSiblingDefaultValue
						});
						
						this.newEditor.editor.width = "10em";
						this.newEditor.editor.lineHeight = "1.5em";
						
						//this.newEditor = new dijit.InlineEditBox({value:this.newSiblingText,width:"10em",lineheight:"1.5em",editor:"dijit.form.ValidationTextBox",editorParams:this.embeddedEditorParams},link);
						this.connect(this.newEditor, "onChange", "createNewSiblingItem");
						this.trail.appendChild(this.newEditor.domNode);
					}
				},
				
				onClickItem: function(item){
					// summary: redirects the browser to the url associated with item
					// item: the item with the link to redirect to
					if(!item.created) return false;
					top.location.href = top.location.href + "?uri=" + this.treeModel.getIdentity(item);
				},
				
				createNewSiblingItem: function(/*Object*/value, focus){
					// summary: triggered by the onChange event from the dijit.InlineEditBox used for creating new items
					// value: Object key-value map of attributes to set on the new item
					var newItem = null;
					var onComplete = function() {
						newItem.onCreate();
					}
					newItem = this.treeModel.newItem(dojo.mixin(value, {onComplete: onComplete, scope: this}),this.parent); // create the new item as a sibling to this.item
					newItem._onCreate = function(){ /*do nothing*/ };  // make sure _onCreate is a non null function
				}
				
			}
);

dojo.declare("com.ibm.widgets.BreadcrumbsEditor",
	[dijit._Widget, dijit._Templated, com.ibm.widgets.InlineEditorWrapper],
	{
		templateString: '<span class="inlineEditor ${class}" waiRole="presentation"><a dojoAttachPoint="editor,focusNode" class="newPageLink" href="javascript:;">${label}</a></span>'
		
	}
);

}

if(!dojo._hasResource["dojo.dnd.Mover"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Mover"] = true;
dojo.provide("dojo.dnd.Mover");




dojo.declare("dojo.dnd.Mover", null, {
	constructor: function(node, e, host){
		// summary: an object, which makes a node follow the mouse, 
		//	used as a default mover, and as a base class for custom movers
		// node: Node: a node (or node's id) to be moved
		// e: Event: a mouse event, which started the move;
		//	only pageX and pageY properties are used
		// host: Object?: object which implements the functionality of the move,
		//	 and defines proper events (onMoveStart and onMoveStop)
		this.node = dojo.byId(node);
		this.marginBox = {l: e.pageX, t: e.pageY};
		this.mouseButton = e.button;
		var h = this.host = host, d = node.ownerDocument, 
			firstEvent = dojo.connect(d, "onmousemove", this, "onFirstMove");
		this.events = [
			dojo.connect(d, "onmousemove", this, "onMouseMove"),
			dojo.connect(d, "onmouseup",   this, "onMouseUp"),
			// cancel text selection and text dragging
			dojo.connect(d, "ondragstart",   dojo.stopEvent),
			dojo.connect(d.body, "onselectstart", dojo.stopEvent),
			firstEvent
		];
		// notify that the move has started
		if(h && h.onMoveStart){
			h.onMoveStart(this);
		}
	},
	// mouse event processors
	onMouseMove: function(e){
		// summary: event processor for onmousemove
		// e: Event: mouse event
		dojo.dnd.autoScroll(e);
		var m = this.marginBox;
		this.host.onMove(this, {l: m.l + e.pageX, t: m.t + e.pageY});
		dojo.stopEvent(e);
	},
	onMouseUp: function(e){
		if(dojo.isWebKit && dojo.dnd._isMac && this.mouseButton == 2 ? 
				e.button == 0 : this.mouseButton == e.button){
			this.destroy();
		}
		dojo.stopEvent(e);
	},
	// utilities
	onFirstMove: function(){
		// summary: makes the node absolute; it is meant to be called only once. 
		// 	relative and absolutely positioned nodes are assumed to use pixel units
		var s = this.node.style, l, t, h = this.host;
		switch(s.position){
			case "relative":
			case "absolute":
				// assume that left and top values are in pixels already
				l = Math.round(parseFloat(s.left));
				t = Math.round(parseFloat(s.top));
				break;
			default:
				s.position = "absolute";	// enforcing the absolute mode
				var m = dojo.marginBox(this.node);
				// event.pageX/pageY (which we used to generate the initial
				// margin box) includes padding and margin set on the body.
				// However, setting the node's position to absolute and then
				// doing dojo.marginBox on it *doesn't* take that additional
				// space into account - so we need to subtract the combined
				// padding and margin.  We use getComputedStyle and
				// _getMarginBox/_getContentBox to avoid the extra lookup of
				// the computed style. 
				var b = dojo.doc.body;
				var bs = dojo.getComputedStyle(b);
				var bm = dojo._getMarginBox(b, bs);
				var bc = dojo._getContentBox(b, bs);
				l = m.l - (bc.l - bm.l);
				t = m.t - (bc.t - bm.t);
				break;
		}
		this.marginBox.l = l - this.marginBox.l;
		this.marginBox.t = t - this.marginBox.t;
		if(h && h.onFirstMove){
			h.onFirstMove(this);
		}
		dojo.disconnect(this.events.pop());
	},
	destroy: function(){
		// summary: stops the move, deletes all references, so the object can be garbage-collected
		dojo.forEach(this.events, dojo.disconnect);
		// undo global settings
		var h = this.host;
		if(h && h.onMoveStop){
			h.onMoveStop(this);
		}
		// destroy objects
		this.events = this.node = this.host = null;
	}
});

}

if(!dojo._hasResource["dojo.dnd.Moveable"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Moveable"] = true;
dojo.provide("dojo.dnd.Moveable");



dojo.declare("dojo.dnd.Moveable", null, {
	// object attributes (for markup)
	handle: "",
	delay: 0,
	skip: false,
	
	constructor: function(node, params){
		// summary: an object, which makes a node moveable
		// node: Node: a node (or node's id) to be moved
		// params: Object: an optional object with additional parameters;
		//	following parameters are recognized:
		//		handle: Node: a node (or node's id), which is used as a mouse handle
		//			if omitted, the node itself is used as a handle
		//		delay: Number: delay move by this number of pixels
		//		skip: Boolean: skip move of form elements
		//		mover: Object: a constructor of custom Mover
		this.node = dojo.byId(node);
		if(!params){ params = {}; }
		this.handle = params.handle ? dojo.byId(params.handle) : null;
		if(!this.handle){ this.handle = this.node; }
		this.delay = params.delay > 0 ? params.delay : 0;
		this.skip  = params.skip;
		this.mover = params.mover ? params.mover : dojo.dnd.Mover;
		this.events = [
			dojo.connect(this.handle, "onmousedown", this, "onMouseDown"),
			// cancel text selection and text dragging
			dojo.connect(this.handle, "ondragstart",   this, "onSelectStart"),
			dojo.connect(this.handle, "onselectstart", this, "onSelectStart")
		];
	},

	// markup methods
	markupFactory: function(params, node){
		return new dojo.dnd.Moveable(node, params);
	},

	// methods
	destroy: function(){
		// summary: stops watching for possible move, deletes all references, so the object can be garbage-collected
		dojo.forEach(this.events, dojo.disconnect);
		this.events = this.node = this.handle = null;
	},
	
	// mouse event processors
	onMouseDown: function(e){
		// summary: event processor for onmousedown, creates a Mover for the node
		// e: Event: mouse event
		if(this.skip && dojo.dnd.isFormElement(e)){ return; }
		if(this.delay){
			this.events.push(
				dojo.connect(this.handle, "onmousemove", this, "onMouseMove"),
				dojo.connect(this.handle, "onmouseup", this, "onMouseUp")
			);
			this._lastX = e.pageX;
			this._lastY = e.pageY;
		}else{
			this.onDragDetected(e);
		}
		dojo.stopEvent(e);
	},
	onMouseMove: function(e){
		// summary: event processor for onmousemove, used only for delayed drags
		// e: Event: mouse event
		if(Math.abs(e.pageX - this._lastX) > this.delay || Math.abs(e.pageY - this._lastY) > this.delay){
			this.onMouseUp(e);
			this.onDragDetected(e);
		}
		dojo.stopEvent(e);
	},
	onMouseUp: function(e){
		// summary: event processor for onmouseup, used only for delayed drags
		// e: Event: mouse event
		for(var i = 0; i < 2; ++i){
			dojo.disconnect(this.events.pop());
		}
		dojo.stopEvent(e);
	},
	onSelectStart: function(e){
		// summary: event processor for onselectevent and ondragevent
		// e: Event: mouse event
		if(!this.skip || !dojo.dnd.isFormElement(e)){
			dojo.stopEvent(e);
		}
	},
	
	// local events
	onDragDetected: function(/* Event */ e){
		// summary: called when the drag is detected,
		// responsible for creation of the mover
		new this.mover(this.node, e, this);
	},
	onMoveStart: function(/* dojo.dnd.Mover */ mover){
		// summary: called before every move operation
		dojo.publish("/dnd/move/start", [mover]);
		dojo.addClass(dojo.body(), "dojoMove"); 
		dojo.addClass(this.node, "dojoMoveItem"); 
	},
	onMoveStop: function(/* dojo.dnd.Mover */ mover){
		// summary: called after every move operation
		dojo.publish("/dnd/move/stop", [mover]);
		dojo.removeClass(dojo.body(), "dojoMove");
		dojo.removeClass(this.node, "dojoMoveItem");
	},
	onFirstMove: function(/* dojo.dnd.Mover */ mover){
		// summary: called during the very first move notification,
		//	can be used to initialize coordinates, can be overwritten.
		
		// default implementation does nothing
	},
	onMove: function(/* dojo.dnd.Mover */ mover, /* Object */ leftTop){
		// summary: called during every move notification,
		//	should actually move the node, can be overwritten.
		this.onMoving(mover, leftTop);
		var s = mover.node.style;
		s.left = leftTop.l + "px";
		s.top  = leftTop.t + "px";
		this.onMoved(mover, leftTop);
	},
	onMoving: function(/* dojo.dnd.Mover */ mover, /* Object */ leftTop){
		// summary: called before every incremental move,
		//	can be overwritten.
		
		// default implementation does nothing
	},
	onMoved: function(/* dojo.dnd.Mover */ mover, /* Object */ leftTop){
		// summary: called after every incremental move,
		//	can be overwritten.
		
		// default implementation does nothing
	}
});

}

if(!dojo._hasResource["dojo.dnd.move"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.move"] = true;
dojo.provide("dojo.dnd.move");




dojo.declare("dojo.dnd.move.constrainedMoveable", dojo.dnd.Moveable, {
	// object attributes (for markup)
	constraints: function(){},
	within: false,
	
	// markup methods
	markupFactory: function(params, node){
		return new dojo.dnd.move.constrainedMoveable(node, params);
	},

	constructor: function(node, params){
		// summary: an object, which makes a node moveable
		// node: Node: a node (or node's id) to be moved
		// params: Object: an optional object with additional parameters;
		//	following parameters are recognized:
		//		constraints: Function: a function, which calculates a constraint box,
		//			it is called in a context of the moveable object.
		//		within: Boolean: restrict move within boundaries.
		//	the rest is passed to the base class
		if(!params){ params = {}; }
		this.constraints = params.constraints;
		this.within = params.within;
	},
	onFirstMove: function(/* dojo.dnd.Mover */ mover){
		// summary: called during the very first move notification,
		//	can be used to initialize coordinates, can be overwritten.
		var c = this.constraintBox = this.constraints.call(this, mover);
		c.r = c.l + c.w;
		c.b = c.t + c.h;
		if(this.within){
			var mb = dojo.marginBox(mover.node);
			c.r -= mb.w;
			c.b -= mb.h;
		}
	},
	onMove: function(/* dojo.dnd.Mover */ mover, /* Object */ leftTop){
		// summary: called during every move notification,
		//	should actually move the node, can be overwritten.
		var c = this.constraintBox, s = mover.node.style;
		s.left = (leftTop.l < c.l ? c.l : c.r < leftTop.l ? c.r : leftTop.l) + "px";
		s.top  = (leftTop.t < c.t ? c.t : c.b < leftTop.t ? c.b : leftTop.t) + "px";
	}
});

dojo.declare("dojo.dnd.move.boxConstrainedMoveable", dojo.dnd.move.constrainedMoveable, {
	// object attributes (for markup)
	box: {},
	
	// markup methods
	markupFactory: function(params, node){
		return new dojo.dnd.move.boxConstrainedMoveable(node, params);
	},

	constructor: function(node, params){
		// summary: an object, which makes a node moveable
		// node: Node: a node (or node's id) to be moved
		// params: Object: an optional object with additional parameters;
		//	following parameters are recognized:
		//		box: Object: a constraint box
		//	the rest is passed to the base class
		var box = params && params.box;
		this.constraints = function(){ return box; };
	}
});

dojo.declare("dojo.dnd.move.parentConstrainedMoveable", dojo.dnd.move.constrainedMoveable, {
	// object attributes (for markup)
	area: "content",

	// markup methods
	markupFactory: function(params, node){
		return new dojo.dnd.move.parentConstrainedMoveable(node, params);
	},

	constructor: function(node, params){
		// summary: an object, which makes a node moveable
		// node: Node: a node (or node's id) to be moved
		// params: Object: an optional object with additional parameters;
		//	following parameters are recognized:
		//		area: String: a parent's area to restrict the move,
		//			can be "margin", "border", "padding", or "content".
		//	the rest is passed to the base class
		var area = params && params.area;
		this.constraints = function(){
			var n = this.node.parentNode, 
				s = dojo.getComputedStyle(n), 
				mb = dojo._getMarginBox(n, s);
			if(area == "margin"){
				return mb;	// Object
			}
			var t = dojo._getMarginExtents(n, s);
			mb.l += t.l, mb.t += t.t, mb.w -= t.w, mb.h -= t.h;
			if(area == "border"){
				return mb;	// Object
			}
			t = dojo._getBorderExtents(n, s);
			mb.l += t.l, mb.t += t.t, mb.w -= t.w, mb.h -= t.h;
			if(area == "padding"){
				return mb;	// Object
			}
			t = dojo._getPadExtents(n, s);
			mb.l += t.l, mb.t += t.t, mb.w -= t.w, mb.h -= t.h;
			return mb;	// Object
		};
	}
});

// WARNING: below are obsolete objects, instead of custom movers use custom moveables (above)

dojo.dnd.move.constrainedMover = function(fun, within){
	// summary: returns a constrained version of dojo.dnd.Mover
	// description: this function produces n object, which will put a constraint on 
	//	the margin box of dragged object in absolute coordinates
	// fun: Function: called on drag, and returns a constraint box
	// within: Boolean: if true, constraints the whole dragged object withtin the rectangle, 
	//	otherwise the constraint is applied to the left-top corner
	dojo.deprecated("dojo.dnd.move.constrainedMover, use dojo.dnd.move.constrainedMoveable instead");
	var mover = function(node, e, notifier){
		dojo.dnd.Mover.call(this, node, e, notifier);
	};
	dojo.extend(mover, dojo.dnd.Mover.prototype);
	dojo.extend(mover, {
		onMouseMove: function(e){
			// summary: event processor for onmousemove
			// e: Event: mouse event
			dojo.dnd.autoScroll(e);
			var m = this.marginBox, c = this.constraintBox,
				l = m.l + e.pageX, t = m.t + e.pageY;
			l = l < c.l ? c.l : c.r < l ? c.r : l;
			t = t < c.t ? c.t : c.b < t ? c.b : t;
			this.host.onMove(this, {l: l, t: t});
		},
		onFirstMove: function(){
			// summary: called once to initialize things; it is meant to be called only once
			dojo.dnd.Mover.prototype.onFirstMove.call(this);
			var c = this.constraintBox = fun.call(this);
			c.r = c.l + c.w;
			c.b = c.t + c.h;
			if(within){
				var mb = dojo.marginBox(this.node);
				c.r -= mb.w;
				c.b -= mb.h;
			}
		}
	});
	return mover;	// Object
};

dojo.dnd.move.boxConstrainedMover = function(box, within){
	// summary: a specialization of dojo.dnd.constrainedMover, which constrains to the specified box
	// box: Object: a constraint box (l, t, w, h)
	// within: Boolean: if true, constraints the whole dragged object withtin the rectangle, 
	//	otherwise the constraint is applied to the left-top corner
	dojo.deprecated("dojo.dnd.move.boxConstrainedMover, use dojo.dnd.move.boxConstrainedMoveable instead");
	return dojo.dnd.move.constrainedMover(function(){ return box; }, within);	// Object
};

dojo.dnd.move.parentConstrainedMover = function(area, within){
	// summary: a specialization of dojo.dnd.constrainedMover, which constrains to the parent node
	// area: String: "margin" to constrain within the parent's margin box, "border" for the border box,
	//	"padding" for the padding box, and "content" for the content box; "content" is the default value.
	// within: Boolean: if true, constraints the whole dragged object withtin the rectangle, 
	//	otherwise the constraint is applied to the left-top corner
	dojo.deprecated("dojo.dnd.move.parentConstrainedMover, use dojo.dnd.move.parentConstrainedMoveable instead");
	var fun = function(){
		var n = this.node.parentNode, 
			s = dojo.getComputedStyle(n), 
			mb = dojo._getMarginBox(n, s);
		if(area == "margin"){
			return mb;	// Object
		}
		var t = dojo._getMarginExtents(n, s);
		mb.l += t.l, mb.t += t.t, mb.w -= t.w, mb.h -= t.h;
		if(area == "border"){
			return mb;	// Object
		}
		t = dojo._getBorderExtents(n, s);
		mb.l += t.l, mb.t += t.t, mb.w -= t.w, mb.h -= t.h;
		if(area == "padding"){
			return mb;	// Object
		}
		t = dojo._getPadExtents(n, s);
		mb.l += t.l, mb.t += t.t, mb.w -= t.w, mb.h -= t.h;
		return mb;	// Object
	};
	return dojo.dnd.move.constrainedMover(fun, within);	// Object
};

// patching functions one level up for compatibility

dojo.dnd.constrainedMover = dojo.dnd.move.constrainedMover;
dojo.dnd.boxConstrainedMover = dojo.dnd.move.boxConstrainedMover;
dojo.dnd.parentConstrainedMover = dojo.dnd.move.parentConstrainedMover;

}

if(!dojo._hasResource["dojo.dnd.TimedMoveable"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.TimedMoveable"] = true;
dojo.provide("dojo.dnd.TimedMoveable");



(function(){
	// precalculate long expressions
	var oldOnMove = dojo.dnd.Moveable.prototype.onMove;
		
	dojo.declare("dojo.dnd.TimedMoveable", dojo.dnd.Moveable, {
		// summary:
		//	A specialized version of Moveable to support an FPS throttling.
		//	This class puts an upper restriction on FPS, which may reduce 
		//	the CPU load. The additional parameter "timeout" regulates
		//	the delay before actually moving the moveable object.
		
		// object attributes (for markup)
		timeout: 40,	// in ms, 40ms corresponds to 25 fps
	
		constructor: function(node, params){
			// summary: an object, which makes a node moveable with a timer
			// node: Node: a node (or node's id) to be moved
			// params: Object: an optional object with additional parameters.
			//	See dojo.dnd.Moveable for details on general parameters.
			//	Following parameters are specific for this class:
			//		timeout: Number: delay move by this number of ms
			//			accumulating position changes during the timeout
			
			// sanitize parameters
			if(!params){ params = {}; }
			if(params.timeout && typeof params.timeout == "number" && params.timeout >= 0){
				this.timeout = params.timeout;
			}
		},
	
		// markup methods
		markupFactory: function(params, node){
			return new dojo.dnd.TimedMoveable(node, params);
		},
	
		onMoveStop: function(/* dojo.dnd.Mover */ mover){
			if(mover._timer){
				// stop timer
				clearTimeout(mover._timer)
				// reflect the last received position
				oldOnMove.call(this, mover, mover._leftTop)
			}
			dojo.dnd.Moveable.prototype.onMoveStop.apply(this, arguments);
		},
		onMove: function(/* dojo.dnd.Mover */ mover, /* Object */ leftTop){
			mover._leftTop = leftTop;
			if(!mover._timer){
				var _t = this;	// to avoid using dojo.hitch()
				mover._timer = setTimeout(function(){
					// we don't have any pending requests
					mover._timer = null;
					// reflect the last received position
					oldOnMove.call(_t, mover, mover._leftTop);
				}, this.timeout);
			}
		}
	});
})();

}

if(!dojo._hasResource["dijit._DialogMixin"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._DialogMixin"] = true;
dojo.provide("dijit._DialogMixin");

dojo.declare("dijit._DialogMixin", null,
	{
		// summary:
		//		This provides functions useful to Dialog and TooltipDialog

		attributeMap: dijit._Widget.prototype.attributeMap,

		execute: function(/*Object*/ formContents){
			// summary:
			//		Callback when the user hits the submit button.
			//		Override this method to handle Dialog execution.
			// description:
			//		After the user has pressed the submit button, the Dialog
			//		first calls onExecute() to notify the container to hide the
			//		dialog and restore focus to wherever it used to be.
			//
			//		*Then* this method is called.
			// type:
			//		callback
		},

		onCancel: function(){
			// summary:
			//	    Called when user has pressed the Dialog's cancel button, to notify container.
			// description:
			//	    Developer shouldn't override or connect to this method;
			//		it's a private communication device between the TooltipDialog
			//		and the thing that opened it (ex: `dijit.form.DropDownButton`)
			// type:
			//		protected
		},

		onExecute: function(){
			// summary:
			//	    Called when user has pressed the dialog's OK button, to notify container.
			// description:
			//	    Developer shouldn't override or connect to this method;
			//		it's a private communication device between the TooltipDialog
			//		and the thing that opened it (ex: `dijit.form.DropDownButton`)
			// type:
			//		protected
		},

		_onSubmit: function(){
			// summary:
			//		Callback when user hits submit button
			// type:
			//		protected
			this.onExecute();	// notify container that we are about to execute
			this.execute(this.attr('value'));
		},

		_getFocusItems: function(/*Node*/ dialogNode){
			// summary:
			//		Find focusable Items each time a dialog is opened,
			//		setting _firstFocusItem and _lastFocusItem
			// tags:
			//		protected
			
			var elems = dijit._getTabNavigable(dojo.byId(dialogNode));
			this._firstFocusItem = elems.lowest || elems.first || dialogNode;
			this._lastFocusItem = elems.last || elems.highest || this._firstFocusItem;
			if(dojo.isMoz && this._firstFocusItem.tagName.toLowerCase() == "input" && dojo.attr(this._firstFocusItem, "type").toLowerCase() == "file"){
					//FF doesn't behave well when first element is input type=file, set first focusable to dialog container
					dojo.attr(dialogNode, "tabindex", "0");
					this._firstFocusItem = dialogNode;
			}
		}
	}
);

}

if(!dojo._hasResource["dijit.DialogUnderlay"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.DialogUnderlay"] = true;
dojo.provide("dijit.DialogUnderlay");




dojo.declare(
	"dijit.DialogUnderlay",
	[dijit._Widget, dijit._Templated],
	{
		// summary: The component that blocks the screen behind a `dijit.Dialog`
		//
		// description:
		// 		A component used to block input behind a `dijit.Dialog`. Only a single
		//		instance of this widget is created by `dijit.Dialog`, and saved as 
		//		a reference to be shared between all Dialogs as `dijit._underlay`
		//	
		//		The underlay itself can be styled based on and id:
		//	|	#myDialog_underlay { background-color:red; }
		//
		//		In the case of `dijit.Dialog`, this id is based on the id of the Dialog,
		//		suffixed with _underlay. 
		
		// Template has two divs; outer div is used for fade-in/fade-out, and also to hold background iframe.
		// Inner div has opacity specified in CSS file.
		templateString: "<div class='dijitDialogUnderlayWrapper'><div class='dijitDialogUnderlay' dojoAttachPoint='node'></div></div>",

		// Parameters on creation or updatable later

		// dialogId: String
		//		Id of the dialog.... DialogUnderlay's id is based on this id
		dialogId: "",

		// class: String
		//		This class name is used on the DialogUnderlay node, in addition to dijitDialogUnderlay
		"class": "",

		attributeMap: { id: "domNode" },

		_setDialogIdAttr: function(id){
			dojo.attr(this.node, "id", id + "_underlay");
		},

		_setClassAttr: function(clazz){
			this.node.className = "dijitDialogUnderlay " + clazz;
		},

		postCreate: function(){
			// summary:
			//		Append the underlay to the body
			dojo.body().appendChild(this.domNode);
			this.bgIframe = new dijit.BackgroundIframe(this.domNode);
		},

		layout: function(){
			// summary:
			//		Sets the background to the size of the viewport
			//
			// description:
			//		Sets the background to the size of the viewport (rather than the size
			//		of the document) since we need to cover the whole browser window, even
			//		if the document is only a few lines long.
			// tags:
			//		private

			var is = this.node.style,
				os = this.domNode.style;

			// hide the background temporarily, so that the background itself isn't
			// causing scrollbars to appear (might happen when user shrinks browser
			// window and then we are called to resize)
			os.display = "none";

			// then resize and show
			var viewport = dijit.getViewport();
			os.top = viewport.t + "px";
			os.left = viewport.l + "px";
			is.width = viewport.w + "px";
			is.height = viewport.h + "px";
			os.display = "block";
		},

		show: function(){
			// summary:
			//		Show the dialog underlay
			this.domNode.style.display = "block";
			this.layout();
			if(this.bgIframe.iframe){
				this.bgIframe.iframe.style.display = "block";
			}
		},

		hide: function(){
			// summary:
			//		Hides the dialog underlay
			this.domNode.style.display = "none";
			if(this.bgIframe.iframe){
				this.bgIframe.iframe.style.display = "none";
			}
		},

		uninitialize: function(){
			if(this.bgIframe){
				this.bgIframe.destroy();
			}
		}
	}
);

}

if(!dojo._hasResource["dijit.TooltipDialog"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.TooltipDialog"] = true;
dojo.provide("dijit.TooltipDialog");






dojo.declare(
		"dijit.TooltipDialog",
		[dijit.layout.ContentPane, dijit._Templated, dijit.form._FormMixin, dijit._DialogMixin],
		{
			// summary:
			//		Pops up a dialog that appears like a Tooltip

			// title: String
			// 		Description of tooltip dialog (required for a11y)
			title: "",

			// doLayout: [protected] Boolean
			//		Don't change this parameter from the default value.
			//		This ContentPane parameter doesn't make sense for TooltipDialog, since TooltipDialog
			//		is never a child of a layout container, nor can you specify the size of
			//		TooltipDialog in order to control the size of an inner widget. 
			doLayout: false,

			// autofocus: Boolean
			// 		A Toggle to modify the default focus behavior of a Dialog, which
			// 		is to focus on the first dialog element after opening the dialog.
			//		False will disable autofocusing. Default: true
			autofocus: true,

			// baseClass: [protected] String
			//		The root className to use for the various states of this widget
			baseClass: "dijitTooltipDialog",

			// _firstFocusItem: [private] [readonly] DomNode
			//		The pointer to the first focusable node in the dialog.
			//		Set by `dijit._DialogMixin._getFocusItems`.
			_firstFocusItem: null,

			// _lastFocusItem: [private] [readonly] DomNode
			//		The pointer to which node has focus prior to our dialog.
			//		Set by `dijit._DialogMixin._getFocusItems`.
			_lastFocusItem: null,

			templateString: null,
			templateString:"<div waiRole=\"presentation\">\n\t<div class=\"dijitTooltipContainer\" waiRole=\"presentation\">\n\t\t<div class =\"dijitTooltipContents dijitTooltipFocusNode\" dojoAttachPoint=\"containerNode\" tabindex=\"-1\" waiRole=\"dialog\"></div>\n\t</div>\n\t<div class=\"dijitTooltipConnector\" waiRole=\"presentation\"></div>\n</div>\n",

			postCreate: function(){
				this.inherited(arguments);
				this.connect(this.containerNode, "onkeypress", "_onKey");
				this.containerNode.title = this.title;
			},

			orient: function(/*DomNode*/ node, /*String*/ aroundCorner, /*String*/ corner){
				// summary:
				//		Configure widget to be displayed in given position relative to the button.
				//		This is called from the dijit.popup code, and should not be called
				//		directly.
				// tags:
				//		protected
				var c = this._currentOrientClass;
				if(c){
					dojo.removeClass(this.domNode, c);
				}
				c = "dijitTooltipAB"+(corner.charAt(1)=='L'?"Left":"Right")+" dijitTooltip"+(corner.charAt(0)=='T' ? "Below" : "Above");
				dojo.addClass(this.domNode, c);
				this._currentOrientClass = c;
			},

			onOpen: function(/*Object*/ pos){
				// summary:
				//		Called when dialog is displayed.
				//		This is called from the dijit.popup code, and should not be called directly.
				// tags:
				//		protected
			
				this.orient(this.domNode,pos.aroundCorner, pos.corner);
				this._onShow(); // lazy load trigger
				
				if(this.autofocus){
					this._getFocusItems(this.containerNode);
					dijit.focus(this._firstFocusItem);
				}
			},
			
			_onKey: function(/*Event*/ evt){
				// summary:
				//		Handler for keyboard events
				// description:
				//		Keep keyboard focus in dialog; close dialog on escape key
				// tags:
				//		private

				var node = evt.target;
				var dk = dojo.keys;
				if (evt.charOrCode === dk.TAB){
					this._getFocusItems(this.containerNode);
				}
				var singleFocusItem = (this._firstFocusItem == this._lastFocusItem);
				if(evt.charOrCode == dk.ESCAPE){
					this.onCancel();
					dojo.stopEvent(evt);
				}else if(node == this._firstFocusItem && evt.shiftKey && evt.charOrCode === dk.TAB){
					if(!singleFocusItem){
						dijit.focus(this._lastFocusItem); // send focus to last item in dialog
					}
					dojo.stopEvent(evt);
				}else if(node == this._lastFocusItem && evt.charOrCode === dk.TAB && !evt.shiftKey){
					if(!singleFocusItem){
						dijit.focus(this._firstFocusItem); // send focus to first item in dialog
					}
					dojo.stopEvent(evt);
				}else if(evt.charOrCode === dk.TAB){
					// we want the browser's default tab handling to move focus
					// but we don't want the tab to propagate upwards
					evt.stopPropagation();
				}
			}
		}	
	);

}

if(!dojo._hasResource["dijit.Dialog"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.Dialog"] = true;
dojo.provide("dijit.Dialog");













/*=====
dijit._underlay = function(kwArgs){
	// summary:
	//		A shared instance of a `dijit.DialogUnderlay`
	//
	// description: 
	//		A shared instance of a `dijit.DialogUnderlay` created and
	//		used by `dijit.Dialog`, though never created until some Dialog
	//		or subclass thereof is shown.
};
=====*/

dojo.declare(
	"dijit.Dialog",
	[dijit.layout.ContentPane, dijit._Templated, dijit.form._FormMixin, dijit._DialogMixin],
	{
		// summary:
		//		A modal dialog Widget
		//
		// description:
		//		Pops up a modal dialog window, blocking access to the screen
		//		and also graying out the screen Dialog is extended from
		//		ContentPane so it supports all the same parameters (href, etc.)
		//
		// example:
		// |	<div dojoType="dijit.Dialog" href="test.html"></div>
		//
		// example:
		// |	var foo = new dijit.Dialog({ title: "test dialog", content: "test content" };
		// |	dojo.body().appendChild(foo.domNode);
		// |	foo.startup();
		
		templateString: null,
		templateString:"<div class=\"dijitDialog\" tabindex=\"-1\" waiRole=\"dialog\" waiState=\"labelledby-${id}_title\">\n\t<div dojoAttachPoint=\"titleBar\" class=\"dijitDialogTitleBar\">\n\t<span dojoAttachPoint=\"titleNode\" class=\"dijitDialogTitle\" id=\"${id}_title\"></span>\n\t<span dojoAttachPoint=\"closeButtonNode\" class=\"dijitDialogCloseIcon\" dojoAttachEvent=\"onclick: onCancel, onmouseenter: _onCloseEnter, onmouseleave: _onCloseLeave\" title=\"${buttonCancel}\">\n\t\t<span dojoAttachPoint=\"closeText\" class=\"closeText\" title=\"${buttonCancel}\">x</span>\n\t</span>\n\t</div>\n\t\t<div dojoAttachPoint=\"containerNode\" class=\"dijitDialogPaneContent\"></div>\n</div>\n",
		attributeMap: dojo.delegate(dijit._Widget.prototype.attributeMap, {
			title: [
				{ node: "titleNode", type: "innerHTML" }, 
				{ node: "titleBar", type: "attribute" }
			]
		}),

		// open: Boolean
		//		True if Dialog is currently displayed on screen.
		open: false,

		// duration: Integer
		//		The time in milliseconds it takes the dialog to fade in and out
		duration: dijit.defaultDuration,

		// refocus: Boolean
		// 		A Toggle to modify the default focus behavior of a Dialog, which
		// 		is to re-focus the element which had focus before being opened.
		//		False will disable refocusing. Default: true
		refocus: true,
		
		// autofocus: Boolean
		// 		A Toggle to modify the default focus behavior of a Dialog, which
		// 		is to focus on the first dialog element after opening the dialog.
		//		False will disable autofocusing. Default: true
		autofocus: true,

		// _firstFocusItem: [private] [readonly] DomNode
		//		The pointer to the first focusable node in the dialog.
		//		Set by `dijit._DialogMixin._getFocusItems`.
		_firstFocusItem: null,
		
		// _lastFocusItem: [private] [readonly] DomNode
		//		The pointer to which node has focus prior to our dialog.
		//		Set by `dijit._DialogMixin._getFocusItems`.
		_lastFocusItem: null,

		// doLayout: [protected] Boolean
		//		Don't change this parameter from the default value.
		//		This ContentPane parameter doesn't make sense for Dialog, since Dialog
		//		is never a child of a layout container, nor can you specify the size of
		//		Dialog in order to control the size of an inner widget. 
		doLayout: false,

		// draggable: Boolean
		//		Toggles the moveable aspect of the Dialog. If true, Dialog
		//		can be dragged by it's title. If false it will remain centered
		//		in the viewport.
		draggable: true,

		// _fixSizes: Boolean
		//		Does this Dialog attempt to restore the width and height after becoming too small?
		_fixSizes: true,

		postMixInProperties: function(){
			var _nlsResources = dojo.i18n.getLocalization("dijit", "common");
			dojo.mixin(this, _nlsResources);
			this.inherited(arguments);
		},

		postCreate: function(){
			dojo.style(this.domNode, {
				visibility:"hidden",
				position:"absolute",
				display:"",
				top:"-9999px"
			});
			dojo.body().appendChild(this.domNode);

			this.inherited(arguments);

			this.connect(this, "onExecute", "hide");
			this.connect(this, "onCancel", "hide");
			this._modalconnects = [];
		},

		onLoad: function(){
			// summary:
			//		Called when data has been loaded from an href.
			//		Unlike most other callbacks, this function can be connected to (via `dojo.connect`)
			//		but should *not* be overriden.
			// tags:
			//		callback
			
			// when href is specified we need to reposition the dialog after the data is loaded
			this._position();
			this.inherited(arguments);
		},

		_endDrag: function(e){
			// summary:
			//		Called after dragging the Dialog. Calculates the relative offset
			//		of the Dialog in relation to the viewport.
			// tags:
			//		private
			if(e && e.node && e.node === this.domNode){
				var vp = dijit.getViewport(); 
				var p = e._leftTop || dojo.coords(e.node,true);
				this._relativePosition = {
					t: p.t - vp.t,
					l: p.l - vp.l
				}			
			}
		},
		
		_setup: function(){
			// summary: 
			//		Stuff we need to do before showing the Dialog for the first
			//		time (but we defer it until right beforehand, for
			//		performance reasons).
			// tags:
			//		private

			var node = this.domNode;

			if(this.titleBar && this.draggable){
				this._moveable = (dojo.isIE == 6) ?
					new dojo.dnd.TimedMoveable(node, { handle: this.titleBar }) :	// prevent overload, see #5285
					new dojo.dnd.Moveable(node, { handle: this.titleBar, timeout: 0 });
				dojo.subscribe("/dnd/move/stop",this,"_endDrag");
			}else{
				dojo.addClass(node,"dijitDialogFixed"); 
			}
			
			this.underlayAttrs = {
				dialogId: this.id,
				"class": dojo.map(this["class"].split(/\s/), function(s){ return s+"_underlay"; }).join(" ")
			};
			
			this._fadeIn = dojo.fadeIn({
				node: node,
				duration: this.duration,
				beforeBegin: dojo.hitch(this, function(){
					var underlay = dijit._underlay;
					if(!underlay){ 
						underlay = dijit._underlay = new dijit.DialogUnderlay(this.underlayAttrs); 
					}else{
						underlay.attr(this.underlayAttrs);
					}
					
					dojo.style(dijit._underlay.domNode, 'zIndex', 948 + dijit._dialogStack.length*2);
					dojo.style(this.domNode, 'zIndex', 949 + dijit._dialogStack.length*2);
					underlay.show();
				}),
				onEnd:	dojo.hitch(this, function(){
					if(this.autofocus){
						// find focusable Items each time dialog is shown since if dialog contains a widget the 
						// first focusable items can change
						this._getFocusItems(this.domNode);
						dijit.focus(this._firstFocusItem);
					}
				})
			 });

			this._fadeOut = dojo.fadeOut({
				node: node,
				duration: this.duration,
				onEnd: dojo.hitch(this, function(){
					node.style.visibility="hidden";
					node.style.top = "-9999px";
					
					// Restore the previous dialog in the stack, or if this is the only dialog
					// then restore to original page
					var ds = dijit._dialogStack;
					if(ds.length == 0){
						dijit._underlay.hide();
					}else{
						dojo.style(dijit._underlay.domNode, 'zIndex', 948 + ds.length*2);
						dijit._underlay.attr(ds[ds.length-1].underlayAttrs);
					}

					// Restore focus to wherever it was before this dialog was displayed
					if(this.refocus){
						var focus = this._savedFocus;

						// If we are returning control to a previous dialog but for some reason
						// that dialog didn't have a focused field, set focus to first focusable item.
						// This situation could happen if two dialogs appeared at nearly the same time, 
						// since a dialog doesn't set it's focus until the fade-in is finished.
						if(ds.length > 0){
							var pd = ds[ds.length-1];
							if(!dojo.isDescendant(focus.node, pd.domNode)){
								pd._getFocusItems(pd.domNode);
								focus = pd._firstFocusItem;
							}
						}

						dijit.focus(focus);
					}
				})
			 });
		},

		uninitialize: function(){
			var wasPlaying = false;
			if(this._fadeIn && this._fadeIn.status() == "playing"){
				wasPlaying = true;
				this._fadeIn.stop();
			}
			if(this._fadeOut && this._fadeOut.status() == "playing"){
				wasPlaying = true;
				this._fadeOut.stop();
			}
			if(this.open || wasPlaying){
				dijit._underlay.hide();
			}
			if(this._moveable){
				this._moveable.destroy();
			}
		},

		_size: function(){
			// summary:
			// 		Make sure the dialog is small enough to fit in viewport.
			// tags:
			//		private

			var mb = dojo.marginBox(this.domNode);
			var viewport = dijit.getViewport();
			if(mb.w >= viewport.w || mb.h >= viewport.h){
				dojo.style(this.containerNode, {
					width: Math.min(mb.w, Math.floor(viewport.w * 0.75))+"px",
					height: Math.min(mb.h, Math.floor(viewport.h * 0.75))+"px",
					overflow: "auto",
					position: "relative"	// workaround IE bug moving scrollbar or dragging dialog
				});
			}
		},

		_position: function(){
			// summary:
			//		Position modal dialog in the viewport. If no relative offset
			//		in the viewport has been determined (by dragging, for instance),
			//		center the node. Otherwise, use the Dialog's stored relative offset,
			//		and position the node to top: left: values based on the viewport.
			// tags:
			//		private
			if(!dojo.hasClass(dojo.body(),"dojoMove")){
				var node = this.domNode,
					viewport = dijit.getViewport(),
					p = this._relativePosition,
					mb = p ? null : dojo.marginBox(node),
					l = Math.floor(viewport.l + (p ? p.l : (viewport.w - mb.w) / 2)),
					t = Math.floor(viewport.t + (p ? p.t : (viewport.h - mb.h) / 2))
				;
				dojo.style(node,{
					left: l + "px",
					top: t + "px"
				});
			}
		},
		
		_onKey: function(/*Event*/ evt){
			// summary:
			//		Handles the keyboard events for accessibility reasons
			// tags:
			//		private

			var ds = dijit._dialogStack;		
			if(ds[ds.length-1] != this){
				// console.debug(this.id + ': skipping because', this, 'is not the active dialog');
				return;
			}

			if(evt.charOrCode){
				var dk = dojo.keys;
				var node = evt.target;
				if (evt.charOrCode === dk.TAB){
					this._getFocusItems(this.domNode);
				}
				var singleFocusItem = (this._firstFocusItem == this._lastFocusItem);
				// see if we are shift-tabbing from first focusable item on dialog
				if(node == this._firstFocusItem && evt.shiftKey && evt.charOrCode === dk.TAB){
					if(!singleFocusItem){
						dijit.focus(this._lastFocusItem); // send focus to last item in dialog
					}
					dojo.stopEvent(evt);
				}else if(node == this._lastFocusItem && evt.charOrCode === dk.TAB && !evt.shiftKey){
					if (!singleFocusItem){
						dijit.focus(this._firstFocusItem); // send focus to first item in dialog
					}
					dojo.stopEvent(evt);
				}else{
					// see if the key is for the dialog
					while(node){
						if(node == this.domNode){
							if(evt.charOrCode == dk.ESCAPE){
								this.onCancel(); 
							}else{
								return; // just let it go
							}
						}
						node = node.parentNode;
					}
					// this key is for the disabled document window
					if(evt.charOrCode !== dk.TAB){ // allow tabbing into the dialog for a11y
						dojo.stopEvent(evt);
					// opera won't tab to a div
					}else if(!dojo.isOpera){
						try{
							this._firstFocusItem.focus();
						}catch(e){ /*squelch*/ }
					}
				}
			}
		},

		show: function(){
			// summary:
			//		Display the dialog
			if(this.open){ return; }

			// first time we show the dialog, there's some initialization stuff to do			
			if(!this._alreadyInitialized){
				this._setup();
				this._alreadyInitialized=true;
			}

			if(this._fadeOut.status() == "playing"){
				this._fadeOut.stop();
			}

			this._modalconnects.push(dojo.connect(window, "onscroll", this, "layout"));
			this._modalconnects.push(dojo.connect(window, "onresize", this, function(){
				// IE gives spurious resize events and can actually get stuck
				// in an infinite loop if we don't ignore them
				var viewport = dijit.getViewport();
				if(!this._oldViewport ||
						viewport.h != this._oldViewport.h ||
						viewport.w != this._oldViewport.w){
					this.layout();
					this._oldViewport = viewport;
				}
			}));
			this._modalconnects.push(dojo.connect(dojo.doc.documentElement, "onkeypress", this, "_onKey"));

			dojo.style(this.domNode, {
				opacity:0,
				visibility:""
			});
			
			if(this._fixSizes){
				dojo.style(this.containerNode, { // reset width and height so that _size():marginBox works correctly
					width:"auto",
					height:"auto"
				});
			}
			
			this.open = true;
			this._onShow(); // lazy load trigger

			this._size();
			this._position();
			dijit._dialogStack.push(this);
			this._fadeIn.play();

			this._savedFocus = dijit.getFocus(this);
		},

		hide: function(){
			// summary:
			//		Hide the dialog

			// if we haven't been initialized yet then we aren't showing and we can just return
			// or if we arent the active dialog, dont allow us to close yet
			var ds = dijit._dialogStack;
			if(!this._alreadyInitialized || this != ds[ds.length-1]){
				return;
			}

			if(this._fadeIn.status() == "playing"){
				this._fadeIn.stop();
			}
			
			// throw away current active dialog from stack -- making the previous dialog or the node on the original page active
			dijit._dialogStack.pop();

			this._fadeOut.play();

			if (this._scrollConnected){
				this._scrollConnected = false;
			}
			dojo.forEach(this._modalconnects, dojo.disconnect);
			this._modalconnects = [];

			if(this._relativePosition){
				delete this._relativePosition;	
			}
			this.open = false;
		},

		layout: function() {
			// summary:
			//		Position the Dialog and the underlay
			// tags:
			//		private
			if(this.domNode.style.visibility != "hidden"){
				if(dijit._underlay){	// avoid race condition during show()
					dijit._underlay.layout();
				}
				this._position();
			}
		},
		
		destroy: function(){
			dojo.forEach(this._modalconnects, dojo.disconnect);
			if(this.refocus && this.open){
				setTimeout(dojo.hitch(dijit,"focus",this._savedFocus), 25);
			}
			this.inherited(arguments);			
		},

		_onCloseEnter: function(){
			// summary:
			//		Called when user hovers over close icon
			// tags:
			//		private
			dojo.addClass(this.closeButtonNode, "dijitDialogCloseIcon-hover");
		},

		_onCloseLeave: function(){
			// summary:
			//		Called when user stops hovering over close icon
			// tags:
			//		private
			dojo.removeClass(this.closeButtonNode, "dijitDialogCloseIcon-hover");
		}
	}
);

// Stack of currenctly displayed dialogs, layered on top of each other
dijit._dialogStack = [];

// For back-compat.  TODO: remove in 2.0


}

if(!dojo._hasResource['com.ibm.widgets.NewPageDialog']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['com.ibm.widgets.NewPageDialog'] = true;
dojo.provide('com.ibm.widgets.NewPageDialog');




dojo.declare('com.ibm.widgets.NewPageDialog',
	[dijit.Dialog],
    {
		shelfBundle: null,
		dialogBundle: null,
		blankImg: "",
		autofocus: false,
		showMakePrivate: true,
		showFriendlyURL: true,
		value: {},
		
		templateString: '<div class="lotusDialogBorder lotusui" waistate="labelledby-${id}" wairole="dialog" role="dialog" index="-1" aria-labelledby="${id}" dojoAttachPoint="dialogDiv">' +
						'<div class="lotusDialog">' +
							'<h1>' +
								'<a href="javascript:void(0);" dojoAttachPoint="closeButtonNode" class="lotusBtnImg lotusClose" title="${closeText}">' +
									'<img src="${blankImg}" alt="" aria-label="${closeText}" />' +
									'<span class="lotusAltText">X</span>' +
								'</a>' +
								'<span dojoAttachPoint="titleNode">${titleText}</span>' +
							'</h1>' +
							'<form dojoAttachPoint="newPageForm" action="javascript:;">' +
								'<div dojoAttachPoint="containerNode" class="lotusDialogContent">' +
									'<div>' +
										'<div class="lotusMessage" dojoAttachPoint="newPageError" style="display: none" role="alert">' +
											'<span>${nlsTitleError}</span>' +
										'</div>' +
										'<div><label for="ibmPortalPageNameInput">${nlsPageTitle}</label></div>' +
										'<div><input id="ibmPortalPageNameInput" type="text" name="title" dojoAttachPoint="typingNode, focusNode" size="24"/></div><br />' +
										
										'<div dojoAttachPoint="divFriendlyURL">'+
											'<div><label for="ibmPortalFriendlyUrlInput">${nlsFriendlyURL}:</label></div>' +
											'<div><input id="ibmPortalFriendlyUrlInput" type="text" name="friendlyURL" dojoAttachPoint="newPageFriendlyURL" size="24"/></div>'+
										'</div><br />' +
										
										'<div dojoAttachPoint="divPrivate">' +
											'<input id="ibmPortalIsPrivateInput" type="checkbox" name="private" dojoAttachPoint="makePrivate"/><span> <label for="ibmPortalIsPrivateInput">${nlsMakePrivate}</label></span>' +
										'</div>' +
									'</div>' +
								'</div>' +
								'<div class="lotusDialogFooter" dojoAttachPoint="dialogFooter">' +
									'<input value="${okText}" class="lotusFormButton" dojoAttachPoint="submitDialog" type="submit"/> ' +
									'<a href="javascript:void(0);" class="lotusAction" dojoAttachPoint="dialogCancel">${cancelText}</a>' +
								'</div>' +
							'</form>' +
						'</div>' +
					'</div>',
								
		postMixInProperties: function() {
			this.shelfBundle = dojo.i18n.getLocalization("com.ibm.bundles", "Shelf");
			this.dialogBundle = dojo.i18n.getLocalization("com.ibm.bundles", "PageCreatorDialog");
			this.cancelText = this.shelfBundle["add_content_cancel"];
			this.closeText = this.shelfBundle["add_content_close"];
			this.okText = this.dialogBundle["page_dialog_create_page"];
			this.nlsPageTitle = this.dialogBundle["page_dialog_page_name"];
			this.nlsTitleError = this.shelfBundle["new_feed_enterTitle"];
			this.nlsFriendlyURL = this.dialogBundle["page_dialog_friendly_url_name"];
			this.nlsMakePrivate = this.dialogBundle["page_dialog_make_private"];
			this.titleText = this.dialogBundle["page_dialog_create_page"];		
		},	
		
		postCreate: function() { 
			this.inherited(arguments);
			
			this.submitDialog.onclick = dojo.hitch(this,function(){this.submit();return false;});
			this.closeButtonNode.onclick = this.dialogCancel.onclick = dojo.hitch(this,function(){this.cancel();return false;});
			
			if (!this.showMakePrivate) { dojo.destroy(this.divPrivate); delete this.divPrivate; }
			this.connect(this.typingNode, "onblur", function() { 
				if (this.typingNode.value != "") { 
					this.newPageError.style.display="none"; 
				}
			});
			if (this.showFriendlyURL){
				this.connect(this.typingNode, "onkeyup", function(){ 
					this.filterFriendlyURL(this.typingNode.value);
				});
				this.connect(this.newPageFriendlyURL, "onkeyup", function(){
					this.filterFriendlyURL(this.newPageFriendlyURL.value);
				});
			} else {
				dojo.destroy(this.divFriendlyURL);
				delete this.divFriendlyURL;
			}
		},
		
		submit: function() {
			if(this.typingNode.value != "") { 	// If they havn't put in a page name it won't let them submit.
					this.hide();
					this.beforeSubmit();
					this.onSubmit();
			}
			else {
				this.newPageError.style.display="block"; 	// shows error if there is no page title.
			}
		},
		
		cancel: function(){
			this.hide();
		},
		
		onChange: function(/*Object*/arg){
		},
		
		onComplete: function(){
		},
		
		beforeSubmit: function(){
		},
		
		onSubmit: function() {
			// When the user presses the Submit button.
			this.value = dojo.formToObject(this.newPageForm);
			this.value.onComplete = this.onComplete;
			this.onChange(this.value);
		},
		
		focus: function(){
			this.newPageError.style.display="none";
			if(this.showMakePrivate){this.makePrivate.checked = false;}
			this.typingNode.value = "";
			if(this.showFriendlyURL){this.newPageFriendlyURL.value = "";}
			this.show();
			this.focusNode.focus();
		},
		
		filterFriendlyURL: function(/*String*/textToFilter) {
		// summary: filters the given text into something more acceptable for the friendly url.
		// textToFilter: text for the filter to run on.
			var friendly = textToFilter.replace(/[!\*\'\(\);:@&=+$,\/?%#\[\]\s]/g,'_');
			this.newPageFriendlyURL.value = friendly;
		}
    }
);

}

if(!dojo._hasResource["com.ibm.dnd.PageCreator"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.dnd.PageCreator"] = true;
dojo.provide("com.ibm.dnd.PageCreator");

dojo.declare("com.ibm.dnd.PageCreator",
	null,
	{		
		creator: function(item, hint){
		//summary: creates the node to be used during
	    //         construction of the avatar
			var node = document.createElement("div");
			if(hint=="avatar"){
				node.className = "ibmPortalDndPageAvatar";
				var title = document.createTextNode(item);
				node.appendChild(title);
			}
			return {node: node, data: item, type: ["cmNode"]};
		}
	});

com.ibm.dnd.PAGE_CREATOR = new com.ibm.dnd.PageCreator();

}

if(!dojo._hasResource["com.ibm.widgets.InlineShelf"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.widgets.InlineShelf"] = true;
 // This is a dropdown inline shelf

dojo.provide("com.ibm.widgets.InlineShelf");



dojo.declare("com.ibm.widgets.InlineShelf",
	[dijit._Widget, dijit._Templated],
	{
		content: null,				// HTML content to display in the shelf
		link: null,					// an id or DOM element to which the shelf's toggle function should be attached
		shelfClass: "",				// css classes to put on the shelf
		displayState: "closed",		// state of the shelf, ie "open", "closed"
		everOpened: false,			// true when the shelf has been opened before
		wipeOut: null,				// animation to slide the shelf out of view
		wipeIn: null,				// animation to slide the shelf into view
		wipeTime: 300,				// the time the shelf takes to slide in/out in milliseconds
		templateString: '<div dojoAttachPoint="focusNode" style="display: none;" class="${shelfClass}"></div>',
		
		startup: function(){
			// create the hide/show animations
			this.wipeOut = dojo.fx.wipeOut({node:this.domNode, duration:this.wipeTime});
			this.wipeIn = dojo.fx.wipeIn({node:this.domNode, duration:this.wipeTime});
			
			// add the content
			if(this.content) this.domNode.appendChild(this.content);
			this.onCreate();
		},
		
		connectButton: function(){
			// set the onclick handler for the toggle link
			if (dojo.isString(this.link)) this.link = dojo.byId(this.link);
			if(this.link && !this.buttonConnection) {
				this.buttonConnection = dojo.connect(this.link, "onclick", this, this.toggleDisplay);
				dojo.removeClass(this.link,"lotusBtnDisabled");
			}
		},
		
		disconnectButton: function(){
			// set the onclick handler for the toggle link
			if(this.buttonConnection) {
				dojo.disconnect(this.buttonConnection);
				this.buttonConnection = null;
			}
			if(this.link) dojo.addClass(this.link, "lotusBtnDisabled");
		},
		
		toggleDisplay: function(){
			// summary: changes the state of the display
			if(this.displayState == "open") {
				this.onClose();
				if(dojo.isIE == 6) dojo.style(this.domNode,"display","none");
				else this.wipeOut.play();
				this.displayState = "closed";
			} else if (this.displayState == "closed"){
				this.onOpen();
				if(!this.everOpened) { this.startup(); }
				if(dojo.isIE == 6) dojo.style(this.domNode,"display","");
				else this.wipeIn.play();
				if(!this.everOpened) { this.onFirstOpen(); this.everOpened = true; }
				this.displayState = "open";
			}
		},
		
		onCreate: function(){
			// summary: stub event for when the shelf is instantiated
		},
		
		onOpen: function(){
			// summary: stub event for when the shelf is displayed
		},
		
		onFirstOpen: function(){
			// summary: stub event for when the shelf is opened for the first time
		},
		
		onClose: function(){
			// summary: stub event for when the shelf is hidden
		}
});

}

if(!dojo._hasResource["com.ibm.customize.SavePageManager"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.customize.SavePageManager"] = true;
dojo.provide("com.ibm.customize.SavePageManager");


dojo.declare("com.ibm.customize.SavePageManager",
	[dijit._Widget, dijit._Templated],
	{
		registered: [],
		saveString: "Save",
		unsavedChangesMsg: "",
		beforeSaveCount: 0,
		dirty: false,
		saving: false,
		templateString: '<button class="lotusFormButton lotusBtnDisabled" aria-disabled="true" dojoAttachPoint="savePageButton" dojoAttachEvent="onclick:saveAll" href="javascript:void(0)">${saveString}</button>',
		
		constructor: function(){
			this.saveString = dojo.i18n.getLocalization("com.ibm.bundles", "Shelf")["shelf_saveChanges"];
			this.unsavedChangesMsg = dojo.i18n.getLocalization("com.ibm.bundles", "Theme")["theme_confirm_leave_edit"];
		},
		
		register: function(obj){
			this.registered.push(obj);
			if(obj.beforeSave) this.beforeSaveCount++;
			obj.connection = (obj.scope) ? dojo.connect(obj.scope,obj.dirty,this,"makeDirty") : dojo.connect(obj.dirty,this,"makeDirty");
		},
		
		saveAll: function(){
			if(this.saving) return;
			this.saving = true;
			this.dirty = false;
			this.beforeSavePage();
		},
		
		beforeSavePage: function(){
			var count = this.beforeSaveCount + 1;

			var counter = dojo.hitch(this, function(){
				if(--count == 0) this.savePage();
			});
			counter();
			
			for(var i in this.registered){
				if(this.registered[i].beforeSave) this.registered[i].beforeSave(counter);
			}
		},
		
		savePage: function(){
			var count = this.registered.length + 1;
			var counter = dojo.hitch(this, function(){
				if(--count == 0) {
					this.saving = false;
					if(!this.dirty) {
						dojo.addClass(this.savePageButton, "lotusBtnDisabled");
						dojo.attr(this.savePageButton,"aria-disabled","true");
						window.onbeforeunload = null;
					}
				}
			});
			counter();
			
			com.ibm.portal.dnd.PORTLET_MEDIATOR.saveMoves(counter);
			for(var i in this.registered){
				this.registered[i].save(counter);
			}
		},
		
		leavePage: function(callback,reload){
			if(!ibmPortalConfig.savePageManager.isDirty()){
				callback();
			} else if (confirm(this.unsavedChangesMsg)){
				window.onbeforeunload = null;
				callback();
				if(reload) window.location.replace(top.location.href);
			}
		},
		
		makeDirty: function(){
			if(!this.dirty){
				this.dirty = true;
				dojo.removeClass(this.savePageButton, "lotusBtnDisabled");
				dojo.attr(this.savePageButton,"aria-disabled","false");
				window.onbeforeunload = dojo.hitch(this, function() {
					if(this.dirty){
						return this.unsavedChangesMsg;
					}
				});
			}
		},
		
		isDirty: function(){
			return this.dirty;
		},
		
		isSaving: function(){
			return this.saving;
		},
		
		uninitialize: function(){
			for(var i in this.registered){
				dojo.disconnect(this.registered[i].connection);
			}
		}
	});

}

if(!dojo._hasResource["com.ibm.UnloadGuard"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.UnloadGuard"] = true;
dojo.provide("com.ibm.UnloadGuard");

(function(){
	
	// This utility is used for guarding against unload events when certain events
	// are still pending.  It provides topics for adding and removing pending events
	// through the dojo.publish/subscribe model.
	
	// If events are still pending when the window tries to unload, a confirmation dialog
	// will be displayed to the user with one of the outstanding pending messages, allowing the user
	// to cancel the unload event and stay on the page if the user so chooses.  There is no
	// way to determine which message amongst the list of pending events is displayed to the user as
	// the only guarantee is that one of them will be displayed.
	
	// Other things can subscribe to these topics also in order to perform other functions.
	// An example could be a widget that shows some visual indicator while certain events are
	// still pending and hides itself when they complete.
	
	// Below is a list of topics used by this module.  The arguments that this utility is interested
	// in are also documented, however, any additional arguments can be used by other modules
	// that are also interested in these topics.  However, this utility will only use the arguments
	// specified below.  Other things can subscribe to these topics also in order to perform other 
	// functions.  An example could be a widget that shows some visual indicator while certain events 
	// are still pending and hides itself when they complete.
	//
	// Topics:
	//		"/window/unload/addPending" - Publish to this with one argument which is the message 
	//			to display to the user if the window is unloaded before the event is completed.
	//		
	//		"/window/unload/removePending" - Publish to this with one argument which is a previously
	//			added message in order to remove this message from the list of pending events.
	//				
	//		"/window/unload/nonePending" - Do not publish to this topic.  It is published to by this
	//			module whenever there are no more pending events after a previous one was removed.
	//			It is meant to be subscribed to.
	
	var pending = {};
	
	var isPending = function() {
		for(var x in pending) {
			if(pending[x] && pending[x].length > 0) return x;
		}
		return false;
	}
	
	var addPending = function(message) {
		if(!pending[message]) pending[message] = [];
		pending[message].push(true);
	}
	
	var removePending = function(message) {
		if(pending[message]) {
			pending[message].pop();
		}
		if(!isPending()) {
			dojo.publish("/window/unload/nonePending");
		}
	}
	

	dojo.subscribe("/window/unload/addPending", null, addPending);
	dojo.subscribe("/window/unload/removePending", null, removePending);

	window.onbeforeunload = function() {
		var msg = isPending();
		if(msg !== false) return msg;
	}
})();

}

if(!dojo._hasResource["dojo.DeferredList"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.DeferredList"] = true;
dojo.provide("dojo.DeferredList");
dojo.declare("dojo.DeferredList", dojo.Deferred, {
	constructor: function(/*Array*/ list, /*Boolean?*/ fireOnOneCallback, /*Boolean?*/ fireOnOneErrback, /*Boolean?*/ consumeErrors, /*Function?*/ canceller){
		// summary:
		//		Provides event handling for a group of Deferred objects.
		// description:
		//		DeferredList takes an array of existing deferreds and returns a new deferred of its own
		//		this new deferred will typically have its callback fired when all of the deferreds in
		//		the given list have fired their own deferreds.  The parameters `fireOnOneCallback` and
		//		fireOnOneErrback, will fire before all the deferreds as appropriate
		//
		//	list:
		//		The list of deferreds to be synchronizied with this DeferredList
		//	fireOnOneCallback:
		//		Will cause the DeferredLists callback to be fired as soon as any
		//		of the deferreds in its list have been fired instead of waiting until
		//		the entire list has finished
		//	fireonOneErrback:
		//		Will cause the errback to fire upon any of the deferreds errback
		//	canceller:
		//		A deferred canceller function, see dojo.Deferred
		this.list = list;
		this.resultList = new Array(this.list.length);

		// Deferred init
		this.chain = [];
		this.id = this._nextId();
		this.fired = -1;
		this.paused = 0;
		this.results = [null, null];
		this.canceller = canceller;
		this.silentlyCancelled = false;

		if(this.list.length === 0 && !fireOnOneCallback){
			this.callback(this.resultList);
		}

		this.finishedCount = 0;
		this.fireOnOneCallback = fireOnOneCallback;
		this.fireOnOneErrback = fireOnOneErrback;
		this.consumeErrors = consumeErrors;

		dojo.forEach(this.list, function(d, index){
			d.addCallback(this, function(r){ this._cbDeferred(index, true, r); return r; });
			d.addErrback(this, function(r){ this._cbDeferred(index, false, r); return r; });
		}, this);
	},

	_cbDeferred: function(index, succeeded, result){
		// summary:
		//	The DeferredLists' callback handler

		this.resultList[index] = [succeeded, result]; this.finishedCount += 1;
		if(this.fired !== 0){
			if(succeeded && this.fireOnOneCallback){
				this.callback([index, result]);
			}else if(!succeeded && this.fireOnOneErrback){
				this.errback(result);
			}else if(this.finishedCount == this.list.length){
				this.callback(this.resultList);
			}
		}
		if(!succeeded && this.consumeErrors){
			result = null;
		}
		return result;
	},

	gatherResults: function(deferredList){
		// summary:	
		//	Gathers the results of the deferreds for packaging
		//	as the parameters to the Deferred Lists' callback

		var d = new dojo.DeferredList(deferredList, false, true, false);
		d.addCallback(function(results){
			var ret = [];
			dojo.forEach(results, function(result){
				ret.push(result[1]);
			});
			return ret;
		});
		return d;
	}
});

}

if(!dojo._hasResource["com.ibm.customize.TabbedController"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.customize.TabbedController"] = true;
 // This is tabbed container with controller children
dojo.provide("com.ibm.customize.TabbedController");






/*2010 09 10 Sue header display change(inline -> none)*/
dojo.declare("com.ibm.customize.TabbedController",
	[com.ibm.widgets.InlineShelf],
	{
		children: [],					// array of children to display in the tabs, each array item is an object {tabName:"",controller:object that implements the Customize Controller API}
		pendingChildren: 0,				// the number of children with pending changes used to determine whether or not the save link should be enabled
		imagePath: '.',					// path to the css images
		hiddenClass: "lotusHidden",		// the css class name to hide content panes
		selectedClass: "lotusSelected",	// the css class to select tabs
		transitions:true, 				// true if com.ibm.portal.fx.Transitions should be used when saving children
		templateString: '<div class="lotusui ibmPortalCustomizeShelf lotusPalette" style="display:none;">' + //none->inline
					'<table border="0" width="100%" cellpadding="0" cellspacing="0" >'+
						'<tr><td>'+
							'<div class="lotusPaletteHeader" style="display:none;">' + //added "display:none" , table tag
								'<ul dojoAttachPoint="tabs" class="lotusTabs"></ul>' +
							'</div>' +
							'<div dojoAttachPoint="containerDivs"></div>' +
						'</td></tr>'+
					'</table>'+
				'</div>',
		refreshRetryInterval: 300,		// if a refresh request is delayed because a save is pending, this is the amount of time to wait before retrying the refresh				
		
		constructor: function() {
			this.bundle = dojo.i18n.getLocalization("com.ibm.bundles", "Shelf");
			this.okText = this.bundle["shelf_saveChanges"];
			this.cancelText = this.bundle["add_content_cancel"];
		},
		
		onFirstOpen: function(){
			this.fillTabs();
		},
		
		fillTabs: function(){
			// create the tabs and container divs for each child
			var clickFirstTab, first = true;
			dojo.forEach(
				this.children,
			    dojo.hitch(this, function(child){
					// create a node for the child to create its container
					var div = dojo.create("div",{className:this.hiddenClass});
					this.containerDivs.appendChild(div);
					div.appendChild(child.controller.domNode);
					child.containerDiv = div;
					// create a tab div to access the container
					var tab = dojo.create("li");
					var tabName = dojo.create("a",{innerHTML:child.controller.tabLabel,href:"javascript:void(0)"});
					tab.appendChild(tabName);
					this.tabs.appendChild(tab);
					child.tab = tab;
					// create an onclick handler for each tab that opens its container
					tabName.onclick = dojo.hitch(this,this.showTab,child);
					// connect to the child's dirty attribute
					this.connect(child.controller, "makeDirty", "modifyPending");
					// if it's the first child, select its tab
					if(first) {
						first = false;
						clickFirstTab = tabName.onclick;
					}
			}));
			clickFirstTab(); 
			this.onStartup();
		},
		
		undoChildren: function(){
			// summary: undoes all pending changes in the children
			dojo.forEach( this.children, dojo.hitch(this, function(child){ 
				child.controller.undo();	
			}));
		},
		
		saveChildren: function(){
			// summary: saves all pending changes in the children and refreshes the page if necessary
			// check if there are any changes in the controllers
			if(!this.pendingChildren) return;
			var closeOverlay = this.transitions ? this.children[0].controller.showWaitMsgInDialog(this.bundle["shelf_saving"]) : function(){};
			this.beforeSave().addCallback(dojo.hitch(this, "_proceedSave", closeOverlay));
		},
		
		_proceedSave: function(closeOverlay) {
			// count function keeps track of how many children are done submitting
			// when count is 0, all children have finished submitting
			var refresh = false;
			var count = this.children.length;
			var counter = dojo.hitch(this,function(){
				if(--count == 0) {
					if(this.transitions) closeOverlay();
					if(refresh) this.refreshPage();
				}
			});
			var handleError = dojo.hitch(this,function(errors){
				counter();
				var message = errors[0].message;
				var details = errors[0].responseText;
				if(message.match(/\D401/)){ // Portal session not authenticated
					details = message;
					message = this.bundle["shelf_session_timeout"];
				}
				var statusMessage = new com.ibm.widgets.StatusMessage( "error", message, details );
				dojo.publish("/portal/status",[{message: statusMessage, uid: 'ibmPortalStatusBox'}]);
			});
			// call beforeSubmit on each child
			var dfdl = new dojo.DeferredList(dojo.map( this.children, function(child){
				return child.controller.beforeSubmit();
			}, this));
			dfdl.addCallback(dojo.hitch(this, function(){
				// call submit on each child
				dojo.forEach( this.children, function(child){ 
					if(child.controller.refresh && child.controller.dirty) refresh = true; 
					child.controller.submit({onComplete:counter,onError:handleError});	
				}, this);
			}));
		},
		
		portalBeforeSave: function(callback){
			if(!this.pendingChildren) { callback(); return; } 
			this.closeOverlay = this.transitions ? this.children[0].controller.showWaitMsgInDialog(this.bundle["shelf_saving"]) : function(){};
			var dfdl = new dojo.DeferredList(dojo.map( this.children, function(child){
				return child.controller.beforeSubmit();
			}, this));
			dfdl.addCallback(dojo.hitch(this, callback));
		},
		
		portalSave: function(callback){
			if(!this.pendingChildren) return;
			var refresh = false;
			var count = this.children.length;
			var counter = dojo.hitch(this,function(){
				if(--count == 0) {
					callback();
					if(this.transitions) this.closeOverlay();
					if(refresh) this.refreshPage();
				}
			});
			var handleError = dojo.hitch(this,function(errors){
				counter();
				var message = errors[0].message;
				var details = errors[0].responseText;
				if(message.match(/\D401/)){ // Portal session not authenticated
					details = message;
					message = this.bundle["shelf_session_timeout"];
				}
				var statusMessage = new com.ibm.widgets.StatusMessage( "error", message, details );
				dojo.publish("/portal/status",[{message: statusMessage, uid: 'ibmPortalStatusBox'}]);
			});
			dojo.forEach( this.children, function(child){ 
				if(child.controller.refresh && child.controller.dirty) refresh = true; 
				child.controller.submit({onComplete:counter,onError:handleError});	
			}, this);
		},
		
		refreshPage: function () {
			// summary: Reloads the page to show any changes that require the page to be completely reloaded to render. If a save is currently in progress,
			//		the reload request will be queued until the save operation completes. 
			if (ibmPortalConfig.savePageManager && !ibmPortalConfig.savePageManager.isDirty()) {
				com.ibm.utilities.refreshPage();
			} else {
				//A refresh has been requested, but we need to wait until the save is completed before honoring it.
				setTimeout( dojo.hitch( this, this.refreshPage ), this.refreshRetryInterval );
			}
		},
		
		modifyPending: function(/*bool*/change){
			// summary: changes the value of the pendingChildren variable
			if(change) this.pendingChildren++
			else this.pendingChildren--;
			if(change) this.makeDirty();
		},
		
		makeDirty: function(){},  // used for Save Page Manager to connect to
		
		showTab: function(/*Object*/selectedChild){
			// summary: displays the content pane for the given controller
			// selectedChild: the child to show
			
			if(!selectedChild.controller.started){
				// if the child isn't started yet, start it up
				selectedChild.controller.startup(this);
			}
			// clear all the tabs and container divs
			dojo.forEach(
				this.children,
			    dojo.hitch(this, function(child){
					dojo.removeClass(child.tab,this.selectedClass);
					dojo.addClass(child.containerDiv,this.hiddenClass);
			}));
			// select and show the given child
			dojo.addClass(selectedChild.tab,this.selectedClass);
			dojo.removeClass(selectedChild.containerDiv,this.hiddenClass);
			this.onShowTab(selectedChild);
			return false; /* to prevent onBeforeUnload event from triggering in IE */
		},
		
		onStartup: function(){
			// summary: stub event to be called when the TabbedController is started up
		},
		
		onShowTab: function(/*Object*/selectedChild){
			// summary: stub event to be called whenever a tab is shown
		},
		
		beforeSave: function(){
			// summary: stub event to be called when saveChildren is called.  Returns a Deferred
			//		which is fired when save processing can be continued.
			var dfd = new dojo.Deferred();
			dfd.callback();
			return dfd;
		}
});

}

if(!dojo._hasResource["dojo.NodeList-fx"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.NodeList-fx"] = true;
dojo.provide("dojo.NodeList-fx");


/*=====
dojo["NodeList-fx"] = {
	// summary: Adds dojo.fx animation support to dojo.query()
};
=====*/

dojo.extend(dojo.NodeList, {
	_anim: function(obj, method, args){
		args = args||{};
		return dojo.fx.combine(
			this.map(function(item){
				var tmpArgs = { node: item };
				dojo.mixin(tmpArgs, args);
				return obj[method](tmpArgs);
			})
		); // dojo._Animation
	},

	wipeIn: function(args){
		//	summary:
		//		wipe in all elements of this NodeList. Returns an instance of dojo._Animation
		//	example:
		//		Fade in all tables with class "blah":
		//		|	dojo.query("table.blah").wipeIn().play();
		return this._anim(dojo.fx, "wipeIn", args); // dojo._Animation
	},

	wipeOut: function(args){
		//	summary:
		//		wipe out all elements of this NodeList. Returns an instance of dojo._Animation
		//	example:
		//		Wipe out all tables with class "blah":
		//		|	dojo.query("table.blah").wipeOut().play();
		return this._anim(dojo.fx, "wipeOut", args); // dojo._Animation
	},

	slideTo: function(args){
		//	summary:
		//		slide all elements of the node list to the specified place.
		//		Returns an instance of dojo._Animation
		//	example:
		//		|	Move all tables with class "blah" to 300/300:
		//		|	dojo.query("table.blah").slideTo({
		//		|		left: 40,
		//		|		top: 50
		//		|	}).play();
		return this._anim(dojo.fx, "slideTo", args); // dojo._Animation
	},


	fadeIn: function(args){
		//	summary:
		//		fade in all elements of this NodeList. Returns an instance of dojo._Animation
		//	example:
		//		Fade in all tables with class "blah":
		//		|	dojo.query("table.blah").fadeIn().play();
		return this._anim(dojo, "fadeIn", args); // dojo._Animation
	},

	fadeOut: function(args){
		//	summary:
		//		fade out all elements of this NodeList. Returns an instance of dojo._Animation
		//	example:
		//		Fade out all elements with class "zork":
		//		|	dojo.query(".zork").fadeOut().play();
		//	example:
		//		Fade them on a delay and do something at the end:
		//		|	var fo = dojo.query(".zork").fadeOut();
		//		|	dojo.connect(fo, "onEnd", function(){ /*...*/ });
		//		|	fo.play();
		return this._anim(dojo, "fadeOut", args); // dojo._Animation
	},

	animateProperty: function(args){
		//	summary:
		//		see dojo.animateProperty(). Animate all elements of this
		//		NodeList across the properties specified.
		//	example:
		//	|	dojo.query(".zork").animateProperty({
		//	|		duration: 500,
		//	|		properties: { 
		//	|			color:		{ start: "black", end: "white" },
		//	|			left:		{ end: 300 } 
		//	|		} 
		//	|	}).play();
		return this._anim(dojo, "animateProperty", args); // dojo._Animation
	},

	anim: function(	/*Object*/ 			properties, 
					/*Integer?*/		duration, 
					/*Function?*/		easing, 
					/*Function?*/		onEnd,
					/*Integer?*/		delay){
		//	summary:
		//		Animate one or more CSS properties for all nodes in this list.
		//		The returned animation object will already be playing when it
		//		is returned. See the docs for `dojo.anim` for full details.
		//	properties: Object
		//		the properties to animate
		//	duration: Integer?
		//		Optional. The time to run the animations for
		//	easing: Function?
		//		Optional. The easing function to use.
		//	onEnd: Function?
		//		A function to be called when the animation ends
		//	delay:
		//		how long to delay playing the returned animation
		//	example:
		//		Another way to fade out:
		//	|	dojo.query(".thinger").anim({ opacity: 0 });
		//	example:
		//		animate all elements with the "thigner" class to a width of 500
		//		pixels over half a second
		//	|	dojo.query(".thinger").anim({ width: 500 }, 700);
		var canim = dojo.fx.combine(
			this.map(function(item){
				return dojo.animateProperty({
					node: item,
					properties: properties,
					duration: duration||350,
					easing: easing
				});
			})
		); 
		if(onEnd){
			dojo.connect(canim, "onEnd", onEnd);
		}
		return canim.play(delay||0); // dojo._Animation
	}
});

}

if(!dojo._hasResource["com.ibm.portal.fx.Transitions"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.portal.fx.Transitions"] = true;
dojo.provide("com.ibm.portal.fx.Transitions");




com.ibm.portal.fx.Transitions = {
	collapsePortlets: function(/*String*/ portletQuery, /*Object*/args){
		dojo.query(portletQuery || ".wpsPortletBody").wipeOut(dojo.mixin({duration: 1000}, args)).play();
	},
	uncollapsePortlets: function(/*String*/ portletQuery, /*Object*/args){
		dojo.query(portletQuery || ".wpsPortletBody").wipeIn(dojo.mixin({duration: 1000}, args)).play();
	},
	combineMapAnimations: function(/*Object*/ map, /*String?*/ prop) {
		prop = prop || "animation";
		return dojo.fx.combine(dojo.map(map, function(obj){
			return obj.animation;
		}));
	},
	chainMapAnimations: function(/*Object*/ map, /*String?*/ prop) {
		prop = prop || "animation";
		return dojo.fx.chain(dojo.map(map, function(obj){
			return obj.animation;
		}));
	},
	fadeToOverlay: function(/*String*/ query, /*Object*/ args, /*Node?*/ context) {
		// summary: Find all nodes matched by the query and cross-fade them out with an overlay
		//		over top of them which has a class called fxOverlay applied to it to visualize
		//		the old position of the node that was just faded.
		// query: String query used in conjunction with dojo.query to retrieve nodes to animate
		// args: Object animation arguments
		// context: Node optional to use as context from which to execute the dojo.query
		// returns: Object map of matching nodes in this format ->
		//		{
		//			overlay: Node overlay node which is faded in by animation
		//			node: Node matched by query that is faded out by animation
		//			animation: dojo._Animation cross-fading animation used to animate the transition
		// 				of the overlay and node.
		// 		} 
		//			
		return dojo.query(query, context).map(function(node) {
			var overlay = dojo.doc.createElement("div");
			var cds = dojo.coords(node);
			dojo.style(overlay, "position", "absolute");
			dojo.style(overlay, "top", (cds.y - dojo.style(node, "marginTop")) + "px");
			dojo.style(overlay, "left", (cds.x - dojo.style(node, "marginLeft")) + "px");
			dojo.style(overlay, "height", cds.h + "px");
			dojo.style(overlay, "width", cds.w + "px");
			dojo.addClass(overlay, "fxOverlay");
			dojo.style(overlay, "border", "solid 2px orange");
			dojo.style(overlay, "opacity", 0);
			dojo.body().appendChild(overlay);
			var anim = dojo.fx.combine([
				dojo.fadeIn(dojo.mixin({node: overlay}, args)),
				dojo.fadeOut(dojo.mixin({node: node}, args))
			]);
			
			return {overlay: overlay, node: node, animation: anim};
		});
	},
	fadeOutOverlay: function(/*Object*/ map, /*Object*/ args) {
		// summary: Cross-fades overlays with the nodes they cover by fading out the overlay
		// 		then fading in the covered node.  Can be used in conjunction with fadeToOverlay.
		//		Note that at the end of each animation, the overlay node will be destroyed.
		// map: Map of overlay nodes and their corresponding nodes that they cover in this format -> 
		// 		{
		//			overlay: Node overlay node
		//			node: Node being covered by overlay
		//		}
		// args: Object animation arguments
		// returns: Object map of matching nodes in this format ->
		//		{
		//			overlay: Node overlay node which is faded out by animation
		//			node: Node matched by query that is faded in by animation
		//			animation: dojo._Animation used to cross-fade the overlays with the
		//				nodes they cover.
		// 		}
		return dojo.map(map, function(obj){
			var anim = dojo.fx.combine([
				dojo.fadeOut(dojo.mixin({node: obj.overlay}, args)),
				dojo.fadeIn(dojo.mixin({node: obj.node}, args))
			]);
			return {overlay: obj.overlay, node: obj.node, animation: anim};
		});
	},
	positionOverlay: function(/*Object*/ map, /*Object*/ args) {
		// summary: Slides overlays to the position and size of the nodes they cover.  Can be
		//		used in conjunction with fadeToOverlay.
		// map: Map of overlay nodes and their corresponding nodes that they cover in this format -> 
		// 		{
		//			overlay: Node overlay node to reposition/resize
		//			node: Node being covered by overlay
		//		}
		// args: Object animation arguments
		// returns: Object map of matching nodes in this format ->
		//		{
		//			overlay: Node overlay node which is faded in by animation
		//			node: Node matched by query that is faded out by animation
		//			animation: dojo._Animation used to slide/resize the overlays to the
		//				nodes they cover.
		// 		}
		return dojo.map(map, function(obj){
			var newCds = dojo.coords(obj.node);
			var oldCds = dojo.coords(obj.overlay);
			
			var sizingAnim = dojo.animateProperty(dojo.mixin({ 
				node: obj.overlay,
				properties: {
					width: { start: oldCds.w, end: newCds.w, unit:"px" },
					height: { start: oldCds.h, end: newCds.h, unit:"px" }
				}
			}, args));
			
			var anim = dojo.fx.combine([
				dojo.fx.slideTo(dojo.mixin({node: obj.overlay, unit:"px", left: newCds.l, top: newCds.t}, args)), 
				sizingAnim
			]);
			return {overlay: obj.overlay, node: obj.node, animation: anim};
		});
	},
	showOverlayDisable: function(node,loading){
		// summary: displays an overlay on top of the given node, disabling its contents
		// node: a string for dojo.query that produces nodes to overlay
		// loading: if true, a loading icon will display on the overlay
		var nodes = dojo.query(node); // TODO: a foreach for this array
		var overlays = new Array();
		for(var i = 0; i < nodes.length; i++){
			nodes[i].style.position = "relative";  // the position of the div must be relative or absolute so the overlay will stay within it
			// create the overlay div
			var overlay = document.createElement("div");
			dojo.addClass(overlay,"ibmPortalOverlayShow");
			if(loading) dojo.addClass(overlay,"ibmPortalLoading");
			// make the overlay the same size as the main content
			dojo.style(overlay,"height",nodes[i].offsetHeight+"px");
			dojo.style(overlay,"width",nodes[i].offsetWidth+"px");
			// save the overlay
			overlays.push(overlay);
			// show the overlay
			nodes[i].appendChild(overlay);
		} 
		return overlays;
	},
	hideOverlayDisable: function(/*DOMNode[]*/overlays){
		// summary: removes an array of overlays by deleting the nodes
		for(var i = 0; i < overlays.length; i++)
			overlays[i].parentNode.removeChild(overlays[i]);
	}
}

}

if(!dojo._hasResource["com.ibm.customize.AddContentController"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.customize.AddContentController"] = true;
 // This is a controller that customizes the content on a page

dojo.provide("com.ibm.customize.AddContentController");


/***********************************************/
/* 2010.09.20 modify by kiwoung jung	start		    */
/* 1. layoutContainerClass add					*/
/* 2. _getSecondContainer method add			*/
/***********************************************/
com.ibm.customize.AddContentController = {
	controlClass: "ibmPortalControlContainer",		// the css class name on dnd portlet controls
	mainContainerClass: "ibmPortalMainContainer",	// the css class name on the dom node for containers[0]
	layoutContainerClass: "ibmPortalLayoutContainer",	// the css class name on the dom node for containers[x]

/***********************************************/
/*       Customize Controller API			   */
/***********************************************/

	store: null,		// the data store providing APIs to manipulate content
	item: null,			// the data store item representing the current page
	pageId: "", 		// the id of the current page
	parent: null,		// a pointer to this controller's parent, if one exists
	dirty: false,		// true if there are changes pending
	added: false,		// true if there were portlets added
	started: false,		// true if the widget is started up
	refresh: true,		// true if a page refresh is required to show saved changes

// if this controller is to be standalone and maintain compliance with the Customize Controller API, it must be supplied with a startup function

	makeDirty: function(/*bool*/change){
		// summary: changes the dirty attribute
		// change: value to assign to the dirty attribute
		this.dirty = change;
	},

	processChange: function(/*Object*/args){
		// summary: used as an event handler for when a user clicks on a result
		// args: 	id: the unique id of the piece of content
		//			label: the display name of the piece of content
		//			prefsMapFcn (optional): a function or the name of a function in dot notation which retrieves a map of the preferences for the piece of content
		//			map (optional): an object of parameters to be passed to prefsMapFcn
		//			takeoverFcn (optional): a function or the name of a function in dot notation which will be run instead of the body of this submit function
		//			takeoverObject (optional): an object of parameters to be passed to takeoverFcn
		if(!this.dirty) this.makeDirty(true);
		if(args.takeoverFcn) {
			args.takeoverObject = dojo.mixin(args.takeoverObject, {controller: this});
			if(dojo.isString(args.takeoverFcn)) return dojo.getObject(args.takeoverFcn)(args.takeoverObject);
			else return args.takeoverFcn(args.takeoverObject);
		}
		if(!this.parent) {
			setTimeout(function(){this.beforeSubmit().addCallback(dojo.hitch(this, function(){this.submit(args)}));}, 1);
		}
		return this.apply(args);
	},


/*2010 09 17     */
	apply: function(/*Object*/args){
		// get the container id off of the DOM div
//		var container = this._getFirstContainer();
		var container = this._getSecondContainer();
	
		// get the container id
		var containerID = null;
		var pageIdSuffix = "@oid:" + this.pageId;
		if(container) containerID = "lm:" + container.id + pageIdSuffix;
		else return;
		
		// get next sibling
		var nextSibling = null;
		var portlets = dojo.query("." + this.controlClass,container);
		for(var i = 0; i < portlets.length; i++){
			var controlid = portlets[i].getAttribute("controlid");
			if(controlid && controlid.length > 0 && controlid != "null") {
				nextSibling = controlid + pageIdSuffix; 
				break;
			}
		}
				
		// create placeholder
		var placeholderDiv = dojo.create("div");
		container.insertBefore(placeholderDiv, container.firstChild);
		var placeholder = new com.ibm.customize.placeholder({titleText:args.label,imagePath:this.imagePath,containerId:container.id},placeholderDiv);
		this.added = true; //this.makeDirty(true);				
						
		// args for creating a new item in the Portal feed
		var modelArgs = {
			portletDefinitionId:args.id,
			parentId:containerID,
			pocType: "lm",
			type: "control"
		};
		
		if(nextSibling) modelArgs.nextId = "lm:" + nextSibling;
		
		var portletControl = this.store.newItem(modelArgs);
		var cid = this.store.getIdentity(portletControl);
		this.pendingItems[cid] = {item: portletControl, prefsMap: this._getPrefsMap(args), afterSubmitDfd: new dojo.Deferred(), placeholder: placeholder};
		
		this.addAfterSubmit(this.pendingItems[cid].afterSubmitDfd);
		
		var listener = dojo.connect(this.store, "onSaveComplete", this, function(saveList){
			if(saveList.hasItem(portletControl)) {
				dojo.disconnect(listener);
				listener = null;
				this._finalizeControl(portletControl, saveList);
				portletControl = null;
			}
		});
		
		var controlCId = cid.substring(3, cid.indexOf("@"));
		placeholder.finish(controlCId);
		return portletControl;
	},
	
	/*    */
	_finalizeControl: function(/*Item*/ portletControl, /*SaveList*/ saveList) {
		var cid = this.store.getCId(portletControl);
		var err = saveList.getError(portletControl);
		if(err) {
			var details = err.message;
			if(err.responseText.indexOf("EJPDB0124E") >= 0) details = this.nlsBundle["add_content_missingRendererError"];
			this.pendingItems[cid].placeholder.error(this.nlsBundle["add_content_addContentError"],details);
			delete this.pendingItems[cid];
		}
		else {
			if(this.pendingItems[cid].prefsMap) {
				this._setPreferences(portletControl, this.pendingItems[cid].prefsMap).addCallbacks(
					dojo.hitch(this, function(prefsItem){
						this._addIdToPlaceholder(portletControl);
						this.pendingItems[cid].afterSubmitDfd.callback();
						delete this.pendingItems[cid];
					}),
					dojo.hitch(this, function(error){
						var details = err.message;
						if(err.responseText.indexOf("EJPDB0124E") >= 0) details = this.nlsBundle["add_content_missingRendererError"];
						this.pendingItems[cid].placeholder.error(this.nlsBundle["add_content_addContentError"],details);
						this.pendingItems[cid].afterSubmitDfd.errback(error);
						delete this.pendingItems[cid];
					})
				);
			}
			else {
				this._addIdToPlaceholder(portletControl);
				this.pendingItems[cid].afterSubmitDfd.callback();
				delete this.pendingItems[cid];
			}
		}
	},
	
	_addIdToPlaceholder: function(control) {
		var cid = this.store.getCId(control);
		var contentID = this.store.getIdentity(control);
		contentID = contentID.substring(3,contentID.indexOf('@'));
		this.pendingItems[cid].placeholder.attr("controlid", contentID);
	},
	
	_getPrefsMap: function(args) {
		// if there is a function to get portlet preferences, get them, or else the preferences map is null
		if(args.prefsMapFcn) {
			if(dojo.isString(args.prefsMapFcn)) return dojo.getObject(args.prefsMapFcn)(args.map);
			else return args.prefsMapFcn(args.map);
		}
		return null;
	},
	
	_setPreferences: function(/*Item*/ portletControl, /*Object*/ prefsMap) {
		// summary: Sets preferences on the portletControl item using the prefsMap for the
		//		map of preferences to set and the args to specify callbacks using onComplete,
		//		onError, and scope properties.
		// portletControl: Item in data store referring to the layout model control
		// prefsMap: Object map of preferences to set according to key-value pairs in map.
		// returns: Deferred object which is fired when the preferences are set and saved.
		var dfd = new dojo.Deferred();
		var windowChain = this.store.getValue(this.store.getValue(portletControl, "portlet"), "portletWindowChain");
		windowChain.addOnLoad(dojo.hitch(this, function(chain){
			var prefs = chain.getPreferences();
			for(var key in prefsMap) {
				var val = prefsMap[key];
				prefs[dojo.isArray(val) ? "setValues" : "setValue"](key, val);
			}
			var listener = dojo.connect(this.store, "onSaveComplete", this, function(saveList) {
				if(saveList.hasItem(prefs.item)) {
					dojo.disconnect(listener);
					var error = saveList.getError(prefs.item);
					if(error == null) {
						dfd.callback(prefs.item);
					}
					else {
						dfd.errback(error);
					}
					dfd = null;
					windowChain = null;
					prefs = null;
				}
			});
			
			prefs.store();
		}));
		return dfd;
	},

	undo: function(/*Object*/args){
		for(var cid in this.pendingItems) {
			this.store.revertItem(this.pendingItems[cid].item);
			this.pendingItems[cid].placeholder.destroyRecursive();
			delete this.pendingItems[cid];
		}
		dojo.forEach(this.beforeSubmitDfds, function(dfd){dfd.cancel();});
		this.beforeSubmitDfds = [];
		this.afterSubmitDfds = [];
	},
	
	undoItem: function(/*Item*/ portletControl) {
		var cid = this.store.getCId(portletControl);
		this.store.revertItem(portletControl);
		this.pendingItems[cid].afterSubmitDfd.callback();
		delete this.pendingItems[cid];
	},

	beforeSubmit: function(/*Object*/args){
		// summary: Returns a Deferred object which is fired when this controller is ready
		//		to be submitted.  Fires all the Deferreds in the list of beforeSubmit dfds
		//		that were added using the addBeforeSubmit function.  When all of them callback
		//		the Deferred that this returns calls back as well.
		var dfd = (new dojo.Deferred()).addCallback(dojo.hitch(this, function(){
			var dfdl = new dojo.DeferredList(this.beforeSubmitDfds, false, false);
			dojo.forEach(this.beforeSubmitDfds, function(df){
				if(df.fired < 0) {
					df.callback();
				}
			});
			this.beforeSubmitDfds = [];
			return dfdl;	// chain up another deferred after dfd calls back so subsequent callbacks now wait on dfdl
		}));
		
		if(args && args.onError) dfd.addErrback(args.onError);
		
		var cbk = dojo.hitch(this, function(){
			dfd.callback();
		});
		if(!this.store.isItemLoaded(this.item)) {
			this.store.loadItem({
				item: this.item,
				onItem: cbk,
				onError: args ? args.onError : null
			});
		}
		else cbk();
		
		return dfd;
	},

	submit: function(/*Object*/args){
		// summary: saves any pending changes to the server.  This should only be called in a callback
		//		on the Deferred object returned by this controller's beforeSubmit function.
		// args: may contain an onComplete handler
		if(this.dirty) this.makeDirty(false);
		var finisher = function(res) {
			var dfd = this.afterSubmit();
			if(args.onComplete) dfd.addCallback(dojo.hitch(args.scope, args.onComplete));
			if(args.onError) dfd.addErrback(dojo.hitch(args.scope, args.onError));
		};
		this.store.save({onComplete: finisher, onError: finisher, scope: this});
	},
	
	afterSubmit: function() {
		var dfd = new dojo.DeferredList(this.afterSubmitDfds, false, false);
		this.afterSubmitDfds = [];
		return dfd;
	},
	
	addAfterSubmit: function(/*Deferred*/ dfd) {
		// summary: Adds a Deferred object to the list of deferreds that must all be fired before
		//		the submit process fires the onComplete handler.  These are NOT fired by the controller
		// 		themselves, but are simply used to attach callbacks to.  They are assumed to have been
		// 		fired at some point by whatever code added them to the afterSubmit queue. 
		if(dfd) this.afterSubmitDfds.push(dfd);
	},
	
	addBeforeSubmit: function(/*Deferred*/ dfd) {
		// summary: Adds a Deferred object to the list of deferreds that must all be fired before
		//		the Deferred object returned by beforeSubmit is fired. 
		if(dfd) this.beforeSubmitDfds.push(dfd);
	},
		
/***********************************************/
/*              Helper functions   	     	   */
/***********************************************/	
		
	_getFirstContainer: function(){
		// summary: returns a DOM node which is where the contents of layout container 0 are rendered
		var firsts = dojo.query("." + this.mainContainerClass); // length should be exactly 1

		if(firsts.length > 0) return firsts[0];
		else { // error
			//var themeBundle = dojo.i18n.getLocalization("com.ibm.bundles", "Theme");
			var msg = this.nlsBundle["add_content_addContentError"];
			//var details = themeBundle["layout_error_heading"];
			var statusMessage = new com.ibm.widgets.StatusMessage("error", msg, "");
			dojo.publish("/portal/status",[{message: statusMessage, uid: 'ibmPortalStatusBox'}]);
		}
		
	},


//2010 09 17  SeonondConainer 
	_getSecondContainer: function(){
		// summary: returns a DOM node which is where the contents of layout container 0 are rendered
		//var firsts = dojo.query("." + this.mainContainerClass); // length should be exactly 1
		var layouts = dojo.query("." + this.layoutContainerClass);

		if(layouts.length == 1){
			return layouts[0];
		}else if(layouts.length >= 2){
			return layouts[1];
//			return layouts[0];
		}else{
			//var themeBundle = dojo.i18n.getLocalization("com.ibm.bundles", "Theme");
			var msg = this.nlsBundle["add_content_addContentError"];
			//var details = themeBundle["layout_error_heading"];
			var statusMessage = new com.ibm.widgets.StatusMessage("error", msg, "");
			dojo.publish("/portal/status",[{message: statusMessage, uid: 'ibmPortalStatusBox'}]);
		}
	},	

		
/**********************************************************/
/*       Functions to create "new" pieces of content      */
/**********************************************************/	
		
	newFeed: function(/*object*/args){ 
	    // summary: creates a new Feedspace portlet with user provided feed url
		// args: contains one item, getInfo, which is a function that takes the form data and runs a callback function on the validated user inputs
		var bundle = dojo.i18n.getLocalization("com.ibm.bundles", "Shelf");
		var form = [{label:bundle["new_feed_title"],id:"new_feed_title",value:"",regex:/\S+/,error:bundle["new_feed_enterTitle"]},{label:bundle["new_feed_url"],id:"new_feed_url",value:"http://",regex:/http:\/\/\S+/,error:bundle["new_feed_enterUrl"],ltr:true}];
		var submit = function(inputs){ args.submit({id:ibmPortalConfig.contentRenderers.feed,label:inputs["new_feed_title"],prefsMapFcn:com.ibm.customize.AddContentController.getFeedspacePreferences,map:{url:inputs["new_feed_url"],label:inputs["new_feed_title"]}}); };
		args.getInfo(form,bundle["new_feed_addFeed"],bundle["add_content_add"],null,submit);
	},
		
	newWCM: function(/*object*/args){ 
	    // summary: creates a new WCM item like a blog, wiki or solo blog
		// args: an associative array that contains:	getInfo: function that takes the form data and runs a callback function on the validated user inputs
		//												showInfo: function that takes an HTML payload and displays it to the user, then runs a callback function
		//												label (optional): a human readable label for the WCM item, such as "Wiki"
		//												type (optional): the type of WCM content, such as "WIKI_LIBRARY_TYPE"
		//												hub (optional): a datastore
		//												item (optional): an item in the datastore
		// args MUST contain EITHER label, type OR hub and an item containing the "label", and "type" attributes
		var label = args.label ? args.label : args.hub.getValue(args.item,"label","");
		label = (args.hub && args.hub.nlsBundle && args.hub.nlsBundle[label]) ? args.hub.nlsBundle[label] : label;
		var waitingMsg = args.hub.getValue(args.item,"waitingMsg","");
		waitingMsg = (args.hub && args.hub.nlsBundle && args.hub.nlsBundle[waitingMsg]) ? args.hub.nlsBundle[waitingMsg] : waitingMsg;
		var type = args.type ? args.type : args.hub.getValue(args.item,"type","");
		var bundle = dojo.i18n.getLocalization("com.ibm.bundles", "Shelf");
		var genericAddStr = dojo.string.substitute(bundle["new_generic_add"], [label]);
		var processInputs = dojo.hitch(args.controller, function(inputs){ 
			// context "this" object points to controller, args.controller 
			var name = dojo.string.trim(inputs["new_wcm_name"]);
			if(name && name.length > 0){
				var contr = com.ibm.customize.AddContentController;
				var closeOverlay = args.showInfo(waitingMsg);
				var validateNameCallback = dojo.hitch(this, function(response){
					if(response == "false"){ 
						closeOverlay();
						// set up the portlet to get created now
						var portletControl = args.submit({id:ibmPortalConfig.contentRenderers.wcm,label:name});
						// create the library before saving the portlet and then set up preferences on the
						// portlet based on the library id
						var createLibraryCallback = dojo.hitch(this, function(response){
							this.pendingItems[this.store.getCId(portletControl)].prefsMap = this._getPrefsMap({prefsMapFcn:contr.getJSRWcmRenderingPreferences,map:{contextid:response,title:name}});
						});
						// remove the portlet before saving if the library creation failed
						var createLibraryErrback = dojo.hitch(this, this.undoItem, portletControl);
						var beforeSubmitDfd = (new dojo.Deferred()).addCallback(dojo.hitch(this, "_processCreateLibrary", name, type, createLibraryCallback, createLibraryErrback, this.store, this.item));
						this.addBeforeSubmit(beforeSubmitDfd);
					} else {
						// alert the user that the name is already in use
						closeOverlay();
						args.getInfo(form,genericAddStr,bundle["add_content_add"],bundle["new_wcm_wcmNameTaken"],processInputs);
					}
				});
				contr._validateNameField(name, type, validateNameCallback, closeOverlay);
			} else {
				// alert the user that the name is invalid
				args.getInfo(form,genericAddStr,bundle["add_content_add"],bundle["new_wcm_wcmNameInvalid"],processInputs);
			}
		});
		// get a name for the WCM object from the user
	    var form = [{label:bundle["new_wcm_name"],id:"new_wcm_name",value:"",regex:/^[\s\S]/,error:bundle["new_wcm_wcmNameInvalid"]}];
		args.getInfo(form,genericAddStr,bundle["add_content_add"],null,processInputs);
	},
		
/*******************************************************/
/*       functions to create portlet preferences   	   */
/*******************************************************/	
		
	getBlurbPreferences: function(/*Object*/itemMap){
		// summary: get blurb portlet preferences
	    var map = {}; 
	    map["view_jsp"] = itemMap.url; 
	    return map;
	},
    
	getFeedspacePreferences: function(/*Object*/itemMap){
		// summary: get feedspace portlet preferences
		var map = {};
	                        
		map["selection"] = "/0";
	    map["headlines.overrideDefaults"] = "true";
	    map["headlines.showChannelbar"] = "true";
	                   
	    var url = itemMap.url.replace(/&/g,"&amp;");          
	    var subscriptions = '<?xml version="1.0" encoding="utf-8"?><opml version="2.0"><head><title><![CDATA[My Subscription List]]></title><dateModified><![CDATA[Fri, 30 Jan 2009 16:07:24 GMT]]></dateModified><ownerName><![CDATA[Scott DeWitt]]></ownerName><ownerEmail><![CDATA[dewittsc@us.ibm.com]]></ownerEmail></head><body><outline xml:id="Subscription_1';
	    subscriptions = subscriptions + '" text="' + itemMap.label + '" type="rss" isComment="false" isBreakpoint="false" created="Thu, 23 Oct 2008 19:01:11 GMT" category="" title="'
	                                            + itemMap.label + '" xmlUrl="' + url + '" htmlUrl="' + url + '" version="atom_1.0"  /></body></opml>';
	    map["subscriptions"] = subscriptions;
		
	    return map;
	},
        
 	getWcmRenderingPreferences: function(/*Object*/arguments){  
		// summary: get WCM rendering portlet preferences
		var map = {};
	                     
		map["WCM_CONTENT_CONTEXT"] = arguments.context;
	    map["WCM_CONTENT_CONTEXT_DIS"] = arguments.context;
	    map["WCM_CONTENT_CONTEXT_LIB"] = arguments.title;
	    map["WCM_CONTENT_TYPE"] = "CONTENT"; 
	    map["WCM_CONTENT_CONTEXT_TYPE"] = "com.aptrix.pluto.site.SiteArea"; 
	    map["WCM_LISTENS_TO"] = "WCM_LINKING_OTHER"; 
	    map["WCM_PORTLET_TITLE"] = arguments.title; 
	                        
	    return map;
	},


 	getJSRWcmRenderingPreferences: function(/*Object*/arguments){  
		// summary: get WCM rendering portlet preferences
		var map = {};
	
	    map["WCM_CONTENT_CONTEXT_IDR"] = arguments.contextid; 
	    map["WCM_BROADCASTS_TO"] = "WCM_LINKING_NONE";
	    map["WCM_CONTENT_TYPE"] = "CONTENT";
	    map["WCM_CONTENT_CONTEXT_TYPE"] = "sitearea";
	    map["WCM_LISTENS_TO"] = "WCM_LINKING_OTHER";
	    map["WCM_PORTLET_TITLE"] = arguments.title;
		map["WCM_PORTLET_TITLE_TYPE"] = "WCM_PORTLET_TITLE_TYPE_GENERAL";
	                        
	    return map;
	},
                    
	getFeedreaderPreferences: function(/*Object*/itemMap){  
		// summary: get feed reader portlet preferences
	    var map = {};
	                        
	    map["FeedReaderPortlet_feedURL"] = itemMap.url.replace(/&/g,"&amp");
	    map["FeedReaderPortlet_feedName"] = itemMap.label;
	    map["FeedReaderPortlet_feedActionPane"] = "false";
	            
	    return map;
	},

/*******************************************************/
/*       Helper functions for blogs/wikis  	           */
/*******************************************************/	

	_addResourceListFeed: function(/*string*/new_name, /*string*/wcmLibraryType, /*string*/operation_id, /*function*/callback, /*function*/ errorFcn, /*resolver*/store, /*page item*/ item){
		// summary: verifies the name or copies a library with the feed
		var baseUrl = ibmPortalConfig.contentHandlerURI;
		var feedUrl = baseUrl + "?uri=wcmbw:id:" + operation_id;
		var message = dojo.i18n.getLocalization("com.ibm.bundles", "Shelf")["new_wcm_wcmNotCopied"];
		dojo.publish("/window/unload/addPending",[message]);
		var getResourceHandler = dojo.xhrPost( {
			url: feedUrl,
			content: {
				blogname: new_name,
				resourcetype: wcmLibraryType
			},
			handleAs: "json",
			preventCache: true,
			load: function(data){
				var finalCallback = dojo.hitch(this,function(){ dojo.publish("/window/unload/removePending",[message]); if(callback) callback(data.items[0]); });
				if(operation_id == "copylibrary" && ibmPortalConfig.hasEditorRoleOnContentNode && (!ibmPortalConfig.wcmPageMetadata.contentRoot || !ibmPortalConfig.wcmPageMetadata.sharingScope)){
					try {
						var cbk = dojo.hitch(this, function(){
							if(!ibmPortalConfig.wcmPageMetadata.contentRoot){
								store.setValue(item, "metadata[com.ibm.portal.wcm.contentroot]$", data.items[0]);
							}
							if(!ibmPortalConfig.wcmPageMetadata.sharingScope){
								store.setValue(item, "metadata[param.sharing.scope]$", "ibm.wcm.0." + new Date().getTime());
							}
							store.saveItems([item],{onComplete:finalCallback,onError:finalCallback});
						});
						if(!store.isItemLoaded(item)) {
							store.loadItem({
								item: item,
								onItem: cbk
							});
						}
						else cbk();
					} catch(e) { finalCallback(); }
				}
				else finalCallback();
			},
			error: function(error){
				var errorMessage = dojo.i18n.getLocalization("com.ibm.bundles", "Shelf")["add_content_addContentError"];
				var statusMessage = new com.ibm.widgets.StatusMessage("error", errorMessage, error.message);
				dojo.publish("/portal/status",[{message: statusMessage, uid: 'ibmPortalStatusBox'}]);
				dojo.publish("/window/unload/removePending",[message]);
				if(errorFcn) errorFcn();
			}
		 });
		 return getResourceHandler;
	},

	_validateNameField: function(/*String*/newName, /*String*/wcmLibraryType, /*function*/callback, /*function*/ errorFcn){
		// summary: makes sure that a name is not already taken in WCM
		var rv = false;
		if (newName && newName.length > 0) {
			rv = true;
			// test if the name is already in use
			return com.ibm.customize.AddContentController._addResourceListFeed( newName, wcmLibraryType, "validinput", callback, errorFcn); 
		}
	},

	_processCreateLibrary: function(/*String*/name, /*String*/wcmLibraryType, /*function*/callback, /*function*/ errorFcn, /*resolver*/store, /*page item*/ item){
		// summary: creates a blog/wiki
		var newLibrId = null;
		// use the feed to perform the copy operation
		var templateName = "Wiki Template";
		if (wcmLibraryType == "BLOG_LIBRARY_TYPE") {
			templateName = "Blog Template";
		}else if (wcmLibraryType == "BLOG_SOLO_TYPE") {
			templateName = "Blog Solo Template";
		}    
		return com.ibm.customize.AddContentController._addResourceListFeed(name, templateName, "copylibrary", callback, errorFcn, store, item);
	}
}

dojo.provide("com.ibm.customize.placeholder");
dojo.declare("com.ibm.customize.placeholder",
	[dijit._Widget, dijit._Templated],
	{
		titleText: "",
		infoAlt: "",
		imagePath: ".",
		containerId: null,
		controlid: "",
		templateString: '<div dojoAttachPoint="focusNode">' +
							'<div class="ibmPortalControl lotusWidget2" dojoAttachPoint="innerDiv">' +
								'<div class="lotusui">' +
									'<h2>' +
										'<span class="lotusLeft" dojoAttachPoint="titleSpan">${titleText}</span>' +
									'</h2>' +
								'</div>' +
								'<div class="lotusWidgetBody">' +
									'<div class="lotusMessage lotusInfo" style="margin: 0pt;">' +
										'<img src="${imagePath}/iconInfo.gif" alt="${infoAlt}"/>' +
										'<span>${infoAlt}</span>' +
									'</div>' +
								'</div>' +
							'</div>' +
						'</div>',
		attributeMap: dojo.delegate(dijit._Widget.prototype.attributeMap, {
			controlid: ""
		}),
						
		constructor: function(){
			var bundle = dojo.i18n.getLocalization("com.ibm.bundles", "Shelf");
			this.infoAlt = bundle["add_content_notLoaded"];
		},
		
		finish: function(id){
			this.attr("controlid",id);
			dojo.addClass(this.domNode,"ibmPortalControlContainer dojoDndItem");
			dojo.attr(this.domNode, "dndType", com.ibm.portal.dnd.PORTLET_MEDIATOR.type);
			this.innerDiv.id = id;
			dojo.addClass(this.titleSpan,"ibmPortalPortletTitle ibmPortalControlDndHandle dojoDndHandle");
			com.ibm.portal.dnd.PORTLET_MEDIATOR.dndContainers[this.containerId].sync();
		},
		
		error: function(msg,details){
			this.destroy(false);
			if(msg){
				var statusMessage = new com.ibm.widgets.StatusMessage("error", msg, details);
				dojo.publish("/portal/status",[{message: statusMessage, uid: 'ibmPortalStatusBox'}]);
			}
		}
	});

}

if(!dojo._hasResource["com.ibm.customize.ChangeStyleController"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.customize.ChangeStyleController"] = true;
 // This is a controller that customizes the styles of a page

dojo.provide("com.ibm.customize.ChangeStyleController");

com.ibm.customize.ChangeStyleController = {
	current: "",			// the style currently selected on the shelf
	set: "",				// the style currently set on the page

/***********************************************/
/*       Customize Controller API			   */
/***********************************************/
	store: null,		// a datastore to save model changes
	item: null,			// an item in the store representing the current page to which changes will be made
	parent: null,		// a pointer to this controller's parent, if one exists
	dirty: false,		// true if there are changes pending
	started: false,		// true if the widget is started up
	refresh: false,		// true if a page refresh is required to show saved changes

	startup: function(/*Object?/Widget?*/parent){
		// summary: sets some variables, sets up the UI and prepares the stylesheet links so they can be switched out smoothly
		// parent: a reference to the parent of this controller
		this.started = true;
		this.current = this.set;
		this.parent = parent;
		if(this.setupUI) this.setupUI();
	},
		
	makeDirty: function(/*bool*/change){
		// summary: changes the dirty attribute
		// change: value to assign to the dirty attribute
		this.dirty = change;
	},
		
	processChange: function(/*Object*/args){
		// summary: used as an event handler for when a user clicks on a result
		this.apply(args);
		if(!this.parent) {
			this.beforeSubmit().addCallback(dojo.hitch(this, function(){this.submit(args)}));
		}
	},
		
	apply: function(/*Object*/args){
		// summary: applies a change associated with a result to the page
		// args: contains args.id which is the id of the selected item
		if(args.id == this.current) return;
		if(args.id == this.set) this.makeDirty(false);
		else if(this.dirty == false) this.makeDirty(true);
		this.current = args.id;	
		this._switchStylesheet(this.current);
	},
		
	undo: function(){
		// summary: reverts any changes made
		if(this.started) this.apply({id:this.set});
	},

	beforeSubmit: function(/*Object*/args){
		// summary: set the metadata for the style in the content model store. Returns a Deferred
		//		which is fired when the controller is ready to be submitted.
		var dfd = new dojo.Deferred();
		var cbk = dojo.hitch(this, function(){
			if(this.started) this.store.setValue(this.item, "metadata[colorPalette]$", this.current);
			dfd.callback();
		});
		if(!this.store.isItemLoaded(this.item)) {
			this.store.loadItem({
				item: this.item,
				onItem: cbk,
				onError: args ? args.onError : null
			});
		}
		else cbk();
		return dfd;
	},
		
	submit: function(/*Object*/args){
		// summary: saves any pending changes to the server
		// args: args may contain an onComplete handler
		if(!this.dirty) { 
			if(args.onComplete) args.onComplete(); 
			return; 
		}
		var onComplete = dojo.hitch(this, function(){
			this.makeDirty(false);
			this.set = this.current;
			if(args.onComplete) args.onComplete();
		});
		this.store.saveItems([this.item],{
			onComplete: onComplete,
			onError: args.onError
		});
	},
		
/***********************************************/
/*              Helper functions   		       */
/***********************************************/

	_switchStylesheet: function(title){
		// summary: switch to the stylesheet with the given title
		var i, currLink;
		for(i = 0; (currLink = document.getElementsByTagName("link")[i]); i++) {
			// if the link is a perferred stylesheet
			if(currLink.getAttribute("rel").indexOf("style") >= 0 && currLink.getAttribute("title")) { 
				// if the chosen theme is found
				if(currLink.getAttribute("title") == title) currLink.disabled = false;
				else currLink.disabled = true; 
			}
	    }
	},

	_loadCss: function(path, title, alternate, disabled){
		var link = dojo.create("link",{type:"text/css",rel:(alternate)?"alternate stylesheet":"stylesheet",href:path,media:"screen",disabled:disabled});
		if(title) link.title = title;
		var head = document.getElementsByTagName("head")[0];
		head.appendChild(link);
	}
}

}

if(!dojo._hasResource["com.ibm.customize.ResultsList"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.customize.ResultsList"] = true;
// This controls the list of results in the customization shelf.  It handles searching datastores and paging.  It usually works with a com.ibm.customize.Container as its parent.

dojo.provide("com.ibm.customize.ResultsList");





dojo.declare("com.ibm.customize.ResultsList",
	[dijit._Widget, dijit._Templated],
	{
		source: null,						// the source which is currently selected for searching
		parent: null, 						// the parent container for this widget
		searchTerms: [], 					// an array of search terms for fetch 
		currRequest: null,					// the current fetch request
		size: 9,							// the number of results displayed at once
		start: 0,							// the index of the first result displayed in the section
		totalItemCount: 0,					// the total number of items matched by the last search query
		templateString: '<div dojoAttachPoint="focusNode">' +
							'<div class="lotusPaletteWidgetContainer" role="grid" dojoAttachPoint="table"></div>' +
							'<div class="lotusPaging">' +
								'<div class="lotusLeft" dojoAttachPoint="pagingStatus"></div>' +
								'<ul class="lotusRight lotusInlinelist">' +
									'<li class="lotusFirst" dojoAttachPoint="prevLink"></li>' +
									'<li dojoAttachPoint="nextLink"></li>' +
								'</ul>' +
								'<div dojoAttachPoint="jumpToLink"></div>' +
							'<div>' +
						'</div>',
		
		constructor: function() {
			this.shelfBundle = dojo.i18n.getLocalization("com.ibm.bundles", "Shelf");
		},
		
		postCreate: function(){ 
			// summary: subscribes to events for when the search terms changes, the source changes, the user wants to add a saved search, or the size of the browser window adjusts
			dojo.subscribe("/epc/customize/search"+this.parent.id, this, this.changeSearchTerms);
			dojo.subscribe("/epc/customize/changeSource"+this.parent.id, this, this.changeSource);
		},
		
		/**********************************/
		/*            SEARCH              */
		/**********************************/
		
		changeSearchTerms: function(/*String[]*/ searchTerms){
			// summary: does a new search when the filters change
			// searchTerms: an array of strings which are filters
			this.searchTerms = searchTerms;
			this.start = 0;
			this._search();
		},
		
		changeSource: function(/*Object*/ source){
			// summary: does a fresh search with no filters when the hub changes
			// source: the new source to search
			if(this.currRequest) this.currRequest.abort();  // make sure any unfinished request is aborted
			this.source = source;
			this.searchTerms = [];
			this.start = 0;
			if(source.hub.noIcons) dojo.addClass(this.domNode.parentNode,"lotusPlain");
			else dojo.removeClass(this.domNode.parentNode,"lotusPlain");
			this._search();
		},
		
		_search: function(){
			// summary: does a fetch operation on the hub and fills the table with the results
			if(this.source.hub == null){
				// alert the user if the hub is null and clear out old info on the paging bar
				this.addMessage("Error",dojo.string.substitute(this.shelfBundle["shelf_badDatastoreError"], [this.source.label]));
				return;
			} else this.setLoading();
			
			// See dojo.data.api.Read.fetch()
			this.currRequest = this.source.hub.fetch({
				queryOptions: { ignoreCase: true },
				query: { keywords: this.searchTerms }, // query is the array of filters that the hub handles in its own way
				count: this.size,
				start: this.start,  
				
				onComplete: dojo.hitch(this, function(/*DatastoreItem[]*/items) {
					// summary: uses the items returned from the search to adjust what is displayed on the paging bars, and fill the table with results
					if(this.parent.filterAdd){
						// filter out any items that should not be displayed
						filterFcn = dojo.hitch(this,function(item){ return this.parent.filterAdd(this.source.hub.mapItem(item)); })
						items = dojo.filter(items,filterFcn);
					}
					if(items.length == 0) this.addMessage("Warning",this.shelfBundle["shelf_noResults"]);
					else this.fill(items);
				}),
				
				onError: dojo.hitch(this, function(/*String*/error, /*Object*/request) {
					// summary: displays an error message in the table and clears out old info on the paging bar
					this.clear();
					this.addMessage("Error", dojo.string.substitute(this.shelfBundle["shelf_feedError"], [this.source.label]));
				}),
				
				onBegin: dojo.hitch(this, function(totalNumber) {
					// summary: records the number of results returns in the current query
					this.totalItemCount = totalNumber;
				})
			});
		},
		
		/***********************************/
		/*              TABLE              */
		/***********************************/
		
		setLoading: function() {
			// summary: adds a loading indicator, for use before search results are appended
			this.clear();
			this.table.appendChild(document.createTextNode(this.shelfBundle["shelf_loading"]));
		},
		
		addMessage: function(/*String*/type,/*String*/msg){
			// summary: clears out the table and then builds it back up enough to enter a single message into the table
			// msg: the message to enter in the table
			this.clear();
			// create the cell
			var message = this.parent.createLotusMsgNode(msg,type);
			this.table.appendChild(message);
			// reset search numbers to 0 and adjust the info on the paging bar
			this.start = 0;
			this.totalItemCount = 0;
		},
		
		clear: function(){
			// summary: clears out the table
			var items = dojo.query(".lotusPaletteWidget",this.table);
			dojo.forEach(items, dojo.hitch(this, function(item){
				dijit.byId(item.id).destroy();
			}));
			this.table.innerHTML = "";
			this.pagingStatus.innerHTML = "";
			this.jumpToLink.innerHTML = "";
			this.prevLink.innerHTML = "";
			this.nextLink.innerHTML = "";
		},
		
		fill: function(/*DatastoreItem[]*/contents){
			// summary: fills the table with rows of catalog item results
			// contents: array holding DatastoreItems to be entered in the table
			this.clear();
			dojo.forEach(contents, dojo.hitch(this, function(item) {
				var newCell = this.parent.newCell(this.source,item)
				this.table.appendChild(newCell);
			}));	
			this.adjustPagingBar();
		},
		
		/************************************/
		/*              PAGING              */
		/************************************/
		
		prev: function(){
			// summary: triggers when the user clicks the Previous link,
			this.start = this.start - this.size;
			this._search();
		},
		
		next: function(){
			// summary: triggers when the user clicks the Next link
			this.start = this.start + this.size;
			this._search();
		},
		
		jumpTo: function(/*Event*/e){
			// summary: triggers when a user jumps to a new page
			// event: the onkeydown event
			e = dojo.fixEvent(e, e.target);
			var key = e.keyCode;
		
			if(key == dojo.keys.ENTER){
				var input = this.jumpToInput.value;
				// if number is not an integer, return
				if(input.toString().search(/^[0-9]+$/) != 0)  return;
				// if number is less than 1, set it to 1
				if(input < 1) input = 1;
				
				// calculate the new starting index for result items and make sure it's within range
				var userInputStart = (input - 1) * this.size;
				var maxStart = (Math.ceil(this.totalItemCount/this.size) - 1) * this.size;
				this.start = (userInputStart < maxStart)?userInputStart:maxStart;
				// search with the new starting index
				this._search();
			}
		},
		
		adjustPagingBar: function(){
			// summary: triggers when a search is performed to make sure the numbers and contents of the bar match up
			var firstItem = (this.totalItemCount == 0)?0:this.start + 1;
			var lastItem = this.start + this.size;
			lastItem = (this.totalItemCount > lastItem)?lastItem:this.totalItemCount;
			
			// displays "Page X of Y" in the paging bar
			var currentPage = Math.ceil(firstItem/this.size);
			var totalPageCount = Math.ceil(this.totalItemCount/this.size);
			this.pagingStatus.innerHTML = dojo.string.substitute(this.shelfBundle["shelf_page"], [currentPage, totalPageCount]);
			
			// create Previous and Next links , and Jump to page ___  if appropriate
			this.createPrevNode(firstItem);
			this.createNextNode(lastItem);
			if(this.totalItemCount > this.size) this.createJumpTo(firstItem);
		},
		
		createPrevNode: function(/*Int*/firstItem){
			// summary: determines if a Previous link should be rendered and creates it if appropriate
			if(firstItem > 1){  // create a link
				var prev = dojo.create("a", {href:"javascript:void(0)",innerHTML:this.shelfBundle["shelf_previous"]});
				prev.onclick = dojo.hitch(this, function(){ this.prev(); return false; /* to prevent onBeforeUnload event from triggering in IE */ });
				this.prevLink.appendChild(prev);
			}
			else  // create unclickable text
				this.prevLink.appendChild(document.createTextNode(this.shelfBundle["shelf_previous"]));
		},
		
		createNextNode: function(/*Int*/lastItem){
			// summary: determines if a Next link should be rendered and creates it if appropriate
			if(this.totalItemCount > lastItem){  // create a link
				var next = dojo.create("a", {href:"javascript:void(0)",innerHTML:this.shelfBundle["shelf_next"]});
				next.onclick = dojo.hitch(this, function(){ this.next(); return false; /* to prevent onBeforeUnload event from triggering in IE */ });
				this.nextLink.appendChild(next);
			}
			else // create unclickable text
				this.nextLink.appendChild(document.createTextNode(this.shelfBundle["shelf_next"]));
		},
		
		createJumpTo: function(firstItem){
			// summary: if there is  more than one page available, this creates a "Jump to page ___" input
			this.jumpToInput = dojo.create("input",{type:"text",value:Math.ceil(firstItem/this.size),className:"lotusText"});
			dojo.connect(this.jumpToInput, "onkeydown", this, this.jumpTo);
			this.jumpToLink.appendChild(document.createTextNode(this.shelfBundle["shelf_jumpTo"]));
			this.jumpToLink.appendChild(this.jumpToInput);
		}
});

}

if(!dojo._hasResource["com.ibm.customize.SearchBar"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.customize.SearchBar"] = true;
// This is an input box which publishes all the words of the input's value as an array to a given event

dojo.provide("com.ibm.customize.SearchBar");




/*2010 10 04 Sue : search bar - display:none */
dojo.declare("com.ibm.customize.SearchBar",
	[dijit._Widget, dijit._Templated],
	{
		imagePath: ".",
		searchId: "",
		searchFieldText: "",
		searching: true,
		publishKeyword: "/epc/customize/search",	// the keyword to publish when a string is submitted
		templateString: '<div dojoAttachPoint="focusNode" class="lotusChunk lotusSearch" style="display:none">' +
							'<form role="search" action="" onsubmit="return false">' +
								'<label for="${searchBoxId}" class="ibmPortalHiddenText" dojoAttachPoint="searchFieldLabel">${searchFieldText}</label>' +
								'<input id="${searchBoxId}" dojoAttachEvent="onkeydown:newSearch" class="lotusText" type="text" value="${searchFieldText}" onfocus="this.value=\'\';" dojoAttachPoint="searchField"/>' +
								'<span class="lotusBtnImg">' +
									'<input dojoAttachEvent="onclick:searchButton" title="${submitSearchText}" class="lotusSearchButton" type="image" alt="" src="${imagePath}/blank.gif"/>' +
									'<span class="lotusAltText">Search</span>' +
								'</span>' +
							'</form>' +
						'</div>',
		
		constructor: function() {
			this.bundle = dojo.i18n.getLocalization("com.ibm.bundles", "Shelf");
			this.submitSearchText = this.bundle["shelf_submitSearch"];
		},
		
		postMixInProperties: function(){
			this.searchBoxId = this.searchId + "_search";
		},
		
		postCreate: function(){
			// summary: subscribe to the event that changes the default text in the search box
			dojo.subscribe("/epc/customize/changeSource"+this.searchId, this, this.changeInputValue);
		},
		
		enableSearch: function(){
			if(!this.searching){
				this.searching = true;
				dojo.style(this.searchField, "backgroundColor", "#FFFFFF");
				dojo.style(this.searchField, "borderColor", "#FFFFFF");
				this.searchField.removeAttribute("disabled");
			}
		},
		
		disableSearch: function(){
			if(this.searching){
				this.searching = false;
				dojo.style(this.searchField, "backgroundColor", "#CCCCCC");
				dojo.style(this.searchField, "borderColor", "#CCCCCC");
				dojo.attr(this.searchField, "disabled", true);
			}
		},
		
		changeInputValue: function(/*Object*/source){
			// summary: changes the text in the field
			if(source.hub.searchable) this.enableSearch();
			else this.disableSearch();
			if(source.searchStr) this.searchFieldText = source.hub.searchable ? source.searchStr : "";
			else this.searchFieldText = source.hub.searchable ? dojo.string.substitute(this.bundle["shelf_search"], [source.label]) : "";
			this.searchField.value = this.searchFieldLabel.innerHTML = this.searchFieldText;
		},
		
		newSearch: function(/*Event*/e){
			// summary: triggers when a user is typing 
			// Publishes an event when the user presses the enter key
			e = dojo.fixEvent(e, e.target);
			var key = e.keyCode;
		
			if(dojo.isIE && key == dojo.keys.ENTER)
				this.searchButton();
		},
		
		searchButton: function(){
			// summary: creates an array of the space separated search terms and publishes them to an event
			if(this.searching){
				var searchWords = (this.searchField.value == this.searchFieldText) ? "" : this.searchField.value;  // no search criteria if field = "Search xxxx"
				var searchArray = searchWords.split(" ");
				// publish the event to a specific id so not all instances of the receiving class respond
				dojo.publish(this.publishKeyword+this.searchId, [searchArray]);
			}
		}
});

}

if(!dojo._hasResource["dojo.fx.easing"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.fx.easing"] = true;
dojo.provide("dojo.fx.easing");

dojo.fx.easing = {
	// summary: Collection of easing functions to use beyond the default dojo._defaultEasing
	// 
	// description:
	//	Easing functions are used to manipulate the iteration through
	//	an _Animation's _Line. _Line being the properties of an Animation,
	//	and the easing function progresses through that Line determing
	//	how quickly (or slowly) it should go. Or more accurately: modify
	//	the value of the _Line based on the percentage of animation completed.
	//	
	//	All functions follow a simple naming convention of "ease type" + "when".
	//	If the name of the function ends in Out, the easing described appears
	//	towards the end of the animation. "In" means during the beginning,
	//	and InOut means both ranges of the Animation will applied, both beginning
	//	and end. 
	//
	//	example:
	//	|	
	//	|	var anim = dojo.fadeOut({
	//	|		node: 'node',	
	//	|		duration: 2000,
	//	|		easing: dojo.fx.easing.quadIn
	//	|	}).play();
	//
	
	linear: function(/* Decimal? */n){
		// summary: A linear easing function
		return n;
	},

	quadIn: function(/* Decimal? */n){
		return Math.pow(n, 2);
	},

	quadOut: function(/* Decimal? */n){
		return n * (n - 2) * -1;
	},

	quadInOut: function(/* Decimal? */n){
		n = n * 2;
		if(n < 1){ return Math.pow(n, 2) / 2; }
		return -1 * ((--n) * (n - 2) - 1) / 2;
	},

	cubicIn: function(/* Decimal? */n){
		return Math.pow(n, 3);
	},

	cubicOut: function(/* Decimal? */n){
		return Math.pow(n - 1, 3) + 1;
	},

	cubicInOut: function(/* Decimal? */n){
		n = n * 2;
		if(n < 1){ return Math.pow(n, 3) / 2; }
		n -= 2;
		return (Math.pow(n, 3) + 2) / 2;
	},

	quartIn: function(/* Decimal? */n){
		return Math.pow(n, 4);
	},

	quartOut: function(/* Decimal? */n){
		return -1 * (Math.pow(n - 1, 4) - 1);
	},

	quartInOut: function(/* Decimal? */n){
		n = n * 2;
		if(n < 1){ return Math.pow(n, 4) / 2; }
		n -= 2;
		return -1 / 2 * (Math.pow(n, 4) - 2);
	},

	quintIn: function(/* Decimal? */n){
		return Math.pow(n, 5);
	},

	quintOut: function(/* Decimal? */n){
		return Math.pow(n - 1, 5) + 1;
	},

	quintInOut: function(/* Decimal? */n){
		n = n * 2;
		if(n < 1){ return Math.pow(n, 5) / 2; };
		n -= 2;
		return (Math.pow(n, 5) + 2) / 2;
	},

	sineIn: function(/* Decimal? */n){
		return -1 * Math.cos(n * (Math.PI / 2)) + 1;
	},

	sineOut: function(/* Decimal? */n){
		return Math.sin(n * (Math.PI / 2));
	},

	sineInOut: function(/* Decimal? */n){
		return -1 * (Math.cos(Math.PI * n) - 1) / 2;
	},

	expoIn: function(/* Decimal? */n){
		return (n == 0) ? 0 : Math.pow(2, 10 * (n - 1));
	},

	expoOut: function(/* Decimal? */n){
		return (n == 1) ? 1 : (-1 * Math.pow(2, -10 * n) + 1);
	},

	expoInOut: function(/* Decimal? */n){
		if(n == 0){ return 0; }
		if(n == 1){ return 1; }
		n = n * 2;
		if(n < 1){ return Math.pow(2, 10 * (n - 1)) / 2; }
		--n;
		return (-1 * Math.pow(2, -10 * n) + 2) / 2;
	},

	circIn: function(/* Decimal? */n){
		return -1 * (Math.sqrt(1 - Math.pow(n, 2)) - 1);
	},

	circOut: function(/* Decimal? */n){
		n = n - 1;
		return Math.sqrt(1 - Math.pow(n, 2));
	},

	circInOut: function(/* Decimal? */n){
		n = n * 2;
		if(n < 1){ return -1 / 2 * (Math.sqrt(1 - Math.pow(n, 2)) - 1); }
		n -= 2;
		return 1 / 2 * (Math.sqrt(1 - Math.pow(n, 2)) + 1);
	},

	backIn: function(/* Decimal? */n){
		// summary: An easing function that starts away from the target, and 
		//		quickly accelerates towards the end value
		var s = 1.70158;
		return Math.pow(n, 2) * ((s + 1) * n - s);
	},

	backOut: function(/* Decimal? */n){
		// summary: An easing function that pops past the range briefly, and 
		// 	slowly comes back. 
		n = n - 1;
		var s = 1.70158;
		return Math.pow(n, 2) * ((s + 1) * n + s) + 1;
	},

	backInOut: function(/* Decimal? */n){
		// summary: An easing function combining the effects of backIn and backOut
		var s = 1.70158 * 1.525;
		n = n * 2;
		if(n < 1){ return (Math.pow(n, 2) * ((s + 1) * n - s)) / 2; }
		n-=2;
		return (Math.pow(n, 2) * ((s + 1) * n + s) + 2) / 2;
	},

	elasticIn: function(/* Decimal? */n){
		// summary: An easing function the elastically snaps from the start value
		if(n == 0 || n == 1){ return n; }
		var p = .3;
		var s = p / 4;
		n = n - 1;
		return -1 * Math.pow(2, 10 * n) * Math.sin((n - s) * (2 * Math.PI) / p);
	},

	elasticOut: function(/* Decimal? */n){
		// summary: An easing function that elasticly snaps around the target value, near the end of the Animation
		if(n==0 || n == 1){ return n; }
		var p = .3;
		var s = p / 4;
		return Math.pow(2, -10 * n) * Math.sin((n - s) * (2 * Math.PI) / p) + 1;
	},

	elasticInOut: function(/* Decimal? */n){
		// summary: An easing function that elasticly snaps around the value, near the beginning and end of the Animation		
		if(n == 0) return 0;
		n = n * 2;
		if(n == 2) return 1;
		var p = .3 * 1.5;
		var s = p / 4;
		if(n < 1){
			n -= 1;
			return -.5 * (Math.pow(2, 10 * n) * Math.sin((n - s) * (2 * Math.PI) / p));
		}
		n -= 1;
		return .5 * (Math.pow(2, -10 * n) * Math.sin((n - s) * (2 * Math.PI) / p)) + 1;
	},

	bounceIn: function(/* Decimal? */n){
		// summary: An easing function that "bounces" near the beginning of an Animation
		return (1 - dojo.fx.easing.bounceOut(1 - n)); // Decimal
	},

	bounceOut: function(/* Decimal? */n){
		// summary: An easing function that "bounces" near the end of an Animation
		var s = 7.5625;
		var p = 2.75;
		var l; 
		if(n < (1 / p)){
			l = s * Math.pow(n, 2);
		}else if(n < (2 / p)){
			n -= (1.5 / p);
			l = s * Math.pow(n, 2) + .75;
		}else if(n < (2.5 / p)){
			n -= (2.25 / p);
			l = s * Math.pow(n, 2) + .9375;
		}else{
			n -= (2.625 / p);
			l = s * Math.pow(n, 2) + .984375;
		}
		return l;
	},

	bounceInOut: function(/* Decimal? */n){
		// summary: An easing function that "bounces" at the beginning and end of the Animation
		if(n < 0.5){ return dojo.fx.easing.bounceIn(n * 2) / 2; }
		return (dojo.fx.easing.bounceOut(n * 2 - 1) / 2) + 0.5; // Decimal
	}
};

}

if(!dojo._hasResource["dojox.fx.easing"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.fx.easing"] = true;
dojo.provide("dojox.fx.easing");
dojo.deprecated("dojox.fx.easing","Upgraded to Core, use dojo.fx.easing instead","2.0");

/*=====
	dojox.fx.easing = {
		// summary:
		//		An Alias to `dojo.fx.easing`. Moved to Core in Dojo 1.2.
	});
=====*/
dojox.fx.easing = dojo.fx.easing;

}

if(!dojo._hasResource["com.ibm.customize.Menu"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.customize.Menu"] = true;
// This is a menu.  It takes a list of sources that each have label attributes to use as display titles.  It publishes an event on a source each time one is clicked.
dojo.provide("com.ibm.customize.Menu");








dojo.declare("com.ibm.customize.Menu",
	[dijit._Widget, dijit._Templated],
	{
		sources: [],									// an array of objects containing labels and datastore hubs for each menu choice
		choices: {},									// a map of label : DOMNode pairs for each choice in the menu
		searchId: "",									// the id of the Container to search within
		menuTitle: "Menu",								// title for the menu
		current: null,									// the menu choice currently selected
		selectedText: "currently selected category",
		unselectedText: "press enter to browse this category",
		publishKeyword: "/epc/customize/changeSource",	// the keyword to publish to add a filter
		templateString: '<div dojoAttachPoint="focusNode"><h3>${menuTitle}</h3><div role="menu" dojoAttachPoint="menuContainer" class="lotusMenu"><ul dojoAttachPoint="list"></ul></div></div>',
		
		constructor: function() {
			this.bundle = dojo.i18n.getLocalization("com.ibm.bundles", "Shelf");
			this.menuTitle = this.bundle["shelf_menu"];
			this.selectedText = this.bundle["menu_selected_text"] || this.selectedText;
			this.unselectedText = this.bundle["menu_unselected_text"] || this.unselectedText;
		},
	
		postCreate: function(){
			// summary: populates the menu with the given choices , makes sure the first item on the list is selected
			
			//subscribe to when a new source is changed so the highlighting in the menu will match
			dojo.subscribe(this.publishKeyword+this.searchId, this, this.changeHighlighting);
			
			if(this.sources.length > 0) {
				// add the choices to the menu with the first choice selected
				dojo.forEach(this.sources, dojo.hitch(this, function(choice){ this.addLi(choice); }));
				this.select(this.sources[0]);
			}
		},
		
		addLi: function(/*Object*/choice){
			// summary: adds a new element to the list of choices in the menu
			// choice: a member of the choices array to add to the menu
			var li = dojo.create("li");
			var newLink = dojo.create("a",{href:"javascript:void(0)",innerHTML:choice.label});
			newLink.onclick = function(){ return false; /* to prevent onBeforeUnload event from triggering in IE */ };
			li.appendChild(newLink);
			var selectedSpan = dojo.create("span",{innerHTML:this.unselectedText,className:"",className:"ibmPortalHiddenText"});
			newLink.appendChild(selectedSpan);
			// when the menu item is clicked, call the select function on it
			dojo.connect(li, 'onclick', this, function(){ this.select(choice); });
			// add the new item to DOM and the map of choices
			this.list.appendChild(li);
			this.choices[choice.label] = {li:li,span:selectedSpan};
		},
		
		select: function(/*Object*/source){
			// summary: triggered by a menu click,
			// source: the menu choice that was clicked
			
			// publish the event to a specific id so not all instances of the receiving class respond
			dojo.publish(this.publishKeyword+this.searchId, [source]);
		},
		
		changeHighlighting: function(/*String*/source){
			// summary: switches which menu choice is selected
			// source: the menu choice that was chosen
			if(this.current) {
				dojo.removeClass(this.choices[this.current].li, "lotusSelected");
				this.choices[this.current].span.innerHTML = this.unselectedText;
			}
			dojo.addClass(this.choices[source.label].li, "lotusSelected");
			this.choices[source.label].span.innerHTML = this.selectedText;
			this.current = source.label;
		}
});

}

if(!dojo._hasResource["com.ibm.customize.LotusPaletteContainer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.customize.LotusPaletteContainer"] = true;
// This is a container which follows the one ui lotus palette spec
// must be provided with a processChange function
dojo.provide("com.ibm.customize.LotusPaletteContainer");










dojo.declare("com.ibm.customize.LotusPaletteContainer",
	[dijit._Widget, dijit._Templated],
	{
		jsonFile: null,				// a JSON configuration file
		dialog: null,				// a dijit dialog
		maxLabelLength: 16,			// the maximum length allowed for a label
		smallWidget: false,			// false if it follows the lotusLargeWidget pattern
		numRows: 4,					// the number of rows of results to be displayed
		label: "",					// a label for this palette section
		selectedClass: "lotusSelected",
		imagePath: ".",
		templateString:'<div class="lotusui">' +
							'<div class="lotusPaletteBody">' +
								'<div dojoAttachPoint="left" class="lotusPaletteNav"></div>' +
								'<div dojoAttachPoint="center" class="lotusPaletteContent lotusui"></div>' +
							'</div>' +
						'</div>',
						
		constructor: function() {
			this.nlsBundle = dojo.i18n.getLocalization("com.ibm.bundles", "Shelf");
		},
		
		postMixInProperties: function() {
			if(this.smallWidget) {
				this.dialog = new com.ibm.customize.LotusDialog({ blankImg:this.imagePath + "/blank.gif" });
				this.dialog.closeButtonNode.onclick = this.dialog.closeLinkNode.onclick = dojo.hitch(this,function(){this.dialog.cancel();return false;});
			}
		},
		
		processChange: function(/*Object*/args) {
		},
		
		getSize: function(){
			// summary: determine the width of a palette widget element on the page with all the current settings by adding one to the page, taking its width, then deleting it
			// use the palette widget to determine how many of them can fit in the ResultsList
			var paletteWidget = dojo.create("div",{className:"lotusPaletteWidget"});
			document.body.appendChild(paletteWidget);
			if (paletteWidget.currentStyle){
				marginL = paletteWidget.currentStyle["marginLeft"].match(/^\d+/);
				marginR = paletteWidget.currentStyle["marginRight"].match(/^\d+/);
			} else if (window.getComputedStyle) {
				marginL = document.defaultView.getComputedStyle(paletteWidget,null).getPropertyValue("margin-left").match(/^\d+/);
				marginR = document.defaultView.getComputedStyle(paletteWidget,null).getPropertyValue("margin-right").match(/^\d+/);
			} 
			var width = paletteWidget.offsetWidth + marginL*1 + marginR*1;
			var containerWidth = this.center.offsetWidth;
			var resultsInOneRow = Math.floor(containerWidth / width);
			dojo.destroy(paletteWidget);
			return resultsInOneRow * this.numRows;
		},
		
		setupUI: function(){
			// summary: starts the UI setup
			this.processJSON(dojo.hitch(this,this.setupUICallback));
		},
		
		setupUICallback: function(sources){
			// summary: populates the SearchBar, Menu and ResultsList widget with configuration data from the JSON file
			var resultsList = new com.ibm.customize.ResultsList({parent:this,size:this.getSize()});
			this.center.appendChild(resultsList.domNode);
				
			var searchBar = new com.ibm.customize.SearchBar({searchId:this.id,imagePath:this.imagePath});
			this.left.appendChild(searchBar.domNode);
				
			var menu = new com.ibm.customize.Menu({sources:sources,searchId:this.id,menuTitle:this.label});
			this.left.appendChild(menu.domNode);
		},
		
		processJSON: function(/*function*/callback){
			// summary: processes the JSON file associated with this controller
			// callback: function to call after the JSON is processed that uses the sourceObjects
			dojo.xhrGet ({
		        url: this.jsonFile,
		        handleAs: 'json',
		        load: dojo.hitch(this, function(data){
					// get the bundle if one is provided
					if(data.localizationPackageName && data.localizationBundleName){
						this.nlsJsonBundle = dojo.i18n.getLocalization(data.localizationPackageName, data.localizationBundleName);
					} else this.nlsJsonBundle = null;
					var sources = data.categories;
					var sourceObjects = new Array();
					for(var i = 0; i < sources.length; i++) {
						// pass the exact same sources item to the class's constructor minus the datastore and renderers properties
						var map = dojo.mixin({}, sources[i]);
						if(map.url && this.createProxyURI) map.url = this.createProxyURI(map.url);
						delete map.datastore; delete map.renderers; delete map.label;
						// create a datastore hub and a new source object
						var evalString = "new " + sources[i].datastore + "(" + dojo.toJson(map) + ")";
						var hub = dojo.eval(evalString);
						if(!hub.validateSelf()) continue;  // do not use this source if it does not validate
						if(hub.getSourceLabel()) var label = hub.getSourceLabel();  // mashups categories feeds
						else var label = this.nlsJsonBundle && this.nlsJsonBundle[sources[i].label] ? this.nlsJsonBundle[sources[i].label] : sources[i].label;  // everything else
						if(label.length == 0) label = this.nlsBundle["add_content_untitled"];
						var searchStr = this.nlsJsonBundle && this.nlsJsonBundle[sources[i].searchStr] ? this.nlsJsonBundle[sources[i].searchStr] : sources[i].searchStr;  // everything else
						if(searchStr && searchStr.length == 0) searchStr = null;
						sourceObjects.push({label:label,hub:hub,renderers:sources[i].renderers,url:sources[i].url,searchStr:searchStr});
					}
					if(callback) callback(sourceObjects);
				}),	
		        error: dojo.hitch(this, function (/*String*/error) {
		            var errorMsg = this.createLotusMsgNode(this.nlsBundle["shelf_configError"],"Error");
					dojo.style(errorMsg,"margin","20px");
					this.domNode.innerHTML = "";
					this.domNode.appendChild(errorMsg);
		        })
		    });
		},
		
		newCell: function(/*Object*/source,/*DataItem*/item){
			// summary:  override this function to fill innerCell with information about the given datastore item
			// source: a datastore
			// item: an item in source
			var map = source.hub.mapItem(item);
			var label = (map.label.length > this.maxLabelLength)?map.label.substring(0,this.maxLabelLength) + '...':map.label;
			
			if(this.smallWidget) {
				var applyToPage = dojo.hitch(this, function() { this.processIntermediateDialogs(source,item); });
				showDetails = dojo.hitch(this, function() { this.showDetailsDialog(map,applyToPage); return false; /* to prevent onBeforeUnload event from triggering in IE */ });
				if(source.hub.noIcons){
					var widget = new com.ibm.customize.noIconSmallWidget({titleText:map.label, truncTitleText:label, imagePath:this.imagePath, apply:applyToPage, showDetails:showDetails});
				} else {
					var widget = new com.ibm.customize.smallWidget({titleText:map.label, truncTitleText:label, imagePath:this.imagePath, iconPath:map.thumbnail, apply:applyToPage, showDetails:showDetails});
				}
			}
			else {
				var applyToPage = dojo.hitch(this, function() { this.processChange({id:map.id,name:map.label}) });
				var widget = new com.ibm.customize.largeWidget({titleText:map.label, truncTitleText:label, imagePath:this.imagePath, iconPath:map.thumbnail, apply:applyToPage, id:map.id, current:map.id == this.current});
			}
			return widget.domNode;
		},
		
		createLotusMsgNode: function(/*string*/message,/*string*/type){
			// summary: returns a div node containing the given message with OneUI styles
			// msg: the error message to display
			// type: either "Warning", "Error", "Info" or "Confirm"
			var err = dojo.create("div",{className:"lotusMessage lotus" + type, style:{ marginRight:"15px" }});
			var img = dojo.create("img",{src:this.imagePath + "/icon" + type + ".gif", alt:message});
			var msg = dojo.create("span",{innerHTML:message});
			err.appendChild(img);
			err.appendChild(msg);
			return err;
		},
		
		changeSelected: function(/*string*/selected){
			// reset the look of the previously selected style/layout
			var items = dojo.query(".lotusPaletteWidget",this.center), selectedWidget = null;
			dojo.forEach(items, dojo.hitch(this, function(item){
				selectedWidget = dijit.byId(item.id);
				if(selectedWidget) selectedWidget.deselect();
			}));
			selectedWidget = dijit.byId(selected);
			if(selectedWidget) selectedWidget.select();
		},
		
		/**********************************/
		/*        DIALOG HELPERS          */
		/**********************************/
		
		processIntermediateDialogs: function(/*Object*/source,/*DataItem*/item){
			// source: a datastore
			// item: an item in source's hub
			var map = source.hub.mapItem(item);
			if(!source.renderers && this.renderers) source.renderers = this.renderers; // so Mashups can provide its renderers dynamically
			if(source.renderers.length == 0){
				// if there are no renderers defined, then this is a self renderer and we assume the item's id is the id of the piece of content to be added
				var takeoverFcn = source.hub.getValue(item,"takeover",null);
				var takeoverObject = takeoverFcn ? {submit:dojo.hitch(this,this.processChange),getInfo:dojo.hitch(this,this.getValuesFromDialog),showInfo:dojo.hitch(this,this.showWaitMsgInDialog),hub:source.hub,item:item} : {};
				var args = {id:map.id,label:map.label,map:map,takeoverFcn:takeoverFcn,takeoverObject:takeoverObject};
				this.processChange(args);
			} else if(source.renderers.length == 1){ 
				// if there is only one renderer available, add it
				var args = {id:source.renderers[0].id,label:map.label,prefsMapFcn:source.renderers[0].fcn,map:map};
				this.processChange(args);
			} else {
				// an intermediate dialog box is opened for the user to choose the desired renderer
				var content = dojo.create("div");
				var header = dojo.create("h4");
				var headerLabel = dojo.create("label",{"for":"widgetRendererSelect",innerHTML:this.nlsBundle["add_content_selectRenderer"]});
				header.appendChild(headerLabel);
				content.appendChild(header);
				var rendererSelect = dojo.create("select",{id:"widgetRendererSelect"});
				content.appendChild(rendererSelect);
				for(var i = 0; i < source.renderers.length; i++){
					var select = dojo.create("option",{innerHTML:this.nlsJsonBundle && this.nlsJsonBundle[source.renderers[i].label] ? this.nlsJsonBundle[source.renderers[i].label] : source.renderers[i].label,value:i});
					rendererSelect.appendChild(select);
				}
				var onSubmit = dojo.hitch(this, function(){ 
					this.dialog.cancel();
					var renderer = source.renderers[rendererSelect.value]; 
					var args = {id:renderer.id,label:map.label,prefsMapFcn:renderer.fcn,map:map};
					this.processChange(args);
				});
				this.dialog.setContent(content, this.nlsBundle["add_content_addToPage"], this.nlsBundle["add_content_add"], onSubmit);
			}
		},
		
		showDetailsDialog: function(/*Object*/itemMap,/*Function*/submitFcn){
			// summary: prepares the markup for the popup dialog to display details.  
			// itemMap: a map of information on the content from the mapItem function of the CatalogMixin class
			// submitFcn: the function to call when the submit button on the dialog is clicked
			var content = dojo.create("div");
			var title = dojo.create("h4",{innerHTML:(itemMap.label)?itemMap.label:this.nlsBundle["add_content_untitled"]});
			content.appendChild(title);
			if(itemMap.updated) {
				var updated = dojo.create("p",{innerHTML:dojo.string.substitute(this.nlsBundle["add_content_lastMod"], [itemMap.updated])});
				content.appendChild(updated);
			}
			if(itemMap.description){ 
				var desc = dojo.create("p",{innerHTML:itemMap.description});
				content.appendChild(desc);
			}
			if(itemMap.tags && itemMap.tags.length > 0){ 
				var tags = dojo.create("p",{innerHTML:dojo.string.substitute(this.nlsBundle["add_content_tags"], [itemMap.tags.join(", ")])});
				content.appendChild(tags);
			}
			var submit = dojo.hitch(this, function(){ this.dialog.cancel(); submitFcn(); });
			this.dialog.setContent(content, this.nlsBundle["add_content_details"], this.nlsBundle["add_content_addToPage"], submit);
		},
		
		showWaitMsgInDialog: function(/*String*/message){
			// summary: abstracts the use of the popup dialog by displaying a message
			// message: message to display in the dialog
			var dialog = new com.ibm.customize.LotusWaitingDialog({spinner:this.imagePath + "/loading.gif", message:message});
			try {
				dialog.show();
			} catch(e) {}
			return dojo.hitch(this,function(){ dialog.cancel(); });
		},
		
		getValuesFromDialog: function(/*object*/formObjs,/*String*/titleText,/*String*/submitText,/*String*/errorText,/*function*/callback){ 
			// summary: abstracts the use of the popup dialog by dislaying a form of text fields to be filled out
			// formObjs: an array of objects in the form:	label: a label for a text field 
			//												id: an id for the input field
			//												value: a value for the same text field 
			//												regex: a regular expression that the value of the field must validate against
			//												error: an error to display if the value does not validate
			// titleText: text to user as the title of the dialog
			// submitText: text to user on the submit button in the dialog
			// errorText: an optional error message to preface the entire form in the dialog, ie a "try again" error
			// callback: a function to be called when all the fields validate, it is called with an object of key value pairs
			//			 with the labels from the formObjs as keys and their corresponding values from the form as values
			var content = document.createElement("div");
			for(var i = 0; i < formObjs.length; i++){ // add an input for each item in formObjs
				var title = dojo.create("h4");
				var titleLabel = dojo.create("label",{innerHTML:formObjs[i].label, "for":formObjs[i].id});
				var error = dojo.create("div",{className:"lotusFormError"}); formObjs[i].errorDiv = error;
				var additionalClasses = "";
				if (formObjs[i].ltr)
					additionalClasses =" lotusLTR";
				var input = dojo.create("input",{type:"text", id:formObjs[i].id, className:"lotusText" + additionalClasses, value:formObjs[i].value}); formObjs[i].input = input;
				title.appendChild(titleLabel);
				content.appendChild(error);
				content.appendChild(title);
				content.appendChild(input);
			}
			if(errorText) formObjs[0].errorDiv.innerHTML = errorText;
			var validateInputs = dojo.hitch(this, function(){
				var fail = false;
				var values = {};
				for(var i = 0; i < formObjs.length; i++){
					if(!formObjs[i].input.value.match(formObjs[i].regex)){ // if the input does not match the regular expression, display an error
						fail = true;
						formObjs[i].errorDiv.innerHTML = formObjs[i].error;
					} else { // if the input does match the regex, add the input value to the return object
						values[formObjs[i].id] = formObjs[i].input.value;
						formObjs[i].errorDiv.innerHTML = "";
					}
				}
				if(!fail){ // if all the regular expressions matched, run the callback function on the values and close the dialog
					this.dialog.cancel();
					callback(values);				
				}
			});
			this.dialog.setContent(content, titleText, submitText, dojo.hitch(this, function(){ validateInputs(); }));
		}
});

dojo.provide("com.ibm.customize.smallWidget");
dojo.declare("com.ibm.customize.smallWidget",
	[dijit._Widget, dijit._Templated],
	{
		titleText: "",
		truncTitleText: "",
		imagePath: ".",
		iconPath: "",
		detailDialogInstruction: "press enter to see details dialog",
		templateString: '<div class="lotusPaletteWidget" role="gridcell">' +
									'<div class="lotusInner">' +
										'<div class="lotusIcon">' +
											'<span>' +
												'<img alt="${truncTitleText}" src="${iconPath}"/>' +
											'</span>' +
										'</div>' +
										'<div class="lotusTitle">' +
											'<h4>' +
												'<a href="javascript:void(0);" title="${titleText}" dojoAttachPoint="titleAnchor">' +
													'${truncTitleText}' +
													'<span class="ibmPortalHiddenText">${detailDialogInstruction}</span>' +
												'</a>' +
											'</h4>' +
										'</div>' +
										'<a class="lotusIcon" href="javascript:void(0)" title="${addToPage}" dojoAttachPoint="addButton">' +
											'<img width="16" height="16" src="${blankPath}" alt=""/>' +
											'<span class="lotusAltText">+</span>' +
										'</a>' +
									'</div>' +
								'</div>',
						
		postMixInProperties: function(){
			var bundle = dojo.i18n.getLocalization("com.ibm.bundles", "Shelf");
			this.addToPage = bundle["add_content_addToPage"];
			this.detailDialogInstruction = bundle["detail_dialog_instruction_text"] || this.detailDialogInstruction;
			if (!this.iconPath) this.iconPath = this.imagePath + "/portletIcon.gif";
			this.blankPath = this.imagePath + "/blank.gif";
		},
			
		postCreate: function(){	
			this.titleAnchor.onclick = dojo.hitch(this, function(){ this.showDetails(); return false; });
			this.addButton.onclick = dojo.hitch(this, function(){ this.apply(); return false; });
		},
		
		apply: function(){},
		
		showDetails: function(){},
		
		select: function(){},
		
		deselect: function(){}
	});

/*2010 09 29 it decorates portlet list that in the widget */
dojo.provide("com.ibm.customize.noIconSmallWidget");
dojo.declare("com.ibm.customize.noIconSmallWidget",
	[com.ibm.customize.smallWidget],
	{
		templateString: '<div class="lotusPaletteWidget" role="gridcell">' +
							'<div class="lotusInner">' +
								'<div class="lotusIcon"></div>' +
								'<div class="lotusTitle">' +
									'<h4>' +
										'<a href="javascript:void(0);" title="${titleText}" dojoAttachPoint="titleAnchor">${truncTitleText}</a>' +
									'</h4>' +
								'</div>' +
								'<a class="lotusIcon" href="javascript:void(0)" title="${addToPage}" dojoAttachPoint="addButton">' +
									'<img width="16" height="16" src="${blankPath}" alt=""/>' +
									'<span class="lotusAltText">+</span>' +
								'</a>' +
							'</div>' +
			'</div>'
	});
	
	dojo.provide("com.ibm.customize.largeWidget");
	dojo.declare("com.ibm.customize.largeWidget",
	[dijit._Widget, dijit._Templated],
	{
		titleText: "",
		truncTitleText: "",
		imagePath: ".",
		iconPath: "",
		current: false,
		selectedClass: "lotusSelected",
		hiddenSelectedText: "currently selected for the page",
		hiddenUnselectedText: "press enter to select",
		templateString: '<div class="lotusPaletteWidget" dojoAttachPoint="addButton" role="gridcell" aria-selected="false">' +
							'<div class="lotusInner">' +
								'<div class="lotusIcon">' +
									'<span>' +
										'<img alt="${truncTitleText}" src="${iconPath}"/>' +
									'</span>' +
								'</div>' +
								'<div class="lotusTitle">' +
									'<h4>' +
										'<a href="javascript:void(0);" title="${titleText}">' +
											'${truncTitleText}' +
											'<span class="ibmPortalHiddenText" dojoAttachPoint="hiddenSelectedTextNode">${hiddenUnselectedText}</span>' +
										'</a>' +
									'</h4>' +
								'</div>' +
							'</div>' +
						'</div>',
						
		postMixInProperties: function(){
			if (!this.iconPath) this.iconPath = this.imagePath + "/portletIcon.gif";
			this.hiddenSelectedText = dojo.i18n.getLocalization("com.ibm.bundles", "Theme")["currently_selected"] || this.hiddenSelectedText;
			this.hiddenUnselectedText = dojo.i18n.getLocalization("com.ibm.bundles", "Shelf")["selection_instructions"] || this.hiddenUnselectedText;
		},
		
		postCreate: function(){
			if(this.current) this.select();
			this.addButton.onclick = dojo.hitch(this, function(){ this.apply(); return false; });
		},
		
		apply: function(){},
		
		select: function(){
			this.current = true;
			dojo.addClass(this.domNode,this.selectedClass);
			dojo.attr(this.domNode,"aria-selected","true");
			this.hiddenSelectedTextNode.innerHTML = this.hiddenSelectedText;
		},
		
		deselect: function(){
			this.current = false;
			dojo.removeClass(this.domNode,this.selectedClass);
			dojo.attr(this.domNode,"aria-selected","false");
			this.hiddenSelectedTextNode.innerHTML = this.hiddenUnselectedText;
		}
	});
	
	dojo.provide("com.ibm.customize.LotusDialog");
	dojo.declare("com.ibm.customize.LotusDialog",
	[dijit.Dialog],
	{
		blankImg: "",
		titleText: "",
		okText: "OK",
		destroyOnClose: false,
		templateString: '<div class="lotusDialogBorder lotusui" waistate="labelledby-${id}" wairole="dialog" role="dialog" index="-1" aria-labelledby="${id}">' +
							'<div class="lotusDialog">' +
								'<h1>' +
									//'<a href="javascript:void(0);" dojoAttachPoint="closeButtonNode" class="lotusBtnImg lotusClose" title="${closeText}">' +
									'<a href="javascript:void(0);" dojoAttachPoint="closeButtonNode" class="lotusBtnImg lotusClose" title="${closeText}" style="width:20px">' +
										'<img src="${blankImg}" aria-label="${closeText}" alt=""/>' +
										'<span class="lotusAltText">X</span>' +
									'</a>' +
									'<span dojoAttachPoint="titleNode">${titleText}</span>' +
								'</h1>' +
								'<div class="lotusDialogContent" dojoAttachPoint="containerNode"></div>' +
								'<div class="lotusDialogFooter">' +
									//'<input value="${okText}" class="lotusFormButton" dojoAttachPoint="submitNode" type="submit" dojoAttachEvent="onclick: submit"/> ' +
									'<input value="${okText}" class="lotusFormButton" dojoAttachPoint="submitNode" type="submit" dojoAttachEvent="onclick: submit"/ style="width:100px"> ' +
									'<a href="javascript:void(0);" dojoAttachPoint="closeLinkNode" class="lotusAction">${cancelText}</a>' +
								'</div>' +
							'</div>' +
						'</div>',
						
		postMixInProperties: function(){
			this.nlsBundle = dojo.i18n.getLocalization("com.ibm.bundles", "Shelf");
			this.closeText = this.nlsBundle["shelf_closeDialog"];
			this.cancelText = this.nlsBundle["add_content_cancel"];
		},
		
		onSubmit: function(){
		},
		
		submit: function(){
			this.onSubmit();
		},

		__doNothing: function(e){
			if (!e) {
				e = window.event;
			}
			console.log("__doNothing: " + e);
			if (e.stopPropagation) {
				e.stopPropagation();
			} else {
				e.cancelBubble = true;
			}
		},
		
		cancel: function(){
			this.hide();
			if(this.destroyOnClose) this.destroy();
		},
		
		setContent: function(content, title, okText, submitFcn){
			dojo.empty(this.containerNode);
			if (dojo.isString(content)) content = document.createTextNode(content);
			this.containerNode.appendChild(content);
			this.titleNode.innerHTML = title || this.titleText;
			this.submitNode.value = okText || this.okText;
			this.onSubmit = submitFcn || function(){};
			this.show();
		}
	});
	
	dojo.provide("com.ibm.customize.LotusWaitingDialog");
	dojo.declare("com.ibm.customize.LotusWaitingDialog",
	[com.ibm.customize.LotusDialog],
	{
		spinner: "",
		message: "",
		destroyOnClose: true,
		templateString: '<div class="lotusDialogBorder lotusui" waistate="labelledby-${id}" wairole="dialog" role="dialog" index="-1" aria-labelledby="${id}">' +
							'<div class="lotusDialog">' +
								'<div class="lotusDialogContent" dojoAttachPoint="containerNode">' +
									'<img src="${spinner}" alt="${loadingText}" title="${loadingText}"/>' +
									'${message}' +
								'</div>' +
							'</div>' +
						'</div>',
						
		postMixInProperties: function(){
			this.nlsBundle = dojo.i18n.getLocalization("com.ibm.bundles", "Shelf");
			this.loadingText = this.nlsBundle["shelf_loading"];
			this.message = "      " + this.message;
		},
		
		show: function(){
			setTimeout( dojo.hitch(this, function(){ if(this.open) dijit._underlay.show(); }), this.duration + 200 );  // make sure underlay is visible
			this.inherited(arguments);
		}
	});

}

if(!dojo._hasResource["com.ibm.customize.AddContentPaletteContainer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.customize.AddContentPaletteContainer"] = true;
// This is Add Content
dojo.provide("com.ibm.customize.AddContentPaletteContainer");



dojo.declare("com.ibm.customize.AddContentPaletteContainer",
	[com.ibm.customize.LotusPaletteContainer],
	{
		legacy: false, 		// true if this is a legacy page
		createProxyURI: null,	// function to create a proxy url
		pendingItems: null,		// items pending creation/modification
		beforeSubmitDfds: null, // Array of Deferreds that must all get called back before submit processing can occur
		afterSubmitDfds: null, // Array of Deferreds that must all get called back before submit fires its onComplete/onError handlers
		
		constructor: function() {
			this.label = this.nlsBundle["add_content_browseContent"];
			this.tabLabel = this.nlsBundle["add_content_launchLabel"];
			this.pendingItems = {};
			this.beforeSubmitDfds = [];
			this.afterSubmitDfds = [];
		},

		startup: function(/*Object/Widget*/parent){
			this.started = true;
			this.parent = parent;
			
			// if this is not a legacy page, set up the UI as usual
			if(!this.legacy) this.setupUI();
			else{
				// display a warning message that a Page Builder layout must be applied before any content can be added to the page
				var warningMsg = this.createLotusMsgNode(this.nlsBundle["add_content_legacyError"],"Warning");
				dojo.style(warningMsg,"margin","20px");
				this.domNode.innerHTML = "";
				this.domNode.appendChild(warningMsg);
			}
		}
});

}

if(!dojo._hasResource["com.ibm.customize.ChangeLayoutController"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.customize.ChangeLayoutController"] = true;
// This is a controller that customizes the styles of a page

dojo.provide("com.ibm.customize.ChangeLayoutController");

com.ibm.customize.ChangeLayoutController = {
	current: "",			// the style currently selected on the shelf
	set: "",				// the style currently set on the page

/***********************************************/
/*       Customize Controller API			   */
/***********************************************/
	store: null,		// a datastore to save model changes
	item: null,			// an item in the store representing the current page to which changes will be made
	parent: null,		// a pointer to this controller's parent, if one exists
	dirty: false,		// true if there are changes pending
	started: false,		// true if the widget is started up
	refresh: true,		// true if a page refresh is required to show saved changes

	startup: function(/*Object?/Widget?*/parent){
		// summary: set some variable and set up the UI
		// parent: a reference to the parent of this controller
		this.started = true;
		this.current = this.set;
		this.parent = parent;
		if(this.setupUI) this.setupUI();
		this.pageId = this.store.getIdentity(this.item).substr(3);
	},
	
	_fullLMId: function(lmId) {
		return "lm:" + lmId + "@" + this.pageId;
	},
		
	makeDirty: function(/*bool*/change){
		// summary: changes the dirty attribute
		// change: value to assign to the dirty attribute
		this.dirty = change;
	},
		
	processChange: function(/*Object*/args){
		// summary: used as an event handler for when a user clicks on a result
		this.apply(args);
		if(!this.parent) {
			this.beforeSubmit().addCallback(dojo.hitch(this, function(){this.submit(args)}));
		}
	},
		
	apply: function(/*Object*/args){
		// summary: applies a change associated with a result to the page
		// args: contains args.id which is the id of the selected item
		if(args.id == this.current) return;
		if(args.id == this.set) this.makeDirty(false);
		else if(this.dirty == false) this.makeDirty(true);
		this.current = args.id;
	},
		
	undo: function(){
		// summary: reverts any changes made
		if(this.started) this.apply({id:this.set});
	},

	beforeSubmit: function(/*Object*/args){
		// summary: set the metadata for the style in the content model store. Returns a Deferred
		//		which is fired when the controller is ready to be submitted.
		var dfd = new dojo.Deferred();
		if(this.dirty){
			var cbk = dojo.hitch(this, function(){
				if(this.started) this.store.setValue(this.item, "metadata[layout]$", this.current);
				this._loadLayout(dojo.hitch(this, function(root){
					this._getTreeModel().getChildren(root, dojo.hitch(this, "_calculateLayoutChanges", root, dfd));
				}));
			});
			if(!this.store.isItemLoaded(this.item)) {
				this.store.loadItem({
					item: this.item,
					onItem: cbk,
					onError: args ? args.onError : null
				});
			}
			else cbk();
		} else dfd.callback();
		return dfd;
	},
		
	submit: function(/*Object*/args){
		// summary: saves any pending changes to the server
		// args: args may contain an onComplete handler
		if(!this.dirty) {
			if(args.onComplete) args.onComplete();
			return; 
		}
		this._saveStore(args);
	},
	
	_calculateLayoutChanges: function(layoutRoot, deferred) {
		var newNumCols = this.columnHash[this.current];
		var oldNumCols = this.columnHash[this.set];
		// change the number of containers in the backend			
		if(!oldNumCols){
			// case 0: transition away from a legacy layout
			this.removeLegacyLayout(newNumCols, layoutRoot, deferred);
		} else if(newNumCols > oldNumCols){ 
			// case 1: less to more containers; add extra containers
			this.addContainers(newNumCols-oldNumCols, layoutRoot);
		} else if(oldNumCols > newNumCols) { 
			// case 2: more to less containers
			var domContainers = dojo.query(".ibmPortalLayoutContainer"); 	// all containers on the page
			if(domContainers.length > newNumCols){  // safeguard if there are less containers than expected
				var parentContainerId = this._fullLMId(domContainers[newNumCols-1].id);			// the last container in the new layout will receive all orphaned controls
				var containersToDelete = new Array();
				var controlsToReparent = new Array();
				// loop through all containers to be deleted
				for(var i = oldNumCols; i != newNumCols; i--){
					if(domContainers[i-1]){ // safeguard in case there aren't as many layout containers as expected
						var removeContainer = domContainers[i-1].id;
						containersToDelete.push(this.store.byId(this._fullLMId(removeContainer))); // container to be deleted
						// controls to reparent
						var controls = dojo.query(".ibmPortalControlContainer",dojo.byId(removeContainer)); 
						// loop through all controls to reparent
						for(var j = 0; j < controls.length; j++){
							controlsToReparent.push(this.store.byId(this._fullLMId(controls[j].getAttribute("controlid"))));
						}
					}
				}
				// reparent the controls and then delete the containers they were in
				if(controlsToReparent.length > 0) {
					this.reparentControls(controlsToReparent, parentContainerId);
					this.deleteContainers(containersToDelete);
				} else if (containersToDelete.length > 0) {
					this.deleteContainers(containersToDelete);
				}
			}
		}
		if(oldNumCols) deferred.callback();
	},
	
	_saveStore: function(args,unfinished) {
		this.store.save({
			onComplete: dojo.hitch(this, function(){
				if(!unfinished) this.makeDirty(false);
				this.set = this.current;
				if(args.onComplete) args.onComplete();
			}),
			onError: args.onError
		});
	},
	
	_getTreeModel: function() {
		// gets the tree model for the store which contains the item
		return this.store.getValue(this.item, "layoutModel");
	},
	
	_loadLayout: function(onItem, onError) {
		// summary: this loads the root layout node, but also the entire layout tree
		this._getTreeModel().getRoot(onItem, onError);		
	},
	
	addContainers: function(/*int*/num,/*item*/rootItem){
		// summary: add containers to the layout model of the current page
		// num: the number of containers to add
		// rootItem: datastore item for the root layout node
		var first = null;
		for(var i = 0; i < num; i++){ 
			var item = this.store.newItem({
				pocType: "lm",
				type: "container"
			}, {parent:rootItem});
			if(i==0) first = item;
		}
		return first;
	},
	
	reparentControls: function(/*Array*/controlsToReparent,/*string*/parent){
		// summary: reparents given controls into a given container on the current page
		// controlsToReparent: an array of the IDs of the controls to reparent
		// parent: the ID of the container on the page which is the new parent
		for(var i = 0, control; i < controlsToReparent.length; i++){
			this.store.setValue(controlsToReparent[i], "parentId", parent); 
		}
	},
	
	deleteContainers: function(/*Array*/containersToDelete){
		// summary: deletes the given containers from the layout model of the current page
		// containersToDelete: an array of the IDs of the containers to delete off the page
		for(var i = 0; i < containersToDelete.length; i++){
			this.store.deleteItem(containersToDelete[i]);
		}
	},
	
	removeLegacyLayout: function(/*int*/num,/*item*/rootItem, deferred){ 
		// summary: removes a legacy layout by:
		//			1. creating the number of containers needed for the new layout
		//			2. moving ALL controls into the first of the newly created containers
		//			3. deleting all containers from the legacy layout which are direct children of the root layout node
		// num: the number of columns to create for the new layout
		// rootItem: datastore item for the root layout node
		var layoutModelItems = this._getTreeModel().getAll();
		var controlsToReparent = dojo.filter(layoutModelItems, function(item) {
			return this.store.getValue(item, "modelNodeType", "").toLowerCase() == "layout-control";
		}, this);
		var containersToDelete = dojo.filter(layoutModelItems, function(item) {
			return this.store.getValue(item, "parentId", "") == this.store.getValue(rootItem,"id");
		}, this);
		var newParentItem = this.addContainers(num,rootItem);
		if(controlsToReparent.length > 0) this.reparentControls(controlsToReparent,this.store.getValue(newParentItem,"id"));
		var deleteOldContainers = dojo.hitch(this, function(){
			if(containersToDelete.length > 0) this.deleteContainers(containersToDelete);
			deferred.callback();
		});
		this._saveStore({onComplete:deleteOldContainers},true);
	}
}

}

if(!dojo._hasResource["com.ibm.customize.ChangeLayoutPaletteContainer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.customize.ChangeLayoutPaletteContainer"] = true;
// This is Change Layout
dojo.provide("com.ibm.customize.ChangeLayoutPaletteContainer");






dojo.declare("com.ibm.customize.ChangeLayoutPaletteContainer",
	[com.ibm.customize.LotusPaletteContainer],
	{
		numRows: 3,			// the number of rows of results to be displayed
		columnHash:{},		// an associative array of layout id to number of columns
		
		constructor: function() {
			this.label = this.nlsBundle["change_layout_browseLayouts"];
			this.tabLabel = this.nlsBundle["change_layout_launchLabel"];
		},
		
		postCreate: function(){
			this.inherited("postCreate",arguments);
			
			// change the size of the item results by adding a css class
			dojo.addClass(this.domNode,"lotusLargeWidgets");
			
			// when the apply function from the Customize Controller API is executed, change the visually selected item
			this.connect(this, "apply", "changeSelection");
		},
		
		setupUICallback: function(sources){
			dojo.forEach(sources, dojo.hitch(this, function(source){ 
				source.hub.fetch({
					onComplete:dojo.hitch(this, function(items){
						dojo.forEach(items, dojo.hitch(this, function(item){
							this.columnHash[item.id] = item.numCols;
						}));
					})
				});
			}));
			this.inherited(arguments);
		},
		
		changeSelection: function(/*object*/args){
			// summary: called when apply is called
			// args: contains args.id which is the newly selected item
			this.changeSelected(args.id);
		}
});

dojo.extend(com.ibm.customize.ChangeLayoutPaletteContainer, com.ibm.customize.ChangeLayoutController);

}

if(!dojo._hasResource["com.ibm.customize.ChangeStylePaletteContainer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.customize.ChangeStylePaletteContainer"] = true;
// This is Change Style
dojo.provide("com.ibm.customize.ChangeStylePaletteContainer");



dojo.declare("com.ibm.customize.ChangeStylePaletteContainer",
	[com.ibm.customize.LotusPaletteContainer],
	{
		numRows: 3,			// the number of rows of results to be displayed
		baseCssPath: "",
		
		constructor: function() {
			this.label = this.nlsBundle["change_style_browseStyles"];
			this.tabLabel = this.nlsBundle["change_style_launchLabel"];
		},
		
		postCreate: function(){
			this.inherited("postCreate",arguments);
			
			// change the size of the item results by adding a css class
			dojo.addClass(this.domNode,"lotusLargeWidgets");
			
			// when the apply function from the Customize Controller API is executed, change the visually selected item
			this.connect(this, "apply", "changeSelection");
		},
		
		setupUICallback: function(sources){
			dojo.forEach(sources, dojo.hitch(this, function(source){ 
				source.hub.fetch({
					onComplete:dojo.hitch(this, function(items){
						dojo.forEach(items, dojo.hitch(this, function(item){
							if(dojo.query("[title~="+item.id[0]+"]").length == 0)
								this._loadCss(this.baseCssPath + item.id[0] + ".css",item.id[0],true,true);
						}));
					})
				});
			}));
			this.inherited(arguments);
		},
		
		changeSelection: function(/*object*/args){
			// summary: called when apply is called
			// args: contains args.id which is the newly selected item
			this.changeSelected(args.id);
		}
});

}

if(!dojo._hasResource["com.ibm.portal.dnd.PortletAvatar"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.portal.dnd.PortletAvatar"] = true;
dojo.provide("com.ibm.portal.dnd.PortletAvatar");

dojo.declare("com.ibm.portal.dnd.PortletAvatar", dojo.dnd.Avatar, {
	construct: function(){
		// summary: constructs the avatar for portlets
		var div = dojo.doc.createElement("div");
		div.style.position = "absolute";
		div.style.zIndex = 1999;
		div.style.margin = "0px";
		var source = this.manager.source, node;
		// create an avatar representation of the node
		// Portal only allows 1 portlet to be dragged, 
		// so it is known to use only the first item in the array
		node = source._normalizedCreator(source.getItem(this.manager.nodes[0].id).data, "avatar").node;
		node.id = "";
		dojo.style(div, "opacity", 0.5);
		div.appendChild(node);
		this.node = div;
	}
});

}

if(!dojo._hasResource["com.ibm.portal.dnd.PortletSourceGhost"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.portal.dnd.PortletSourceGhost"] = true;
dojo.provide("com.ibm.portal.dnd.PortletSourceGhost");




dojo.declare("com.ibm.portal.dnd.PortletSourceGhost", com.ibm.dnd.CustomManagerSource, {
	managerOverrides: {
		OFFSET_X: 1,
		OFFSET_Y: 1,
		makeAvatar: function(){
			return new com.ibm.portal.dnd.PortletAvatar(this);
		}
	},
	copyState: function(){
		return false;
	},
	onOverEvent: function(){
		// create ghost in empty container
		com.ibm.portal.dnd.PortletSourceGhost.superclass.onOverEvent.call(this);

		if(com.ibm.portal.dnd.PORTLET_MEDIATOR.isDragging && dojo.dnd.manager().target){
			var currentContainer = dojo.dnd.manager().target.node;	
			var portlets = dojo.query('.'+com.ibm.portal.dnd.PORTLET_MEDIATOR.portletContainerClass, currentContainer);	
			// check to see if layout container is empty
			if(portlets.length == 0){			
				com.ibm.portal.dnd.PORTLET_MEDIATOR.emptyContainer = currentContainer;
				if(dojo.query("."+com.ibm.portal.dnd.PORTLET_MEDIATOR.ghostClass).length == 0 ){
					// creating ghosts in empty layout container
					com.ibm.portal.dnd.PORTLET_MEDIATOR.emptyContainer.appendChild(com.ibm.portal.dnd.PORTLET_MEDIATOR.createEmptyContainerGhostMarkup(com.ibm.portal.dnd.PORTLET_MEDIATOR.ghostHeight, currentContainer.offsetWidth));
				}
			}else{
			// clear the empty layout container object
				com.ibm.portal.dnd.PORTLET_MEDIATOR.emptyContainer = null;			
			}
		}
	},
	onOutEvent: function(){
		// remove ghost from empty container
		com.ibm.portal.dnd.PortletSourceGhost.superclass.onOutEvent.call(this);
		if(dojo.query("."+com.ibm.portal.dnd.PORTLET_MEDIATOR.ghostClass).length > 0){
			com.ibm.portal.dnd.PORTLET_MEDIATOR.removeGhost();
		}
	},
	_addItemClass: function(node, type){
		// summary: adds a class with prefix "dojoDndItem" and create ghost
		// node: Node: a node
		// type: String: a variable suffix for a class name
		if(com.ibm.portal.dnd.PORTLET_MEDIATOR.isDragging){
			com.ibm.portal.dnd.PORTLET_MEDIATOR.currentTarget = node;
			com.ibm.portal.dnd.PORTLET_MEDIATOR.createGhost(node, type);
		}
	},
	_removeItemClass: function(node, type){
		// summary: removes a class with prefix "dojoDndItem" and remove ghost
		// node: Node: a node
		// type: String: a variable suffix for a class name
		if(com.ibm.portal.dnd.PORTLET_MEDIATOR.isDragging){
			com.ibm.portal.dnd.PORTLET_MEDIATOR.removeGhost();
		}
	}
});

}

if(!dojo._hasResource["com.ibm.portal.dnd.PortletSource"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.portal.dnd.PortletSource"] = true;
dojo.provide("com.ibm.portal.dnd.PortletSource");




dojo.declare("com.ibm.portal.dnd.PortletSource", com.ibm.dnd.CustomManagerSource, {
	managerOverrides: {
		OFFSET_X: 1,
		OFFSET_Y: 1,
		makeAvatar: function(){
			return new com.ibm.portal.dnd.PortletAvatar(this);
		}
	},
	copyState: function(){
		return false;
	},
	onOverEvent: function(){
		// create ghost in empty container
		com.ibm.portal.dnd.PortletSource.superclass.onOverEvent.call(this);

		if(com.ibm.portal.dnd.PORTLET_MEDIATOR.isDragging && dojo.dnd.manager().target){
			var currentContainer = dojo.dnd.manager().target.node;	
			var portlets = dojo.query('.'+com.ibm.portal.dnd.PORTLET_MEDIATOR.portletContainerClass, currentContainer);	
			// check to see if layout container is empty
			if(portlets.length == 0){			
				com.ibm.portal.dnd.PORTLET_MEDIATOR.emptyContainer = currentContainer;
				var node = document.createElement("div");
				node.id = "ibmPortalEmptyLayoutContainerIndicator";
				dojo.addClass(node, com.ibm.portal.dnd.PORTLET_MEDIATOR.defaultTargetIndicator);
				dojo.addClass(node, "ibmPortalEmptyLayoutContainerIndicator");
				com.ibm.portal.dnd.PORTLET_MEDIATOR.emptyContainer.appendChild(node);
			}else{
			// clear the empty layout container object
				com.ibm.portal.dnd.PORTLET_MEDIATOR.emptyContainer = null;				
			}
		}
	},
	onOutEvent: function(){
		// remove ghost from empty container
		com.ibm.portal.dnd.PortletSource.superclass.onOutEvent.call(this);

		if(com.ibm.portal.dnd.PORTLET_MEDIATOR.emptyContainer){
			var node = dojo.byId("ibmPortalEmptyLayoutContainerIndicator");
			if(node)
				node.parentNode.removeChild(node);
		}
	}
});

}

if(!dojo._hasResource["com.ibm.portal.dnd.PortletMediator"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.portal.dnd.PortletMediator"] = true;
dojo.provide("com.ibm.portal.dnd.PortletMediator");








dojo.declare("com.ibm.portal.dnd.PortletMediator",
	null,
	{
		type: "ibmPortalPortlet",
		isDragging: false,
		currentType: null,
		currentTarget: null,
		currentTargetId: null,
		currentParentId: null,
		currentSourceId: null,
		currentMargin: 0,
		emptyContainer: null,
		before: false,
		ghostHeight: 0,
		ghostClass: "ibmPortalDndGhost",
		portletBodyClass: "ibmPortalPortletBody",
		portletContainerClass: "ibmPortalControlContainer",
		layoutContainerClass: "ibmPortalLayoutContainer",
		layoutRootClass: "ibmPortalLayoutRoot",		
		defaultTargetIndicator: "dojoDndItemBefore",
		dndContainers: {},
		delaySave: true,
		movedItems: [],
		//added by cbh start
		dndStartContainerId: "",
		dndStartActionId:"",
		dndStartActionFrontId: "",
		dndStartActionRearId: "",
		//added by cbh finish
		
		init: function(){		
			//gather the portlet containers
			var containers = dojo.query("."+com.ibm.portal.dnd.PORTLET_MEDIATOR.layoutContainerClass);
			dojo.forEach(
				containers,
			    function(item){
					var portlets = dojo.query('.'+com.ibm.portal.dnd.PORTLET_MEDIATOR.portletContainerClass, item);				
					//add required dnd attributes/classes for portlets
					dojo.forEach(
						portlets,
						function(portlet){	
							// create this portlet as a dnd item
							dojo.addClass(portlet, "dojoDndItem");
							
							// set the dnd type as a portlet
							dojo.attr(portlet, "dndType", com.ibm.portal.dnd.PORTLET_MEDIATOR.type);
							
							//set the drag and drop handle inside the control
							var controlDndHandle = dojo.query('.ibmPortalControlDndHandle', portlet);
							if(controlDndHandle){
								controlDndHandle.addClass("dojoDndHandle");
							}
						}
					);

					com.ibm.portal.dnd.PORTLET_MEDIATOR.dndContainers[item.id] = null;

					//create dnd containers	for portlets
					var cls = dojo.eval(ibmPortalConfig.portletDndSource);
					com.ibm.portal.dnd.PORTLET_MEDIATOR.dndContainers[item.id] = new cls(
							item,{
							creator: com.ibm.portal.dnd.PORTLET_MEDIATOR.creator, 
							accept: [com.ibm.portal.dnd.PORTLET_MEDIATOR.type], 
							withHandles: ibmPortalConfig.dndPortletsWithHandles,
							singular: true,
							skipForm: true
							});
				}
			);			
			
			// connect dnd events
			dojo.subscribe("/dnd/start", com.ibm.portal.dnd.PORTLET_MEDIATOR, "onStart");
			dojo.subscribe("/dnd/drop/before", com.ibm.portal.dnd.PORTLET_MEDIATOR, "onBeforeDrop");
			dojo.subscribe("/dnd/drop", com.ibm.portal.dnd.PORTLET_MEDIATOR, "onDrop");
			dojo.subscribe("/dnd/cancel", com.ibm.portal.dnd.PORTLET_MEDIATOR, "onCancel");
		},
		saveMoves: function(callback){
			ibmPortalConfig.resolver.saveItems(this.movedItems,{onComplete:callback,onError:callback});
			this.movedItems = [];
			//console.log("com.ibm.portal.dnd.PortletMediator:::saveMoves()");
		},
		onStart: function(source, nodes, copy){
			//console.log("com.ibm.portal.dnd.PortletMediator:::onStart()");
			this.dndStartContainerId = "";
			this.dndStartActionId = "";
			this.dndStartActionFrontId = "";
			this.dndStartActionRearId = "";

			this.isDragging = true;
			var sourceObject = source.getItem(nodes[0].id);
			this.currentType = sourceObject.type;
			if(this.currentType == this.type){			
				// set the cursor to move on the entire page
				dojo.style(dojo.body(),{cursor:"move"});
				// override style for portlet body
				dojo.query("."+this.portletBodyClass).style({cursor:"move"});
				
				this.setLayoutContainerHeight();
				
				//retrieve the current node that is dragging
				var node = dojo.byId(nodes[0].id);
				
				//retrieve control height
				this.ghostHeight = node.offsetHeight;
				
				//calculate the control's margin
				var control = dojo.query(".ibmPortalControl", node)[0];
				this.currentMargin = dojo.marginBox(node).w - control.offsetWidth;
				//retrieve the current dragging control's id
				this.currentSourceId = dojo.attr(node,"controlId");

				//added by cbh start
				this.dndStartContainerId = dojo.byId(nodes[0].id).parentNode.id
				this.dndStartActionId = this.currentSourceId;
				var front = "";
				var rear = "";
				var portlets = dojo.query('.'+com.ibm.portal.dnd.PORTLET_MEDIATOR.portletContainerClass, dojo.byId(this.dndStartContainerId));
				for (var k=0; k<portlets.length; k++) {
					if (this.dndStartActionId == dojo.attr(portlets[k], "controlId")) {
						if (k > 0) {
							front = dojo.attr(portlets[k-1], "controlId");
						}
						if (k < portlets.length-1) {
							rear = dojo.attr(portlets[k+1], "controlId");
						}
					}
				}
				this.dndStartActionFrontId = front;
				this.dndStartActionRearId = rear;
				//console.log("dndStartContainerId: "+this.dndStartContainerId);
				//console.log("dndStartActionId: "+this.dndStartActionId);
				//console.log("dndStartActionFrontId: "+this.dndStartActionFrontId);
				//console.log("dndStartActionRearId: "+this.dndStartActionRearId);
				//added by cbh finish
				
				dojo.style(node, { display:"none" });
			}
		},
		onBeforeDrop: function(source, nodes, copy){
			//console.log("com.ibm.portal.dnd.PortletMediator:::onBeforeDrop()");
			if(this.currentType == this.type){
				if(this.currentTarget && !this.emptyContainer){
					this.currentParentId = dojo.byId(this.currentTarget.id).parentNode.id;
					if(this.before == true){
					// the target is before the current node
						this.currentTargetId = this.currentTarget.id;
					}else{
					// the target is after the current node	
						var layoutContainer = this.getLayoutContainer(dojo.byId(this.currentTarget.id));					
						var portlets = dojo.query("."+this.portletContainerClass, layoutContainer);
						
						for(var index=0;index<portlets.length;index++){
							if(portlets[index].id == this.currentTarget.id){
								if(index+1 < portlets.length){
									this.currentTargetId = portlets[index+1].id;
									break;
								}else{
									// the target is below the last node
									// set to null to append at end of container
									this.currentTargetId = null;	
									break;
								}
							}
						}
					}
				}else{
				// the target is an empty container
					if(this.emptyContainer){
						this.currentParentId = this.emptyContainer.id;
						this.currentTargetId = null;
					}else{
						this.onCancel();
					}
				}
			}
		},
		onDrop: function(source, nodes, copy){
			//console.log("com.ibm.portal.dnd.PortletMediator:::onDrop()");
			if(this.currentType == this.type){
				// reset the cursor to default
				dojo.style(dojo.body(), { cursor:"default" });
				dojo.query("."+this.portletBodyClass).style({cursor: "default"});
				this.removeLayoutContainerHeight();
				this.removeTargetIndicator();			
				this.isDragging = false;
				this.resetGhostDimensions();

				//added by cbh start
				var dropContainerId = dojo.byId(nodes[0].id).parentNode.id
				var node = dojo.byId(nodes[0].id);
				var dropActionId = dojo.attr(node, "controlId");
				var dropActionFrontId = "";
				var dropActionRearId = "";
				var _portlets = dojo.query('.'+com.ibm.portal.dnd.PORTLET_MEDIATOR.portletContainerClass, dojo.byId(dropContainerId));
				for (var k=0; k<_portlets.length; k++) {
					if (dropActionId == dojo.attr(_portlets[k], "controlId")) {
						if (k > 0) {
							dropActionFrontId = dojo.attr(_portlets[k-1], "controlId");
						}
						if (k < _portlets.length-1) {
							dropActionRearId = dojo.attr(_portlets[k+1], "controlId");
						}
					}
				}
				//console.log("dropContainerId: "+dropContainerId);
				//console.log("dropActionId: "+dropActionId);
				//console.log("dropActionFrontId: "+dropActionFrontId);
				//console.log("dropActionRearId: "+dropActionRearId);
				if (dropActionId == this.dndStartActionId && dropContainerId == this.dndStartContainerId &&
					dropActionFrontId == this.dndStartActionFrontId && dropActionRearId == this.dndStartActionRearId) {
					//console.log("do not invoke sendMoveRequest function");
				} else {
					this.sendMoveRequest(nodes[0].id);
				}
				//added by cbh finish

				//this.sendMoveRequest(nodes[0].id);
				//var node = dojo.byId(nodes[0].id);
				if(node)
					dojo.style(node, { opacity: 1, display:"" });
			}
		},
		onCancel: function(){
			//console.log("com.ibm.portal.dnd.PortletMediator:::onCancel()");
			//added by cbh start
			this.dndStartContainerId = "";
			this.dndStartActionId = "";
			this.dndStartActionFrontId = "";
			this.dndStartActionRearId = "";
			//added by cbh finish

			if(this.currentType == this.type){
				// reset the cursor to default
				dojo.style(dojo.body(), { cursor:"default" });
				dojo.query("."+this.portletBodyClass).style({cursor: "default"});
				this.removeLayoutContainerHeight();
				var node = dojo.byId(dojo.dnd.manager().nodes[0].id);
				dojo.style(node, { opacity: 1, display:"" });
				this.isDragging = false;
				this.resetGhostDimensions();
			}
		},
		sendMoveRequest: function(sourceId){
			//console.log("com.ibm.portal.dnd.PortletMediator:::sendMoveRequest()");
			var suffix = "@oid:"+ibmPortalConfig.contentNodeOID;
			var targetControlId = null;
			
			if(this.currentTargetId != null){
				targetControlId = dojo.attr(dojo.byId(this.currentTargetId),"controlId")+suffix;
			}
			
			if(this.currentSourceId && this.currentParentId){
				
				var store = ibmPortalConfig.resolver;
				var setAttributes = dojo.hitch(this,function(item){
					store.setValue(item, "parentId", "lm:"+this.currentParentId+suffix);
					//console.log("container="+this.currentParentId+", nextId="+targetControlId);
					if(targetControlId) store.setValue(item, "nextId", "lm:"+targetControlId);
					if(!this.delaySave) store.save();
					else this.movedItems.push(item);
				});
				var item = store.byId("lm:"+this.currentSourceId+suffix);
				if(store.isItemLoaded(item)){
					//console.log("store.isItemLoaded()");
					setAttributes(item);
				} else {
					//console.log("store.loadItem()");
					store.loadItem({
						item: item,
						onItem: setAttributes
					});
				}			
			}
			
			this.resetTargets();
		},
		createGhost: function(node, type){
			if(type == "Before"){
				this.before = true;
				node.insertBefore(this.createGhostMarkup(this.ghostHeight), 
								  node.childNodes[0]);
				
			}else if (type == "After"){
				this.before = false;
				node.appendChild(this.createGhostMarkup(this.ghostHeight));
			}
		},
		removeGhost: function(){
			var ghost = dojo.byId(this.ghostClass);
			if(ghost){
				var parent = ghost.parentNode;
				parent.removeChild(ghost);
			}
		},
		removeTargetIndicator: function(){
			if(ibmPortalConfig.dndPortletsWithGhost){
				this.removeGhost();
			}else{
				// this cleans up the indicator on empty containers
				dojo.query("."+this.defaultTargetIndicator).removeClass(this.defaultTargetIndicator);
			}
		},
		createGhostMarkup: function(height){
			var elem = document.createElement("div");
			dojo.style(elem, { height: height+"px"});
			var node = dojo.byId(dojo.dnd.manager().target.current.id);
			elem.style.width=node.offsetWidth;

			if(dojo.isIE)
				dojo.style(elem, { margin: "0"});
			
			elem.className = this.ghostClass;
			elem.id = this.ghostClass;
			return elem;
		},
		createEmptyContainerGhostMarkup: function(height, width){
			var elem = document.createElement("div");
			dojo.style(elem, { height: height+"px"});
			dojo.style(elem, { width: width-this.currentMargin});
			
			if(dojo.isIE)
				dojo.style(elem, { margin: "0"});
			
			elem.className = this.ghostClass;
			elem.id = this.ghostClass
			return elem;
		},
		creator: function(item, hint){
			if(hint=="avatar"){
				var node = dojo.doc.createElement("div");
				if(dojo.dnd.manager().source.current){
					// use the portlet markup as avatar
					node.innerHTML = String(item);
					var elem = dojo.byId(dojo.dnd.manager().source.current.id);
					dojo.style(node, { width: elem.offsetWidth+"px", opacity: 0.5});
				}
				return {node: node, data: item, type: [com.ibm.portal.dnd.PORTLET_MEDIATOR.type]};
			}else{  // this works the same way as the _normalizedCreator/onDropExternal functions in dojo.dnd.Source when there is no given creator function
				if(dojo.isOpera) {
					var node = dojo.byId(com.ibm.portal.dnd.PORTLET_MEDIATOR.currentSourceId).parentNode;  // opera returned nothing using dojo.query below
				} else {
					var node = dojo.query("[controlid~="+com.ibm.portal.dnd.PORTLET_MEDIATOR.currentSourceId+"]")[0];
				}
				var source = com.ibm.portal.dnd.PORTLET_MEDIATOR.dndContainers[node.parentNode.id];
				var t = source.getItem(node.id);
				source.delItem(node.id);
				source.selection = {};  // prevents node from being deleted in dojo.dnd.Selector.deleteSelectedNodes called by onDropExternal()
				return {node: node, data: t.data, type: t.type};
			}
		},
		getLayoutContainer: function(node){
		    var elem = node.parentNode;

		    while ( !(elem.className.indexOf(this.layoutContainerClass)) ) {
				elem = elem.parentNode;
			}
		    
		    return elem;
		},
		setLayoutContainerHeight: function(){
			var containers = dojo.query("."+this.layoutContainerClass);
			var height = 0;
			for(var i = 0; i < containers.length; i++){
				var currentHeight = containers[i].clientHeight;
				
				if(currentHeight > height){
						height = currentHeight;
				}
			}
			containers.style({minHeight: height+"px"});
			// Fixes IE6 not knowing how to use minheight
			if (dojo.isIE == 6)
				containers.style({height: height+"px"});
		},
		removeLayoutContainerHeight: function(){
			dojo.query("."+this.layoutContainerClass).style({minHeight:"0px"});
			dojo.query("."+this.layoutContainerClass).style({height:"auto"});
		},
		resetGhostDimensions: function(){
			this.ghostHeight = 0;
		},
		resetTargets: function(){
			this.currentTargetId = null;
			this.emptyContainer = null;
		}
	}
);

com.ibm.portal.dnd.PORTLET_MEDIATOR = new com.ibm.portal.dnd.PortletMediator();


}

if(!dojo._hasResource["com.ibm.widgets.LazyLoadingDropdown"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.widgets.LazyLoadingDropdown"] = true;
dojo.provide("com.ibm.widgets.LazyLoadingDropdown");


dojo.declare("com.ibm.widgets.LazyLoadingDropdown",
[dijit.form.DropDownButton],
{
	label: "",			// text to put on the button
	url: null,			// url to the drop down menu content
	loaded: false,		// true if the content from the url has been loaded
	button: true,		// true if it should be a buttom DOM element, if false it will be an anchor
	btnClass: "",		// class to put on the drop down button
	savedList: null,	// list of all menu items added via insertChild, list can be cleared via removeSaved function
	emptyMenuText:"0",	// text to display if the menu is empty
	arrowImg: "",		// url to a drop down image to display
	altText: "",		// alt text for the image
	templateString:'<span class="dijitLeft dijitInline" dojoattachevent="onmouseenter:_onMouse,onmouseleave:_onMouse,onmousedown:_onMouse,onclick:_onDropDownClick,onkeydown:_onDropDownKeydown,onblur:_onDropDownBlur,onkeypress:_onKey" widgetid="${id}">' +
						'<span class="dijitInline">' +
							'<${domType} title="${altText}" href="javascript:void(0);" class="${btnClass}" waistate="haspopup-true,labelledby-${id}_label" wairole="button" dojoattachpoint="focusNode,titleNode" type="button" role="button" aria-haspopup="true" aria-labelledby="${id}_label" tabindex="0" style="-moz-user-select: none;">' +
								'<span id="${id}_label" dojoattachpoint="containerNode,popupStateNode">${label}</span>' +
								'<img alt="${altText}" src="${arrowImg}"/>' +
								'<span class="lotusAltText">${altText}</span>' +
							'</${domType}>' +
						'</span>' +
					'</span>',
					
	postMixInProperties: function(){
		// summary: create the drop down menu and save list and initialize variables
		this.dropDown = new dijit.Menu({style:"display: none;"});
		this.savedList = new Array();
		this.domType = this.button ? "button" : "a";
	},
	
	insertChild: function(child,save){
		// summary: inserts a child into the dropdown menu
		// child: menu item to put insert
		// save: true if it should be added to the savedList
		this.dropDown.addChild(child);
		if(save) this.savedList.push(child);
	},
	
	removeSaved: function(){
		// summary: delete all the items out of the saved list and the menu
		for(var i = 0; i < this.savedList.length; i++){
			this.dropDown.removeChild(this.savedList[i]);
		}
		delete this.savedList;
		this.savedList = new Array();
	},
	
	_onDropDownClick: function(){
		// summary: loads the url menu data if necessary, and runs the onOpenMenu function
		if(!this.loaded){
			this.loaded = true;
			if(this.url) this.loadMenuItemsFromURL();
			else this.postLoadMenuItems();
		} else {
			this.removeSaved();
			this.onOpenMenu();
			this.inherited("_onDropDownClick",arguments);
		}
	},
					
	loadMenuItemsFromURL: function(){
		// loads the json object of menu items from the given url
		dojo.io.iframe.send ({
			url: this.url,
			handleAs: "json",
			method: "GET",
			load: dojo.hitch(this, function (data) {
				// add each json item into the menu
				dojo.forEach(data, dojo.hitch(this,function(item){
					if(item.label){
						var menuItem = new dijit.MenuItem({
							 label: item.label,
							 onClick: item.fcn
						});
						this.dropDown.addChild(menuItem);
					}
				}));
				this.postLoadMenuItems();
			}),
			error: dojo.hitch(this, function (e) {
				var statusMessage = new com.ibm.widgets.StatusMessage("error", this.errorMsg, "");
				dojo.publish("/portal/status",[{message: statusMessage, uid: 'ibmPortalStatusBox'}]);
			})
        });
	},
	
	postLoadMenuItems: function(){
		// run the given onOpenMenu function
		this.onOpenMenu();
		// if the menu is empty, add a menu item containing the "empty menu" text
		if(this.dropDown.getChildren().length == 0){
			var menuItem = new dijit.MenuItem({
				 label: this.emptyMenuText,
				 onClick: function(){}
			});
			this.dropDown.addChild(menuItem);
		}
		this._onDropDownClick();
		// select the first menu item for accessibility
		//this.dropDown.getChildren()[0].focus();
	},
	
	onOpenMenu: function(){
	}
});

}

if(!dojo._hasResource["com.ibm.widgets.StatusBar"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.widgets.StatusBar"] = true;
dojo.provide( "com.ibm.widgets.StatusBar" );

dojo.require( "dojox.data.dom" );



dojo.declare( "com.ibm.widgets.StatusType", 
    null,
    {
	    constructor: function(/*int*/id,  /*String*/styleClass, /*String*/ iconPath, /*String*/ colorStr) {
	        this._id = id;
	        this._styleClass = styleClass;
	        this._iconPath = iconPath;
	        this._color = colorStr;  // status color fader start color for this class
	    }
    }
);

dojo.declare( "com.ibm.widgets.StatusMessage", 
    null,
    {
    	constructor: function(/*int*/type, /*String*/message, /*String*/details) {
	        this._type = type;
	        this._message = message;
	        this._details = details;
    	}	
    }
);


dojo.declare( "com.ibm.widgets.StatusColorFader", 
    null,
    {
    	constructor: function(/*String*/containerId, /*String*/endColorStr) {
	        this._containerId = containerId;
	        this._beginColorStr = "";
	        this._endColorStr = "";
	
	        this._redCtr = 0x00;
	        this._greenCtr = 0x00;
	        this._blueCtr = 0x00;
	
	        this._endRed = 0x00;
	        this._endGreen = 0x00;
	        this._endBlue = 0x00;
	
	        this.setEndColor(endColorStr);
	
	        this._fadeCallbackId = null;
	
	        this._enable = true;
	    },
        fade: function() {

             // adjust r, g, b counters and see if we have reached end color
             var shouldStop = true;

             // looping here rather than incrementing/decrementing by 10
             // this makes sure we approach the end value without going past it
             // and we can still support any arbitrary start and end color values
             for (var ctr = 0; ctr < 10; ctr++) {
                 if (this._redCtr < this._endRed) {
                     this._redCtr++;
                     shouldStop = false;
                 }
                 else if (this._redCtr > this._endRed) {
                     this._redCtr--;
                     shouldStop = false;
                 }
    
                 if (this._greenCtr < this._endGreen) {
                     this._greenCtr++;
                     shouldStop = false;
                 }
                 else if (this._greenCtr > this._endGreen) {
                     this._greenCtr--;
                     shouldStop = false;
                 }
    
                 if (this._blueCtr < this._endBlue) {
                     this._blueCtr++;
                     shouldStop = false;
                 }
                 else if (this._blueCtr > this._endBlue) {
                     this._blueCtr--;
                     shouldStop = false;
                 }
             }

             if (shouldStop) {
                 this.stop();
             }
             else {
                 var updateColorStr = "#" + this.getHexString(this._redCtr) + this.getHexString(this._greenCtr) + this.getHexString(this._blueCtr);
                 var header = document.getElementById(this._containerId);
                 if (header != null) {
                     header.style.backgroundColor = updateColorStr;
                     
                 }
                 else {
                     //alert("problem - header was null");
                     this.stop();
                 }
             }

        },
        start: function() {

             if (this._enable) {
                 var header = document.getElementById(this._containerId);
                 header.style.backgroundColor = this._beginColorStr;
                 var me = this;
                 this._fadeCallbackId = self.setInterval(function () { me.fade() }, 20);
             }

        },
        stop: function() {

             if (this._fadeCallbackId != null) {
                 clearInterval(this._fadeCallbackId);
             }

        },
        setBeginColor: function(/*string*/ hexString) {

             this._beginColorStr = hexString;

             this._redCtr = this.getColorValue(hexString, "r");
             this._greenCtr = this.getColorValue(hexString, "g");
             this._blueCtr = this.getColorValue(hexString, "b");

        },
        setEndColor: function(/*string*/ hexString) {

             this._endColorStr = hexString;

             this._endRed = this.getColorValue(hexString, "r");
             this._endGreen = this.getColorValue(hexString, "g");
             this._endBlue = this.getColorValue(hexString, "b");

        },
        getColorValue: function(/*string*/ hexString, /*string*/ rgb) {

             var subStr = "";
             if (rgb == "r") {
                 subStr = hexString.slice(1, 3);
             }
             else if (rgb == "g") {
                 subStr = hexString.slice(3, 5);
             }
             else if (rgb == "b") {
                 subStr = hexString.slice(5);
             }
             var rv = parseInt(subStr, 16);

             return rv;
        },
        getHexString: function(/*int*/ num) {

             var rv = 0;
             if (num >= 0x10) {
                 rv = num.toString(16);
             }
             else {
                 rv = "0" + num.toString(16);
             }
             return rv;
        },
        setEnable: function(/*boolean*/ value) {

             this._enable = value;

        }
    }
);



dojo.declare( "com.ibm.widgets.StatusBar", 
    [dijit._Widget, dijit._Templated],
    // end constructor
    {
    	uid: "statusBar",
    	locale: "en",
    	errorGifPath: "",
    	warningGifPath: "",
    	infoGifPath: "",
    	multipleMessagesGifPath: "",
    	showDetails: false,
    	isBidi: false,
    	
    	templateString:"<div class=\"statusBar\"\r\n\t><div dojoAttachEvent=\"\"\r\n\t\t\twaiRole=\"alert\" \r\n\t\t\tclass=\"ibmPortalStatusBar\" \r\n\t\t\tdojoAttachPoint=\"containerNode,focusNode\"\r\n\t></div\r\n></div>\r\n",

    	postCreate: function() {  
	        this._messages = new Array();
	        this._numMessages = 0;
	        this._baseURL = window.location.protocol+"//"+window.location.host;
	        this._statusTypesMap = { 
	            "error" : new com.ibm.widgets.StatusType(0, "ibmPortalError", this._baseURL + this.errorGifPath, "#FF0000"),
	            "warning" : new com.ibm.widgets.StatusType(1, "ibmPortalWarning", this._baseURL + this.warningGifPath, "FFFF00"),
	            "info" : new com.ibm.widgets.StatusType(2, "ibmPortalInfo", this._baseURL + this.infoGifPath, "#0077FF"),
	            "multiple" : new com.ibm.widgets.StatusType(3, "ibmPortalMultiple",this._baseURL + this.multipleMessagesGifPath, "#E9CAF9")
	        };
	        //Subscribe to status topics.
	        this._statusHandler = dojo.subscribe("/portal/status", this, this.addMessage);
	
	        // create new message status bar color fader
	        this._summaryHeaderId = "ibmPortalStatusBarHeader";
	        var endBackgroundColorStr = this._statusTypesMap["multiple"]._color;
	        this.colorFader = new com.ibm.widgets.StatusColorFader( this._summaryHeaderId, endBackgroundColorStr);
	        if(typeof(ibmPortalConfig) != "undefined") this.isBidi = ibmPortalConfig.isRTL;
			else if(typeof(ibmConfig) != "undefined") this.isBidi = ibmConfig.isBidi;
	    }, 
	    startup: function() {
			this.inherited(arguments);
		},
        _getStatusContainer: function () {
            return this.containerNode;   
        },
        setShowDetails: function (/*boolean*/showDetails) {
            this.showDetails = showDetails;    
        },
        toggleShowDetails: function() {
            this.setShowDetails(!this.showDetails);
            //var statusContainer = this._getStatusContainer();
            //dojox.data.dom.removeChildren( statusContainer );
            this.colorFader.setEnable(false);  // disable the fader when toggling details
            this.render();
            this.colorFader.setEnable(true);
        },
        clear: function () {
            //summary: clears all contents of the statusBar
            var statusContainer = this._getStatusContainer();
            dojox.data.dom.removeChildren( statusContainer );
            this._messages.length = 0;
        },
        print: function() {
            //create new window
            var printWindow=window.open( '', 'status', 'resizable=yes,scrollbars=yes,menubar=no,toolbar=yes,status=no,width=800px,height=600px,screenX=10px,screenY=10px,top=10px,left=10px');
            var printDoc = printWindow.document;
            printDoc.title="Status";
            // set base url so relative image paths will resolve correctly
            var baseElem = printWindow.document.createElement("base");
            baseElem.setAttribute("href",window.location.protocol+"//"+window.location.host);
            printDoc.documentElement.childNodes[0].appendChild(baseElem);
            //add container div
            printDoc.body.innerHTML = "<div id='statusBar' class='statusBar'></div>";
            
            for (x in this._messages) {
				var statusType = this._statusTypesMap[this._messages[x]._type];
				
				// status entry base container
				var entry = printDoc.createElement("div");
				entry.className = statusType._styleClass;
				
				// header for status bar message
				var header = printDoc.createElement("h3");
				var headerDiv = printDoc.createElement("div");
				if (this.isBidi) {
					headerDiv.className = "ibmPortalStatusHeaderRHS";
					dojo.attr(headerDiv, "dir", "rtl");
				}
				else {
					headerDiv.className = "ibmPortalStatusHeaderLHS";
				}
				var icon = printDoc.createElement("img");
				icon.src = statusType._iconPath;
				headerDiv.appendChild(icon);
				headerDiv.appendChild(printDoc.createTextNode(this._messages[x]._message));
				header.appendChild(headerDiv);
				entry.appendChild(header);
				// details of the status bar message
				var detailsDiv = printDoc.createElement("div");
				if (this.isBidi) {
					dojo.attr(detailsDiv, "dir", "rtl");
				}
				detailsDiv.className = "ibmPortalDetails";
				detailsDiv.appendChild(printDoc.createTextNode(this._messages[x]._details));
				entry.appendChild(detailsDiv);
				printWindow.document.getElementById("statusBar").appendChild(entry);
			}
        },
        addMessage: function(/*Object*/args) {
            //summary: adds a message to the message array
            if(args.uid && args.uid != this.uid) {
            	return;
            }
            var message = args.message;
            this._messages.push(message);
            // temp limit to handle infinite loops if there is an error raised in this code
            if (this._messages.length < 100){
               this.render(this._getStatusContainer());
            }
  
        },
        render: function(/*Node*/ targetContainer) {
            //summary: render the message(s) in the statusBar  
            if (targetContainer == null){
            targetContainer = this._getStatusContainer();
            }
            dojox.data.dom.removeChildren( targetContainer );
            // only render multiple header if there is more than one message.
            // in renderMessage, if their is only one message, it will render as the header
            if (this._messages.length > 1) {
                this.renderHeader(targetContainer);
            }
            else if (this._messages.length == 1) {
                this.renderMessage(targetContainer,this._messages[0], this.showDetails,0);
            }
            
            // if showing details, render all the messages
            if(this.showDetails && this._messages.length > 1){
                for (x in this._messages){
                    this.renderMessage(targetContainer, this._messages[x], this.showDetails, x);
                }
            }
            // if not showing details, only show the last one
            //else {
            //    this.renderMessage(this._messages[this._messages.length-1], this._showDetails, this._messages.length-1 );
            //}


            // if we have more than one message and we are not showing details,
            // then start a color fade based on the last message received
            if(!this.showDetails && this._messages.length > 1){
                // in case its already running for a previous message
                this.colorFader.stop();

                // get the last message type that came in to get its color
                var end = this._messages.length - 1;
                var startBackgroundColorStr = this._statusTypesMap[this._messages[end]._type]._color;
                this.colorFader.setBeginColor(startBackgroundColorStr);
                this.colorFader.start();
            }
        
   
        },
        renderHeader: function(/*Node*/ targetContainer) {
            var v3theme_Properties = dojo.i18n.getLocalization("com.ibm.portal", "v3theme", this.locale);
            
            //summary: render the main statusBar 
            //description: this is the main statusBar, which includes the main controls, and either the single status message,
            // or an indicator of the number of messages contained within the details view. 
            //
            if(this._messages.length > 1) {
                var headerMessage = new com.ibm.widgets.StatusMessage( "multiple", v3theme_Properties["itemsAvailable"], "" );
                this.renderMessage(targetContainer, headerMessage, this.showDetails, -1);
            }
            // if only one message, render it as the header
            else if(this._messages.length == 1){
               // this.renderMessage(targetContainer, this._messages[0], this._showDetails, 0);
            }
 
        },
        renderMessage: function (/*Node*/ targetContainer, /*com.ibm.widgets.StatusMessage*/message, /*boolean*/ showDetails, /*int*/index ) {
            //summary: renders a single message in the statusBar
            //description: renders the following markup:
            //<div class="ibmPortalError">
            //<h3><img src="./error.gif"/> An Error Occurred <a href="#"> 3 more...</a></h3>
            //<div class="ibmPortalDetails">Its a really really bad one</div>
            //</div>
            //var statusContainer = this._getStatusContainer();
            var statusType = this._statusTypesMap[message._type];
            //dojox.data.dom.removeChildren( statusContainer );
            
            // status entry base container
            var entry = document.createElement( "div" );
            entry.className = statusType._styleClass;
            
            // summary header - the colored area of each status message
            var header = document.createElement("h3");
            header.id = this._summaryHeaderId;   // set id for color fader
            // Lefthandside (LHS) contains icon, message, and show/hide details
            var header_LHS = document.createElement("div");
            if(!this.isBidi){
                header_LHS.className = "ibmPortalStatusHeaderLHS";
            }
            else{
                header_LHS.className = "ibmPortalStatusHeaderRHS";
            }               

            var icon = document.createElement("img");
            icon.src = statusType._iconPath;
            header_LHS.appendChild(icon);
            
            var messageText = null;
            var v3theme_Properties = dojo.i18n.getLocalization("com.ibm.portal", "v3theme", this.locale);
            
            // is this the top header status summary and we have more than one message
            if(this._messages.length > 1 && index < 0){
//                header_LHS.appendChild(document.createTextNode(''+this._messages.length+' messages are available for review.'));
                // then format the message
                if(!this.isBidi)
                    messageText = ''+this._messages.length+' '+v3theme_Properties["messagesAvailable"];
                else
                    messageText = v3theme_Properties["messagesAvailable"]+' '+this._messages.length+'';
            }
            // do we have only one message
            else if(this._messages.length == 1){
                messageText = message._message;
                // adjust the left margin for a single message which will have a style class that is normally indented
                entry.style.marginLeft="0px";
            }
            else{
                header_LHS.appendChild(document.createTextNode(message._message));
            }

            header.appendChild(header_LHS);

            // render top level multiple messages status bar header
            if((this._messages.length > 1 && index < 0)||(this._messages.length == 1)){
                var me = this;
                var detailsAnchor = document.createElement("a");
                detailsAnchor.href="javascript:void(0)";
                detailsAnchor.onclick=function (e) { me.toggleShowDetails(); return false; };

                var header_RHS = document.createElement("div");

                var clearAnchor = document.createElement("a");
                clearAnchor.href="javascript:void(0);";
                clearAnchor.onclick=function (e) { me.clear(); return false; };
                clearAnchor.appendChild(document.createTextNode(v3theme_Properties["clear"]));

                var printAnchor = document.createElement("a");
                printAnchor.href="javascript:void(0);";
                printAnchor.onclick=function(e){ me.print(); };
                printAnchor.appendChild(document.createTextNode(v3theme_Properties["print"]));

                var showDetailsText = v3theme_Properties["showDetails"];
                var hideDetailsText = v3theme_Properties["hideDetails"];
                
                if(this.isBidi){
                	header_RHS.className = "ibmPortalStatusHeaderLHS";
                }
                else {
                	header_RHS.className = "ibmPortalStatusHeaderRHS";
                }
                
                header_LHS.appendChild(document.createTextNode(messageText));
                if (showDetails){
                    detailsAnchor.appendChild(document.createTextNode(hideDetailsText));
                }
                else {
                    detailsAnchor.appendChild(document.createTextNode(showDetailsText));
                }
                header_LHS.appendChild(detailsAnchor);
                // clear link
                header_RHS.appendChild(clearAnchor);
                // print link
                header_RHS.appendChild(printAnchor);
                header.appendChild(header_RHS);
            }

            var clearingDiv = document.createElement("div");
            clearingDiv.className="wptheme-clearing ";
            header.appendChild(clearingDiv);

            entry.appendChild(header);
    
            // details
            if (showDetails && index >=0){
                var detailsDiv = document.createElement("div");
                detailsDiv.className = "ibmPortalDetails";
                detailsDiv.appendChild(document.createTextNode(message._details));
                entry.appendChild(detailsDiv);
            }
            targetContainer.appendChild(entry);
    
        }
    }
); // end declare StatusBar

}

if(!dojo._hasResource["com.ibm.widgets.PageToolbarButton"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.widgets.PageToolbarButton"] = true;
dojo.provide("com.ibm.widgets.PageToolbarButton");

dojo.declare("com.ibm.widgets.PageToolbarButton", dijit.form.Button, {
	label: "",
	btnClass: "",
	templateString: '<button class="lotusBtn ${btnClass}" dojoattachevent="onclick:onClick,onmouseenter:_onMouse,onmouseleave:_onMouse,onmousedown:_onMouse" widgetid="${id}" id="${id}" waistate="labelledby-${id}_label" wairole="button" type="button" name="" dojoattachpoint="titleNode,focusNode" role="button" aria-labelledby="${id}_label" tabindex="0" style="-moz-user-select: none;">'+
					'<span id="${id}_label" class="dijitInline dijitButtonText" dojoattachpoint="containerNode">${label}</span>'+
					'</button>',

	onClick: function(){
		// summary: stub event for when button is clicked
	}
});

}

if(!dojo._hasResource["com.ibm.strategy.Strategy"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.strategy.Strategy"] = true;
/*
 * @author Ben
 */ 
dojo.provide("com.ibm.strategy.Strategy");



dojo.declare("com.ibm.strategy.Strategy",
	null,
	{
		// extensions: Array
		//		Array of strings indicating which functions in this strategy should be used
		//		to wrap functions of the same name in the object this strategy is applied to.
		//		Extensions cannot be named "strategyInit", "around", or "proceed", as these
		//		reserved words for strategy management.  If an extension is defined here
		//		but no matching mapped function is found in the extensionsMap object AND no
		//		function with the same name as the function to extend is found in this strategy,
		//		then the strategy will simply call the original function without special
		//		handling.
		extensions: [],
		
		// extensionsMap: Object
		//		Map of key-value pairs indicating what functions in the strategy are called
		// 		when a function on the wrapped object is called.  Keys in this map correspond
		//		to function names on the wrapped object, and should also appear in this strategy's
		//		extensions array.  Values associated with the keys correspond to the function
		//		in this strategy that are called when the wrapped function on the original object
		//		is called.  Note that these mappings are optional, and if a mapping does not
		//		exist in this map for an extension found in the extensions array, then the function
		//		called in this strategy is the same name as the function it wrapped.  Because of
		//		this, this extensionsMap object itself is optional and can be null to provide
		// 		default wrapping where the extension function names are the same in the original
		// 		object and the strategy wrapping them.
		extensionsMap: {},
		
		strategyInit: function(obj) {
			// summary: Function called when a strategy instance is applied to an object.
			// obj: The object that this strategy is applied to.			
		},
		
		getStrategyContext: function() {
			return dojox.lang.aspect.getContext();
		},
		
		around: function() {
			// summary: Helper function used to manage the around advice that this strategy
			//		incorporates using its extension functions.
			var fName = this.getStrategyContext().joinPoint.targetName;
			if(this.extensionsMap[fName]) {
				return this[this.extensionsMap[fName]].apply(this, arguments);
			}
			else if(this[fName]) {
				return this[fName].apply(this, arguments);
			}
			else {
				return this.proceed(arguments);
			}
		},
		
		proceed: function(args) {
			// summary: Helper function to proceed to the next function in the advice
			//		wrapping chain.  Strategy extensions can call this.proceed(arguments)
			//		to call the next function in the chain of their current context.
			return dojox.lang.aspect.proceed.apply(null, args);
		}
	}
);

com.ibm.strategy.Strategy.applyStrategy = function(obj, strategy) {
	strategy.strategyInit(obj);
	var adv = dojox.lang.aspect.advise(obj, strategy.extensions, strategy);
	return adv;
}

com.ibm.strategy.Strategy.removeStrategy = function(adv) {
	dojox.lang.aspect.unadvise(adv);
}

}

if(!dojo._hasResource["com.ibm.strategy.PageAddedNotificationStrategy"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.strategy.PageAddedNotificationStrategy"] = true;
dojo.provide("com.ibm.strategy.PageAddedNotificationStrategy");



dojo.declare("com.ibm.strategy.PageAddedNotificationStrategy",
	com.ibm.strategy.Strategy,
	{
		// extensions: Array
		//		Array of strings indicating which functions in this strategy should be used
		//		to wrap functions of the same name in the object this strategy is applied to.
		//		Extensions cannot be named "strategyInit", "around", or "proceed", as these
		//		reserved words for strategy management.
		// 		This extension is set in the pageBuilderTheme.js file in the theme,
		//		it is set for com.ibm.mm.builder.viewMorePage widget.
		extensions: ["save"],
		
		constructor: function(operationCallback, finishedCallback) {
			if(operationCallback) this.operationCallback = operationCallback;
			if(finishedCallback) this.finishedCallback = finishedCallback;
		},
		
		save: function() {
			var me = this,
				oldNavModelGetter = com.ibm.mm.builder.utils.navigationUtil.getNavigationModel;
			com.ibm.mm.builder.utils.navigationUtil.getNavigationModel = function(){
				var navModel = oldNavModelGetter.apply(this, arguments);
				com.ibm.mm.builder.utils.navigationUtil.getNavigationModel = oldNavModelGetter;
				var oldCommit = navModel.commit;
				navModel.commit = function() {
					var dfd = oldCommit.apply(this, arguments);
					dfd.setOperationCallback(function(newNode){
						me.operationCallback(newNode);
					});
					dfd.setFinishedCallback(function(){
						me.finishedCallback();
					});
					navModel.commit = oldCommit;
					return dfd;				
				}
				return navModel;
			};			
			var ret = this.proceed(arguments);

			return ret;
		},
		
		operationCallback: function(newNode) {
			// summary: Function which is called at the end of each step in Deferred processing which
			// 		fires its operation callback when a new node is added to the navigation.
			// newNode: Navigation node created by the page addition.
		},
		
		finishedCallback: function() {
			// summary: Function which is called at the end of the Deferred processing which
			// 		fires its operation callback when the add page operation completes either
			// 		successfully or unsuccessfully.
		}
	}
);

}

if(!dojo._hasResource["com.ibm.strategy.PageMovedNotificationStrategy"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.strategy.PageMovedNotificationStrategy"] = true;
dojo.provide("com.ibm.strategy.PageMovedNotificationStrategy");



dojo.declare("com.ibm.strategy.PageMovedNotificationStrategy",
	com.ibm.strategy.Strategy,
	{
		// extensions: Array
		//		Array of strings indicating which functions in this strategy should be used
		//		to wrap functions of the same name in the object this strategy is applied to.
		//		Extensions cannot be named "strategyInit", "around", or "proceed", as these
		//		reserved words for strategy management.
		// 		This extension is set in the enhancedPageContextMenu.jsp file in the theme,
		//		it is set for the com.ibm.mm.builder.utils.navigationUtil object.
		extensions: ["reorderPageNode"],
		
		constructor: function(callback) {
			if(callback) this.callback = callback;
		},
		
		reorderPageNode: function() {
			var me = this,
				instance = this.getStrategyContext().instance,
				navigationModel =  com.ibm.mm.builder.utils.navigationUtil.getNavigationModel(),
				oldCommit = navigationModel.commit;	
			
			navigationModel.commit = function() {
				var dfd = oldCommit.apply(this, arguments);
				dfd.setOperationCallback(function(newNode){
					me.callback(newNode);
				});
				return dfd;				
			}
			
			var ret = this.proceed(arguments);
			navigationModel.commit = oldCommit;
			return ret;
		},
		
		callback: function(newNode) {
			// summary: Function which is called at the end of the Deferred processing which
			// 		fires its operation callback when the share operation completes either
			// 		successfully or unsuccessfully.
		}
	}
);

}

if(!dojo._hasResource["com.ibm.strategy.ShareNotificationStrategy"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.strategy.ShareNotificationStrategy"] = true;
dojo.provide("com.ibm.strategy.ShareNotificationStrategy");



dojo.declare("com.ibm.strategy.ShareNotificationStrategy",
	com.ibm.strategy.Strategy,
	{
		// extensions: Array
		//		Array of strings indicating which functions in this strategy should be used
		//		to wrap functions of the same name in the object this strategy is applied to.
		//		Extensions cannot be named "strategyInit", "around", or "proceed", as these
		//		reserved words for strategy management.
		extensions: ["saveACL"],
		
		constructor: function(callback) {
			if(callback) this.callback = callback;
			ibmPortalConfig.isShareStrategySet = true;
		},
		
		saveACL: function() {
			var me = this,
				instance = this.getStrategyContext().instance,
				oldCommit = instance.acModel.commit,
				oldSetCallback = null,
				count = 0;
				
			var utilsAdvice = com.ibm.strategy.Strategy.applyStrategy(
				instance.acModelUtil, new com.ibm.strategy.ACModelUtilsWrapper(function(inc){count += inc;}));	
				
			instance.acModel.commit = function() {
				var dfd = oldCommit.apply(this, arguments);
				oldSetCallback = dfd.setOperationCallback;
				dfd.setOperationCallback = function(func) {
					var wrappedFunc = function(newNode) {
						com.ibm.strategy.Strategy.removeStrategy(utilsAdvice);
						utilsAdvice = null;
						if(--count <= 0) me.callback(newNode);
						return func(newNode);
					}
					var ret = oldSetCallback.call(this, wrappedFunc);
					dfd.setOperationCallback = oldSetCallback;
					return ret;
				}
				instance.acModel.commit = oldCommit;
				return dfd;
			}
			return this.proceed(arguments);
		},
		
		callback: function(newNode) {
			// summary: Function which is called at the end of the Deferred processing which
			// 		fires its operation callback when the share operation completes either
			// 		successfully or unsuccessfully. 
		}
	}
);

dojo.provide("com.ibm.strategy.ACModelUtilsWrapper");

dojo.declare("com.ibm.strategy.ACModelUtilsWrapper",
	com.ibm.strategy.Strategy,
	{
		// extensions: Array
		//		Array of strings indicating which functions in this strategy should be used
		//		to wrap functions of the same name in the object this strategy is applied to.
		//		Extensions cannot be named "strategyInit", "around", or "proceed", as these
		//		reserved words for strategy management.
		extensions: ["insertMemberWithRoleType", "removeMembersWithRoleType"],
		
		constructor: function(incFunc) {
			if(incFunc) this.incFunc = incFunc;
		},
		
		insertMemberWithRoleType: function(model, members, role) {
			if(members) {
				var count = 0;
				for(var x in members) {
					if(members[x]) count ++;
				}
				this.incFunc(count);
			}
			return this.proceed(arguments);
		},
		
		removeMembersWithRoleType: function(model, role, members) {
			if(members) {
				var count = 0;
				for(var x in members) {
					if(members[x]) count ++;
				}
				this.incFunc(count);
			}
			return this.proceed(arguments);
		},
		
		incFunc: function(inc) {
			// summary: Fired when a certain number of principals are added or removed
			//		from the list of ACL modifications to be made. 
			// inc: The number to add to the current number of principals which 
			//		will be affected by the ACL change.  
		}
	}
);

}

if(!dojo._hasResource["ibm.portal.search.widgets.common"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["ibm.portal.search.widgets.common"] = true;

dojo.provide("ibm.portal.search.widgets.common");

dojo.declare(
	"ibm.portal.search.scope.XmlWriter", null,
	{
		//constants
		SPACE: " ",
		EQUALS: "=",
		QUOTES: "\"",
		SLASH: "/",
		START_TAG: "<",
		END_TAG: ">",
		SCOPE_ELEMENT: "scope",
		TITLE_ELEMENT: "title",
		DESCRIPTION_ELEMENT: "description",
		QUERY_TEXT_ELEMENT: "querytext",
		SCOPE_PROPERTY_ELEMENT: "scopeproperty",
		KEY_ATTRIBUTE: "key",
		VALUE_ATTRIBUTE: "value",
		ID_ATTRIBUTE: "id",
		SELECTED_SCOPE: "SELECTED_SCOPE",
		SCOPEELEMENT_ELEMENT: "scopeelement",
		LOCATION_ELEMENT: "location",
		FEATURE_ELEMENT: "feature",
		FEATURE_VALUE_ELEMENT: "feature_value",
		FEATURE_ID: "feature_id",
		SOURCE_ATTRIBUTE: "source",
		PATH_ATTRIBUTE: "path",
		
		writeAttribute: function(key, value, buffer) {
		    buffer.push(this.SPACE);
		    buffer.push(key);
		    buffer.push(this.EQUALS);
		    buffer.push(this.QUOTES);
		    buffer.push(value);
		    buffer.push(this.QUOTES);
		},
		startElement: function(elementName, attributes, attributeValues, close, buffer)  {
		    buffer.push(this.START_TAG);
		    buffer.push(elementName);
		    if (attributes !== null) {
		        if (attributes.constructor == Array) {
		            for (i = 0; i < attributes.length; i++) {
		                this.writeAttribute(attributes[i], attributeValues[i], buffer);
		            }
		        } else {
		            this.writeAttribute(attributes, attributeValues, buffer);
		        }
		    }
		    if (close) {
		        buffer.push(this.SLASH);
		    }
		    buffer.push(this.END_TAG);
		},
		writeNoAttributeElement: function(elementName, content, buffer)  {
		    this.startElement(elementName, null, null, false, buffer);
		    buffer.push(content);
		    this.endElement(elementName, buffer);
		},
		endElement: function(elementName, buffer) {
		    buffer.push(this.START_TAG);
		    buffer.push(this.SLASH);
		    buffer.push(elementName);
		    buffer.push(this.END_TAG);
		},
		writeScope: function(/*ibm.portal.search.scope.Scope*/ scope) {
			 var buffer = [];
		    // start scope tag
		    this.startElement(this.SCOPE_ELEMENT, this.ID_ATTRIBUTE, scope.id, false, buffer);
		    
		    //write title, description and  query text
		    this.writeNoAttributeElement(this.TITLE_ELEMENT, scope.label, buffer);
		    this.writeNoAttributeElement(this.DESCRIPTION_ELEMENT, scope.description, buffer);
		    if (scope.query != null) {
		        this.writeNoAttributeElement(this.QUERY_TEXT_ELEMENT, scope.query, buffer);
		    }
		    
		    //write elements
		    for (elementIndex = 0; elementIndex < scope.scopeElements.length; elementIndex++) {
		        this.writeScopeElement(scope.scopeElements[elementIndex], buffer);
		    }
		    //write properties
		    for (property in scope.properties) {
		        this.startElement(this.SCOPE_PROPERTY_ELEMENT, 
		            [this.KEY_ATTRIBUTE, this.VALUE_ATTRIBUTE], 
		            [property, scope.properties[property]], true, buffer);
		    }
		    //end scope
		    this.endElement(this.SCOPE_ELEMENT, buffer);
		    //transform the buffer to a string
		    return buffer.join("");
		},
		writeScopeElement: function(/*ibm.portal.search.scope.ScopeElement*/ scopeElement, buffer) {
			this.startElement(this.SCOPEELEMENT_ELEMENT, null, null, false, buffer);
		
		    //write locations
		    for (index = 0; index < scopeElement.locations.length; index++) {
		        var sourcePathPair = scopeElement.locations[index];
		        var source = sourcePathPair[0];
		        var path = sourcePathPair[1];
		        if (path === null) {
		            this.startElement(this.LOCATION_ELEMENT, 
		                this.SOURCE_ATTRIBUTE, source, true, buffer);
		        } else {
		            this.startElement(this.LOCATION_ELEMENT, 
		                [this.SOURCE_ATTRIBUTE, this.PATH_ATTRIBUTE],
		                 sourcePathPair, true, buffer);
		        }
		    }
		    
		    //write features
		    for (id in scopeElement.features) {
		        this.startElement(this.FEATURE_ELEMENT, 
		                this.FEATURE_ID, id, false, buffer);
		        
		        var value = scopeElement.features[id] ;
		        if (dojo.isArray(value)) {
		            for (i = 0; i < value.length; i++) {
		                this.writeNoAttributeElement(this.FEATURE_VALUE_ELEMENT, value[i], buffer);
		            }
		        } else {
		            this.writeNoAttributeElement(this.FEATURE_VALUE_ELEMENT, value, buffer);
		        }
		        this.endElement(this.FEATURE_ELEMENT, buffer);
		    }
		    
		    this.endElement(this.SCOPEELEMENT_ELEMENT, buffer);
		}
});

dojo.declare(
	"ibm.portal.search.scope.Scope", null,
	{
	//summary:
	//	a Javascript object reflecting a SIAPI scope
	
	//id: String
	//	the id of the scope. It is not required for contextual scopes.
	id: null,
	
	//label: String
	//	name of the scope. Will be displayed in the search menu.
	label: null,
	
	//description: String
	//	description of the scope. Will be displayed as tooltip in the search menu.
	description: null,
	
	//icon: String
	//	URL of an icon representing this scope. Will be displayed in the search menu.
	icon: null,
	
	//params:
	//	should include values for the label, description, icon, and possibly id attributes
	constructor: function(/*String*/ name, /*String*/ description, /*String*/ icon, /*String?*/ id) {
		this.label = name;
		this.description = description;
		this.icon = icon;
		this.id = (id != null)? id : name;
	},
	
	//summary: 
	//	Adds a scope element to the scope
	addElement: function (/*ibm.portal.search.scope.ScopeElement*/scopeElement) {
		if (this.scopeElements == null) {
			this.scopeElements = [];
		}
    	this.scopeElements.push(scopeElement);
	},
	
	//summary: 
	//	Adds the property to the scope
	addProperty: function (/*String*/ key, /*String*/ value) {
		if (this.properties == null) {
			this.properties = {};
		}
    	this.properties[key] = value;
	},
	
	//summary: 
	//	Adds the query text to the scope
	addQuery: function (/*String*/ query) {
		this.query = query;
	},
	
	//summary:
	//	checks whether this is a contextual scope
	isContextual: function() {
		return (this.scopeElements != null);
	},
	
	//summary:
	//	extracts a string represenation of the scope which can be sent to a search service
	getValue: function () {
		if (this.isContextual()) {
			var writer = new ibm.portal.search.scope.XmlWriter();
			return writer.writeScope(this);
		} else {
			return this.id;
		}
	}
});

dojo.declare(
	"ibm.portal.search.scope.ScopeElement", null,
	{
	constructor: function() {
    	this.locations = [];
	    this.features = {};
	},
	//summary:
	//	Adds a location to the scope element. path parameter is optional.
	addLocation: function(/*String*/ source, /*String*/ path) {
    	this.locations.push([source, path]);
	},
	//summary:
	//	Adds the feature to the scope element.
	//value: can be either a single value, or an array of values (each of them a string)
	//	
	addFeature: function(/*String*/ id, /*String or String array*/value) {
	    if (dojo.isArray(value)) {
	        this.features[id] = [];
	        for (i = 0; i < value.length; i++)  {
	              this.features[id].push(value[i]);
	        }       
	    } else {
	        this.features[id] = value;
	    }
	}
});

//a topic which indicates a search scope was selected
ibm.portal.search.scope.SCOPE_SELECTED_TOPIC = 'ibm.portal.search.SCOPE_SELECTED_TOPIC';
	
//a topic which is used for adding a new contextual search scope
ibm.portal.search.scope.ADD_SCOPE_TOPIC = 'ibm.portal.search.ADD_SCOPE_TOPIC';

//a topic which is used for submitting a new scoped query to the search center
ibm.portal.search.scope.SUBMIT_SCOPE_TOPIC = 'ibm.portal.search.SUBMIT_SCOPE_TOPIC';

//a topic which indicates a new search query was submitted
ibm.portal.search.NEW_QUERY_TOPIC = 'ibm.portal.search.NEW_QUERY_TOPIC';

//this constant value represents the currently selected scope
ibm.portal.search.scope.SELECTED_SCOPE = 'ibm.portal.search.scope.SELECTED_SCOPE';

//Summary:
// Appends the given scope to the search menu in the theme as a contextual scope.
ibm.portal.search.scope.addContextualScope = function(/*ibm.portal.search.scope.Scope*/ scope, 
	/*Boolean?*/ isDefault) {
	dojo.publish(ibm.portal.search.scope.ADD_SCOPE_TOPIC, [scope, isDefault]);
}

//Summary:
//	Performs search for the supplied query text upon the supplied scope. 
//	The call is synchronous and the caller is directed to the Search Center page.
ibm.portal.search.scope.submit = function(/*ibm.portal.search.scope.Scope*/ scope, /*String?*/ query) {
	dojo.publish(ibm.portal.search.scope.SUBMIT_SCOPE_TOPIC, [scope, query]);
}

dojo.declare(
	"ibm.portal.search.Query", null,
	{
	//summary:
	//	a Javascript object reflecting a SIAPI query
	
	//text: String
	//	the actual text of the query
	text: null,

	//language: String
	//	the language of the query
	language: null,
	
	//scope: String
	//	the value of the query scope 
	scope: null,
	
	//advancedQueries: Array
	//	Advanced query parts which should be submitted but not displayed
	advancedQueries: null,
	
	//returns the full text of the query, including advanced parts
	getFullQueryText: function() {
		var queryText = this.text;
		if (this.advancedQueries.length > 0) {
			return queryText + " " + this.advancedQueries.join(" ");
		}
		return queryText;
	},
	
	//add an advanced part to the query string
	addAdvancedQuery: function(/*String*/advancedQuery) {
		this.advancedQueries.push(advancedQuery);
	},
	
	//params:
	//	should include values for the text, language, and scope attributes
	constructor: function(params) {
		this.advancedQueries = [];
		dojo.mixin(this, params);
	}
});

//define the ibm.portal.search.util namespace
if (ibm.portal.search.util == undefined) {
	ibm.portal.search.util = {};
}

//summary:
//	returns the URL of the search service for the supplied action and parameters
ibm.portal.search.util.getServiceUrl = function(root, action, params) {
	var urlBuffer = [root];
	urlBuffer.push(action);
	urlBuffer.push('?');
	urlBuffer.push(dojo.objectToQuery(params));
	return urlBuffer.join('');
}

//summary:
//	returns the first word in the current path
ibm.portal.search.util.getContextRoot = function() {
	var end = window.location.pathname.indexOf("/", 1);
	return window.location.pathname.substring(0, end);
}

//summary:
//	opens a new window (smaller than the current one). useful for displaying help
ibm.portal.search.util.openSideWindow = function(/*String*/newWindowUrl) {
	var newWindowAtts = 'width=800,height=600,toolbar=yes,location=no,directories=no,status=yes,menubar=no,scrollbars=yes,resizable=yes,';
	var browserSpecificAtts = dojo.isIE? 'left=15,top=15': 'screenX=15,screenY=15';
	window.open(newWindowUrl, '', newWindowAtts + browserSpecificAtts);
}

//summary:
//	returns the user locale, which is set as the language of the html document
ibm.portal.search.util.getLocale = function() {
	return document.documentElement.lang;
}

ibm.portal.search.util.xmlNamespaces = {
	'atom': 'http://www.w3.org/2005/Atom',
	'opensearch': 'http://a9.com/-/spec/opensearch/1.1/',
	'xsl': 'http://www.w3.org/1999/XSL/Transform',
	'xhtml': 'http://www.w3.org/1999/xhtml'
}

//summary:
//	get the value of an xml node
ibm.portal.search.util.getXpathValue = function(/*DomNode*/ xmlDoc, /*String*/ nodePath) {
	var nodes =	com.ibm.portal.xpath.evaluateXPath(nodePath, 
		xmlDoc, ibm.portal.search.util.xmlNamespaces);
	
	if (nodes == null || nodes.length == 0) {
		return null;
	}
	var node = nodes[0];
	if (node.firstChild == null) {
		return node.data;
	}
	return node.firstChild.data;
}

}

if(!dojo._hasResource["ibm.portal.search.Enhanced.widgets.searchBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["ibm.portal.search.Enhanced.widgets.searchBox"] = true;










dojo.provide("ibm.portal.search.Enhanced.widgets.searchBox");

ibm.portal.search.util.getNodes = function(/*DomNode*/ xmlDoc, /*String*/ nodePath) {
	return com.ibm.portal.xpath.evaluateXPath(nodePath, 
		xmlDoc, ibm.portal.search.util.xmlNamespaces);
};

dojo.declare(
   "ibm.portal.search.Enhanced.widgets.ScopeSearchWidget",
   [dijit._Widget, dijit._Templated, dijit._Container],
   {
   	//summary:
	//	a widget which allows the user to choose a scope and enter query, in order to perform search.
	
	//define template by external file
	templateString:"<form dojoAttachPoint=\"queryForm\" action=\"${submitUrl}\" dojoAttachEvent=\"onsubmit:submitQueryForm\" \n\tmethod=\"get\" name=\"searchQueryForm\" class=\"lotusSearch\"\n\t><table class=\"lotusLayout\" cellspacing=\"0\" summary=\"layout table\"\n\t\t><tr><td style=\"display: none\" dojoAttachPoint=\"scopeSelectionNode\"><a href=\"javascript:;\" class=\"lotusScope\" title=\"${resourceBundle.scopeButtonTooltip}\" dojoAttachPoint=\"scopeNode\" dojoAttachEvent=\"onclick:openMenu\"\n\t\t\t\t><img class=\"lotusIcon lotusHidden\" dojoAttachPoint=\"scopeIconNode\" alt=\"\" /\n\t\t\t\t><span dojoAttachPoint=\"scopeNameNode\"></span\n\t\t\t\t><span class=\"lotusAltText\">&#x25bc;</span\n\t\t\t></a></td><td\n\t\t><input type=\"hidden\" dojoAttachPoint=\"scope\" name=\"scope\"/\n\t\t><input type=\"hidden\" name=\"sourceContentNode\" value=\"${sourceContentNode}\"/\n\t\t><label class=\"lotusHidden\" for=\"${id}searchInput\">${resourceBundle.searchInstruction}</label\n\t\t><input type=\"text\"\n\t\t\tdojoAttachPoint=\"query\"\n\t\t\tdojoAttachEvent=\"onfocus:onTextFocus, onblur:onTextBlur\"\n\t\t\tname=\"query\"\n\t\t\tid=\"${id}searchInput\"\n\t\t\tclass=\"${disabledTextClass} lotusText\" \n\t\t\tvalue=\"${resourceBundle.searchInstruction}\"/\n\t\t></td><td><span class=\"lotusBtnImg\"\n\t\t><input class=\"lotusSearchButton\" type=\"image\" alt=\"${resourceBundle.searchInstruction}\" title=\"${resourceBundle.searchAltText}\" src=\"${blankIcon}\"/\n\t\t><span class=\"lotusAltText\">${resourceBundle.searchAltText}</span></span></td></tr></table\n></form>\n",
	
	//widgetsInTemplate: Boolean
	//	override dijit._Templated's default value
	widgetsInTemplate: true,
	
	//submitUrl: String
	//	the URL to whom the search form will be submitted
	submitUrl: '',
	
	//sourceContentNode: String
	//	contains the id of the current content node
	sourceContentNode: '',
	
	//disabledTextClass: String
	//	The CSS class of an empty query box, which displays the name of the search scope
	disabledTextClass: 'lotusInactive',
	
	//contextualScopes: Array
	//	an array of contextual scopes, added by the user
	contextualScopes: null,
	
	//searchLinks: Array
	//	an array of additional search links for the search menu, added by the user
	searchLinks: null,
	
	//menuTTL: number
	//	The time (in milliseconds) to cache the search menu in the browser
	menuTTL: 1000 * 60 * 15,//15 minutes

	//resourceBundle: Object
	//	A map between keys and translated strings
	resourceBundle: null,
	
	scopes: null,
	
	emptyScope: {id: "", label: "", description: "", icon: ""},
	
	searchFeedUrl: null,
	
	timeStamp: null,
	
	displayScopes: true,
	
	//override dijit._Widget's method
	postMixInProperties: function() {
		this.blankIcon = dojo.moduleUrl("dojo.resources", "blank.gif").toString();
	},
	
	//override dijit._Widget's method
	startup: function () {
		dojo.subscribe(ibm.portal.search.scope.SCOPE_SELECTED_TOPIC, this, 'scopeSelected');
		dojo.subscribe(ibm.portal.search.NEW_QUERY_TOPIC, this, 'newQuery');
		dojo.subscribe(ibm.portal.search.scope.ADD_SCOPE_TOPIC, this, 'addContextualScope');
		dojo.subscribe(ibm.portal.search.scope.SUBMIT_SCOPE_TOPIC, this, 'submitScope');
	},
	
	//override dijit._Widget's method
	postCreate: function(){
		this.scopeService = ibm.portal.search.util.getServiceUrl(this.searchFeedUrl, 'scopes', {
			locale: djConfig.locale,
			customLinks: true,
			timeStamp: this.timeStamp
		});
		this.retrieveScopes();
	},
	
	//summary:
	//	this function will be called following a 'SCOPE_SELECTED' event
	//newScope: ibm.portal.search.scope.Scope
	//	the scope object that was selected by the user
	scopeSelected: function(/*ibm.portal.search.scope.Scope*/ newScope) {
		if (djConfig.isDebug) {
			console.debug("scopeSelected");
		}
		this.selectedScope = newScope;
		this.scopeIconNode.src = newScope.icon;
		dojo.toggleClass(this.scopeIconNode, "lotusHidden", (newScope.icon == null));		
		this.scopeNameNode.innerHTML = newScope.label;
		this.scope.value = newScope.id;
		this.closeMenu();
	},
	
	//summary:
	//	add a contextual scope to the search menu
	//scope: ibm.portal.search.scope.Scope
	//	the scope object
	//isDefault: Boolean
	//	Optional (default is false). Add this scope as the currently selected scope.
	addContextualScope: function(/*ibm.portal.search.scope.Scope*/ scope, /*Boolean?*/ isDefault) {
		if (djConfig.isDebug) {
			console.debug("addContextualScope");
		}
		if (this.contextualScopes == null) {
			this.contextualScopes = [];
		}
		if (isDefault) {
			this.scopeSelected(scope);
		} 
		this.contextualScopes.push(scope);
	},
	
	//summary:
	//	this function will be called following a 'NEW_QUERY' event
	//newQuery: ibm.portal.search.Query
	//	the query that was submitted
	newQuery: function(/*ibm.portal.search.Query*/ newQuery) {
		if (djConfig.isDebug) {
			console.debug("ScopeSearchWidget: newQuery");
		}
		this.query.value = newQuery.text;
		if (dojo.hasClass(this.query, this.disabledTextClass)) {
			dojo.removeClass(this.query, this.disabledTextClass);
		}
		this.onBlur();
	},
	//summary:
	//	this function retrieves the scopes from the server, or from browser cache
	retrieveScopes: function() {
		dojo.xhrGet({
			url: this.scopeService,
			load: dojo.hitch(this, "handleScopes"),
			error: dojo.hitch(this, "handleScopeError"),
			handleAs: 'text'
		});
	},
	
	//summary:
	//	this function handles the scope information retrieved from the server
	handleScopes: function(response, ioArgs) {
		var scopesXml = com.ibm.portal.xslt.loadXmlString(response);//required because of IE issues
		var feed = ibm.portal.search.util.getNodes(scopesXml, "/atom:feed")[0];
		var entries = ibm.portal.search.util.getNodes(feed, "atom:entry");
		this.scopes = [];
		
		for (var i = 0; i < entries.length; i++) {
			var id = ibm.portal.search.util.getXpathValue(entries[i], "atom:id");
			var label = ibm.portal.search.util.getXpathValue(entries[i], "atom:title");			
			var link = ibm.portal.search.util.getXpathValue(entries[i], "atom:link/@href");
			var description = ibm.portal.search.util.getXpathValue(entries[i], "atom:summary");
			var icon = ibm.portal.search.util.getXpathValue(entries[i], "opensearch:image");
			var scope = new ibm.portal.search.scope.Scope(label, description, icon, id);
			if (link != null) {
				scope.link = link;
			}
			this.scopes.push(scope);
		}
		
		if (this.scopes.length == 0) {
			this.scopes.push(this.emptyScope);
		}
		if (this.scopes.length > 1 && this.displayScopes) {
			dojo.style(this.scopeSelectionNode, "display", "");
		}
		
		var firstScope = this.scopes[0];
		this.scopeSelected(new ibm.portal.search.scope.Scope(firstScope.label, 
					firstScope.description, firstScope.icon, firstScope.id));		
	},
	
	//summary:
	//	this function handles an error when retrieving scopes from the server
	handleScopeError: function(response, ioArgs) {
		this.scopes = [this.emptyScope];
	},
	
	//summary:
	//	this menu items for contextual scopes
	addContextualScopesMenuItems: function() {
		if (this.contextualScopes == null) {
			return;//no need for special search links
		}
		for (var i = 0; i < this.contextualScopes.length; i++) {
			this.addScopeMenuItem(this.contextualScopes[i]);
		}
		this.scopeMenu.addChild(new dijit.MenuSeparator({}));
	},
	
	//summary:
	//	this function adds a single scope item to the menu
	addScopeMenuItem: function(scopeItem) {
		var menuItemParams = {
			obj: scopeItem, 
			label: scopeItem.label,
			parentMenu: this.scopeMenu,
			scopeSearchWidget: this
		}			
		if (scopeItem.icon != null) {
			menuItemParams._blankGif = scopeItem.icon;
		}
		var menuItem = new dijit.MenuItem(menuItemParams);
		this.scopeMenu.addChild(menuItem);
		if (scopeItem.description != null) {
			menuItem.iconNode.title = scopeItem.description;
		}
	},
	
	//summary:
	//	this function adds the scope items to the menu
	addScopeMenuItems: function() {
		if (djConfig.isDebug) {
			console.debug("addScopeMenuItems");
		}
		var scopeItems = this.scopes;
		
		var firstCustomLink = true;
		for (var i = 0; i < scopeItems.length; i++) {
			var scopeItem = scopeItems[i];
			if (scopeItem.link != null && firstCustomLink) {//this is the first custom link
				this.scopeMenu.addChild(new dijit.MenuSeparator({}));
				firstCustomLink = false;
			}
			this.addScopeMenuItem(scopeItem);
		}
	},
	
	//summary:
	//	get the text from the query box.
	getQueryText: function () {		
		return this.query.value;
	},
	
	//summary:
	//	this function is called when the search form is submitted
	submitQueryForm: function(event) {
		if (djConfig.isDebug) {
			console.debug("submitQueryForm");
		}
		var queryText = this.getQueryText();		
		if (dojo.hasClass(this.query, this.disabledTextClass)) {
			this.query.value = "";
		}
		
		this.scope.value = encodeURIComponent(dojo.toJson(this.selectedScope));
		return true;
	},
	//summary:
	//	update scope and query parameters and submits the search form
	submitScope: function(/*ibm.portal.search.scope.Scope*/ scope, /*String?*/ query) {
		if (djConfig.isDebug) {
			console.debug("submitScope");
		}
		
		if (scope != ibm.portal.search.scope.SELECTED_SCOPE) {
			this.queryForm.method.value = 'POST';
			this.scope.value = encodeURIComponent(dojo.toJson(scope));
		} else {
			this.scope.value = encodeURIComponent(dojo.toJson(this.selectedScope));
		}
		
		this.query.value = (query != null)? query: '';
		if (scope.query != null) {
			this.query.value = this.query.value + " " + scope.query;
		}
		
		this.queryForm.submit();
	},
	//summary:
	//	this function is called when the user focuses on the search input field
	onTextFocus: function() {
		if (dojo.hasClass(this.query, this.disabledTextClass)) {
			this.query.value = "";
			dojo.removeClass(this.query, this.disabledTextClass);
		}
	},
	//summary:
	//	this function is called when the user removed focus from the search input field
	onTextBlur: function() {
		if (this.query.value == "") {
			dojo.addClass(this.query, this.disabledTextClass);
			this.query.value = this.resourceBundle.searchInstruction;			
		}
	},
	
	selectOption: function(menuItem) {
		if (menuItem.obj.link != null) {//this is a custom link
			var queryText = menuItem.scopeSearchWidget.getQueryText();
			queryText = queryText.replace(/"/g, "\\\"");
			var newWindow = window.open();
			//The delayed focus was added to solve a problem in IE
			//The location is set only after the focus to avoid cross-frame-scripting issues
			newWindow.setTimeout("focus(); document.location = \"" + menuItem.obj.link + queryText + "\";", 100);
			this.scopeSearchWidget.closeMenu();
		} else {
			dojo.publish(ibm.portal.search.scope.SCOPE_SELECTED_TOPIC, [menuItem.obj])
			this.query.focus();
		}
	},
	
	getScopeMenu: function() {
		if (this.scopeMenu != null) {
			return this.scopeMenu;
		}
		this.scopeMenu = new dijit.Menu({
			onItemClick: dojo.hitch(this, "selectOption")
		});
		this.connect(this.scopeMenu, '_onBlur', 'closeMenu');
			
		this.addContextualScopesMenuItems();
		this.addScopeMenuItems();
	
		return this.scopeMenu;
	},
	
	openMenu: function(evt) {
		var menu = this.getScopeMenu();
		
		dijit.popup.open({
		    popup: menu,
		    around: this.scopeNode,
		    //Specify how the popup should align with the button that was clicked
		    orient: (dojo._isBodyLtr() ? {'BL':'TL', 'BR':'TR'} : 
				      {'BR':'TR', 'BL':'TL'}),
		    onExecute: function(){ 
		    },
		    onCancel : dojo.hitch(this,function() {
			dijit.popup.close(menu);
			dijit.focus(this.scopeNode);
		    }),
		    onClose: function() {
		    }
		});
		
		//Must focus here or else clicking off won't blur and won't cause it to close
		menu.focus();
		
		dojo.stopEvent(evt);
    },
    
	closeMenu: function() {
		if (this.scopeMenu) {
		    dijit.popup.close(this.scopeMenu);
		    //fix problem where previouly selected scopes remain marked as selected.
		    var children = this.scopeMenu.getChildren();
		    for (var i = 0; i < children.length; i++) {
			dojo.removeClass(children[i].domNode, 'dijitMenuItemHover');
		    }
		}
	}
});

}

if(!dojo._hasResource["com.ibm.lang.DeferredQueue"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.lang.DeferredQueue"] = true;
/*
 * @author allenbj
 */ 
dojo.provide("com.ibm.lang.DeferredQueue");

dojo.declare("com.ibm.lang.DeferredQueue",
	null,
	{
		constructor: function(/*Deferred?*/ def) {
			this.curDef = def;
			this.firstDef = def;
		},
		_addCallbacks: function(/*Deferred*/ source, /*Deferred*/ target) {
			source.addCallbacks(
				function(res){target.callback(res); return res;},	// callback
				dojo.hitch(this, function(err){						// errback
					try{
						if(!err._raised) {
							this.raiseError(err);	// in case raiseError fails... we still guarantee all callbacks
							err._raised = true;
						}
					}catch(err2){}
					target.callback(err);
					return err;
				})
			);
		},
		addBefore: function(/*Deferred*/ def) {
			// summary: Inserts a Deferred into the front of the queue which will fire the 
			// 		Deferred that is currently in the front of the queue when it calls back.
			//		Allows preprocessing or delaying of this DeferredQueue's firing.
			//		Note, if the queue has already fired, this will cause an error when the
			//		def argument callsback.
			if(!this.firstDef) this.firstDef = def;
			else {
				var oldFirst = this.firstDef;
				this.firstDef = def;
				this._addCallbacks(def, oldFirst);
			}
		},
		add: function(/*Deferred*/ def) {
			// summary: Adds a deferred to the queue which will be fired as a callback
			//		to the previous deferred in the queue.  If this is the first deferred
			//		to be added to the queue, firing it will start the queue.
			if(!this.firstDef) this.firstDef = def;
			if(this.curDef) {
				var oldCur = this.curDef;
				this.curDef = def;
				this._addCallbacks(oldCur, def);
			}
			else {
				this.curDef = def;
			}
			return this;
		},
		fire: function(res) {
			// summary: Starts the queue by firing the first deferred in the queue
			//		passing the argument to this function to the callback function of
			//		the first deferred.
			// res: Anything
			if(this.firstDef) this.firstDef.callback(res);
			return this;
		},
		raiseError: function(err) {
			// summary: Called whenever one of the Deferreds in the queue fires its errback.
			//		If an error is raised once by this and then a subsequent Deferred is errbacked
			//		with the exact same error, it will not be raised again.  However, if the next
			//		Deferred throws or returns a new error, that will be raised only once itself.
			//		This allows any errors to be raised once and only once without losing any of them.
			//		NOOP by default, so override this or connect to it to provide implementation.
		},
		destroy: function() {
			delete this.firstDef;
			delete this.curDef;
			delete this.raiseError;
		}
	}
);

}

if(!dojo._hasResource["com.ibm.xml.xpath"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.xml.xpath"] = true;
/*
 * @author Ben
 */ 
dojo.provide("com.ibm.xml.xpath");

/*
 * 
 * Internal API, not Public, therefore not supported as public APIs.
 * 
 */



com.ibm.xml.xpath = ibm.portal.xml.xpath;

if(dojo.isIE) {
	com.ibm.xml.xpath.evaluate = function(expr, context, namespaces, single) {
		var result = null;
		if(namespaces) {
			var ns = "";
			for (var prop in namespaces) {
			    ns += "xmlns:"+prop+"='"+namespaces[prop]+"' ";
			}
			if (context.ownerDocument) {
			    context.ownerDocument.setProperty("SelectionNamespaces", ns);
			} else {
			    context.setProperty("SelectionNamespaces", ns);
			}
		}
        if(!single) { 
	        result = context.selectNodes(expr);
			var resultSet = [];
	        for (var i=0; i<result.length; i++) {
	            if (result[i]) {
	                resultSet.push(result[i]);
	            }
	        }
	        return resultSet;
        }
        else {
        	return context.selectSingleNode(expr);
        }
	}
}
else {
	com.ibm.xml.xpath.evaluate = function(expr, context, namespaces, single) {
		var result = null;
		var rootDoc = context;
    	if(!rootDoc.evaluate) rootDoc = context.ownerDocument;
    	try {
			result = rootDoc.evaluate( 
				expr, 
				context, 
				function(prefix) { return namespaces[prefix] || null;}, 
				single ? XPathResult.FIRST_ORDERED_NODE_TYPE : XPathResult.ORDERED_NODE_ITERATOR_TYPE, 
				null 
			);
    	}
    	catch(err) {
    		throw new Error("Error with xpath expr: " + expr + " - " + err);
    	}
		
		if(!single) {
			var thisResult;
		    var resultSet = new Array();
		    var len = 0;
		    do {
		        thisResult = result.iterateNext();
		        if (thisResult) {
		            resultSet[len] = thisResult;
		            len++;
		        }
		    } while ( thisResult );
		    return resultSet;
		}
		else {
			return result.singleNodeValue;
		}
	}
}

}

if(!dojo._hasResource["com.ibm.xml.XmlNodeList"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.xml.XmlNodeList"] = true;
/*
 * @author Ben
 */ 
dojo.provide("com.ibm.xml.XmlNodeList");




(function(){
	
	var xpath = function(expr, ctx, single) {
		return com.ibm.xml.xpath.evaluate.call(this, expr, ctx, this.ns, single);
	}
	
	var wrap = function(arr, ns) {
		arr.constructor = com.ibm.xml.XmlNodeList;
		dojo._mixin(arr, com.ibm.xml.XmlNodeList.prototype);
		arr.ns = ns;
		return arr;
	}
	
	com.ibm.xml.XmlNodeList = function() {
		var ret = wrap(Array.apply(null, arguments), null);
		return ret;
	}
	
	var xnl = com.ibm.xml.XmlNodeList, xnlp = xnl.prototype, d = dojo, dom = com.ibm.domUtilities;
	
	xnl.fromArray = function(arr, ns) {
		return wrap(arr, ns);
	}
	
	var flatten = function(arr, ctr) {
		if(arr && (arr instanceof Array || typeof arr == "array")) {
			var flatArr = ctr ? new ctr() : [];
			d.forEach(arr, function(item){
				flatArr = flatArr.concat(flatten(item, ctr));
			});
			return flatArr;
		}
		else return arr;
	}
	
	var createElement = function(def, parentNode) {
		return dom.createFromJson(parentNode.ownerDocument, def, this.ns, parentNode);
	}
	
	d.extend(xnl, {
		map: function(/*Function*/ func, /*Object*/ scope) {
			var ret = d.map(this, func, scope, xnl);
			ret.ns = this.ns;
			return ret;
		},
		indexOf: function(/*XmlNode|Function*/ pred, /*Number*/ startFrom, /*Boolean?*/ fromEnd) {
			var last = this.length || 0, jump = 1, i = 0;
			if(fromEnd) {
				jump = last = -1;
				i = this.length - 1;
			}
			if(startFrom != undefined) i = startFrom;
			// forked for performance reasons
			if(!d.isFunction(pred)) {
				while((fromEnd && i > last) || i < last) {
					if(pred == this[i]) {
						return i;
					}
					i += jump;
				}
			}
			else {
				while((fromEnd && i > last) || i < last) {
					if(pred(this[i])) {
						return i;
					}
					i += jump;
				}
			}
			return -1;
		},
		lastIndexOf: function(/*XmlNode|Function*/ pred, /*Number*/ startFrom) {
			return this.indexOf(pred, startFrom, true);
		},
		forEach: function(/*Function*/ func, /*Object*/ scope) {
			d.forEach(this, func, scope);
			return this;
		},
		removeProp: function(/*String*/prop) {
			switch(prop) {
				case "childNodes":
					this.prop(prop).forEach(function(nodeList){nodeList.remove();});
					return this;
				case "firstChild":
				case "lastChild":
				case "parentNode":
				case "nextSibling":
				case "previousSibling":
					this.prop(prop).remove();
					return this;
				case "text":
				case "textContent":
				case "xml":
				case "innerXML":
					return this.prop(prop, "");
				case "localName":
				case "baseName":
					return this;
				default:
					this.forEach(function(node){delete node[prop];}, this);
					return this;
			}
		},
		removeAttr: function(/*String*/attr) {
			this.forEach(function(node){
				com.ibm.domUtilities.removeAttribute(node, attr, this.ns);
			}, this);
			return this;
		},
		prop: function(/*String*/ prop, /*Object?*/ value) {
			var asXnl = false, f = null, ns = this.ns;
			if(arguments.length < 2) {
				switch(prop) {
					case "childNodes":
						f = function(node){
							var ret = xnl.apply(null, dojo._toArray(node[prop]));
							ret.ns = ns;
							return ret;
						}
						asXnl = true;
						break;
					case "firstChild":
					case "lastChild":
					case "parentNode":
					case "nextSibling":
					case "previousSibling":
						f = function(node){return node[prop];}
						asXnl = true;
						break;
					case "text":
					case "textContent":
						f = function(node){ return dom.textContent(node); };
						break;
					case "xml":
					case "innerXML":
						f = function(node){ return dom.innerXML(node); };
						break;
					case "localName":
					case "baseName":
						prop = [d.isIE ? "baseName" : "localName"];
					default:
						f = function(node){return node[prop];}
				}
				var retArr = d.map(this, f, this);
				if(asXnl) {
					retArr = xnl.apply(retArr, retArr);
					retArr.ns = ns;
				}
				return retArr;
			}
			else {
				var curVal = value;
				
				switch(prop) {
					case "text":
					case "textContent":
						f = function(node) { dojox.data.dom.textContent(node, curVal); };
						break;
					default:
						f = function(node) { node[prop] = curVal; };
				}
				if(dojo.isArrayLike(value)) {
					var sf = f, idx = 0;
					f = function(node) {
						curVal = value[idx++];
						if(curVal !== undefined) sf(node);
					}
				}
				
				d.map(this, f, this);
				return this;
			}
		},
		attr: function(/*String*/ attr, /*String?*/ value) {
			var ns = this.ns;
			if(arguments.length < 2) {
				return d.map(this, function(node){
					if(!dom.hasAttribute(node, attr, ns)) return;
					return dom.getAttribute(node, attr, ns);
				}, this);
			}
			else {
				var curVal = value;
				
				var f = function(node) {
					dom.setAttribute(node, attr, curVal, ns);
				};
				
				if(dojo.isArrayLike(value)) {
					var sf = f, idx = 0;
					f = function(node) {
						curVal = value[idx++];
						if(curVal !== undefined) sf(node);
					}
				}
				
				d.map(this, f, this);
				return this;
			}
		},
		hasAttr: function(/*String*/ attr) {
			return d.map(this, function(node){
				return dom.hasAttribute(node, attr, this.ns);
			}, this);
		},
		every: function(/*Function*/ func, /*Object*/ scope) {
			return d.every(this, func, scope);
		}, 
		some: function(/*Function*/ func, /*Object*/ scope) {
			return d.some(this, func, scope);
		},
		filter: function(/*String*/ xpathPredicate) {
			var resList = this, a = arguments, fIdx = 0;
			if(d.isString(xpathPredicate)) {
				resList = resList.select(".[" + xpathPredicate + "]");
				fIdx = 1;
			}
			if(a.length > 1) {
				resList = xnl.apply(resList, d.filter(resList, a[fIdx], a[fIdx+1]));
				resList.ns = this.ns;
			}
			return resList;
		},
		select: function(/*String*/ xpathExpr, /*Boolean*/ single) {
			if(!xpathExpr) return this;
			var resList = [];
			this.forEach(function(node){
				resList = resList.concat(xpath.call(this, xpathExpr, node, single) || []);
			}, this);
			
			resList = wrap(resList, this.ns);
			return resList;
		},
		remove: function() {
			return this.forEach(function(node){
				if(node.parentNode) {
					node.parentNode.removeChild(node);
				}
			}, this);
		},
		replace: function(/*Array*/nodeList) {
			for(var i=0; i<nodeList.length && i<this.length; i++) {
				this[i].parentNode.replaceChild(nodeList[i], this[i]);
			}
			return this;
		},
		destroy: function() {
			this.remove();
			this.splice(0, this.length);
			return this;
		},
		createFromJson: function(/*Object*/ def) {
			return this.forEach(dojo.partial(createElement, def), this);
		},
		toString: function() {
			return "XmlNodeList{ " + Array.prototype.toString.call(this) + " }";
		}
	});
	
	d.forEach(["slice", "splice", "concat"], function(name){
		xnlp[name] = function() {
			return wrap(Array.prototype[name].apply(this, arguments), this.ns);
		}
	}, this);
	
	d.forEach(["attributes", "baseURI", "childNodes", "firstChild", "lastChild", 
		"localName", "baseName", "namespaceURI", "nextSibling", "nodeName", "nodeType",
		"ownerDocument", "parentNode", "prefix", "previousSibling", "tagName", "innerXML",
		"text", "textContent"], function(name){
		xnlp[name] = function() {
			return this.prop(name);
		}
	}, this);
	
	// syntactic sugar for those who want it
	xnlp.$ = xnlp.select;
	xnlp._$ = xnlp.prop;
	xnlp.text = xnlp.textContent;
})();

}

if(!dojo._hasResource["com.ibm.xml.SimpleXmlAccessor"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.xml.SimpleXmlAccessor"] = true;
/*
 * @author Ben
 */ 
dojo.provide("com.ibm.xml.SimpleXmlAccessor");






dojo.declare("com.ibm.xml.SimpleXmlAccessor",
	null,
	{
		namespaces: {},
		
		constructor: function(args) {
			dojo.mixin(this, args);
		},
		
		evaluate: function(/*String*/ expr, /*Object*/ context, /*Boolean*/ single) {
			var ret = com.ibm.xml.xpath.evaluate(expr, context, this.namespaces, single);
			if(single) {
				if(ret)	ret = [ret];
				else ret = [];
			}
			ret = com.ibm.xml.XmlNodeList.apply(null, ret);
			ret.ns = this.namespaces;
			return ret;
		},
		
		//select: function(/*String*/ selector, /*Object*/ data, /*Boolean*/ single) {
		//	return this.evaluate(selector, data, single);
		//},
		
		prop: function(/*DOMNode*/ node, /*String*/ prop, /*Object?*/ value) {
			// summary:  Function to provide cross-browser support for properties of a queried
			//		node.  Supports textContent as a special property since not
			//		all browsers implement the textContent property of DOM nodes.
			
			if(arguments.length < 3) {
				switch(prop) {
					case "textContent":
						return dojox.data.dom.textContent(node);
					case "localName":
					case "baseName":
						return node[dojo.isIE ? "baseName" : "localName"];
					default:
						return node[prop];
				}
			}
			else {
				switch(prop) {
					case "textContent":
						dojox.data.dom.textContent(node, value);
						return true;
					default:
						node[prop] = value;
						return true;
				}
			}
		},
		attr: function(/*DOMNode*/ node, /*String*/ attr, /*Object?*/ value) {
			// summary: Gets/sets an attribute on a node.  Acts as a getter if value is 
			//		not specified (undefined) and acts as a setter if value is specified,
			//		even if it is set to null.  As a getter, this returns undefined if
			//		the attribute does not exist on the node instead of returning null
			//		or any empty string.  That way, callers can distinguish between an
			//		attribute's presence and an empty value.
			if(arguments.length < 3) {
				if(!com.ibm.domUtilities.hasAttribute(node, attr, this.namespaces)) return;
				return com.ibm.domUtilities.getAttribute(node, attr, this.namespaces);
			}
			else return com.ibm.domUtilities.setAttribute(node, attr, value, this.namespaces);
		},
		getSelf: function(/*DOMNode*/ node) {
			return node;
		},
		createElement: function(/*DOMDoc*/ doc, /*String*/ tagName, /*Object?*/ attrMap) {
			return com.ibm.domUtilities.createElement(doc, tagName, this.namespaces, attrMap);
		},
		createFromJson: function(/*DOMNode*/ node, /*Object*/ def) {
			return com.ibm.domUtilities.createFromJson(node.ownerDocument, def, this.namespaces, node);
		}
	}
);

(function(){
	var p = com.ibm.xml.SimpleXmlAccessor.prototype;
	p.select = p.evaluate;
})();

}

if(!dojo._hasResource["com.ibm.data.resolver.FaultFactory"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.data.resolver.FaultFactory"] = true;
dojo.provide("com.ibm.data.resolver.FaultFactory");





dojo.declare("com.ibm.data.resolver.FaultFactory",
	null,
	{
		namespaces: {env: "http://www.w3.org/2003/05/soap-envelope"},
		
		selectors: {
			subcode: "/env:Fault/env:Code/env:Subcode/env:Value",
			reason: "/env:Fault/env:Reason/env:Text[" + (dojo.isIE ? "@xml:lang = '${0}'": "lang('${0}')") + "]",
			role: "/env:Fault/env:Role",
			detail: "/env:Fault/env:Detail"
		},
		
		constructor: function() {
			this.engine = new com.ibm.xml.SimpleXmlAccessor({namespaces: this.namespaces});
		},
		
		getFaultError: function(/*String*/xmlStr,/*Error*/ error) {
			// summary: Takes an input xmlStr containing the SOAP Fault document in string format
			//		and a prexisting Error, and returns the same error with its properties
			//		modified appropriately to reflect the Fault document's contents.
			// xmlStr: String representing a SOAP Fault document
			// error: Error object to modify according to the Fault
			var data = com.ibm.domUtilities.docFromString(xmlStr);
			error.name = "Fault - " + this._getRole(data);
			error.number = this._getSubCode(data);
			error.message = this._getReason(data);			
			error.description = this._getDetail(data);
			return error;
		},
		_getSubCode: function(data) {
			return this.engine.select(this.selectors.subcode, data, true).text()[0];
		},
		_getReason: function(data, /*String?*/locale) {
			if(!locale) locale = dojo.locale;
			var query = this.selectors.reason;
			query = dojo.string.substitute(query, [locale]);
			return this.engine.select(query, data, true).text()[0];
		},
		_getRole: function(data) {
			return this.engine.select(this.selectors.role, data, true).text()[0];
		},
		_getDetail: function(data) {
			return this.engine.select(this.selectors.detail, data, true).text()[0];
		},
		toString: function(){
			return this.declaredClass;
		}
	}
);

if(!dojo.isIE) {
	com.ibm.data.resolver.FaultFactory.prototype.namespaces["xml"] = "http://www.w3.org/XML/1998/namespace";
}

}

if(!dojo._hasResource["com.ibm.planner.SimplePOPlan"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.planner.SimplePOPlan"] = true;
/*
 * @author Ben
 */ 
dojo.provide("com.ibm.planner.SimplePOPlan");

// Provides partial-order planning an execution path to achieve
// a desired goal given steps with presteps associated with them.
// This is simple because a real partial-order planner would have
// steps available to it, each with pre-conditions and post-conditions,
// managing the current state of conditions before and after each
// step to reach the desired goal set of conditions.


dojo.declare("com.ibm.planner.SimplePOPlan",
	null,
	{
		constructor: function(/*Array?*/ steps) {
			this.steps = {};
			this.orderedSteps = [];
			this._nctr = Math.floor(Math.random() * 100001);
			if(steps) {
				for(var i=0; i<steps.length; i++) {
					this.insertStep(steps[i]);
				}
			}
			//added by cbh
			this.resursive = 0;
		},
		destroy: function() {
			for(var s in this.steps) {
				this.steps[s].destroy();
			}
			delete this.steps;
			delete this.orderedSteps;
		},
		_genName: function() {
			return "s_" + this._nctr++;
		},
		indexOf: function(/*Step*/ step) {
			return dojo.indexOf(this.orderedSteps, step);
		},
		getStep: function(/*String*/ name) {
			return this.steps[name];
		},
		hasStep: function(/*String*/ name) {
			return !!this.steps[name];
		},
		makeStep: function(/*String*/ name, /*Object*/ contents) {
			var step = new com.ibm.planner.SimplePOStep(name, contents);
			this.insertStep(step);
			return step;
		},
		_insStep: function(/*Step*/ step, /*Map*/ map) {
			//console.log("star:::step.name="+step.name);
			if(!map[step.name]) {
				var insertIdx = 0;
				for(var i=0, pre; pre = step.preSteps[i], i<step.preSteps.length; i++) {
					var pidx;
					//console.log("pre.name="+pre.name+", map[pre.name]="+map[pre.name]);
					if(map[pre.name]) {
						pidx = this.indexOf(pre);
						if(pidx >= insertIdx) insertIdx = pidx + 1;
					}
					else {
						//start[added by cbh]
						//if (step.name === pre.name) {
						//	this.resursive++;
						//	if (this.resursive >= 10) {
						//		this.resursive = 0;
						//		console.log("recursive limited >>>>>>>>>>>>>>>>>");
						//		continue;
						//	}
						//}
						//finish[added by cbh]
						pidx = this._insStep(pre, map);
						if(pidx <= insertIdx) insertIdx++;
						else insertIdx = pidx + 1;
					}
				}
				this.orderedSteps.splice(insertIdx, 0, step);
				map[step.name] = step;
				return insertIdx;
			}
		},
		orderSteps: function() {
			this.orderedSteps = [], map = {};
			for(var name in this.steps) {
				this._insStep(this.steps[name], map);
			}
			return this;
		},
		insertStep: function(/*Step*/ step) {
			if(!step.name) {
				step.name = this._genName();
			}
			if(!this.steps[step.name]) {
				this.steps[step.name] = step;
			}
			return this;
		},
		_reset: function() {
			delete this.groupList;
		},
		replan: function() {
			this._reset();
			this.orderSteps();
			return this;
		},
		_insertIntoGroupList: function(/*Array*/ gList, /*Step*/ step) {
			for(var j=gList.length-1; j>=0; j--) {
				if(!gList[j].hasPreStepOf(step)) {
					if(j > 0) continue;
					else gList[j].addStep(step);
				}
				else if(j < gList.length-1) {
					gList[j+1].addStep(step);
					return;
				}
				else {
					gList.push(new com.ibm.planner.SimplePOStepGroup([step]));
					return;
				}
			}
		},
		size: function() {
			return this.orderedSteps.length;
		},
		getList: function() {
			// summary: Returns an array of steps that satisfy the partial ordering constraints
			//		of the steps in this plan.  It may not be the most optimal ordering, but is
			//		at least consistent in terms of partial ordering.
			return this.orderedSteps;
		},
		filter: function(filterFunc) {
			// summary: Filters the steps in this plan by the filterFunc argument.  Allows a
			//		caller to remove steps from the plan that it knows are irrelevant for its 
			//		needs and allows more efficient processing as well as correct grouping
			//		when creating group lists.
			this.orderedSteps = dojo.filter(this.orderedSteps, filterFunc);
			return this;
		},
		getGroupList: function() {
			// summary: Returns an array of StepGroup objects.  Each group contains steps
			//		which can be (theoretically) executed simultaneously.  The array is
			//		ordered so that all partial ordering constraints are satisfied correctly
			//		but steps that have no ordering constraints between them can be executed
			//		simultaneously.
			// returns: SimplePOStepGroup[] list of grouped steps
			if(!this.groupList) {
				// cache the group list since it can be expensive to create
				var groupList = [], list = this.getList();
				if(list.length>0) groupList.push(new com.ibm.planner.SimplePOStepGroup([list[0]]));
				for(var i=1, st; st=list[i], i<list.length; i++) {
					this._insertIntoGroupList(groupList, st);
				}
				this.groupList = groupList;
			}
			return this.groupList;
		}
	}
);

dojo.declare("com.ibm.planner.SimplePOStep",
	null,
	{
		constructor: function(name, contents) {
			this.name = name;
			this.contents = contents;
			this.preSteps = [];
		},
		destroy: function() {
			delete this.preSteps;
			delete this.contents;
			delete this.name;
		},
		isPreStepOf: function(/*Step*/ step) {
			return step.hasPreStep(this);
		},
		hasPreStep: function(/*Step*/ step) {
			return dojo.indexOf(this.preSteps, step) > -1;
		},
		addPreStep: function(/*Step*/ step) {
			this.preSteps.push(step);
		},
		toString: function() {
			return "<Step '" + this.name + "'>";
		}
	}
);

dojo.declare("com.ibm.planner.SimplePOStepGroup",
	null,
	{
		constructor: function(/*Array?*/ steps) {
			this.steps = steps ? steps.slice() : [];
		},
		destroy: function() {
			delete this.steps;
		},
		getSteps: function() {
			return this.steps;
		},
		addStep: function(/*Step*/ step) {
			this.steps.push(step);
		},
		hasPreStepOf: function(/*Step*/ step) {
			for(var i=0, st; st=this.steps[i], i<this.steps.length; i++) {
				if(st.isPreStepOf(step)) return true;
			}
			return false;
		},
		toString: function() {
			return "<StepGroup (" + this.steps + ")>";
		}
	}
);

}

if(!dojo._hasResource["com.ibm.data.DependencyManager"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.data.DependencyManager"] = true;
/*
 * @author Ben
 */ 
dojo.provide("com.ibm.data.DependencyManager");


/*
 * Provides data store item-dependency management tools for creating, managing, and
 * resolving dependencies between data store items.  For simplicity, this requires the
 * data store to implement the dojo.data.api.Identity API.
 * 
 * This manages *DIRECT* dependencies and should not be used to explicitly create 
 * indirect dependencies through chains.  Indirect, chained dependencies are managed 
 * internally and implicitly, therefore only direct dependencies should be explicitly 
 * added/removed.  Dependencies are unidirectional (one-way) relationships between
 * two items that visually look like one-way directed arrows in a graph between two
 * nodes where the dependent points to the superior.
 * 
 * DO NOT create cyclical dependencies as this will cause infinite recursion problems
 * which are not handled by this module.
 */

dojo.declare("com.ibm.data.DependencyManager",
	null,
	{
		constructor: function(store) {
			this._st = store;
			this._rels = {};
			// Map keyed by dependent ids with arrays whose indexes map to the dependency
			// type.  Each array item is another map of item ids that match the
			// superior in each dependency relationship.
			// {
			//		"sourceId": [
			//			{
			//				"targetId1": 1,
			//				"targetId2": 1
			//			},
			//			{
			//				"targetId1": 1
			//			}
			//		]
			// }

		},
		destroy: function() {
			delete this._st;
			delete this._rels;
		},
		_initItemDep: function(/*String*/ id) {
			var r = this._rels;
			if(!r[id]) {
				r[id] = [{}];
				for(var t in com.ibm.data.DependencyManager.types) {
					r[id].push({});
				}
			}
			return this;
		},
		updateDependencyId: function(/*String*/ oldId, /*String*/ newId) {
			// summary: Updates an id in the dependency map using its oldId
			//		and changing all dependencies in the map to use the newId.
			var r = this._rels;
			// update dependent relationships			
			if(r[oldId]) {
				r[newId] = r[oldId];
				delete r[oldId];
			}
			
			// update superior relationships
			for(var id in r) {
				for(var i = 0, typeR; typeR = r[id],i < r[id].length; i++) {
					if(typeR[oldId]) {
						typeR[newId] = typeR[oldId];
						delete typeR[oldId];
					}
				}
			}
			
			return this;
		},
		getDependencies: function(/*String*/ sourceId) {
			// summary: Returns an array of dependencies that this item has with other
			//		items.
			// sourceId: String id of the dependency source to search for dependencies.
			// returns: Array of dependencies whose indexes refer to the dependency
			//		type and whose objects at those indexes contain a map where the keys
			// 		are the dependency target ids.
			//		IMPORTANT -> DO NOT MODIFY THIS ARRAY!
			this._initItemDep(sourceId);
			return this._rels[sourceId];
		},
		getSourcesByType: function(/*String*/targetId, /*Number*/type) {
			var arr = this.getDependencies(targetId);
			var sources = [];
			if(arr) {
				for(var id in arr[0]) {
					if(arr[0][id][type]) sources.push(id);
				}
			}
			return sources;
		},
		getTargetsByType: function(/*String*/ sourceId, /*Number*/type) {
			// summary: Returns an array of all the targets of a source given a 
			// 		dependency type.
			// returns: Array of superior IDs in a particular dependency type
			type++;
			var arr = this.getDependencies(sourceId);
			var targets = [];
			if(arr) {
				for(var id in arr[type]) {
					targets.push(id);
				}
			}
			return targets;
		},
		addDependency: function(/*String*/ sourceId, /*String*/ targetId, /*Number*/ type) {
			var r = this._rels;
			type++;
			// source -> target
			this._initItemDep(sourceId);
			r[sourceId][type][targetId] = 1;
			
			// target -> source
			this._initItemDep(targetId);
			if(!r[targetId][0][sourceId]) r[targetId][0][sourceId] = [];
			r[targetId][0][sourceId][type - 1] = 1;
			return this;
		},
		removeDependency: function(/*String*/ sourceId, /*String*/ targetId, /*Number*/ type) {
			var r = this._rels;
			type++;
			if(r[sourceId] && r[sourceId][type][targetId]) {
				delete r[sourceId][type][targetId];
			}
			if(r[targetId] && r[targetId][0][sourceId] && r[targetId][0][sourceId][type]) {
				delete r[targetId][0][sourceId][type - 1];
			}
			return this;
		},
		getPlan: function(/*Array*/ items, /*Number*/ type) {
			// summary: Returns a partial-order plan which serializes the ordering of the items argument 
			// 		array for processing in sequences where dependencies are important.
			// 		The plan will also include any items that are not in the items array argument but
			// 		are in the superior chain of items in the arguments array.  Creating this plan can 
			// 		take some time if there are large dependency trees in the current type among the
			//		items in the arguments array.
			var plan = new com.ibm.planner.SimplePOPlan();
			dojo.forEach(items, function(dependentItem){
				this._buildPlan(plan, this._st.getIdentity(dependentItem), type);
			}, this);
			return plan;
		},
		_buildPlan: function(/*POPlan*/ plan, /*String*/ sourceId, /*Number*/ type) {
			if(!plan.hasStep(sourceId)) {
				var thisStep = plan.makeStep(sourceId, null);
				var supList = this.getTargetsByType(sourceId, type);
				for(var i=0; i < supList.length; i++) {
					var preStep = this._buildPlan(plan, supList[i], type);
					if(preStep) thisStep.addPreStep(preStep);
				}
				return thisStep;
			}
			else {
				return plan.getStep(sourceId);
			}
		}
	}
);

// separated "create" and "delete" for performance reasons
// adds a little bit of extra work for consumers, but its well-worth it
com.ibm.data.DependencyManager.types = {
	// create: Ensures that the dependency target is created before the source in any 
	// 		create actions.  Consumers may have to do special processing between 
	// 		create steps if a server-generated ID is used and needs to be mapped onto
	//		the dependent item before creating it on the server (for referential
	//		integrity).
	"create": 0,
	// delete: Ensures that if the dependency source is deleted, the target is too.  
	// 		Consumers may handle this differently depending on their implementation.  
	// 		Example 1: If an IO request is made to delete the source, it is assumed 
	// 		that the server also deletes the target, so the target is simply 
	// 		deleted on the client to synchronize with the server.
	//		Example 2: Each resource needs to be deleted separately, so a separate
	//		request is made to delete a resource once its source is deleted.
	"delete": 1,
	// load: Ensures that when the source loads, the target has loaded as well.
	//		For performance reasons, it is recommended to remove this dependency
	//		once the target has loaded (at any point) since it will no longer
	//		provide any value.  This can be used to keep things that are used 
	//		together loaded together.
	"load": 2,
	// order: Ensures that the target comes before the source in this type of
	// 		relationship when an ordered plan is built.  Keep in mind that if
	//		this creates an explicit dependency, so an ordered plan that potentially
	//		supports grouping will create a separate group for the target and source
	//		in these types of relationships when groups are formed because of this
	//		dependency.
	"order": 3
};

}

if(!dojo._hasResource["com.ibm.data.Resolver"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.data.Resolver"] = true;
/*
 * @author Ben
 */ 
dojo.provide("com.ibm.data.Resolver");

//







(function(){	
	var rzHandlers = {};
	
	com.ibm.data.Resolver = {
		register: function(prefix, cntr) {
			if(!rzHandlers[prefix]) rzHandlers[prefix] = cntr;
		},
		getHandler: function(prefix) {
			return rzHandlers[prefix];
		},
		getStore: function(args) {
			// TODO: Should this factory function return singletons or new objects
			return new com.ibm.data.ResolverStore(args);
		},
		_flagDigestUpdate: function() {
			dojo.cookie( "DigestTracker", (new Date()).getTime(), {path: "/"} );
		},
		TOPICS: {
			UpdateDigest: "/resolver/UpdateDigest"
		}
	}
	
	dojo.subscribe(com.ibm.data.Resolver.TOPICS.UpdateDigest, com.ibm.data.Resolver._flagDigestUpdate);
})();



dojo.declare("com.ibm.data.ResolverStore",
	null,
	{
		// tunnel: Boolean flag indicating whether PUT and DELETE requests should
		//		be tunneled through POST requests
		tunnel: false,
		
		
		// states: Object map of possible states that items in this store can have.  These are
		//		not mutually exlusive and do not follow a finite state machine pattern since
		//		items have multiple states simultaneously.
		states: {
			"new": 0,			// new and not yet created on the server
			"dirty": 1,			// update to an existing item that hasn't been saved yet
			"deletedExpl": 2,	// explicitly deleted
			"deletedImpl": 3,	// implicitly deleted by means of dependency relationship
			"deleted": 4,		// deleted
			"loaded": 5,		// has been loaded
			"saving": 6			// has already been processed and queued for saving, yet not completed yet
		},
		
		_features: {
			'dojo.data.api.Read': true,
			'dojo.data.api.Write': true,
			'dojo.data.api.Identity': true,
			'dojo.data.api.Notification': true,
			'com.ibm.data.api.ServerGenerated': true
		},
		
		namespaces: {},
		
		headers: {
			"DIGEST": "X-Request-Digest",
			"STATUS": "X-Status-Code",
			"URI": "Content-ID",
			"CONTENT_TYPE": "Content-Type",
			"METHOD": "X-Method-Override",
			"AUTH_OVERRIDE": "X-IBM-XHR"
		},
		
		_digest: "",
		url: "",
		
		saveWait: 1,
		
		constructor: function(args) {
			dojo.mixin(this, args);
			this._handlers = {};
			this._cachedItems = {};
			this._itemLoaders = {};
			this._cidMap = {};
			this._ioOutQueue = this._getDeferredQueue(new dojo.Deferred()).fire();
			this._laundryQueue = [];
			this._cidCntr = Math.floor(Math.random() * 10000001);
			this._etagMap = {};
			this._notifyOn = true;
			
			this.multiPart = true;
			this.multiPartUrl = this.url + "?uri=mashup:multiplex";
			
			this._auth = dojo.getObject("com.ibm.ajax.auth");
			this._depMgr = new com.ibm.data.DependencyManager(this);
			this._messages = dojo.i18n.getLocalization("com.ibm.bundles", "Resolver");
			this._faultFactory = new com.ibm.data.resolver.FaultFactory();
			// will we need this AdapterRegistry someday???
			// right now, we always know our argument type, but we may not always
			/*
			var reg = this._handlerReg = new dojo.AdapterRegistry(false);
			reg.register("strMatch", 
				dojo.isString, 
				dojo.hitch(this, function(str){
					if(str.indexOf(":") > 0) {
						return this._getHandlerByUri(str);
					}
					else {
						return this._getHandlerByPocType(str);
					}
				})
			);
			reg.register("itemMatch", 
				dojo.hitch(this, this._isItem), 
				dojo.hitch(this, this._getHandlerByItem)
			);
			*/
			
			dojo.addOnWindowUnload(dojo.hitch(this, function(){
				this.destroy();
			}));
		},
		destroy: function() {
			for(var id in this._cachedItems) {
				var item = this._cachedItems[id];
				try {
					if(this._isItem(item)) this._getHandlerByItem(item).uninitialize(item);
					for(var p in item) {
						delete item[p];
					}
				} 
				catch(err) {}
			}
			delete this._cachedItems;
			for(var scheme in this._handlers) {
				var h = this._getHandlerByPocType(scheme);
				h.destroy();
				delete h._$; 
			}
			delete this._handlers;
			delete this._itemLoaders;
			this._depMgr.destroy();
			delete this._depMgr;
			delete this._ioOutQueue;
			delete this._laundryQueue;
			delete this._messages;
		},
		getNamespaces: function() {
			return this.namespaces;
		},
		applyHandlerStrategy: function(/*String*/ scheme, /*Strategy*/ strategy) {
			var h = this._getHandlerByPocType(scheme);
			return com.ibm.strategy.Strategy.applyStrategy(h, strategy);
		},
		unapplyHandlerStrategy: function(/* Advice */ adv) {
			com.ibm.strategy.Strategy.removeStrategy(adv);
		},
		_initStoreMeta: function(/*Item*/ item, /*Object*/ mixin) {
			if(item._$ == null) {
				item._$ = {
					states: [],
					store: this
				};
			}
			item._$ = dojo.mixin(item._$, mixin);
			return item;
		},
		_getDeferredQueue: function(/*Deferred?*/ dfd) {
			var dfdq = new com.ibm.lang.DeferredQueue(dfd);
			dfdq.raiseError = dojo.hitch(this, "raiseError");
			return dfdq;
		},
		_getPocTypeFromUri: function(/*String*/ uri) {
			if(!uri) {
				var err = new Error(this.fmt("errorNoPocHandler", [uri]))
				this.raiseError(err);
				throw err;
			}
			return uri.split(":")[0];
		},
		_getHandlerByPocType: function(/*String*/ prefix) {
			if(!this._handlers[prefix]) {
				var h = com.ibm.data.Resolver.getHandler(prefix);
				if(!h) {
					var err = new Error(this.fmt("errorNoPocHandler", [prefix]));
					this.raiseError(err);
					throw err;
				}
				var inst = new h(this, this._depMgr);
				this._handlers[prefix] = inst;
				inst._$ = {
					stateLists: [[],[],[]]
				};
			}
			return this._handlers[prefix];
		},
		_getHandlerByItem: function(/* item */ item) {
			this._assertItem(item);
			return this._getHandlerByPocType(item._$.pocType);
		},
		_getHandlerByUri: function(/*String*/ uri) {
			return this._getHandlerByPocType(this._getPocTypeFromUri(uri));
		},
		raiseError: function(error) {
			// summary: Raises an error received during some processing related to this store,
			//		by this store, or by one of its subsidiaries.  Calls console.error by default, 
			// 		so connect to it or override it to provide custom implementation.
			// error: Error object to raise.
			console.error(error);
		},
		fmt: function(key, map) {
			return dojo.string.substitute(this._messages[key], map, function(mapValue, mapKey){
				if(mapValue === null) return "null";
				if(mapValue === undefined) return "undefined";
				return mapValue;
			});
		},
		_isItem: function(/*Object*/ something) {
			return something 
				&& something._$
				&& something._$.pocType
				&& something._$.store === this;
		},
		_assertItem: function(/*Object*/ something) {
			// summary: Throws an exception if the argument is not a valid item in this store.
			// something: Object to check to determine if it is an item in this store.
			if(!this._isItem(something)) {
				var err = new Error(this.fmt("errorInvalidItem", [something]));
				this.raiseError(err);
				throw err;
			}
			return true;
		},
		_assertString: function(/*ject*/ something) {
			// summary: Throws an exception if the argument is not a string.
			// something: Object to check to determine if it is a string.
			if(!dojo.isString(something)) {
				var err = new Error(this.fmt("errorInvalidString", [something]));
				this.raiseError(err);
				throw err;
			}
			return true;
		},
		_getDigestFromResponse: function(response, ioArgs) {
			var digest = ioArgs.xhr.getResponseHeader(this.headers.DIGEST);
			if(digest) this._digest = digest;
		},
		_flagDigestUpdate: function() {
			dojo.publish(com.ibm.data.Resolver.TOPICS.UpdateDigest);
		},
		_queryToHeader: function(query) {
			return dojo.objectToQuery(query).replace(/&/mg, "; ");
		},
		_isResponseError: function(partArgs, xhr) {
			var s = xhr.status;
			// 1223 is for MSIE's MSXML "interpretation" of a 204
			if((s >= 200 && s < 300) || s == 302 || s == 1223) {
				return false;
			}
			return true;
		},
		_multiPartContentHandler: function(partArgs, xhr, defaultContentHandler) {
			// summary: Preprocesses multipart part response information, returning an updated response or
			//		the original depending on the required semantics.
			var status = xhr.getResponseHeader(this.headers.STATUS);
			xhr.status  = status ? status - 0 : 200;
			var response = xhr.responseText;
			if(this._isResponseError(partArgs, xhr)) {
				if(xhr.getResponseHeader(this.headers.CONTENT_TYPE) == "application/soap+xml") {
					response = this._faultFactory.getFaultError(response, new Error());
				}
				else response = new Error(response);
			}
			else {
				response = defaultContentHandler(partArgs, xhr);
			}
			return response;
		},
		_io: function(/*Array*/ ioArgsArr, /*Boolean?*/ fetchSiteMap) {
			// summary: Initializes and manages all IO for this store.
			// returns: Object map 
			//		{
			//			start: Function starting the IO this function sets up
			//			deferredList: DeferredList tracking all requests
			//		}
			var multiPartsArr = [],
				dfdBuilder = null,
				deferredFunc = null;
				
			if(this.multiPart){ 
				dfdBuilder = function(ioArgs) {
					var dfd = new dojo.Deferred();
					
					if(!ioArgs.headers) ioArgs.headers = {};
					ioArgs.headers[this.headers.URI] = ioArgs.query.uri;
					ioArgs.headers[this.headers.METHOD] = ioArgs.method.toUpperCase();
					delete ioArgs.query.uri;
					var query = this._queryToHeader(ioArgs.query);
					if(query.length > 0) ioArgs.headers[this.headers.URI] += "; " + query;
					delete ioArgs.query;
					
					var oldError = ioArgs.error;
					ioArgs.error = function(error, args) {
						try {
							if(oldError) oldError.call(ioArgs, error, args);
						} catch(err){}
					};
					
					var oldHandle = ioArgs.handle;
					ioArgs.handle = function(response, args) {
						try {
							if(oldHandle) oldHandle.call(ioArgs, response, args);
						} catch(err){}
						if(response instanceof Error) {
							dfd.errback(response);
						}
						else dfd.callback(response);
					};
					multiPartsArr.push(ioArgs);
					
					return dfd;
				};
				
				deferredFunc = dojo.hitch(this, function() {
					var hdrs = {}; hdrs[this.headers.AUTH_OVERRIDE] = "true";
					var mPartDfd = com.ibm.utilities.multiPartXhr("POST", {
						headers: hdrs,
						url: this.multiPartUrl,
						partContentHandler: dojo.hitch(this, "_multiPartContentHandler"),
						preHandle: dojo.hitch(this, function(response, args){
							if(!this._authHandler(response, args)) return;
							this._getDigestFromResponse(response, args);
						})
					}, multiPartsArr);
				});
			}
			else {
				var ioChain = [];
				dfdBuilder = function(ioArgs) {
					ioArgs.url = this.url + "?" + dojo.objectToQuery(ioArgs.query);
					delete ioArgs.query;
					
					ioArgs.method = ioArgs.method.toLowerCase();
					if(ioArgs.method == "put" || ioArgs.method == "post") {
						ioArgs[ioArgs.method + "Data"] = ioArgs.data;
					}
                    if(!ioArgs.headers) ioArgs.headers = {};
                    ioArgs.headers[this.headers.AUTH_OVERRIDE] = "true";
					if(this.tunnel && ioArgs.method != "post" && ioArgs.method != "get") {
						ioArgs.headers[this.headers.METHOD] = ioArgs.method.toUpperCase();
						ioArgs.method  = "post";
					}
                    var oldHandle = ioArgs.handle;
                    ioArgs.handle = dojo.hitch(this, function(response, args) {
                    	if(!this._authHandler(response, args)) return;
						if(oldHandle) oldHandle.call(args, response, args);
					});
					var oldLoad = ioArgs.load;
					ioArgs.load = dojo.hitch(this, function(response, args) {
						this._getDigestFromResponse(response, args);
						if(oldLoad) oldLoad.call(args, response, args);
					});
					
					var ioDef = new dojo.Deferred();
					ioChain.push(function(){
						return dojo.xhr(ioArgs.method, ioArgs, true).addCallbacks(function(resp){
							return ioDef.callback(resp);
						}, function(err){
							return ioDef.errback(err);
						});
					});
					return ioDef;
				};
				
				deferredFunc = function() {
					dojo.forEach(ioChain, function(ioFunc){
						ioFunc();
					});
				}
			}
		
			var dfds = dojo.map(ioArgsArr, dfdBuilder, this),
				dfdl = new dojo.DeferredList(dfds);
				
			dfdl.addCallback(function(resultArr){
				return dojo.map(resultArr, function(res){
					return res[1];
				});
			});
			
			return {
				start: function(res){
					deferredFunc();
					return dfdl;
				},
				deferredList: dfdl
			};
		},
		_authHandler: function(response, args) {
			if(this._auth) {
                if (this._auth.isAuthenticationRequired(response, args)) {
                    this._auth.authenticationHandler();
                    return false;
                }
            }
            return true;
		},
		_ioOut: function(/*Array*/ ioArgsArr) {
			// summary: Internal function managing IO requests to push data to the server.
			//	Manages all IO transports for this data store, providing multiplexing
			//		of IO requests into complicated chains of potentially multipart requests
			//		for performance enhancements.  Ensures data dependencies between items
			//		are enforced and managed appropriately.  When this is called, it immediately
			//		sends the IO request, returning the Deferred which will be fired upon
			//		IO completion.
			if(!ioArgsArr || ioArgsArr.length == 0) {
				var retDfd = new dojo.Deferred();
				retDfd.callback([]);
				return retDfd;
			}
			var ioObj = this._io(ioArgsArr);
			this._flagDigestUpdate();
			return ioObj.start();				// initialize IO	
		},
		_ioIn: function(/*Array*/ ioArgsArr) {
			// summary: Internal function managing IO requests to get data from the server.
			//		Manages all IO transports for this data store, providing multiplexing
			//		of IO requests into complicated chains of potentially multipart requests
			//		for performance enhancements.
			return (new dojo.DeferredList(dojo.map(ioArgsArr, function(ioArgs){
				/*
				if(this._etagMap[ioArgs.url]) {
					if(!ioArgs.headers) ioArgs.headers = {};
					ioArgs.headers["If-None-Match"] = this._etagMap[ioArgs.url];
				}
				
				ioArgs._oldHandle = ioArgs.handle;
				ioArgs.handle = dojo.hitch(this, function(response, ioArgs) {
					this._etagMap[ioArgs.url] = ioArgs.xhr.getResponseHeader("etag");
					if(ioArgs._oldHandle) return ioArgs._oldHandle(response, ioArgs);
				});
				*/
                var oldHandle = ioArgs.handle;
                ioArgs.handle = dojo.hitch(this, function(response, args) {
					if(!this._authHandler(response, args)) return;
					if(oldHandle) oldHandle.call(args, response, args);
				});
				return dojo.xhrGet(ioArgs);
			}, this))).addCallback(function(resultArr){
				return dojo.map(resultArr, function(res){
					return res[1];
				})
			});
		},
		_fromCache: function(id) {
			return this._cachedItems[id];
		},
		_toCache: function(id, item) {
			this._cachedItems[id] = item;
		},
		
		/********************************/
		/**                            **/
		/**                            **/
		/**     dojo.data.api.Read     **/
		/**                            **/
		/**                            **/
		/********************************/
		getValue: function(	/* item */ item, 
							/* attribute-name-string */ attribute, 
							/* value? */ defaultValue){
			this._assertString(attribute);
			return this._getHandlerByItem(item).getValue(item, attribute, defaultValue);
		},
		getValues: function(/* item */ item,
							/* attribute-name-string */ attribute){
			this._assertString(attribute);
			return this._getHandlerByItem(item).getValues(item, attribute);
		},
		getAttributes: function(/* item */ item){
			return this._getHandlerByItem(item).getAttributes(item);
		},
		hasAttribute: function(	/* item */ item,
								/* attribute-name-string */ attribute){
			this._assertString(attribute);
			return this._getHandlerByItem(item).hasAttribute(item, attribute);
		},
		containsValue: function(/* item */ item,
								/* attribute-name-string */ attribute, 
								/* anything */ value){
			this._assertString(attribute);
			return this._getHandlerByItem(item).containsValue(item, attribute, value);
		},
		isItem: function(/* anything */ something){
			return this._isItem(something)
				&& !this._hasState(something, this.states["deleted"]);
		},
		isItemLoaded: function(/* anything */ something) {
			return this.isItem(something) && this._hasState(something, this.states["loaded"]);
		},
		loadItem: function(/* object */ keywordArgs){
			var it = keywordArgs.item;
			if(this.isItemLoaded(it)) {
				return;
			}
			var ldr = this._getItemLoader(it);
			if(keywordArgs.onItem) ldr.addOnLoad(dojo.hitch(keywordArgs.scope, keywordArgs.onItem));
			if(keywordArgs.onError) ldr.addOnError(dojo.hitch(keywordArgs.scope, keywordArgs.onError));
		},
		fetch: function( keywordArgs ) {
			//    summary:
	        //        Given a query and set of defined options, such as a start and count of items to return,
	        //        this method executes the query and makes the results available as data items.
	        //        The format and expectations of stores is that they operate in a generally asynchronous 
	        //        manner, therefore callbacks are always used to return items located by the fetch parameters.
	        //
	        //    description:
	        //        A Request object will always be returned and is returned immediately.
	        //        The basic request is nothing more than the keyword args passed to fetch and 
	        //        an additional function attached, abort().  The returned request object may then be used 
	        //        to cancel a fetch.  All data items returns are passed through the callbacks defined in the 
	        //        fetch parameters and are not present on the 'request' object.
	        //
	        //        This does not mean that custom stores can not add methods and properties to the request object
	        //        returned, only that the API does not require it.  For more info about the Request API, 
	        //        see dojo.data.api.Request
	        //
	        //    keywordArgs:
	        //        The keywordArgs parameter may either be an instance of 
	        //        conforming to dojo.data.api.Request or may be a simple anonymous object
	        //        that may contain any of the following:
	        //        { 
	        //            query: query-string or query-object,
	        //            queryOptions: object,
	        //            onBegin: Function,
	        //            onItem: Function,
	        //            onComplete: Function,
	        //            onError: Function,
	        //            scope: object,
	        //            start: int
	        //            count: int
	        //            sort: array
	        //        }
	        //        All implementations should accept keywordArgs objects with any of
	        //        the 9 standard properties: query, onBegin, onItem, onComplete, onError 
	        //        scope, sort, start, and count.  Some implementations may accept additional 
	        //        properties in the keywordArgs object as valid parameters, such as 
	        //        {includeOutliers:true}.         
	        //
			//	The *query* parameter.
			//        The query may be optional in some data store implementations.
			//        The dojo.data.api.Read API does not specify the syntax or semantics
			//        of the query itself -- each different data store implementation
			//        may have its own notion of what a query should look like.
			//        However, as of dojo 0.9, 1.0, and 1.1, all the provided datastores in dojo.data
			//        and dojox.data support an object structure query, where the object is a set of 
			//        name/value parameters such as { attrFoo: valueBar, attrFoo1: valueBar1}.  Most of the
			//        dijit widgets, such as ComboBox assume this to be the case when working with a datastore 
			//        when they dynamically update the query.  Therefore, for maximum compatibility with dijit 
			//        widgets the recommended query parameter is a key/value object.  That does not mean that the
			//        the datastore may not take alternative query forms, such as a simple string, a Date, a number, 
			//        or a mix of such.  Ultimately, The dojo.data.api.Read API is agnostic about what the query 
			//        format.  
			//        Further note:  In general for query objects that accept strings as attribute 
			//        value matches, the store should also support basic filtering capability, such as * 
			//        (match any character) and ? (match single character).  An example query that is a query object
			//        would be like: { attrFoo: "value*"}.  Which generally means match all items where they have 
			//        an attribute named attrFoo, with a value that starts with 'value'.
	        //
	        //    The *queryOptions* parameter
	        //        The queryOptions parameter is an optional parameter used to specify optiosn that may modify
	        //        the query in some fashion, such as doing a case insensitive search, or doing a deep search
	        //        where all items in a hierarchical representation of data are scanned instead of just the root 
	        //        items.  It currently defines two options that all datastores should attempt to honor if possible:
	        //        {
	        //            ignoreCase: boolean, //Whether or not the query should match case sensitively or not.  Default behaviour is false.
	        //            deep: boolean     //Whether or not a fetch should do a deep search of items and all child 
	        //                            //items instead of just root-level items in a datastore.  Default is false.
	        //        }
	        //
	        //    The *onBegin* parameter.
	        //        function(size, request);
	        //        If an onBegin callback function is provided, the callback function
	        //        will be called just once, before the first onItem callback is called.
	        //        The onBegin callback function will be passed two arguments, the
	        //        the total number of items identified and the Request object.  If the total number is
	        //        unknown, then size will be -1.  Note that size is not necessarily the size of the 
	        //        collection of items returned from the query, as the request may have specified to return only a 
	        //        subset of the total set of items through the use of the start and count parameters.
	        //
	        //    The *onItem* parameter.
	        //        function(item, request);
	        //        If an onItem callback function is provided, the callback function
	        //        will be called as each item in the result is received. The callback 
	        //        function will be passed two arguments: the item itself, and the
	        //        Request object.
	        //
	        //    The *onComplete* parameter.
	        //        function(items, request);
	        //
	        //        If an onComplete callback function is provided, the callback function
	        //        will be called just once, after the last onItem callback is called.
	        //        Note that if the onItem callback is not present, then onComplete will be passed
	        //        an array containing all items which matched the query and the request object.  
	        //        If the onItem callback is present, then onComplete is called as: 
	        //        onComplete(null, request).
	        //
	        //    The *onError* parameter.
	        //        function(errorData, request); 
	        //        If an onError callback function is provided, the callback function
	        //        will be called if there is any sort of error while attempting to
	        //        execute the query.
	        //        The onError callback function will be passed two arguments:
	        //        an Error object and the Request object.
	        //
	        //    The *scope* parameter.
	        //        If a scope object is provided, all of the callback functions (onItem, 
	        //        onComplete, onError, etc) will be invoked in the context of the scope
	        //        object.  In the body of the callback function, the value of the "this"
	        //        keyword will be the scope object.   If no scope object is provided,
	        //        the callback functions will be called in the context of dojo.global().  
	        //        For example, onItem.call(scope, item, request) vs. 
	        //        onItem.call(dojo.global(), item, request)
	        //
	        //    The *start* parameter.
	        //        If a start parameter is specified, this is a indication to the datastore to 
	        //        only start returning items once the start number of items have been located and
	        //        skipped.  When this parameter is paired withh 'count', the store should be able
	        //        to page across queries with millions of hits by only returning subsets of the 
	        //        hits for each query
	        //
	        //    The *count* parameter.
	        //        If a count parameter is specified, this is a indication to the datastore to 
	        //        only return up to that many items.  This allows a fetch call that may have 
	        //        millions of item matches to be paired down to something reasonable.  
	        //
	        //    The *sort* parameter.
	        //        If a sort parameter is specified, this is a indication to the datastore to 
	        //        sort the items in some manner before returning the items.  The array is an array of 
	        //        javascript objects that must conform to the following format to be applied to the
	        //        fetching of items:
	        //        {
	        //            attribute: attribute || attribute-name-string,
	        //            descending: true|false;   // Optional.  Default is false.
	        //        }
	        //        Note that when comparing attributes, if an item contains no value for the attribute
	        //        (undefined), then it the default ascending sort logic should push it to the bottom 
	        //        of the list.  In the descending order case, it such items should appear at the top of the list.
	        // 
	        //    returns:
	        //        The fetch() method will return a javascript object conforming to the API
	        //        defined in dojo.data.api.Request.  In general, it will be the keywordArgs
	        //        object returned with the required functions in Request.js attached.
	        //        Its general purpose is to provide a convenient way for a caller to abort an
	        //        ongoing fetch.  
	        // 
	        //        The Request object may also have additional properties when it is returned
	        //        such as request.store property, which is a pointer to the datastore object that 
	        //        fetch() is a method of.
	        //
	        //    exceptions:
	        //        Throws an exception if the query is not valid, or if the query
	        //        is required but was not supplied.
			if(!keywordArgs) keywordArgs = {};
			keywordArgs.aborted = false;
			if(!keywordArgs.scope) keywordArgs.scope = dojo.global;
			if(!keywordArgs.queryOptions) keywordArgs.queryOptions = {};
			var preventCache = keywordArgs.queryOptions.preventCache;
			var url = this._buildUrl(keywordArgs, this.url);
			keywordArgs.url = url;
			
			var pocType = this._getPocTypeFromUri(keywordArgs.query.uri);
			var pocHandler = this._getHandlerByPocType(pocType);
			var cType = pocHandler.definition.handleAs;
			
			var loadHandler = dojo.hitch(this, function(response, ioArgs) {
				try {
					if(keywordArgs.aborted) return;
					if(dojo.isIE && cType == "xml") response = com.ibm.domUtilities.docFromString(response);
					this.processResponse(response, keywordArgs, pocType);
				}
				catch(err) {
					this.raiseError(err);
				}
			});
			var errorHandler = function(error, ioArgs) {
				if(keywordArgs.onError) keywordArgs.onError.call(keywordArgs.scope, error, keywordArgs);
			};
			
			var args = {
				preventCache: preventCache,
				content: {},
				url: url,
				handleAs: "text",
				headers: {"X-IBM-XHR":"true"},
				load: loadHandler,
				error: errorHandler
			}
			
			if(cType) {
				if(!dojo.isIE || cType != "xml") {
					// special handling for "xml" in IE
					args.handleAs = cType;
				}
			}
			
			if(keywordArgs.queryOptions.timeout != null) {
				args.timeout = keywordArgs.queryOptions.timeout;
			}
			else if(this.timeout) {
				args.timeout = this.timeout;
			}
			
			var deferred = null;
			keywordArgs.abort = function() {
				keywordArgs.aborted = true;
				deferred.cancel();
			};
			args = this.modifyRequestArgs(args, keywordArgs);
			
			deferred = this._ioIn([args]);
			//keywordArgs.deferred = deferred;

			this._lastRequest = keywordArgs;
			return keywordArgs;
		},
		modifyRequestArgs: function(ioArgs, request) {
			// summary: Allows modification to request arguments before sending a request
			//		to the server.  Subclasses may override this to modify arguments
			//		like setting headers, manipulating the url, overriding a handleAs argument,
			//		or anything else.  Returns the modified request args.
			// ioArgs: dojo.__XhrArgs request args to be sent to the server
			// request: dojo.data.api.Request object
			// returns: dojo.__XhrArgs modified request arguments
			return ioArgs;
		},
		_queryUrlToObject: function(queryStr) {
			if(!queryStr || queryStr.length == 0) return {};
			var start = queryStr.indexOf("?");
			var str = queryStr;
			if(start > -1 && (start < str.length - 1)) { 
				// extract only the query part of the queryStr URL
				str = queryStr.substring(start + 1);
			}
			return dojo.queryToObject(str);
		},
		_prepareQuery: function(keywordArgs) {
			var q = keywordArgs.query;
			if(!q) q = {};
			else if(dojo.isString(q)) {
				q = this._queryUrlToObject(q);
			}
			keywordArgs.query = this._getHandlerByUri(q.uri).modifyFetchQuery(q);
			if(this._digest && this.url.indexOf(this._digest)) keywordArgs.query.digest = this._digest;
			return this.prepareQuery(keywordArgs);
		},
		prepareQuery: function(keywordArgs) {
			// summary: User overridable function to modify the keywordArgs object
			// 		used to fetch results from the back end after the keywordArgs.query
			//		property has been normalized to an object map but before any other
			//		processing has taken place to build the URL.  This can be used to
			//		extract other parts of the keywordArgs map to add properties to the
			//		query object that are dependent on the back end implementation.  One
			//		example includes extracting the keywordArgs.sort parameters and appending
			//		appropriate properties to the keywordArgs.query property that will end
			//		up being built into the generated URL to the server.
			// returns: Object Modified keywordArgs object.
			return keywordArgs;
		},
		_buildUrl: function(keywordArgs, baseUrl) {
			// summary: Builds a url string from this store's base url and the
			// 		query argument.
			// keywordArgs: Object
			//		A request object map as sent to the fetch function
			// returns: String The constructed url.
			var ret = "";
			var keywordArgs = this._prepareQuery(keywordArgs);
			var queryPart = dojo.objectToQuery(keywordArgs.query);
			if(baseUrl.indexOf("?") > -1) {
				ret = baseUrl + "&" + queryPart; // String
			}
			else ret = baseUrl + "?" + queryPart; // String
			
			return (this.modifyUrl(keywordArgs, ret));
		},
		modifyUrl: function(keywordArgs, url) {
			return url;
		},
		processFetchedItems: function(/*Array*/ items, /*Object*/ meta, /*Request*/ request, /*String*/ pocType, /*Object*/ pocHandler) {
			var preventClientCache = (request.queryOptions && request.queryOptions.preventClientCache);
			var replaceCache = (request.queryOptions && request.queryOptions.replaceCache);
			
			// iterate through the items we just fetched and handle them according to the queryOptions cache parameters
			// and what we already have in the cache
			for(var i = 0; i < items.length; i++) {
				this._initStoreMeta(items[i], {pocType: pocType});
				this._addState(items[i], pocHandler, this.states["loaded"]);
				this._toCache(this.getIdentity(items[i]), items[i]);		
				// any pre-existing item detection should be done by POC Handlers themselves
			}
			
			return items;
		},
		processResponse: function(/*Object*/ data, /*Request*/ request, /*String*/ pocType) {
			// summary: Extension point for descendants or consumers of this store to handle
			//		responses from server requests for data.  Most subclasses can leave this
			// 		function as-is, but if special handling is required that cannot be done
			// 		with other extension points, this can be overridden as well.
			// 		Must call onBegin, onItem, and onComplete callbacks correctly as 
			// 		specified by dojo.data.api.Read.  The onError callback is handled elsewhere.
			// data: Object data of the response from an IO request in the format expected by
			//		the handler.
			// request: Request used to fetch the result
			// pocHandler: Object POC handler to use to process this response data
			if(request.aborted) return;
			var pocHandler = this._getHandlerByPocType(pocType);
			var composite = pocHandler.processFetch(data, request);
			items = this.processFetchedItems(composite.items, composite.meta, request, pocType, pocHandler);
			if(request.onBegin) request.onBegin.call(request.scope, composite.meta.resultSize, request);
			if(request.aborted) return;
			if(request.onItem) {
				for(var i = 0; i < items.length; i++) {
					if(request.aborted) return;
					request.onItem.call(request.scope, items[i], request);
				}
			}
			if(request.aborted) return;
			if(request.onComplete) {
				// call onComplete with items array if onItem wasn't specified, otherwise
				// call it with null
				if(!request.onItem) request.onComplete.call(request.scope, items, request);
				else request.onComplete.call(request.scope, null, request);
			}
		},
		
		getFeatures: function(){
			return this._features;
		},
		close: function(/*dojo.data.api.Request || keywordArgs || null */ request){
			if(request && request.abort) request.abort();
		},
		getLabel: function(/* item */ item){
			return this._getHandlerByItem(item).getLabel(item);
		},
		getLabelAttributes: function(/* item */ item){
			return this._getHandlerByItem(item).getLabelAttributes(item);
		},
		
		/********************************/
		/**                            **/
		/**                            **/
		/**   dojo.data.api.Identity   **/
		/**                            **/
		/**                            **/
		/********************************/	
		getIdentity: function(/* item */ item){
			return this._getHandlerByItem(item).getIdentity(item);
		},
		getIdentityAttributes: function(/* item */ item){
			return this._getHandlerByItem(item).getIdentityAttributes(item);
		},
		fetchItemByIdentity: function(/* object */ keywordArgs){
			var item = this.byId(keywordArgs.identity);
			if(this.isItemLoaded(item)) {
				if(keywordArgs.onItem) {
					keywordArgs.onItem.call(scope ? scope : dojo.global, item);
				}
			}
			else {
				this.loadItem({
					item: item,
					onItem: keywordArgs.onItem,
					onError: keywordArgs.onError,
					scope: keywordArgs.scope
				});
			}
		},
		byId: function(/*String*/ id) {
			var item = this._fromCache(id);
			if(!item) {
				item = this.byCId(id);	// might be a cid...
				if(!item) {
					// create stub
					var type = this._getPocTypeFromUri(id),
						h = this._getHandlerByPocType(type);
					item = h.createStub({id: id});
					this._initStoreMeta(item, {pocType: type});
					this._toCache(id, item);
				}
			}
			return item;
		},
		
		/********************************/
		/**                            **/
		/**                            **/
		/**    dojo.data.api.Write     **/
		/**                            **/
		/**                            **/
		/********************************/
		_createItemFromProps: function(keywordArgs, parentInfo, pocHandler) {
			var pocType = keywordArgs.pocType;
			delete keywordArgs.pocType;
			if(!parentInfo) parentInfo = {};
			
			if(parentInfo.parent && !keywordArgs.parentId) {
				// if the parent id wasn't specified in keywordArgs but we got a parent item in the parentInfo
				// object, set the keywordArgs.parentId prop to the id of the parent item
				keywordArgs.parentId = this.getIdentity(parentInfo.parent);
			}
			else if(!parentInfo.parent && keywordArgs.parentId){
				// get the parent item from either cache or as a stub (which is not loaded)
				parentInfo.parent = this.byId(keywordArgs.parentId);
			}
			
			// set the locale since some templates may need it if it's not already supplied
			if(!keywordArgs.locale) keywordArgs.locale = dojo.locale;
			
			var createdItem = this._initStoreMeta(pocHandler.newItem(keywordArgs, parentInfo), {pocType: pocType});
			this._addState(createdItem, pocHandler, this.states["loaded"]);
			return createdItem;
		},
		
		newItem: function(/* Object? */ keywordArgs, /*Object?*/ parentInfo){
			var h = this._getHandlerByPocType(keywordArgs.pocType);
			var parentItem = parentInfo ? parentInfo.parent : null;
			if(!keywordArgs.id) keywordArgs.id = h.definition.scheme + ":" + this.getUniqueCId();
			var id = keywordArgs.id;
			var item = this._createItemFromProps(keywordArgs, parentInfo, h);
			item._$.onCreateDefQueue = this._getDeferredQueue(new dojo.Deferred());
			this.registerCId(h.getIdentity(item), item);	// in case the handler modified the id
			this._toCache(id, item);
			this._changeState(item, h, this.states["new"]);
			if(this._notifyOn) {
				this.onNew(item, {item: parentItem});
			} // notify new
			return item;
		},
		deleteItem: function(/* item */ item){
			var h = this._getHandlerByItem(item);
			this._changeState(item, h, this.states["deletedExpl"]);
			if(this._notifyOn) {} // notify delete
		},
		_getItemLoader: function(item) {
			var id = this.getIdentity(item);
			if(!this._itemLoaders[id]) {
				this._itemLoaders[id] = (new com.ibm.data.ItemsLoader({
					query: {
						uri: id
					},
					store: this,
					filter: function(itemsArray) {
						return itemsArray[0];	// Item
					}
				})).addOnResult(dojo.hitch(this, function(){
					delete this._itemLoaders[id];
				}));
			}
			return this._itemLoaders[id];
		},
		_setValue: function(/* item */ item, 
							/* string */ attribute,
							/* almost anything */ value,
							/* boolean */ multi){
			this._assertString(attribute);
			if(this._notifyOn) var oldVal = this[multi ? "getValues" : "getValue"](item, attribute);
			var h = this._getHandlerByItem(item);
			if(!this.isItemLoaded(item)) {
				var err = new Error(this.fmt("errorWriteNotLoaded"));
				this.raiseError(err);
				throw err;
			}
			h.backup(item);
			var res = h[multi ? "setValues" : "setValue"](item, attribute, value);
			if(res) {
				this._changeState(item, h, this.states["dirty"]);
				if(this._notifyOn) {} // notify set
			}
			return res;
		},
		setValue: function(	/* item */ item, 
							/* string */ attribute,
							/* almost anything */ value){
			return this._setValue(item, attribute, value, false);
		},	
		setValues: function(/* item */ item,
							/* string */ attribute, 
							/* array */ values){
			return this._setValue(item, attribute, values, true);
		},	
		unsetAttribute: function(	/* item */ item, 
									/* string */ attribute){
			this._assertString(attribute);
			if(this._notifyOn) var oldVal = this.getValue(item, attribute);
			var h = this._getHandlerByItem(item);
			h.backup(item);
			var res = h.unsetAttribute(item, attribute);
			if(res) {
				this._changeState(item, h, this.states["dirty"]);
				if(this._notifyOn) {} // notify unset
			}				
			return res;
		},
		onSaveComplete: function(/*SaveList*/ saveList) {
			// summary: Event fired when a save operation has been completed.
			// saveList: SaveList containing information about each item saved during the last save 
			// 		operation, including the errors during save processing for each item, if any
			//		exist.  Connect to this using dojo.connect to receive notifications about save
			//		operations in this store, but take care to note that the saveList is destroyed
			// 		after this function is called.  It will be available to any connected functions
			// 		but will be unusable afterwards. 
		},
		save: function(/* object */ keywordArgs){
			// summary: Saves all dirty items in this store.
			// keywordArgs: Object map specifying callbacks to the save operation.
			//		{
			//			onComplete: function(saveList){} called when the save operation completes successfully
			//			onError: function(saveList, error){} called when some or all parts of the save operation
			//					failed
			//			scope: Object scope in which to call the callbacks
			//		}
			var clist = this._getUnSavedStateList(this.states["new"]),
				ulist = this._getUnSavedStateList(this.states["dirty"]),
				dlist = this._getUnSavedStateList(this.states["deletedExpl"]);
			var dirtyList = clist.concat(ulist);
			if(!keywordArgs) keywordArgs = {};
			keywordArgs._itemsOfInterest = dirtyList.concat(dlist);	// all items that we're picking up to save right now
			this._queueForLaundry(dirtyList, dlist, keywordArgs);			
		},
		saveItems: function(/*Array*/ items, /*Object*/ keywordArgs) {
			// summary: Incremental store save by saving the dirty items in the items argument array.
			//		If any of the items have dependencies that must be resolved before they can be saved,
			//		these dependencies will be tracked down and resolves, even if that means that other items
			//		not included in this list are saved along with this list.
			// items: Array of items to save
			// keywordArgs: Object map specifying callbacks to the save operation.
			//		{
			//			onComplete: function(saveList){} called when the save operation completes successfully
			//			onError: function(saveList, error){} called when some or all parts of the save operation
			//					failed
			//			scope: Object scope in which to call the callbacks
			//		}
			var dirtyList = [], delList = [];
			dojo.forEach(items, function(item){
				if(this._hasState(item, this.states["saving"])) return;
				if(this._hasState(item, this.states["new"]) ||
					this._hasState(item, this.states["dirty"])) {
					dirtyList.push(item);
				}
				else if(this._hasState(item, this.states["deletedExpl"])) {
					delList.push(item);
				}
			}, this);
			if(!keywordArgs) keywordArgs = {};
			keywordArgs._itemsOfInterest = dojo.isArray(items) ? items.slice() : null;	// all items that were specifically requested to be saved
			this._queueForLaundry(dirtyList, delList, keywordArgs);
		},
		_itemToIOArgs: function(item, saveList){
			var handler = this._getHandlerByItem(item);
			var itemSaveArgs = handler.processSave(item);
			var isCreationStep = this._hasState(item, this.states["new"]);
			
			var oldLoad = itemSaveArgs.load;
			itemSaveArgs.load = dojo.hitch(this, function(data, ioArgs){
				this._removeState(item, handler, this.states["new"]);
				this._removeState(item, handler, this.states["dirty"]);
				if(isCreationStep) this._fireCreated(item);
				if(oldLoad) oldLoad.call(itemSaveArgs, data, ioArgs);
				oldLoad = null;
				return data;
			});
			
			var oldError = itemSaveArgs.error;
			itemSaveArgs.error = dojo.hitch(this, function(err, ioArgs){
				saveList.setError(item, err);
				if(oldError) oldError.call(itemSaveArgs, err, ioArgs);
				oldError = null;
				return err;
			});
			
			var oldHandle = itemSaveArgs.handle;
			itemSaveArgs.handle = dojo.hitch(this, function(data, ioArgs){
				this._removeState(item, handler, this.states["saving"]);
				if(oldHandle) oldHandle.call(itemSaveArgs, data, ioArgs);
				oldHandle = null;
				return data;
			});
			return itemSaveArgs;
		},
		_planStepsMapper: function(step, saveList){
			var item = this.byId(step.name);
			var args = this._itemToIOArgs(item, saveList);
			if(this._hasState(item, this.states["new"])) {
				args.method = "POST";
			}
			else {
				args.method = "PUT";
			}
			return args;
		},
		_filterUnmetDependencies: function(steps, type, saveList) {
			return dojo.filter(steps, function(step){
				var item = this.byId(step.name);
				var targets = this._depMgr.getTargetsByType(step.name, type);
				return dojo.every(targets, function(id){
					var targetItem = this.byId(id);
					if(!this.isCreated(targetItem)) {
						saveList.setError(item, saveList.getError(targetItem));
						this._removeState(item, this._getHandlerByItem(item), this.states["saving"]);
						return false;
					}
					return true;
				}, this);
			}, this);
		},
		_queueForLaundry: function(dirtyList, delList, keywordArgs) {
			if(this._laundryQueue.length == 0) {
				setTimeout(dojo.hitch(this, "_launder"), this.saveWait);
			}
			dojo.forEach([dirtyList, delList], function(list){
				dojo.forEach(list, function(item){
					this._addState(item, this._getHandlerByItem(item), this.states["saving"]);
				}, this);
			}, this);
			this._laundryQueue.push({dirtyList: dirtyList, delList: delList, keywordArgs: keywordArgs});
		},
		_callSaveCallbacks: function(keywordArgsList, saveList) {
			dojo.forEach(keywordArgsList, function(kw){
				var errors = saveList.getErrors(kw._itemsOfInterest), method;
				if(errors.length > 0) {
					method = "onError";
				}
				else {
					method = "onComplete";
				}
				if(kw[method]) {
					try { kw[method].call(kw.scope ? kw.scope : dojo.global, saveList); }
					catch(err) { this.raiseError(err); }
				}
			}, this);
		},
		_launder: function() {
			var dirtyList = [], delList = [], argsList = [], pile;
			var saveList = new com.ibm.data.SaveList({store: this});
			
			while((pile = this._laundryQueue.shift()) != null) {
				dirtyList = dirtyList.concat(pile.dirtyList);
				delList = delList.concat(pile.delList);
				if(pile.keywordArgs) argsList.push(pile.keywordArgs);
			}
			
			var onCompleteQ = this._getDeferredQueue(),
				onErrorQ = this._getDeferredQueue();
			// rework to use keywordArgs._itemsOfInterest when firing callbacks
			dojo.forEach(argsList, function(keywordArgs){
				if(keywordArgs.onComplete) {
					onCompleteQ.add((new dojo.Deferred()).addCallback(
						dojo.hitch(keywordArgs.scope ? keywordArgs.scope : dojo.global, keywordArgs.onComplete, saveList)));
				}
				if(keywordArgs.onError) {
					onErrorQ.add((new dojo.Deferred()).addCallback(
						dojo.hitch(keywordArgs.scope ? keywordArgs.scope : dojo.global, keywordArgs.onError, saveList)));
				}
			}, this);
			
			var laundryPlan = this._depMgr.getPlan(dirtyList, com.ibm.data.DependencyManager.types["create"])
					.orderSteps()
					.filter(dojo.hitch(this, function(step){
						var item = this.byId(step.name)
						ret = this.isDirty(item); // && !this._hasState(item, this.states["saving"]);
						if(ret) {
							saveList.addItem(item);
							//this._addState(item, this._getHandlerByItem(item), this.states["saving"]);
						}
						return ret;	
						// plan includes entire dependency tree
						// only clean the dirty laundry that isn't currently in a pile or in the wash
					})
				),
				piles = laundryPlan.getGroupList();
				
			// order each pile using "order" dependencies
			dojo.forEach(piles, function(pile){
				var map = {};
				var pileItems = dojo.map(pile.steps, function(step){
					var item = this.byId(step.name);
					map[step.name] = item;
					return item;
				}, this);
				
				var pilePlan = this._depMgr.getPlan(pileItems, com.ibm.data.DependencyManager.types["order"])
					.orderSteps()
					.filter(dojo.hitch(this, function(step){
						return map[step.name] != null;
					}));
				
				pile.steps = pilePlan.orderedSteps;
			}, this);
			
			delList = dojo.map(delList, function(item) {
				saveList.addItem(item);
				//this._addState(item, this._getHandlerByItem(item), this.states["saving"]);
				var args = {
					query: {
						uri: this.getIdentity(item),
						rep: "empty"
					},
					method: "DELETE",
					load: dojo.hitch(this, function() {
						var h = this._getHandlerByItem(item);
						dojo.forEach(["dirty", "deletedExpl", "deletedImpl", "deleted", "saving"], function(stStr){
							this._removeState(item, h, this.states[stStr]);
						}, this);
						h.uninitialize(item);
						for(var p in item) {
							delete item[p];
						}
					})
				}
				
				var oldError = args.error;
				args.error = dojo.hitch(this, function(err, ioArgs){
					saveList.setError(item, err);
					if(oldError) oldError.call(args, err, ioArgs);
					oldError = null;
					return err;
				});
				
				return args;
			}, this);

			var currentPile = piles.shift(),
				ioReadyDfd = new dojo.Deferred();
			
			ioReadyDfd.addCallback(dojo.hitch(this, function(){
				var planList;
				if(currentPile != null) {
					planList = dojo.map(currentPile.steps, function(step){
						return this._planStepsMapper(step, saveList);
					}, this);
				}
				else planList = [];
				
				var ioArgsArr = planList.concat(delList);
				
				var washNextPile = dojo.hitch(this, function(res) {
					if((currentPile = piles.shift()) != null) {
						try {
							currentPile.steps = this._filterUnmetDependencies(currentPile.steps, com.ibm.data.DependencyManager.types["create"], saveList);
							ioArgsArr = dojo.map(currentPile.steps, function(step){
								return this._planStepsMapper(step, saveList);
							}, this);
							return this._ioOut(ioArgsArr).addCallback(washNextPile);
						}
						catch(err) {
							this.raiseError(err);
						}
					}
					else {
						var errorList = saveList.getErrors();
						if(errorList.length == 0) {
							onCompleteQ.fire(saveList);
						}
						if(errorList.length > 0) {
							onErrorQ.fire(saveList, new Error());
						}
						this.onSaveComplete(saveList);
						saveList.destroy();
					}
					return res;
				});
				
				return this._ioOut(ioArgsArr).addCallback(washNextPile);
			}));
			
			this._ioOutQueue.add(ioReadyDfd);
		},
		revert: function(){
			for(var pre in this._handlers) {
				this.revertHandler(this._handlers[pre]);
			}
		},
		revertHandler: function(/*String*/ handlerUri) {
			var h = this._handlers[handlerUri];
			if(h) {
				var states = ["dirty", "deletedExpl", "new"];
				dojo.forEach(states, function(state){
					var list = this._getHandlerStateList(h, this.states[state]);
					dojo.forEach(list, function(item){
						this._revertHandlerItem(item, h);
					}, this);
				}, this);
			}
		},
		revertItem: function(/*item*/ item) {
			var h = this._getHandlerByItem(item);
			if(h) {
				this._revertHandlerItem(item, h);
			}
		},
		_revertHandlerItem: function(item, handler) {
			if(this._hasState(item, this.states["new"])) {
				this._removeState(item, handler, this.states["new"]);
				handler.uninitialize(item);
			}
			else {
				this._removeState(item, handler, this.states["dirty"]);
				this._removeState(item, handler, this.states["deletedExpl"]);
				handler.restore(item);
			}
		},
		_changeState: function(/* item */ item, /*object*/ handler, /*Number*/ state ) {
			if(this._hasState(item, state)) return;
			switch(state) {
				case this.states["new"]:
					// create dependencies are managed at save time
					if(this._hasState(item, this.states["dirty"]) || this._hasState(item, this.states["deleted"])) return;	// don't change state
					this._addState(item, handler, state);
					return;
				case this.states["dirty"]:
					if(this._hasState(item, this.states["new"]) || this._hasState(item, this.states["deleted"])) return;	// don't change state
					this._addState(item, handler, state);
					break;
				case this.states["deletedExpl"]:
				case this.states["deletedImpl"]:
					// delete dependencies are managed immediately on the client
					this._addState(item, handler, state);
					state = this.states["deleted"];
				case this.states["deleted"]:
					this._removeState(item, handler, this.states["dirty"]);
					this._removeState(item, handler, this.states["new"]);
					this._addState(item, handler, state);
					var targList = this._depMgr.getTargetsByType(this.getIdentity(item), com.ibm.data.DependencyManager.types["delete"]);
					dojo.forEach(targList, function(targetId){
						var targetItem = this.byId(targetId);
						this._changeState(targetItem, this._getHandlerByItem(targetItem), this.states["deletedImpl"]);
					}, this);
					break;
				case this.states["loaded"]:
				default:
					this._addState(item, handler, state);
			}
		},
		_removeState: function(/* item */ item, /*object*/ handler, /*Number*/ state, /*Boolean?*/ skipList ) {
			if(!this._hasState(item, state)) return;
			delete item._$.states[state];
			if(!skipList) {
				var list = this._getHandlerStateList(handler, state);
				if(list) {
					for(var i = 0; i < list.length; i++) {
						if(list[i] == item) list.splice(i, 1);
						break;
					}
				}
			}
			switch(state) {
				case this.states["deleted"]:
					var targList = this._depMgr.getTargetsByType(this.getIdentity(item), com.ibm.data.DependencyManager.types["delete"]);
					dojo.forEach(targList, function(targetItem){
						this._removeState(targetItem, this._getHandlerByItem(targetItem), this.states["deletedImpl"]);
					}, this);
					break;
				case this.states["deletedImpl"]:
					if(!this._hasState(item, this.states["deletedExpl"])) {
						this._removeState(item, handler, "deleted");
					}
					break;
				case this.states["deletedExpl"]:
					if(!this._hasState(item, this.states["deletedImpl"])) {
						this._removeState(item, handler, "deleted");
					}
					break;
				default:					
			}
		},
		_addState: function(/* item */ item, /*object*/ handler, /*Number*/ state) {
			if(this._hasState(item, state)) return;
			item._$.states[state] = true;
			var list = this._getHandlerStateList(handler, state);
			if(list) list.push(item);
		},
		_hasState: function(/* item */ item, /*String*/ state) {
			if(item._$.states[state]) return true;
			return false;
		},
		_getHandlerStateList: function(/*PocHandler*/ handler, /*Number*/ state) {
			switch(state) {
				case this.states["new"]:
				case this.states["dirty"]:
				case this.states["deletedExpl"]:
					return handler._$.stateLists[state];
					break;
				default: return null;
			}
		},
		_getUnSavedStateList: function(/*Number?*/ state) {
			// summary: Gets an array of items in this store which belong to a given state
			//		that have not already been processed for saving.
			var arr = [];
			for(var scheme in this._handlers) {
				var h = this._handlers[scheme];
				if(state != null) {
					arr = arr.concat(this._getHandlerStateList(h, state));
				}
				else {
					dojo.forEach(["new", "dirty", "deletedExpl"], function(st){
						var list = this._getHandlerStateList(h, this.states[st]);
						// for loop cleans up state lists in case something before hasn't
						for(var i = 0; i < list.length; i++) {
							if(!this._hasState(list[i]), this.states[st]) {
								list.splice(i, 1);
							}
						}
						arr = arr.concat(list);
					}, this);
				}
			}
			return dojo.filter(arr, function(item){
				return !this._hasState(item, this.states["saving"]);
			}, this);
		},
		isDirty: function(/* item? */ item){
			if(item && this._assertItem(item)) {
				return this._hasState(item, this.states["dirty"]) || 
						this._hasState(item, this.states["new"]) ||
						this._hasState(item, this.states["deleted"]);
			}
			else {
				for(var scheme in this._handlers) {
					var h = this._handlers[scheme];
					if(this._getHandlerStateList(h, this.states["dirty"]).length > 0 ||
						this._getHandlerStateList(h, this.states["deleted"]).length > 0 ||
						this._getHandlerStateList(h, this.states["new"]).length > 0) {
						return true;
					}
				}
				return false;
			}
		},
		
		/**************************************/
		/**                                  **/
		/**                                  **/
		/** com.ibm.data.api.ServerGenerated **/
		/**                                  **/
		/**                                  **/
		/**************************************/
		
		isCreated: function(/*item*/ item) {
			// summary: Indicates whether or not the item has been created on the server and
			//		the server-generated values were properly applied to the client-side
			//		object.	NOTE: Any client-side modifications	to the values of an item for 
			// 		which isCreated returns true can potentially modify the server-generated 
			// 		values to be out-of-sync with the server.
			// 		Therefore, it's important to note that isCreated merely indicates whether
			//		or not the client-side item has a server-side resource associated with it,
			// 		and any values that the server generated for the resource (such as a unique
			// 		id) were applied to the client-side item object when it was saved to the server.
			this._assertItem(item);
			return !this._hasState(item, this.states["new"]);
		},
		_fireCreated: function(item) {
			if(item._$.onCreateDefQueue) {
				item._$.onCreateDefQueue.fire(item);
				item._$.onCreateDefQueue.destroy();
				delete item._$.onCreateDefQueue;
			}
		},
		addOnCreate: function(/*Item*/ item, /*Function*/ callback) {
			// summary: Register callback to be called when the given item is created on the server.
			//		If the item is already created, this will call the callback immediately.
			this._assertItem(item);
			if(!item._$.onCreateDefQueue) {
				// doesn't have a queue, meaning this was never created by this store but was
				// loaded from the server
				callback(item);
			}
			else {
				item._$.onCreateDefQueue.add((new dojo.Deferred()).addCallback(callback));
			};
		},
		getUniqueCId: function() {
			return "cid:" + this._cidCntr++;
		},
		registerCId: function(/*String*/ cid, /*item*/ item) {
			this._cidMap[cid] = item;
			item._$.cid = cid;
			this.addOnCreate(item, dojo.hitch(this, function(item){
				//console.info("Resetting CID to real ID for %o", item);
				var id = this.getIdentity(item);
				this._toCache(id, item);
				this._depMgr.updateDependencyId(cid, id);
			}));
		},
		getCId: function(item) {
			this._assertItem(item);
			return item._$.cid;
		},
		byCId: function(/*String*/ cid) {
			return this._cidMap[cid];
		},
		seedStore: function(/* Object */ keywordArgs, /*Object?*/ parentInfo) {
			// summary: Seeds the store with a pre-existing item using the same
			// 		signature as the newItem function, but without instructing
			// 		the store to actually create the item on the server since the
			// 		item already exists.
			// description: This function allows the data store to be seeded
			// 		with items that are already known in detail through some
			// 		other mechanism.  It allows the store to make use of those
			// 		items without having to request them, particularly if their
			// 		data is already known, resulting in better performance and
			// 		a method to bootstrap the store with a set of pre-existing 
			// 		items.
			// keywordArgs:  A javascript object defining the initial content 
			// 		of the item as a set of JavaScript 'property name: value' 
			// 		pairs.
			// parentInfo: An optional javascript object defining what item is 
			// 		the parent of this item (in a hierarchical store.  Not all 
			// 		stores do hierarchical items), and what attribute of that parent 
			// 		to assign the new item to.  If this is present, and the attribute 
			// 		specified is a multi-valued attribute, it will append this item 
			// 		into the array of values for that attribute.  The structure	of 
			// 		the object is as follows:
			//		{
			//			parent: someItem,
			//			attribute: "attribute-name-string"
			//		}
			// returns: Item the generated item in this data store
			if(keywordArgs.id && !keywordArgs.pocType) keywordArgs.pocType = this._getPocTypeFromUri(keywordArgs.id);
			var h = this._getHandlerByPocType(keywordArgs.pocType);
			var item = this._createItemFromProps(keywordArgs, parentInfo, h);
			this._toCache(h.getIdentity(item), item);
			return item;
		},
		
		/********************************/
		/**                            **/
		/**                            **/
		/** dojo.data.api.Notification **/
		/**                            **/
		/**                            **/
		/********************************/
		onDelete: function(/* Item */ deletedItem) {
			// summary: See dojo.data.api.Notification.onDelete()
			return deletedItem;
		},

		onNew: function(/* Item */ newItem, /* Object */ parentInfo) {
			// summary: See dojo.data.api.Notification.onNew()
			return {newItem: newItem, parentInfo: parentInfo};
		},

		onSet: function(/* Item */ item, /*String*/ attribute, /*Object | Array*/ oldValue, /*Object | Array*/ newValue) {
			// summary: See dojo.data.api.Notification.onSet()
			return {item: item, attribute: attribute, oldValue: oldValue, newValue: newValue};
		}
	}
);

dojo.declare("com.ibm.data.SaveList",
	null,
	{
		store: null,
		list: null,
		
		constructor: function(args) {
			this.list = [];
			dojo.mixin(this, args);
		},
		addItem: function(item) {
			var id = this.store.getIdentity(item);
			if(!this.list[id]) {
				var inf = [item, null];
				this.list.push(inf);
				this.list[id] = inf;
			}
		},
		removeItem: function(item) {
			var id = this.store.getIdentity(item);
			if(this.list[id]) {
				delete this.list[id];
				for(var i=0, inf; inf=this.list[i], i<this.list.length; i++) {
					if(this.store.getIdentity(inf[0]) == id) {
						this.list.splice(i, 1);
						return;
					}
				}
			}
		},
		_getInf: function(item) {
			// summary: Finds and returns the information associated with the item 
			// 		argument if	it exists.
			if(this.store.isItem(item)) {
				var id = this.store.getIdentity(item);
				if(this.list[id]) return this.list[id];
				else return this.list[this.store.getCId(item)];
			}
			else {
				// for deleted items that are no longer recognized in
				// the store and may have no information whatsoever left on them
				for(var i=0; i<this.list.length; i++) {
					if(item == this.list[i][0]) return this.list[i];
				}
				return null;
			}
		},
		hasItem: function(item){
			// summary: Returns boolean true/false indicating whether or not
			//		the given item argument exists in this SaveList.
			// item: Item
			return this._getInf(item) != null;
		},
		getData: function(item) {
			// summary: Gets the associated data with the item argument, if it
			//		exists.
			// item: Item
			return this._getInfResource(item, 2);
		},
		setData: function(item, data) {
			// summary: Associates data with the item argument in this SaveList.
			// item: Item
			// data: Anything
			this._setInfResource(item, data, 2);
		},
		getDataSet: function(/*Array?*/ items) {
			return this._getInfSet(items, 2);
		},
		getError: function(item) {
			// summary: Gets an error associated with an item in this SaveList,
			//		returning null if none exists.
			// item: Item
			return this._getInfResource(item, 1);
		},
		setError: function(item, err) {
			// summary: Associates an error with an item in this SaveList for 
			//		later retrieval.
			// item: Item
			// err: Error
			this._setInfResource(item, err, 1);
		},
		getErrors: function(/*Array?*/ items) {
			// summary: Gets an array of errors from this SaveList, if any exist.
			//		Takes an optional argument of an array of items to filter by
			//		so that the errors retrieved are only from among the items
			//		specified in the argument array.  If the argument is null,
			//		this returns all errors that exist in this SaveList.
			return this._getInfSet(items, 1);
		},
		_setInfResource: function(item, res, type) {
			// summary: Associates a resource with the item by its type.
			var inf = this._getInf(item);
			if(inf) inf[type] = res;
		},
		_getInfResource: function(item, type) {
			// summary: Gets a resource associated with the item by its type.
			var inf = this._getInf(item);
			return inf ? inf[type] : null;
		},
		_getInfSet: function(/*Array?*/ items, /*Number*/ type) {
			var set = [], method = (type == 1 ? "getError" : "getData");
			if(items) {
				dojo.forEach(items, function(item){
					var res = this[method](item);
					if(res) set.push(err);
				}, this);
			}
			else {
				dojo.forEach(this.list, function(inf) {
					if(inf[type]) {
						set.push(inf[type]);
					}
				}, this);
			}
			return set;
		},
		destroy: function() {
			// summary: Destroys this SaveList, making it unusable by subsequent callers,
			//		freeing up any memory resources it consumed.
			delete this.list;
			delete this.store;
		}
	}
);

}

if(!dojo._hasResource["com.ibm.query.TypeHandler"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.query.TypeHandler"] = true;
/*
 * @author Ben
 */ 
dojo.provide("com.ibm.query.TypeHandler");


(function(){
	var th = com.ibm.query.TypeHandler;
	var dst = dojo.date.stamp;
	th.types = {
		"Number": {
			to: function(value) {
				return value - 0;
			},
			from: function(value) {
				return value.toString();
			}
		},
		"Date": {
			to: function(value) {
				return dst.fromISOString(value);
			},
			from: function(value) {
				return dst.toISOString(value);
			}
		}
	}
	
	th.toType = function(/*String*/ value, /*String*/ type) {
		if(th.types[type] && dojo.isFunction(th.types[type].to)) {
			return th.types[type].to(value);
		}
		else return value;
	}
	
	th.fromType = function(/*String*/ value, /*String*/ type) {
		if(th.types[type] && dojo.isFunction(th.types[type].from)) {
			return th.types[type].from(value);
		}
		else return value;
	}
})();

}

if(!dojo._hasResource["com.ibm.query.QueryRuleEngine"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.query.QueryRuleEngine"] = true;
/*
 * @author Ben
 */ 
dojo.provide("com.ibm.query.QueryRuleEngine");



// Abstract module for providing support for querying data within other modules.
// Provides default implementations for looking up query rules, parameterizing them,
// and converting to and from arbitrary data types and String values.
// To be useful, this is meant to be extended to provide implementations for the getByRule,
// setByRule, and unsetByRule functions.  The toType and fromType functions provide no
// type-conversions by default and should be extended as well for custom types.




dojo.declare("com.ibm.query.QueryRuleEngine",
	null,
	{
		queryRules: {},
		
		// context: Object
		//		Context in which to run manual getter/setter functions in query rules.  Defaults to this query
		//		engine instance if none is provided.
		context: null,
		
		types: {},
		
		constructor: function(args) {
			this.context = this;
			dojo.mixin(this, args);
		},
		
		isReadOnly: function(/*Object*/ rule) {
			return rule.readOnly;
		},
		toType: function(/*String*/ value, /*String*/ type) {
			// summary: Converts the String value to the given type as specified by the semantics of the
			//		implementation, then returns the converted value.  The type can be anything.
			// value: String original value from the data
			// type: String name of the type to convert the value to
			// returns: Anything converted value
			if(this.types[type]) {
				return this.types[type].to.call(this.context, value);
			}
			else return com.ibm.query.TypeHandler.toType(value);
		},
		fromType: function(/*Anything*/ value, /*String*/ type) {
			// summary: Converts the value from the given type to a String as specified by the semantics 
			// 		of the implementation, then returns the String value.
			// value: Anything typed value
			// type: String name of the type to convert the value from
			// returns: String value
			if(this.types[type]) {
				return this.types[type].from.call(this.context, value);
			}
			else return com.ibm.query.TypeHandler.fromType(value);
		},
		
		isParameterizable: function(/*String*/ key) {
			return key.charAt(key.length - 1) == '$';
		},
		getRulesWithParams: function(/*Object?*/ map) {
			// summary: Returns a map of the rules from another map that are parameterizable.  Takes an
			//		argument map or defaults to using this.queryRules if the argument is null.
			// map: Object map to use to lookup query rules.  If null, this.queryRules is used instead.
			// returns: Object map of rules which can be parameterized.
			var parmRules = {};
			if(!map) map = this.queryRules;
			for(var key in map) {
				if(this.isParameterizable(key)) {
					parmRules[key] = map[key];
				}
			}
			return parmRules;
		},
		
		getQuery: function(/*String*/ queryKey, /*Object?*/map, /*Boolean?*/ multiValued) {
			// summary: Takes a queryKey string to key into the map argument, if provided, or 
			//		this.queryRules if map is null, and then determines if it is a parameterized key 
			// 		indicated by the last character in the key being a '$'.  If it's not a 
			// 		parameterized key, it simply returns the queryRule matching the key without 
			// 		any substitution.  If it is parameterized,	this finds the parameterizable 
			// 		queryRule whose	key also ends with a '$', and parameterizes that query rule it 
			// 		finds with values for the comma-separated parameters found within the square 
			// 		brackets (Ex. '[param0,param1,param2]') part of the queryKey.
			// 		Example - A queryKey of 'localizedName[edward, tj]$' would lookup
			// 			the key 'localizedName$' in this.queryRules.
			// 			The resulting query rule would be used as a template for parameterization.
			//			The parameter values used to parameterize the template would
			//			be ['edward', 'tj'] and would match the ${0} and ${1} parameters
			//			in the query rule respectively.  Each property in the query rule that
			//			is a string is parameterized by the parameter values in the input queryKey
			//			and then the parameterized query rule object is returned.  Note that 
			//			the parameter values are white-space-trimmed on the beginning and end of
			//			the strings.
			//		
			//		These additional properties get set on the returned rule as well (and therefore
			// 		should be considered reserved properties in rule definitions) -
			//			{
			//				ruleKey: String input key with parameters in place
			// 				parameters: Array of parameters found in the input key, or null
			// 					if none existed
			// 				multiValued: Boolean multiValued property as specified by the argument
			//			}
			// queryKey: String key to lookup the query rule and perform any parameterization substitutions
			//		that are valid.  String in one of two forms.
			// 		1) "key" for a non-parameterized key.  MUST NOT end with a '$' character.
			//		2) "key[param0,param1,...]$" for a parameterized key.  MUST end with a '$' character.
			// 			Parameters are extracted out via comma-splitting and returned in an array as 
			// 			strings in the order they appear.  Returns 
			// 			{key: "key$", parameters: ["param0", "param1", ...]}
			// map: Object map to use to lookup query rules.  If null, this.queryRules is used instead.
			// multiValued: Boolean value set on the rule's multiValued property.  Rules and query engines
			//		can use this property to perform queries that generate arrays of results instead of
			//		single values (if the attribute supports that).
			// returns: The query rule specified by this queryKey after all (if any) parameters 
			// 			have been bound to their values as specified by the caller.
			var obj = this.extractKeyParts(queryKey);
			if(!map) map = this.queryRules;
			var rule = map[obj.key];
			
			if(!rule) return rule;
			// if this is not a parameterized map rule, just return the map rule as-is
			if(!obj.parameters) {
				rule.parameters = null;
				rule.ruleKey = obj.key;
				rule.multiValued = !!multiValued;
				return rule;
			}
			
			// otherwise, parameterize the map by using the array of parameters passed into the attribute
			// like this ->  attribute[parm1, parm2, parm3]$
			// parameterized attributes always end with $
			var expRule = {};
			for(var prop in rule) {
				if(dojo.isString(rule[prop])) {
					expRule[prop] = dojo.string.substitute(rule[prop], obj.parameters, function(part){
						return dojo.string.trim(part);
					});
				}
				else {
					expRule[prop] = rule[prop];
				}
			}
			expRule.parameters = obj.parameters;
			expRule.ruleKey = obj.key;
			expRule.multiValued = !!multiValued;
			return expRule;
		},
		extractKeyParts: function( /*String*/ keyInput ) {
			// summary: Expands a keyInput and determines if it is a key to a parameterizable query rule.
			//		If it is, extract the parameters from the argument and return the base key name
			//		used to look up the correct query rule in this object's queryRules without the parameter
			// 		values, and also return the parameters as an array of strings.  
			// 		If the keyInput is not the key of a parameterizable map rule, just return the key and a 
			// 		null parameter array.
			// keyInput: String in one of two forms.
			// 		1) "key" for a non-parameterized key.  Must not end with a '$' character.  Returns
			//			{key: "key", parameters: null}
			//		2) "key[param0,param1,...]$" for a parameterized key.  Parameters are extracted out
			//			and returned in an array as strings in the order they appear.  Returns 
			// 			{key: "key$", parameters: ["param0", "param1", ...]}
			// returns: Object {key: queryKeyWithoutParameters, parameters: arrayOfParameterValues}
			if(this.isParameterizable(keyInput)) {
				var start = keyInput.indexOf('[');
				var end = keyInput.lastIndexOf(']');
				if(start > -1 && end > start) {
					var baseName = keyInput.substring(0, start) + "$";
					var parms = keyInput.substring(start + 1, end).split(',');
					return {key: baseName, parameters: parms};
				}
			}
			return {key: keyInput, parameters: null};
		},
		
		getByRule: function(/*Object*/ data, /*Object*/ rule, /*Boolean?*/ multiValued) {
			return data;
		},
		setByRule: function(/*Object*/ data, /*Object*/ rule, /*Object*/ value, /*Boolean?*/ multiValued) {
			if(this.isReadOnly(rule)) return false;
			return true;
		},
		unsetByRule: function(/*Object*/ data, /*Object*/ rule, /*Boolean?*/ multiValued) {
			if(this.isReadOnly(rule)) return false;
			return true;
		}
	}
);

}

if(!dojo._hasResource["com.ibm.data.resolver.QueryRulePocHandler"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.data.resolver.QueryRulePocHandler"] = true;
/*
 * @author Ben
 */ 
dojo.provide("com.ibm.data.resolver.QueryRulePocHandler");



/* 
 * An abstract module which implements the POC handler's dojo.data APIs using an implementation of
 * the com.ibm.query.QueryRuleEngine module.
 * 
 * Modules should extend this and provide an instance of a query engine that can be used 
 * to query the data they use in their particular format.  Extensions should also provide
 * implementations for functions in this module that are simply stubs.
 */

dojo.declare("com.ibm.data.resolver.QueryRulePocHandler",
	null,
	{
		// definition: Object
		//		Defines this POC handler's capabilities and metadata.  Returned by the define API function.
		definition: {
			scheme: "",
			handleAs: "text",
			features: {}
		},
		
		// queryRules: Object
		//		Qurey rules which map directly to attributes of items from this POC
		//		handler.  Attributes are keys and values correspond to query rules
		//		in the particular format expected by the implementation of the
		//		QueryRuleEngine module that extensions provide.  All functions inside
		// 		query rules which are called by the engine are called in context
		//		of the engine.
		queryRules: {},
		
		// bodyQueryRules: Object
		//		Query rules used to extract meta data from request bodies but are
		//		not attributes on items from this POC handler
		bodyQueryRules: {},
		
		// customAttributes: Object
		// 		Supports custom attributes that this handler supports
		// 		that are not part of the queryRules framework.  When getting
		//		and setting attributes of items in this handler, the handler
		//		first looks up a rule that matches the attribute in the queryRules
		//		map.  If none is found, it then looks for a rule in this
		//		customAttributes map.  If a rule is found in the customAttributes
		//		map, then the rule is parameterized and the parameters are
		//		passed to the appropriate get/set function in the rule.  The
		//		function is called in context of this POC handler.
		// 		Map of keys, which are attribute names, whose corresponding 
		// 		values are objects with two properties like this:
		//		{
		//			// get supports get operations; multiValued indicates if
		// 			// getValues was called 
		//			get: function(item, multiValued, parameters) {},
		//			// set supports set operations; multiValued indicates if
		// 			// setValues was called
		//			set: function(item, value, multiValued, parameters) {}
		//		}
		//		
		customAttributes: {},
		
		// queryEngineClass: String
		//		Fully-qualified name of the javascript object constructor used
		//		to create an instance of a query rule engine used by this POC
		//		handler.
		queryEngineClass: "com.ibm.query.QueryRuleEngine", 
		
		// types: Object
		//		Map used to instantiate the query engine with in order to pass
		//		custom types for conversion to and from Strings during query
		//		rule processing for get and set operations.
		types: {
			"Item": {
				to: function(value) {
					if(value) return this.resolver.byId(value);
					return null;
				},
				from: function(value) {
					if(this.resolver.isItem(value)) {
						return this.resolver.getIdentity(value);
					}
					else return value;
				}
			},
			"decodedURI": {
				to: function(value) {
					// change from encoded string to decoded string
					return decodeURI(value);
				},
				from: function(value) {
					// change from decoded string to encoded string
					return encodeURI(value);
				}
			}
		},
		
		constructor: function(resolverStore, dependencyManager) {
			this.resolver = resolverStore;
			this.depMgr = dependencyManager;
			this.engine = this.buildEngine();
		},
		
		buildEngine: function() {
			// summary: Creates and returns an instance of the query rule engine
			//		used by this POC handler for querying data in items and response
			//		data.  Called by the constructor once during instantiation of
			//		this POC handler.  Can be overridden by extensions to provide
			//		additional parameters to the engine.  For convenience, the engine's
			// 		context is set to this POC handler so that delegated functions that
			// 		the engine calls are called in context of this handler.
			// returns: Object instance of a query rule engine.
			var cls = dojo.getObject(this.queryEngineClass);
			return new cls({queryRules: this.queryRules, types: this.types, resolver: this.resolver, handler: this});
		},
		
		/********************************/
		/**                            **/
		/**                            **/
		/**     dojo.data.api.Read     **/
		/**                            **/
		/**                            **/
		/********************************/
		_getValue: function(	/* item */ item, 
							/* attribute-name-string */ attribute, 
							/* value? */ defaultValue,
							/* Boolean */ multiValued) {
			if(item._unsetAttrs[attribute]) return defaultValue;
			var rule = this.engine.getQuery(attribute, this.customAttributes, multiValued);
			if(rule) {
				return this.customAttributes[attribute].get.call(this, item, multiValued, rule.parameters);
			}
			else if(item.data) {
				rule = this.engine.getQuery(attribute, this.queryRules, multiValued);
				if(!rule) return defaultValue;
				var res = this.engine.getByRule(item.data, rule, multiValued);
				if(!res.found) {
					if(item._backupData) {
						res = this.engine.getByRule(item._backupData, rule, multiValued);
						if(res.found) return res.value;
					}
					return defaultValue;
				}
				return res.value;
			}
			return defaultValue;
		},
		
		getValue: function(	/* item */ item, 
							/* attribute-name-string */ attribute, 
							/* value? */ defaultValue){
			return this._getValue(item, attribute, defaultValue, false);
		},
		getValues: function(/* item */ item,
							/* attribute-name-string */ attribute){
			return this._getValue(item, attribute, [], true);
		},
		getAttributes: function(/* item */ item){
			var attrs = [];
			for(var x in this.queryRules) {
				attrs.push(x);
			}
			for(var y in this.customAttributes) {
				attrs.push(y);
			}
			return attrs;
		},
		hasAttribute: function(	/* item */ item,
								/* attribute-name-string */ attribute){
			if(item._unsetAttrs[attribute]) return false;
			var rule = this.engine.getQuery(attribute, this.queryRules);
			if(!rule) {
				rule = this.engine.getQuery(attribute, this.customAttributes);
				if(rule) {
					return this.customAttributes[attribute].get.call(this, item, false, rule.parameters) !== undefined;
				}
				return false;
			}
			var res = this.engine.getByRule(item.data, rule);
			if(!res.found) {
				return false;
			}
			return true;
		},
		containsValue: function(/* item */ item,
								/* attribute-name-string */ attribute, 
								/* anything */ value){
			return dojo.some(this.getValues(item, attribute), function(val){
				if(val == value) return true;
				return false;
			}, this);
		},
		getLabel: function(/* item */ item){
			var arr = this.getLabelAttributes(item);
			var str = "";
			for(var i=0; i<arr.length; i++) {
				str += this.getValue(item, arr[i]);
			}
			return str;
		},
		getLabelAttributes: function(/* item */ item){
			
		},
		
		/********************************/
		/**                            **/
		/**                            **/
		/**   dojo.data.api.Identity   **/
		/**                            **/
		/**                            **/
		/********************************/	
		getIdentity: function(/* item */ item){
			var arr = this.getIdentityAttributes(item);
			var str = "";
			for(var i=0; i<arr.length; i++) {
				str += this.getValue(item, arr[i]);
			}
			return str;
		},
		getIdentityAttributes: function(/* item */ item){
			
		},
		
		/********************************/
		/**                            **/
		/**                            **/
		/**    dojo.data.api.Write     **/
		/**                            **/
		/**                            **/
		/********************************/
		newItem: function(/* Object? */ keywordArgs, /*Object?*/ parentInfo){
			
		},
		deleteItem: function(/* item */ item){
			
		},
		_setValue: function(	/* item */ item, 
							/* string */ attribute,
							/* almost anything */ value,
							/* Boolean */ multiValued){
			var res = false,
				rule = this.engine.getQuery(attribute, this.customAttributes, multiValued);
			if(rule) {
				res = this.customAttributes[attribute].set.call(this, item, value, multiValued, rule.parameters);
			}
			else if(item.data) {
				rule = this.engine.getQuery(attribute, this.queryRules, multiValued);
				if(!rule) return false;
				res = this.engine.setByRule(item.data, rule, value, multiValued);
			}
			if(res) {
				delete item._unsetAttrs[attribute];
			}
			return res;
		},
		setValue: function(	/* item */ item, 
							/* string */ attribute,
							/* almost anything */ value){
			return this._setValue(item, attribute, value, false);
		},	
		setValues: function(/* item */ item,
							/* string */ attribute, 
							/* array */ values){
			return this._setValue(item, attribute, values, true);
		},	
		unsetAttribute: function(	/* item */ item, 
									/* string */ attribute){
			var rule = this.engine.getQuery(attribute, this.queryRules);
			if(!rule) {
				rule = this.engine.getQuery(attribute, this.customAttributes);
				return false;
			}
			var res = this.engine.unsetByRule(item.data, rule);
			if(res) {
				item._unsetAttrs[attribute] = true;
			}
			return res;
		},
		backup: function(item) {
			// summary: Creates a single backup copy of this item on the client for
			//		later restoration if necessary.  Calling this function multiple
			//		times before _restore() or _persist() is called on this item will do nothing
			//		after the initial backup, effectively maintaining only the first
			//		version of the item before any changes were made.
			//		Override this to actually backup the data.
			if(!item._backupData) {
				
			}
			return false;
		},
		restore: function(item) {
			// summary: Restores the single backup copy of this item on the client,
			//		erasing all modifications made since backup() was called.
			if(item._backupData) {
				
			}
			return false;
		},
		persist: function(item) {
			// summary: Persists the changes made to this item since the backup() was
			// 		called.  After this is called, there is no way to restore the backup
			//		as it is erased completely.
			delete item._backupData;
		},
		modifyFetchQuery: function(query) {
			return query;
		},
		dataToItem: function(/*Object*/ data) {
			var item = this.createStub({});
			item.data = data;
			return item;
		},
		processFetch: function(/*Object*/ data, /*Request*/ request) {
			// return items and metadata about the data (like stuff in the feed, not merely
			//		the entries)
		},
		processSave: function(/*Item*/ item) {
			this.updateReferences(item);
		},
		updateReferences: function(item) {
			// summary: Called by the processSave function immediately before the data for this item is
			//		actually serialized out for the ioArgs.  This allows the POC handler to update any
			//		data in the item that may have changed due to dependencies being resolved.  One example
			//		is when the item references another item that did not have a real id but was using
			//		a client id instead.  At the point when this is called, the referenced item should have
			//		its real id assigned to it but still be accessible by its client id using the resolver's
			//		byId or byCId functions.
		},
		createStub: function(/*Object*/ keywordArgs) {
			return {
				data: keywordArgs.data,
				id: keywordArgs.id,
				_unsetAttrs: {},
				_writeLog: [],
				_cachedMeta: {}	// for caching complex objects
			}
		},
		uninitialize: function(/*Item*/ item) {
			// summary: Uninitializes an item and frees up any memory or listeners this item is holding.
			//		Called on successful delete of an item or on delete of a pending created item.
			delete item.id;
			delete item._unsetAttrs;
			delete item._cachedMeta;
			delete item._backupData;
			delete item._writeLog;
			delete item.data;
		},
		destroy: function() {
			delete this.resolver;
			delete this.depMgr;
			delete this.engine;
		},
		_makeModifiable: function(item) {
			// summary: Modifies the data of this item to become modifiable
			//		for writing back to the server.  Subclasses can override this
			//		to do things like prune an item to only include necessary information
			//		for updates and nothing more.  This is called by backup once after
			//		backing up the original element first.  After this returns,
			//		this item's element may have been modified.  Any queries against
			//		this item should now include logic to check the backup copy as well
			//		if a query doesn't return anything as it could have been deleted by
			//		this function.  Care should be taken to ensure that the query result
			//		specifically detects if nothing was found or if the actual value was
			//		null or empty.
		},
		toString: function() {
			return "[" + this.declaredClass + " - " + this.definition.scheme + "]";
		}
	}
);

}

if(!dojo._hasResource["com.ibm.query.XmlQueryRuleEngine"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.query.XmlQueryRuleEngine"] = true;
/*
 * @author Ben
 */ 
dojo.provide("com.ibm.query.XmlQueryRuleEngine");
// Extension of com.ibm.query.QueryRuleEngine for XML formatted data using native XPath APIs
// for cross-browser, extremely fast queries 






dojo.declare("com.ibm.query.XmlQueryRuleEngine",
	[com.ibm.query.QueryRuleEngine, com.ibm.xml.SimpleXmlAccessor],
	{
		// queryRules: Object map of key-value pairs.  Values are objects which contain these
		//		properties -
		//		{
		// 			selector: String xpath query to retrieve elements only (not attributes)
		// 			field: String specifies what part of the node to retrieve.  
		// 				- "$value"||"value" gets the "value" property of the node
		// 				- "@value" gets the "value" attribute of the node
		// 				- ""||null gets the node itself
		// 			setter: Function called to set the property on the data matching this
		// 				rule whenever the selector returns no nodes.  
		// 				This handles cases when the xpath query itself returns nothing 
		// 				and nodes need to be created first.  If the selector succeeds to begin 
		// 				with, this setter is not called since the value can be set via the field.
		//			unset: String optional indicating what to set on the node to handle an
		//				unset operation.
		//				- ""||null deletes the value matched in the rule field from the node
		//				- "!" deletes the entire node itself
		//			type: String indicating the type of the value that this query rule
		//				matches.  Supports -
		//				"String" - Default
		//				"Number" - value is explicitly converted to a Number on 
		// 					get/set operations
		//				"Node" - value is a DOMNode
		//				"Date" - value is a Javascript Date object.  If the raw data is a String,
		// 					it is converted to/from ISO8601	format or as W3C specifies at
		// 					http://www.w3.org/TR/NOTE-datetime.
		//			readOnly: Boolean indicates if this attribute is read-only or not.  If a write
		//				operation is attempted on a read-only attribute, it fails.
		//			deferMultiValued: Boolean indicating that multi-valued set operations should
		//				always explicitly call the setter function provided by the rule instead 
		//				of attempting to set the multi-valued value on the nodes retrieved via
		//				the selector.
		//			deferSet: Boolean indicating if all write operations should call the setter
		//				function directly instead of attempting to use the selector and field
		// 				properties via the normal query rule processing.
		//		}
		queryRules: {},
		
		getField: function(/*XmlNodeList*/dataSet, /*String*/field, /*Boolean?*/multiValued) {
			var mapper = this._mapField(field),
				fieldName = field.substr(1),
				value = null;
			if(mapper) {
				value = dataSet[mapper](fieldName);
			}
			else {
				value = dataSet;
			}
			if(!multiValued) {
				value = value[0];
			}
			
			return value;
		},
		setField: function(/*XmlNodeList*/dataSet, /*String*/field, /*anything|Array*/value, /*Boolean?*/multiValued) {
			var mapper = this._mapField(field),
				fieldName = field.substr(1);
			
			if(!mapper) {
				mapper = "replace";
			}
			
			value = dataSet[mapper](fieldName, value);
			
			return true;
		},
		unsetField:  function(/*XmlNodeList*/dataSet, /*String*/field, /*String*/unsetField) {
			var mapper = null,
				fieldName = field.substr(1);
			switch(unsetField.charAt(0)) {
				case "!":
					mapper = "remove";
					break;
				default: 
					switch(fieldName.charAt(0)) {
						case "$":
							mapper = "removeProp";
							break;
						case "@":
							mapper = "removeAttr";
							break;
						default:
							mapper = "remove";
							break;
					}
			}
			
			dataSet[mapper](fieldName);
			return true;
		},
		getByRule: function(/*Object*/ data, /*Object*/ rule, /*Boolean?*/ multiValued) {
			var ret = {
				found: false
			};
			var nodeSet = this.select(rule.selector, data, !multiValued);
			if(nodeSet.length == 0) return ret;	// indicating no selector results
			ret.found = true;
			
			var fieldResult = this.getField(nodeSet, rule.field, multiValued);
			if(multiValued) {
				ret.value = dojo.map(fieldResult, function(fRes){
					return this.toType(fRes, rule.type);
				}, this);
			}
			else {
				ret.value = this.toType(fieldResult, rule.type);
			}
			
			if(ret.value === undefined) ret.found = false;	// the field didn't even exist
			
			return ret;
		},
		setByRule: function(/*Object*/ data, /*Object*/ rule, /*anything|Array*/ value, /*Boolean?*/ multiValued) {
			if(this.isReadOnly(rule)) return false;
			if(multiValued) {
				value = dojo.map(value, function(val){
					return this.fromType(val, rule.type);
				}, this);
			}
			else {
				value = this.fromType(value, rule.type);
			}
			if((rule.deferSet || (multiValued && rule.deferMultiValued)) && rule.setter) {
				return rule.setter.call(this.context, data, rule, value, multiValued);
			}
			var nodeSet = this.select(rule.selector, data, !multiValued);
			if(nodeSet.length == 0) {
				if(rule.setter) {
					return rule.setter.call(this.context, data, rule, value, multiValued);
				}
				return false;	// false, indicating set failed
			}
			
			return this.setField(nodeSet, rule.field, value, multiValued);
		},
		unsetByRule: function(/*Object*/ data, /*Object*/ rule) {
			if(this.isReadOnly(rule)) return false;
			var nodeSet = this.select(rule.selector, data, true);
			if(nodeSet.length == 0) return true;	// undefined, indicating was already unset
			
			return this.unsetField(nodeSet, rule.field, rule.unset);
		},
		_mapField: function(field) {
			switch(field.charAt(0)) {
				case "$":
					return "prop";
				case "@":
					return "attr";
				default: 
					return null;
			}
		}
	}
);

}

if(!dojo._hasResource["com.ibm.data.resolver.XmlPocHandler"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.data.resolver.XmlPocHandler"] = true;
/*
 * @author Ben
 */ 
dojo.provide("com.ibm.data.resolver.XmlPocHandler");




dojo.declare("com.ibm.data.resolver.XmlPocHandler",
	[com.ibm.data.resolver.QueryRulePocHandler, com.ibm.data.TemplateInstantiator],
	{
		// definition: Object
		//		Defines this POC handler's capabilities and metadata.  Returned by the define API function.
		definition: {
			scheme: "",
			handleAs: "xml",
			features: {}
		},
		
		namespaces: {},
		
		// queryEngineClass: String
		//		Fully-qualified name of the javascript object constructor used
		//		to create an instance of a query rule engine used by this POC
		//		handler.
		queryEngineClass: "com.ibm.query.XmlQueryRuleEngine", 
		
		constructor: function() {
			this.namespaces = dojo.mixin({}, this.namespaces, this.resolver.getNamespaces());
			this.engine.namespaces = this.namespaces;
			this._createTemplates();
		},
		
		_createTemplates: function() {
			// summary: Creates any XML templates that are used by this handler for generating
			//		data for new or seeded items.
		},
		
		buildEngine: function() {
			// summary: Creates and returns an instance of the query rule engine
			//		used by this POC handler for querying data in items and response
			//		data.  Called by the constructor once during instantiation of
			//		this POC handler.  Can be overridden by extensions to provide
			//		additional parameters to the engine.  For convenience, the engine's
			// 		context is set to this POC handler so that delegated functions that
			// 		the engine calls are called in context of this handler.
			// returns: Object instance of a query rule engine.
			var cls = dojo.getObject(this.queryEngineClass);
			return new cls({queryRules: this.queryRules, types: this.types, namespaces: this.namespaces, resolver: this.resolver, handler: this});
		},
		
		syncNamespaces: function(/*DOMNode*/ node) {
			var myNs = this.namespaces; 
			dojo.forEach(node.ownerDocument.documentElement.attributes, function(attrNode) { 
				var idx = attrNode.nodeName.indexOf("xmlns:"); 
				if(idx == 0) {
					var prefix = attrNode.nodeName.substr(6);
					/*if(myNs[prefix] != attrNode.nodeValue) {
						myNs[prefix] = attrNode.nodeValue;
					}*/
					if(myNs[prefix] != attrNode.value) {
						myNs[prefix] = attrNode.value;
					}
				} 
			});
		},
		
		setValue: function(	/* item */ item, 
							/* string */ attribute,
							/* almost anything */ value){
			var res = this.inherited(arguments);
			if(res) this._logWrite(item, {attribute: attribute, value: value});
			return res;
		},	
		setValues: function(/* item */ item,
							/* string */ attribute, 
							/* array */ values){
			var res = this.inherited(arguments);
			if(res) this._logWrite(item, {attribute: attribute, values: values});
			return res;
		},	
		unsetAttribute: function(	/* item */ item, 
									/* string */ attribute){
			var res = this.inherited(arguments);
			if(res) this._logWrite(item, {attribute: attribute});
			return res;
		},
		
		newItem: function(/* Object? */ keywordArgs, /*Object?*/ parentInfo){
			this.modifyNewItemArgs(keywordArgs, parentInfo);
			return this.createItem(keywordArgs, parentInfo);
		},
		createItem: function(keywordArgs, parentInfo) {
			var existingItem = null;
			if(keywordArgs.id) {
				existingItem = this.resolver._fromCache(keywordArgs.id);
				if(existingItem && existingItem.data) {
					for(var p in keywordArgs) {
						this[dojo.isArray(keywordArgs[p]) ? "setValues" : "setValue"](existingItem, p, keywordArgs[p]);
					}
					return existingItem;
				}
			}
			var template = this.getTemplate(keywordArgs, parentInfo);
			keywordArgs = dojo.mixin({}, template.templateProps, keywordArgs);
			var instTempl = this.instantiateTemplate(template, keywordArgs, parentInfo);
			var itemStub = existingItem ? existingItem : this.createStub(keywordArgs);
			itemStub.data = instTempl;
			return this.fillInProperties(itemStub, template, keywordArgs, parentInfo);
		},
		fillInProperties: function(newItem, template, keywordArgs, parentInfo) {
			for(var p in keywordArgs) {
				if(!(p in template.templateProps)) {
					this[dojo.isArray(keywordArgs[p]) ? "setValues" : "setValue"](newItem, p, keywordArgs[p]);
				}
			}
			return newItem;
		},
		getTemplate: function(args, parentInfo) {
			// summary: Used to retrieve a template string for creating a new item.  
			// 		Can be overrided by subclasses to return the template string to be used
			//		when instantiating a new item based on the arguments.
			// args: Object arguments that are passed into the newItem function for this store
			// parentInfo: Object parentInfo that is passed into the newItem function for this store
			// returns: Object map of two properties defining a template:
			// 		templateString: String template to instantiate with arguments map
			//		templateProps: Object map of properties used in the template along with default values
			return {
				templateString: "",
				templateProps: {}
			};
		},
		modifyNewItemArgs: function(args, parentInfo) {
			return args;
		},
		instantiateTemplate: function(template, args, parentInfo) {
			return this.getTemplateInstance(template.templateString, args);
		},
		backup: function(item) {
			// summary: Creates a single backup copy of this item on the client for
			//		later restoration if necessary.  Calling this function multiple
			//		times before _restore() or _persist() is called on this item will do nothing
			//		after the initial backup, effectively maintaining only the first
			//		version of the item before any changes were made.
			if(!item._backupData) {
				item._backupData = item.data.cloneNode(true);
				this._makeModifiable(item);
				item._logEnabled = true;
				return true;
			}
			return false;
		},
		restore: function(item) {
			// summary: Restores the single backup copy of this item on the client,
			//		erasing all modifications made since backup() was called.
			if(!item._backupData) {
				delete item.data;
				item.data = item._backupData;
				delete item._backupData;
				item._writeLog.splice(0, item._writeLog.length);
				return true;
			}
			return false;
		},
		persist: function(item) {
			// summary: Persists the changes made to this item since the backup() was
			// 		called.  After this is called, there is no way to restore the backup
			//		as it is erased completely.
			this._writeLogToBackup(item);
			this.inherited(arguments);
		},
		processFetch: function(/*DOMDoc*/ xmlDoc, /*Request*/ request) {
			// summary: Extension point for descendants or consumers of this store to handle
			//		responses from server requests for data.  Most subclasses can leave this
			// 		function as-is, but if special handling is required that cannot be done
			// 		with other extension points, this can be overridden as well.
			// 		Must call onBegin, onItem, and onComplete callbacks correctly as 
			// 		specified by dojo.data.api.Read.  The onError callback is handled elsewhere.
			// xmlDoc: DOMDoc of the response from an IO request
			// request: Request used to fetch the result
			return this.inherited(arguments);
		},
		processSave: function(/*Item*/ item) {
			return this.inherited(arguments);
		},
		_logWrite: function(item, map) {
			// summary: Logs write operations to this item so that they can later
			//		be repeated to the backup during persistence.
			if(item._logEnabled) item._writeLog.push(map);
		},
		_writeLogToBackup: function(item) {
			// summary: Repeates the write log for this item to the original backup
			// 		node.  Used mainly for persisting changes to support a 2-phase
			//		write operation (write-commit).
			if(item._backupData) {
				item.data = item._backupData;
				item._logEnabled = false;
				for(var i = 0; i < item._writeLog.length; i++) {
					var op = item._writeLog[i];
					if(op.values) {
						this.setValues(item, op.attribute, op.values);
					}
					else if(op.value !== undefined){
						this.setValue(item, op.attribute, op.value);
					}
					else this.unsetValue(item, op.attribute);
				}
				item._writeLog.splice(0, item._writeLog.length);
			}
		}
	}
);

}

if(!dojo._hasResource["com.ibm.query.rules.Atom"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.query.rules.Atom"] = true;
/*
 * @author Ben
 */ 
dojo.provide("com.ibm.query.rules.Atom");

com.ibm.query.rules.Atom = {
	
	namespaces: {
		//"xml" : "http://www.w3.org/XML/1998/namespace",	// added for non-IE browsers
		"atom" : "http://www.w3.org/2005/Atom",
		"app" : "http://www.w3.org/2007/app"
	},
	
	syndication: {
		mimeTypes: {
			atom: "application/atom+xml"
		},
		common: {
			// rules that apply to atom:feed and atom:entry elements
			title: {selector: "./atom:title", field: "$textContent", setter: 
				function(item, rule, value){
					this.createFromJson(item.element, {
						name: "atom:title",
						children: [value]
					});
					return true;
				}
			},
			id: {selector: "./atom:id", field: "$textContent", setter: 
				function(item, rule, value){
					this.createFromJson(item.element, {
						name: "atom:id",
						children: [value]
					});
					return true;
				}
			},
			updated: {selector: "./atom:updated", field: "$textContent", type: "Date"},
			category: {selector: "./atom:category", field: "@term", setter: 
				function(item, rule, value){
					this.createFromJson(item.element, {
						name: "atom:category",
						attributes: {
							"term": value
						}
					});
					return true;
				}
			},
			categoryScheme: {selector: "./atom:category", field: "@scheme", setter: 
				function(item, rule, value){
					this.createFromJson(item.element, {
						name: "atom:category",
						attributes: {
							"scheme": value
						}
					});
					return true;
				}
			},
			categoryLabel: {selector: "./atom:category", field: "@label", setter: 
				function(item, rule, value){
					this.createFromJson(item.element, {
						name: "atom:category",
						attributes: {
							"label": value
						}
					});
					return true;
				}
			},
			contributer: {selector: "./atom:contributer", type: "Node"},
			author: {selector: "./atom:author", type: "Node"},
			summary: {selector: "./atom:summary", field: "$textContent", setter: 
				function(item, rule, value){
					this.createFromJson(item.element, {
						name: "atom:summary",
						children: [value]
					});
					return true;
				}
			},
			source: {selector: "./atom:source", type: "Node", setter: 
				function(item, rule, value){
					item.element.appendChild(value);
					return true;
				}
			},
			rights: {selector: "./atom:rights", field: "$textContent", setter: 
				function(item, rule, value){
					this.createFromJson(item.element, {
						name: "atom:rights",
						children: [value]
					});
					return true;
				}
			},
			selfLink: {selector: "./atom:link[@rel='self']", field: "@href", setter: 
				function(item, rule, value){
					this.createFromJson(item.element, {
						name: "atom:link",
						attributes: {
							"rel": "self",
							"href": value
						}
					});
					return true;
				}
			},
			link: {selector: "./atom:link[@href]", field: "@href", setter: 
				function(item, rule, value){
					this.createFromJson(item.element, {
						name: "atom:link",
						attributes: {
							"href": value
						}
					});
					return true;
				}
			},
			content: {selector: "./atom:content", type: "Node", setter: 
				function(item, rule, value){
					item.element.appendChild(value);
					return true;
				}
			}
		},
		entry: {
			// the following rules are for atom:entry specific attributes
			subtitle: {selector: "./atom:subtitle", field: "$textContent", setter: 
				function(item, rule, value){
					this.createFromJson(item.element, {
						name: "atom:subtitle",
						children: [value]
					});
					return true;
				}
			},
			generator: {selector: "./atom:generator", field: "$textContent", setter: 
				function(item, rule, value){
					this.createFromJson(item.element, {
						name: "atom:generator",
						children: [value]
					});
					return true;
				}
			},
			icon: {selector: "./atom:icon", field: "$textContent", setter: 
				function(item, rule, value){
					this.createFromJson(item.element, {
						name: "atom:icon",
						children: [value]
					});
					return true;
				}
			},
			logo: {selector: "./atom:logo", field: "$textContent", setter: 
				function(item, rule, value){
					this.createFromJson(item.element, {
						name: "atom:logo",
						children: [value]
					});
					return true;
				}
			}
		}
	},
	
	publishing: {
		mimeTypes: {
			service: "application/atomsvc+xml",
			contentTypeReg: "application/atomcat+xml"
		},
		serviceDoc: {
			workspace: {selector: "./app:workspace", type: "Node"},
			workspaceTitle: {selector: "./app:workspace/atom:title", field: "$textContent"}
		},
		categoriesDoc: {
			category: {selector: "./app:categories/atom:category", type: "Node"},
			categoryTerm: {selector: "./app:categories/atom:category", field: "@term"},
			categoryScheme: {selector: "../app:categories", field: "@scheme"},
			categoriesScheme: {selector: "./app:categories", field: "@scheme"},
			categoriesFixed: {selector: "./app:categories", field: "@fixed"},
			categoriesLink: {selector: "./app:categories", field: "@href"}
		},
		member: {selector: "./app:collection/app:member", type:"Node"}
	}
};

if(!dojo.isIE) {
	com.ibm.query.rules.Atom.namespaces["xml"] = "http://www.w3.org/XML/1998/namespace";
}

}

if(!dojo._hasResource["com.ibm.data.resolver.AtomPocHandler"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.data.resolver.AtomPocHandler"] = true;
/*
 * @author Ben
 */ 
dojo.provide("com.ibm.data.resolver.AtomPocHandler");




dojo.declare("com.ibm.data.resolver.AtomPocHandler",
	com.ibm.data.resolver.XmlPocHandler,
	{
		queryRules: dojo.mixin({}, com.ibm.query.rules.Atom.syndication.common, com.ibm.query.rules.Atom.syndication.entry),
		
		bodyQueryRules: dojo.mixin({}, com.ibm.query.rules.Atom.syndication.common),
				
		namespaces: {
			"atom" : "http://www.w3.org/2005/Atom"
		},
		mergeItems: function(/*Item*/ updateItem, /*Item*/ existingItem) {
			if(this.resolver.isDirty(existingItem)) {
				existingItem._backupData = updateItem.data;
				// if we already modified an item, we've potentially cleaned up
				// much of the data that we either don't want or don't need
				// when writing it, so we don't want to add that back in here,
				// so just update the backup data with the latest results
				/*
				for(var i = 0; i < existingItem._writeLog.length; i++) {
					var op = existingItem._writeLog[i];
					if(op.values) {
						this.setValues(updateItem, op.attribute, op.values);
					}
					else if(op.value !== undefined){
						this.setValue(updateItem, op.attribute, op.value);
					}
					else this.unsetValue(updateItem, op.attribute);
				}
				*/
			}
			else existingItem.data = updateItem.data;
			return existingItem;
		},
		processEntryData: function(entryData) {
			var tempItem = this.dataToItem(entryData);
			var tempItemId = this.getIdentity(tempItem);
			var existingItem = this.resolver._fromCache(tempItemId);
			if(existingItem) {
				tempItem = this.mergeItems(tempItem, existingItem);
			}
			return tempItem;
		},
		parseFeed: function(request, xmlDoc) {
			var items = [], root = null, result = this.engine.select("/atom:feed", xmlDoc, true);
			if(result.length == 0) {
				result = this.engine.select("/atom:entry", xmlDoc);
				if(result.length == 0) {
					// the root is not an atom:feed or atom:entry
					throw new Error(this.resolver.fmt("errorDataFormat"));
				}
				else {
					// the root is an atom:entry element, so there's only one item
					root = result[0];
					items.push(this.processEntryData(root));
				}
			}
			else {
				// the root is an atom:feed element
				root = result[0];
				result = result.select("./atom:entry");
				if(result.length > 0) {
					result.forEach(function(entry){
						items.push(this.processEntryData(entry));
					}, this);
				}
			}
			
			return {items: items, root: root};
		},
		processFetch: function(/*DOMDoc*/ xmlDoc, /*Request*/ request) {
			// summary: Extension point for descendants or consumers of this store to handle
			//		responses from server requests for data.  Most subclasses can leave this
			// 		function as-is, but if special handling is required that cannot be done
			// 		with other extension points, this can be overridden as well.
			// xmlDoc: DOMDoc of the response from an IO request
			// request: Request used to fetch the result
			// returns: Object map with two properties:
			//		items: Array of the items fetched
			//		meta: Object map of meta data associated with the request
			var composite = this.parseFeed(request, xmlDoc),
				meta = {root: composite.root, resultSize: composite.items.length};
			
			if(!this._nsSynced) {
				this.syncNamespaces(composite.root);
				this._nsSynced = true;
			}
			
			dojo.forEach(composite.items, function(item){
				item._cachedMeta.requestMeta = meta;
			}, this);
			
			return {items: composite.items, meta: meta};
		},
		processSave: function(/*Item*/ item) {
			// transform an item of this POC handler into an ioArgs for IO transmission
			this.inherited(arguments);
			var args = {
				data: com.ibm.domUtilities.stringFromDoc(item.data), 
				headers: {},
				handleAs: this.definition.handleAs
			};
			
			args.headers[this.resolver.headers.CONTENT_TYPE] = "application/atom+xml";
			
			if(!this.resolver.isCreated(item)) {
				args.load = dojo.hitch(this, function(response, ioArgs) {
					var entries = this.engine.select("//atom:entry", response);
					var cid = this.getIdentity(item);
					if(entries && entries.length > 0) {
						item.data = entries[0];
						item.cid = item.id;
						delete item.id;
						var genId = this.getIdentity(item);
					}
					return response;
				});
			}
			args.query = this.getSaveQuery(item);
			return args;
		},
		getSaveQuery: function(/*item*/ item) {
			// overwrite this for custom logic
			var q = {
				uri: this.getIdentity(item)
			};
			if(this.resolver.isCreated(item)) {
				// merge updates
				q.mode = "merge";
			}
			return q;
		},
		getLabel: function(/* item */ item){
			return this.getValue(item, "title");
		},
		getLabelAttributes: function(/* item */ item){
			return ["title"];
		},
		
		getIdentity: function(/* item */ item){
			if(!item.id) {
				item.id = this.getValue(item, "id");
			}
			return item.id;
		},
		getIdentityAttributes: function(/* item */ item){
			return ["id"];
		},
		instantiateTemplate: function(template, args, parentInfo) {
			var xmlDoc = this.inherited(arguments);
			var nodes = this.engine.select("//atom:entry", xmlDoc);
			if(nodes && nodes.length > 0) {
				xmlDoc = nodes[0];
			}
			return xmlDoc;
		}
	}
);

}

if(!dojo._hasResource["com.ibm.query.rules.OpenSearch"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.query.rules.OpenSearch"] = true;
/*
 * @author Ben
 */ 
dojo.provide("com.ibm.query.rules.OpenSearch");



com.ibm.query.rules.OpenSearch = {
	
		namespaces: dojo.mixin({}, com.ibm.query.rules.Atom.namespaces, {
			"os" : "http://a9.com/-/spec/opensearch/1.1/"
		}),
		
		common: {
			nextLink: {selector: "./atom:link[@rel='next']", field: "@href"},
			startIndex: {selector: "./os:startIndex", field: "$textContent", type: "Number"},
			itemsPerPage: {selector: "./os:itemsPerPage", field: "$textContent", type: "Number"},
			totalResults: {selector: "./os:totalResults", field: "$textContent", type: "Number"},
			query: {selector: "./os:Query", type: "Node"}
		}
};

}

if(!dojo._hasResource["com.ibm.data.resolver.OpenSearchPocHandler"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.data.resolver.OpenSearchPocHandler"] = true;
/*
 * @author Ben
 */ 
dojo.provide("com.ibm.data.resolver.OpenSearchPocHandler");




dojo.declare("com.ibm.data.resolver.OpenSearchPocHandler",
	com.ibm.data.resolver.AtomPocHandler,
	{
		bodyQueryRules: dojo.mixin({}, 
			com.ibm.data.resolver.AtomPocHandler.prototype.bodyQueryRules, 
			com.ibm.query.rules.OpenSearch.common
		),
		
		namespaces: dojo.mixin({}, 
			com.ibm.data.resolver.AtomPocHandler.prototype.namespaces,
			com.ibm.query.rules.OpenSearch.namespaces),
		
		processFetch: function(/*DOMDoc*/ xmlDoc, /*Request*/ request) {
			// summary: Extension point for descendants or consumers of this store to handle
			//		responses from server requests for data.  Most subclasses can leave this
			// 		function as-is, but if special handling is required that cannot be done
			// 		with other extension points, this can be overridden as well.
			// 		Must call onBegin, onItem, and onComplete callbacks correctly as 
			// 		specified by dojo.data.api.Read.  The onError callback is handled elsewhere.
			// xmlDoc: DOMDoc of the response from an IO request
			// request: Request used to fetch the result
			var composite = this.inherited(arguments);
			composite.meta.resultSize = this.engine.getByRule(composite.meta.root, this.bodyQueryRules["totalResults"]).value;
			composite.meta.nextURL = this.engine.getByRule(composite.meta.root, this.bodyQueryRules["nextLink"]).value;
			composite.meta.startIndex = this.engine.getByRule(composite.meta.root, this.bodyQueryRules["startIndex"]).value;
			composite.meta.itemsPerPage = this.engine.getByRule(composite.meta.root, this.bodyQueryRules["itemsPerPage"]).value;
			return composite;
		}
	}
);

}

if(!dojo._hasResource["com.ibm.data.resolver.ResolverQueryRules"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.data.resolver.ResolverQueryRules"] = true;
/*
 * @author Ben
 */ 
dojo.provide("com.ibm.data.resolver.ResolverQueryRules");




com.ibm.data.resolver.ResolverQueryRules = {
	
	namespaces: dojo.mixin({}, com.ibm.query.rules.OpenSearch.namespaces, {
        "xsl" : "http://www.w3.org/1999/XSL/Transform",
        "thr" : "http://purl.org/syndication/thread/1.0",
        "xhtml" : "http://www.w3.org/1999/xhtml",
        "service": "http://www.ibm.com/xmlns/prod/sw/model/service/1.0",
        "ac": "http://www.ibm.com/xmlns/prod/lotus/access-control/v1.0",
        /*
        "model" : "http://www.ibm.com/xmlns/prod/websphere/portal/v6.0.1/portal-model-elements",
        "base" : "http://www.ibm.com/xmlns/prod/websphere/portal/v6.0/ibm-portal-composite-base",
        "ext" : "http://www.ibm.com/xmlns/prod/websphere/portal/v6.0.1/portal-model",
        "creationcontext" : "http://www.ibm.com/xmlns/prod/websphere/portal/v6.1.0/portal-creationcontext",
        */
        "xsi" : "http://www.w3.org/2001/XMLSchema-instance"
    }),
	
	// atom rules are meant to be used with XML query plugin in conjunction with atom feed data
	atom: {
		modelExt: {
			modelNodeType: {selector: "./atom:content/*", field: "$localName", readOnly: true}
		},
		uniqueNameExt: {
			uniqueName: {selector: "./atom:id[@ext:uniquename]", field: "@ext:uniquename", setter: 
				function(data, rule, value){
					this.createFromJson(data, {
						name: "atom:id",
						attributes: {
							"ext:uniquename": value
						}
					});
					return true;
				}
			}
		},
		threadExt: {
			parent: {selector: "./thr:in-reply-to", field: "@ref", type: "Item"},
			parentId: {selector: "./thr:in-reply-to", field: "@ref"},
			parentURI: {selector: "./thr:in-reply-to", field: "@href"}
		},
		treeExt: {
			// for full tree support, combine this with the threadExt map also
			childrenURI: {selector: "./atom:link[@rel='replies']", field: "@href", readOnly: true},
			next: {selector: "./atom:link[@rel='next']", field: "@ext:uri", type: "Item", unset: "!"},
			nextId: {selector: "./atom:link[@rel='next']", field: "@ext:uri", unset: "!"},
			nextURI: {selector: "./atom:link[@rel='next']", field: "@href", unset: "!"}
		},
		L10nExt: {
			// localizedTitle and localizedDescription are parameterized by language code
			localizedTitle$: {selector: "./atom:content/*[model:title]/model:title/base:nls-string[" + (dojo.isIE ? "@xml:lang = '${0}'": "lang('${0}')") + "]", field: "$textContent", locale: "${0}"},
			localizedDescription$: {selector: "./atom:content/*[model:description]/model:description/base:nls-string[" + (dojo.isIE ? "@xml:lang = '${0}'": "lang('${0}')") + "]", field: "$textContent", locale: "${0}"}
		},
		acExt: {
			userOwned: {selector: "./atom:content/*/ac:allowed-access", field: "@ac:user-owned"},
			accessLevel: {selector: "./atom:content/*/ac:allowed-access/ac:access-level", field: "@ac:type"},
			accessLevel$: {selector: "./atom:content/*/ac:allowed-access/ac:access-level[@ac:type='${0}']", field: "@ac:type", acType: "${0}"}
		},
		operationsExt: {
			contextMenu: {selector: "./atom:link[@ext:rel='contextMenu']", field: "@ext:uri", readOnly: true},
			contextMenuURI: {selector: "./atom:link[@ext:rel='contextMenu']", field: "@href", readOnly: true}
		},
		contentExt: {
			layoutURI: {selector: "./atom:link[@ext:rel='layout']", field: "@href", readOnly: true},
			theme: {selector: "./atom:link[@ext:rel='theme']", field: "@ext:uri", setter: function(data, rule, value) {
				this.createFromJson(data, {
					name: "atom:link",
					attributes: {
						"ext:rel": "theme",
						"ext:uri": value,
						"href": value
					}
				});
				return true;
			}}			
		},
		metaExt: {
			metadata$: {selector: "./atom:content/*/model:metadata[@name='${0}']/base:value", field: "@value", mdname: "${0}", deferSet: true, setter: 
				function(data, rule, value, multiValued){
					var valueDef = {
						name: "base:value",
						attributes: {
							"xsi:type": "base:String"
						}
					};
					
					var modelNode = this.select("./atom:content/*", data, true);
					var metaNode = modelNode.select("model:metadata[@name='" + rule.mdname + "']", true);
					if(metaNode.length == 0) {
						modelNode.createFromJson({
							name: "model:metadata",
							attributes: {
								"name": rule.mdname
							}
						});
					}
					metaNode = modelNode.select("model:metadata[@name='" + rule.mdname + "']", true);
					metaNode.select("*").destroy();	// clear existing values
					if(multiValued) {
						dojo.forEach(value, function(val){
							valueDef.attributes.value = val;
							metaNode.createFromJson(valueDef);
						}, this);
					}
					else {
						valueDef.attributes.value = value;
						metaNode.createFromJson(valueDef);
					}
					
					return true;
				}
			}
		}
	}
};

// minimize code
(function(){
	var atomBase = com.ibm.data.resolver.ResolverQueryRules.atom;
	
	var atomParentSetter = function(data, rule, value, multiValued){
		var nodeSet = this.select(rule.selector, data, false);	// XmlNodeList
		if(nodeSet.length == 0) {
			this.createFromJson(data, {
				name: "thr:in-reply-to",		// change to atom:link style
				attributes: {
					"ext:uri": value,
					"type": "application/atom+xml",
					"ref": value,
					"href": value
				}
			});
		}
		else {
			nodeSet.attr("ext:uri", value).attr("ref", value).attr("href", value);
		}
		return true;
	};
	
	atomBase.threadExt.parent.setter = atomParentSetter;
	atomBase.threadExt.parentId.setter = atomParentSetter;
	atomBase.threadExt.parentURI.setter = atomParentSetter;
	
	atomBase.threadExt.parent.deferSet = true;
	atomBase.threadExt.parentId.deferSet = true;
	atomBase.threadExt.parentURI.deferSet = true;
	
	var atomNextSetter = function(data, rule, value){
		var attrs = {
			"ext:uri": value,
			"rel": "next", 
			"type": "application/atom+xml"
		};
		attrs[rule.field.substr(1)] = value;
		this.createFromJson(data, {
			name: "atom:link",
			attributes: attrs
		});
		return true;
	};
	
	atomBase.treeExt.next.setter = atomNextSetter;
	atomBase.treeExt.nextId.setter = atomNextSetter;
	atomBase.treeExt.nextURI.setter = atomNextSetter;
	
	var atomL10nExtSetter = function(nodeName, data, rule, value){
		var contentNode = this.select("./atom:content/*", data, true);
		var titleNode = contentNode.select("model:title", true);
		var stringNodeDef = {
			name: "base:nls-string",
			attributes: {
				"xml:lang": rule.locale
			},
			children: [value]
		};
		
		if(titleNode.length == 0) {
			contentNode.createFromJson({
				name: nodeName,
				children: [stringNodeDef]
			});
		}
		else {
			titleNode.createFromJson(stringNodeDef);
		}
		return true;
	};
	
	atomBase.L10nExt.localizedTitle$.setter = dojo.partial(atomL10nExtSetter, "model:title");
	atomBase.L10nExt.localizedDescription$.setter = dojo.partial(atomL10nExtSetter, "model:description");
	
}());

}

if(!dojo._hasResource["com.ibm.data.ItemsLoader"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.data.ItemsLoader"] = true;
/*
 * @author Ben
 */ 
dojo.provide("com.ibm.data.ItemsLoader");

dojo.declare("com.ibm.data.ItemsLoader",
	null,
	{
		store: null,
		query: null,
		cacheContext: null,
		cacheProperty: null,
		preload: true,
		fetchOnReload: false,
		resultSet: null,
		
		constructor: function(/*Object*/ args) {
			dojo.mixin(this, args);
			this._lastModified = (new Date()).getTime();
			if(this.preload) setTimeout(dojo.hitch(this, "_load"), 1);
		},
		filter: function(resultSet) {
			// summary: Filters the resultSet that this ItemsLoader loads, passing the filtered
			//		set to each callback.  Note that this function should be idempotent, meaning 
			// 		that it should be able to run multiple times on its own return value without
			//		changing the return value.  In other words, if the filtering function is
			//		executed once and then executed again on its own return value, the return
			//		value of the second execution should be the same as the first.
			return resultSet;
		},
		_getResultSet: function() {
			// gets the stored result set in this items loader;
			// callbacks may modify this object/array, resulting in changes that are reflected
			// in subsequent callbacks; this also filters the resultSet unless it hasn't been 
			// modified since last being filtered
			if(this._lastModified == this.resultSet._lastModified) {
				return this.resultSet;
			}
			else {
				this.resultSet = this.filter(this.resultSet);
				this._lastModified = this.resultSet._lastModified = (new Date()).getTime();
				if(this.cacheContext && this.cacheProperty) {
					this.cacheContext[this.cacheProperty] = this.resultSet;
				}
				return this.resultSet;
			}
		},
		_load: function() {
			if(!this._def) {
				this._def = new dojo.Deferred();
				if(this.cacheContext && this.cacheProperty) {
					this.resultSet = this.cacheContext[this.cacheProperty];
					if(this.resultSet) {
						this.resultSet.loaded = true;
						this._def.callback();
						return this._def;
					}
				}
				this._fetch();
			}
			
			return this._def;
		},
		_fetch: function() {
			this.store.fetch({
				query: this.query,
				onComplete: function(items){
					items.loaded = true;
					this.resultSet = items;
					this._def.callback();
				},
				onError: function(err) {
					this._def.errback(err);
				},
				scope: this
			});
		},
		addOnLoad: function(/*Function*/ callback) {
			this._load().addCallback(this._wrap(callback));
			return this;
		},
		addOnError: function(/*Function*/ callback) {
			this._load().addErrback(this._wrap(callback));
			return this;
		},
		addOnResult: function(/*Function*/ callback) {
			return this.addOnLoad(this._wrap(callback)).addOnError(this._wrap(callback));
		},
		_wrap: function(f) {
			if(f) return dojo.hitch(this, function() {
				try {
					f(this._getResultSet());
				}
				catch(err) {
					this.raiseError(err);
				}
			})
		},
		raiseError: function(err) {
			console.error(err);
		},
		reload: function() {
			// summary: Reloads this loader to retrieve the items again.
			//		If the previous callbacks haven't been called yet as the 
			//		items haven't been loaded, the previous load request
			//		is cancelled and all existing callbacks that were already 
			// 		added earlier are lost and must be added again if desired.
			if(this._def) this._def.cancel();
			delete this._def;
			if(this.fetchOnReload && this.cacheContext && this.cacheProperty) {
				delete this.cacheContext[this.cacheProperty];
			}
			this._load();
			return this;
		}
	}
);

}

if(!dojo._hasResource["com.ibm.data.resolver.strategy.PocHandlerStrategy"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.data.resolver.strategy.PocHandlerStrategy"] = true;
/*
 * @author Ben
 */ 
dojo.provide("com.ibm.data.resolver.strategy.PocHandlerStrategy");



dojo.declare("com.ibm.data.resolver.strategy.PocHandlerStrategy",
	com.ibm.strategy.Strategy,
	{
		// summary: Base strategy implementation for advising POC handlers.
		//		Provides support for using an instance property called "handler"
		//		within this strategy's functions for gaining easy access to the 
		// 		current handler being advised.
		
		// handler: Object POCHandler object which is the currently advised module
		//		in context of the point where this instance property is referenced.
		//		This is set dynamically at each advice wrapper.
		handler: null,
		
		around: function() {
			this.handler = this.getStrategyContext().instance;
			var ret = this.inherited(arguments);
			this.handler = this.getStrategyContext().instance;
			return ret;
		}
	}
);

}

if(!dojo._hasResource["com.ibm.data.resolver.strategy.UpdateStrategy"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.data.resolver.strategy.UpdateStrategy"] = true;
/*
 * @author Ben
 */
dojo.provide("com.ibm.data.resolver.strategy.UpdateStrategy");




dojo.declare("com.ibm.data.resolver.strategy.UpdateStrategy",
	com.ibm.data.resolver.strategy.PocHandlerStrategy,
	{
		// summary: Provides boilerplate strategy for wrapping setValue and setValues calls in 
		// 		POC handlers in order to provide plugins for special logic associated with 
		// 		updates to item data.
		
		extensions: ["setValue", "setValues"],
		
		extensionsMap: {
			"setValue": "_setValue",
			"setValues": "_setValue"
		},
				
		_setValue: function(item, attribute, value) {
			return this.proceed(arguments);
		}
	}
);

}

if(!dojo._hasResource["com.ibm.data.resolver.tree.TreeModeledHandler"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.data.resolver.tree.TreeModeledHandler"] = true;
/*
 * @author Ben
 */ 
dojo.provide("com.ibm.data.resolver.tree.TreeModeledHandler");

// Module for managing tree-modeled data from a particular POC handler.
// Handler implementations can mix this in to get special support for
// tree modeled attributes.  This is written to support extensions of
// the QueryRulePocHandler by default, but in concept can support
// any POC handler which provides a cacheContext on each item and a
// childrenCacheKey.




dojo.declare("com.ibm.data.resolver.tree.TreeModeledHandler",
	null,
	{
		// parentMgmtStrategy: 
		//		com.ibm.strategy.Strategy that manages dependencies between parents
		//		and children operations in the tree model
		parentMgmtStrategy: "com.ibm.data.resolver.tree.ParentDependencyStrategy",
		
		// siblingMgmtStrategy: 
		//		com.ibm.strategy.Strategy that manages dependencies between siblings
		//		in the tree model
		siblingMgmtStrategy: "com.ibm.data.resolver.tree.SiblingDependencyStrategy",
		
		// cacheContext: Property on the item which is used to store cached values
		cacheContext: "_cachedMeta",
		
		// childrenCacheKey: Property on an item's cacheContext which is used to store
		//		the children of that item
		childrenCacheKey: "children",
		
		constructor: function() {
			this.customAttributes = dojo.mixin({}, this.customAttributes, {
				mayHaveChildren: {
					get: function(item, multiValued) {
						var children = item[this.cacheContext][this.childrenCacheKey];
						if(children && children.loaded) return children.length > 0;
						if(item[this.cacheContext].mayHaveChildren == true) return true;
						return this.getValue(item, "childrenURI") != null;
					},
					set: function(item, value, multiValued) {
						// allow store seeding with this attribute
						if(value === 1) item[this.cacheContext].mayHaveChildren = true;
						// can't write to this attribute as it is derived from others
						return false;
					}
				},
				children: {
					get: function(item, multiValued) {
						// returns ItemsLoader
						if(!item._cachedMeta.childrenLoader) {
							var query = this.getChildrenQuery(item);
							
							item._cachedMeta.childrenLoader = new com.ibm.data.ItemsLoader({
								store: this.resolver,
								query: query,
								fetchOnReload: true,
								cacheContext: item[this.cacheContext],
								cacheProperty: this.childrenCacheKey,
								filter: dojo.hitch(this, "filterChildren", item)
							});
						}
						return multiValued ? [item._cachedMeta.childrenLoader] : item._cachedMeta.childrenLoader;
					},
					set: function(item, value, multiValued) {
						if(dojo.isArray(value) && multiValued && value.preloaded) {
							// leverage to preload children... usually not used for normal
							// processing besides seeding the store with items
							item[this.cacheContext][this.childrenCacheKey] = value.slice();
						}
						return false;	// writing to this should never flag the item dirty
					}
				},
				treeModel: {
					get: function(item, multiValued) {
						if(!item._cachedMeta.treeModel) {
							item._cachedMeta.treeModel = new com.ibm.data.resolver.tree.PocTreeModel({
								root: item,
								handler: this,
								resolver: this.resolver
							});
						}
						return multiValued ? [item._cachedMeta.treeModel] : item._cachedMeta.treeModel;
					},
					set: function(item, value, multiValued) {
						// can't write to this attribute
						return false;
					}
				}
			});
			
			
			com.ibm.strategy.Strategy.applyStrategy(this, new (dojo.getObject(this.parentMgmtStrategy))());
			com.ibm.strategy.Strategy.applyStrategy(this, new (dojo.getObject(this.siblingMgmtStrategy))());
			
		},
		
		processFetch: function(/*DOMDoc*/ xmlDoc, /*Request*/ request) {
			// summary: Extension point for descendants or consumers of this store to handle
			//		responses from server requests for data.  Most subclasses can leave this
			// 		function as-is, but if special handling is required that cannot be done
			// 		with other extension points, this can be overridden as well.
			// xmlDoc: DOMDoc of the response from an IO request
			// request: Request used to fetch the result
			// returns: Object map with two properties:
			//		items: Array of the items fetched
			//		meta: Object map of meta data associated with the request
			var map = this.inherited(arguments);
			
			if(request.query.levels > 1 || request.query.levels == "all") {
				var topItem = this.resolver.byId(request.query.uri);
				dojo.forEach(map.items, function(item){
					
				}, this);
			}
			return map;
		},
		
		updateReferences: function(item) {
			// see the QueryRulePocHandler@updateReferences
			this.inherited(arguments);
			var parentId = this.getValue(item, "parentId");
			if(parentId) {
				// get the "real" id of my parent, which at this point should no longer be a cid
				var parentItem = this.resolver.byId(parentId);
				if(parentItem) this.setValue(item, "parentId", this.resolver.getIdentity(parentItem));
			}
		},
		
		modifyChildren: function(children) {
			// summary: Updates the last modified time of the children array so consumers will
			//		know when the children have been updated last.
			children._lastModified = (new Date()).getTime();
		},
		
		getChildrenQuery: function(item) {
			return this.getValue(item, "childrenURI", 
				dojo.objectToQuery({
					uri: this.getIdentity(item),
					levels: 2,
					mode: "download"
				})
			);
		},
		
		filterChildren: function(parentItem, items) {
			var id = this.getIdentity(parentItem);
			items = dojo.filter(items, function(item){
				// only push the results whose parent has the same id as parentItem
				return id == this.resolver.getValue(item, "parentId");
			}, this);
			items.loaded = true;
			return items;
		}
	}
);

dojo.declare("com.ibm.data.resolver.tree.ParentDependencyStrategy",
	com.ibm.data.resolver.strategy.UpdateStrategy,
	{
		extensions: com.ibm.data.resolver.strategy.UpdateStrategy.prototype.extensions.concat(["processFetch", "newItem", "createStub"]),
		
		extensionsMap: dojo.mixin({}, com.ibm.data.resolver.strategy.UpdateStrategy.prototype.extensionsMap, {
			"newItem": "updateNewItem",
			"createStub": "updateNewItem"
		}),
		
		_setValue: function(item, attribute, value) {
			// wraps setValue and setValues... so check both
			var success = false;
			if(attribute == "parent" || attribute == "parentId" || attribute == "parentURI") {
				var multi = this.getStrategyContext().joinPoint.targetName == "setValues";
				var oldValue = this.handler[multi ? "getValues" : "getValue"](item, attribute),
					newValue = value;
				success = this.proceed(arguments);
				if(success) {
					if(multi) {
						oldValue = oldValue ? oldValue[0] : null;
						newValue = newValue ? newValue[0] : null;
					}
					if(attribute == "parent") {
						if(oldValue) oldValue = this.handler.getIdentity(oldValue);
						if(newValue) newValue = this.handler.getIdentity(newValue);
					}
					this._changeDependencies(this.handler.getIdentity(item), newValue, oldValue);
				}
			}
			else {
				success = this.proceed(arguments);
			}
			
			return success;
		},
		
		_checkAndUpdateDependencies: function(item) {
			// summary: Utility to check and update the parent dependency of an item
			var pId = this.handler.getValue(item, "parentId");
			if(pId) {
				this._changeDependencies(this.handler.getIdentity(item), pId);
			}
		},
		
		updateNewItem: function() {
			// summary: Direct wrapping
			var item = this.proceed(arguments);
			this._checkAndUpdateDependencies(item);
			return item;
		},
		
		processFetch: function() {
			// summary: Direct wrapping
			var map = this.proceed(arguments);
			dojo.forEach(map.items, function(item){
				this._checkAndUpdateDependencies(item);
			}, this);
			return map;
		},
		
		_changeDependencies: function(childId, newParentId, oldParentId) {
			// summary: Utility to update dependencies
			if(oldParentId == newParentId) return;
			if(oldParentId) {
				this.handler.depMgr.removeDependency(oldParentId, childId, com.ibm.data.DependencyManager.types["delete"]);
				this.handler.depMgr.removeDependency(childId, oldParentId, com.ibm.data.DependencyManager.types["create"]);
			}
			if(newParentId) {
				this.handler.depMgr.addDependency(newParentId, childId, com.ibm.data.DependencyManager.types["delete"]);
				this.handler.depMgr.addDependency(childId, newParentId, com.ibm.data.DependencyManager.types["create"]);
			}
		}
	}
);

dojo.declare("com.ibm.data.resolver.tree.SiblingDependencyStrategy",
	com.ibm.data.resolver.strategy.UpdateStrategy,
	{
		// summary: Manages dependencies in ordering when next attribute values are updated
		//		on items, particularly when the next value is changed from or to an item
		//		that is not created yet.
		
		extensions: com.ibm.data.resolver.strategy.UpdateStrategy.prototype.extensions.concat(["processSave"]),
		
		// blocked: Boolean indicating whether or not to handle setValue/setValues calls
		//		by this strategy.  This strategy can block itself so that it does not perform
		//		normal advising of these calls in certain circumstances, such as cases where
		//		infinite loops are possible or when dependency management is already performed
		//		and does not need to be performed twice.
		blocked: false,
		
		odepType: com.ibm.data.DependencyManager.types["order"],
		cdepType: com.ibm.data.DependencyManager.types["create"],
		
		processSave: function(/*Item*/ item) {
			this.blocked = true;
			this.handler.setValue(item, "nextId", this._getEffectiveNextId(item));
			this.blocked = false;
			return this.proceed(arguments);
		},
		
		_getEffectiveNextId: function(item) {
			if(!item) return null;
			var next = this.handler.getValue(item, "next");
			if(next) {
				if(!this.handler.resolver.isCreated(next)) {
					return this._getEffectiveNextId(next);
				}
				else return this.handler.getIdentity(next);
			}
			else return null;
		},
		
		_setValue: function(item, attribute, value) {
			// wraps setValue and setValues... so check both
			var success = false;
			if(!this.blocked && (attribute == "next" || attribute == "nextId")) {
				var multi = this.getStrategyContext().joinPoint.targetName == "setValues";
				var oldValue = this.handler[multi ? "getValues" : "getValue"](item, attribute),
					newValue = value;
				success = this.proceed(arguments);
				if(success) {
					if(multi) {
						oldValue = oldValue ? oldValue[0] : null;
						newValue = newValue ? newValue[0] : null;
					}
					if(attribute == "next") {
						if(oldValue) oldValue = this.handler.getIdentity(oldValue);
						if(newValue) newValue = this.handler.getIdentity(newValue);
					}
					this._changeDependencies(this.handler.getIdentity(item), newValue, oldValue);
				}
			}
			else {
				success = this.proceed(arguments);
			}
			
			return success;
		},
		
		_changeDependencies: function(id, newNextId, oldNextId) {
			// summary: Utility
			if(oldNextId == newNextId) return;
			// dependencies here go from source -> target like next -> previous because of
			// ordering constraints						
			this._remove(id);
			this._insert(id, newNextId);			
		},
		
		_remove: function(id) {
			// summary: Remove an item with id from an abstract ordered list denoted
			//		by order dependency relationships
			var targetDeps = this.handler.depMgr.getTargetsByType(id, this.odepType);
			var sourceDeps = this.handler.depMgr.getSourcesByType(id, this.odepType);
			
			// relink dependencies in updated list (A <- B <- C becomes A <- C)
			
			// add links (B <- C becomes A <- C)
			dojo.forEach(targetDeps, function(target){
				dojo.forEach(sourceDeps, function(source){
					this.handler.depMgr.addDependency(source, target, this.odepType);
				}, this);
				this.handler.depMgr.removeDependency(id, target, this.odepType);
			}, this);
			
			// remove dependencies in updated list (A <- B gets removed)
			dojo.forEach(sourceDeps, function(source){
				this.handler.depMgr.removeDependency(source, id, this.odepType);
			}, this);
		},
		
		_insert: function(id, nextId) {
			// summary: Insert an item with id into an abstract ordered list denoted
			//		by order dependency relationships
			if(!nextId) {
				var createDeps = this.handler.depMgr.getSourcesByType(this.handler.getValue(this.handler.resolver.byId(id), "parentId"), this.cdepType);
				
				dojo.forEach(createDeps, function(depId){
					if(this.handler.resolver._getHandlerByUri(depId) == this.handler) {
						var item = this.handler.resolver.byId(depId);
						if(!this.handler.getValue(item, "nextId")) {
							this.handler.depMgr.addDependency(id, depId, this.odepType);
						}
					}
				}, this);
			}
			else {
				var targetDeps = this.handler.depMgr.getTargetsByType(nextId, this.odepType);
				
				// move dependencies (A <- C becomes A <- B <- C)
				dojo.forEach(targetDeps, function(target){
					this.handler.depMgr.removeDependency(nextId, target, this.odepType);
					this.handler.depMgr.addDependency(id, target, this.odepType);
				}, this);
				
				this.handler.depMgr.addDependency(nextId, id, this.odepType);
			}
		}
	}
);


dojo.declare("com.ibm.data.resolver.tree.AtomModelTreeStrategy",
	com.ibm.data.resolver.strategy.UpdateStrategy,
	{
		// summary: Strategy used to manage data referring to relative position information
		// 		in a tree model in the remote ATOM feeds.  This strategy takes care to set
		//		data correctly in the reflected ATOM XML document when data APIs are called
		//		to change attribute values on items.  It also understands and parses the
		//		semantics of fetched data with regards to parent-children relationships
		//		and associates children in a chuck of data with their respective parents.
		
		extensions: com.ibm.data.resolver.strategy.UpdateStrategy.prototype.extensions.concat(["processFetch"]),
		
		_setValue: function(item, attribute, value) {
			var success = false;
			switch(attribute) {
				case "next":
				case "nextId":
					if(!value) {
						success = this.handler.unsetAttribute(item, attribute);
					}
					else success = this.proceed(arguments);
					if(success) {
						// parent is required in data when setting the next sibling
						var parentId = this.handler.getValue(item, "parentId");
						if(parentId) this.handler.setValue(item, "parentId", parentId);
					}
					break;
				default:
					success = this.proceed(arguments);
			}
			return success;
		},
		
		processChildren: function(/*Object*/ map, /*String|Number*/ levels, /*String*/requestURI) {
			if(levels > 1 || levels == "all") {
				var treeMap = {};
				dojo.forEach(map.items, function(item){
					var id = this.handler.getIdentity(item),
						parentId;
					treeMap[id] = {
						item: item
					};
					if(id != requestURI) {
						parentId = this.handler.getValue(item, "parentId");
						if(treeMap[parentId]) {
							treeMap[id].level = treeMap[parentId].level + 1;
							if(treeMap[parentId].children) treeMap[parentId].children.push(item);
						}
					}
					else {
						treeMap[id].level = 1;
					}
					
					if(levels == "all" || treeMap[id].level < levels) {
						if(!item._cachedMeta.children) {
							treeMap[id].children = item._cachedMeta.children = [];
						}
						item._cachedMeta.children.loaded = true;
					}
				}, this);
			}
		},
		
		processFetch: function(/*DOMDoc*/ xmlDoc, /*Request*/ request) {
			// summary: Extension point for descendants or consumers of this store to handle
			//		responses from server requests for data.  Most subclasses can leave this
			// 		function as-is, but if special handling is required that cannot be done
			// 		with other extension points, this can be overridden as well.
			// xmlDoc: DOMDoc of the response from an IO request
			// request: Request used to fetch the result
			// returns: Object map with two properties:
			//		items: Array of the items fetched
			//		meta: Object map of meta data associated with the request
			var map = this.proceed(arguments);
			var levels = request.query.levels;
			if(dojo.isString(levels)) levels = levels.toLowerCase();
			this.processChildren(map, levels, request.query.uri);
			return map;
		}
	}
);

}

if(!dojo._hasResource["com.ibm.data.resolver.tree.PocTreeModel"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.data.resolver.tree.PocTreeModel"] = true;
/*
 * @author Ben
 */ 
dojo.provide("com.ibm.data.resolver.tree.PocTreeModel");

dojo.declare("com.ibm.data.resolver.tree.PocTreeModel",
	null,
	{
		root: null,
		resolver: null,
		handler: null,
		deferWrites: true,
		listening: true,
		
		constructor: function(args) {
			dojo.mixin(this, args);
			this._dirtyItems = {};
			this._allItems = {};
			this._ancLoaders = {};
			if(this.root) {
				this._allItems[this.getIdentity(this.root)] = this.root;
			}
			this._connections= [].concat([
				dojo.connect(this.resolver, "onNew", this, "_onNew"),
				dojo.connect(this.resolver, "onSet", this, "_onSet"),
				dojo.connect(this.resolver, "onDelete", this, "_onDelete")
			]);
			
			if(dojo.isIE) {
				dojo.addOnWindowUnload(dojo.hitch(this, function(){
					this.destroy();
				}));
			}
		},
		assertRelevance: function(item) {
			if(!this.inModel(item)) {
				throw new Error(this.resolver.fmt("errorNotInModel"));
			}
		},
		
		destroy: function(){
			// summary: destroys this object, releasing connections to the store
			 dojo.forEach(this._connections, dojo.disconnect);
			 delete this._connections;
			 delete this._allItems;
			 delete this._dirtyItems;
			 delete this._ancLoaders;
			 delete this.root;
		},
				
		// =======================================================================
		// Methods for traversing hierarchy
		
		getRoot: function(onItem, onError){
			// summary:
		    //            Calls onItem with the root item for the tree, possibly a fabricated item.
			//            Throws exception on error.
			if(this.store.isItemLoaded(this.root)) {
				onItem(this.root);
			}
			else {
				this.store.loadItem({
					item: this.root, 
					onItem: onItem,
					onError: onError
				});
			}
		},
		
		mayHaveChildren: function(/*dojo.data.Item*/ item){
	        // summary
	        //            Tells if an item has or may have children.  Implementing logic here
	        //            avoids showing +/- expando icon for nodes that we know don't have children.
	        //            (For efficiency reasons we may not want to check if an element actually
	        //            has children until user clicks the expando node)
	        return this.handler.getValue(item, "mayHaveChildren");
		},
		getChildren: function(/*dojo.data.Item*/ parentItem, /*Function(items)*/onComplete, /*Function(error)*/onError){
	        // summary
	        //           Calls onComplete() with array of child items of given parent item, all loaded.
	        //            Throws exception on error.
	        this.handler.getValue(parentItem, "children")
	        	.addOnLoad(dojo.hitch(this, function(items){
	        		dojo.forEach(items, function(item) {
	        			this._allItems[this.getIdentity(item)] = item;
	        		}, this);
		        	if(onComplete) {
		        		onComplete(this.filterChildren(parentItem, items.slice()));
		        	}
		        }))
		        .addOnError(dojo.hitch(this, function(error){
		        	if(onError) onError(error);
		        }));
		},
		
		filterChildren: function(parentItem, childItems) {
			return childItems;
		},
		
		getIdentity: function(/* item */ item){
	        // summary: returns identity for an item
	        return this.handler.getIdentity(item);
		},
		getLabel: function(/*dojo.data.Item*/ item){
	        // summary: get the label for an item
	        return this.handler.getLabel(item);
		},
		getAncestors: function(/*dojo.data.Item*/item, /*Function(items)*/onComplete, /*Function(error)*/onError) {
			// summary: Gets an array of ancestors of the current item which includes the item itself as the first
			//		element then walks up the tree to the root, which is the last element.
			this.assertRelevance(item);
			var id = this.getIdentity(item);
			if(this._ancLoaders[id]) {
				this._ancLoaders[id].addOnLoad(onComplete).addOnError(onError);
			}
			else {
				var parent = null, loadFirst = true, chain = [];
				while(this.resolver.isItemLoaded(item)) {
					this._allItems[this.getIdentity(item)] = item;
					chain.push(item);
					parent = this.getParent(item);
					if(!parent) break;
					item = parent;
					loadFirst = false;
				}
				if(!parent && onComplete && !loadFirst) {	// full chain
					onComplete(chain);
				}
				else {
					this._ancLoaders[id] = (new com.ibm.data.ItemsLoader({
						store: this.resolver,
						query: this.getAncestorQuery(item),
						filter: function(resultSet) {
							return chain.concat(resultSet);
						}
					})).addOnResult(dojo.hitch(this, function(items){
						delete this._ancLoaders[id];	// cleanup
						dojo.forEach(items, function(item) {
		        			this._allItems[this.getIdentity(item)] = item;
		        		}, this);
		        	})).addOnLoad(onComplete).addOnError(onError);
				}
			}
		},
		getAncestorQuery: function(/*dojo.data.Item*/item) {
			// summary: Returns a query object which can be passed to the resolver store fetch function to load
			//		the ancestors of a particular item in the tree model.
			return {
				uri: this.getIdentity(item),
				levels: "-all"
			};
		},
		getParent: function(/*dojo.data.Item*/ item) {
			// summary: returns the parent item of this item argument
			return this.handler.getValue(item, "parent");
		},
		
		// =======================================================================
		// Write interface
		newItem: function(/* Object? */ args, /*Item?*/ parent){
	        // summary
	        //            Creates a new item.   See dojo.data.api.Write for details on args.
	        var parentInfo = {parent: parent, attribute: "parent"};
	        var item = this.store.newItem(args, parentInfo);
	        this.store.save({onComplete: args.onComplete, onError: args.onError, scope: args.scope});
	        return item;
		},
		isCreated: function(/*item*/ item) {
			// summary: Indicates whether or not the item has been created on the server and
			//		the server-generated values were properly applied to the client-side
			//		object.	NOTE: Any client-side modifications	to the values of an item for 
			// 		which isCreated returns true can potentially modify the server-generated 
			// 		values to be out-of-sync with the server.
			// 		Therefore, it's important to note that isCreated merely indicates whether
			//		or not the client-side item has a server-side resource associated with it,
			// 		and any values that the server generated for the resource (such as a unique
			return this.resolver.isCreated(item);	
		},
		addOnCreate: function(/*item*/ item, /*Function*/ callback) {
			// summary: Register callback to be called when the given item is created on the server.
			//		If the item is already created, this will call the callback immediately.
			return this.resolver.addOnCreate(item, callback);			
		},
		pasteItem: function(/*Item*/ childItem, /*Item*/ oldParentItem, /*Item*/ newParentItem, /*Boolean*/ bCopy, /*int|Item?*/ pos){
	        // summary:
	        //            Move an item from one parent item to another or to another position under the same parent.
	        //            Used in drag & drop.
	        // childItem: Item to move.
	        // oldParentItem: Previous parent of item being moved.
	        // newParentItem: Item that the item being moved was dropped on.
	        // bCopy: Boolean indicating if the item should be copied or not.
	        // pos: Number|Item indicating the position at which this item gets inserted into the
	        //		model.  If it is a number, it indicates the index in the list of children where
	        //		to insert the child.  If it's an item in the model, it indicates the next sibling
	        //		of the item that will be inserted.  If null, the item is added to the end of the
	        //		list of children.
	        
	        // turning off notifications while doing multiple updates... that way
	        // we can send one onChildrenChange event to all listeners with the proper
	        // list of children
	        var chId = this.getIdentity(childItem),
	        	oldPId = this.getIdentity(oldParentItem),
	        	newPId = this.getIdentity(newParentItem),
	        	listeningState = this.listening;
	        if(chId == newPId) {
	        	// dropped on ourself... do nothing... as if this is possible somehow
	        	return;
	        }
	        else {
	        	this._dirtyItems[chId] = childItem;
	        	if(oldPId != newPId) {
	        		this.listening = false;
	        		this.resolver.setValue(childItem, "parentId", newPId);
	        		this.listening = listeningState;
	        	}
	        	
	        	this.getChildren(newParentItem, dojo.hitch(this, function(items){
	        		// to manage the children on the client, we need to load them first...
	        		// usually this will already have been done before operations like pasteItem
	        		// are called on some parent items
	        		this.listening = false;
    				var nextSibling = null;
    				if(pos != null) {
    					// normalize pos to a number, and nextSibling to an item
		        		if(typeof(pos) == "number") {
		        			if(items.length < pos) {
		        				nextSibling = items[pos + 1];
		        			}
		        		}
		        		else if(this.resolver.isItem(pos)) {
		        			nextSibling = pos;
		        			var nextId = this.getIdentity(pos);
		        			pos = dojo.indexOf(items, function(item) {
		        				return this.getIdentity(item) == nextId;
		        			}, this);
		        			if(pos < 0) pos = items.length;
		        		}
		        		else pos = Infinity;	// land softly if pos is invalid
						if(nextSibling) {
							this.resolver.setValue(childItem, "next", nextSibling);
						}
		        	}
		        	else {
		        		this.resolver.unsetAttribute(childItem, "next");
		        	}
		        	
		        	if(!this.deferWrites) this.save();
    				
        			// reparenting involves removing from the old and inserting into the new
        			// moving within the same parent works the same way
	        		this._removeChildItem(oldParentItem, childItem);
	        		this._insertChildItem(newParentItem, childItem, pos);

					this.listening = listeningState;
		        	this.onTreeChange(childItem, oldParentItem, newParentItem, nextSibling);
		        	if(newParentItem) this.getChildren(newParentItem, dojo.hitch(this, "onChildrenChange", newParentItem));
		        	if(oldParentItem) this.getChildren(oldParentItem, dojo.hitch(this, "onChildrenChange", oldParentItem));
    			}));
	        }
		},
		
		save: function(args) {
			var arr = [];
			for(var id in this._dirtyItems) {
				arr.push(this._dirtyItems[id]);
				delete this._dirtyItems[id];
			}
			this.resolver.saveItems(arr, args);
		},
		
		// explicitly uses item._cachedMeta.children array in managing children of an item in a tree model
		// on the client
		_insertChildItem: function(/*Item*/parentItem, /*Item*/ item, /*Number*/ pos) {
			var items = parentItem._cachedMeta.children;
			if(!this.mayHaveChildren(parentItem)) {
				// we just inserted an item under another item that had no children before
				if(!items) {
					items = parentItem._cachedMeta.children = [];
				}
				items.loaded = true;;
			}
			if(!items || !items.loaded) return false;	// children haven't loaded yet, so we can't manage them on the client
			if(pos == null || pos >= items.length) {
				items.push(item);
			}
			else {
				items.splice(pos, 0, item);
			}
			this.handler.modifyChildren(items);
			return true;
		},
		_removeChildItem: function(/*Item*/parentItem, /*Item*/ item) {
			var items = parentItem._cachedMeta.children;
			if(!items || !items.loaded) {
				return false;	// children haven't loaded yet, so we can't manage them on the client
			}

			var id = this.getIdentity(item);
			for(var i = 0; i < items.length; i++) {
				if(this.getIdentity(items[i]) == id) {
					items.splice(i,1);	// remove the item from the array
					break;	// break out of the loop since we already found ourselves
				}
			}
			this.handler.modifyChildren(items);
			return true;
		},
		
		inModel: function(/*Item|String*/ obj) {
			return true;
		},
		
		loadedInModel: function(/*Item|String*/ obj) {
			if(!dojo.isString(obj)) {
				obj = this.getIdentity(obj);
			}
			return !!this._allItems[obj];
		},
		
		_onNew: function(/* Item */ newItem, /* Object */ parentInfo) {
			// summary: Callback handler for the store attached to this tree model to call
			//		when an item is created 
			if(!this.listening || !parentInfo || !parentInfo.item) {
				return;
			}
			if(this.handler != this.resolver._getHandlerByItem(newItem)) {
				return;
			}
			var parentItem = parentInfo.item;
			if(this.loadedInModel(parentItem)) {
				this._dirtyItems[this.handler.getIdentity(newItem)] = newItem;
				var nextSibling = this.handler.getValue(newItem, "next");
				this._insertChildItem(parentItem, newItem, nextSibling);
				this.onTreeChange(newItem, null, parentItem, nextSibling);
				this.getChildren(parentItem, dojo.hitch(this, "onChildrenChange", parentItem));
			}
		},
		
		_onDelete: function(/* Item */ deletedItem) {
			// summary: Callback handler for the store attached to this tree model to call
			//		when an item is deleted
			if(!this.listening) return;
			if(this.loadedInModel(deletedItem)) {
				this._dirtyItems[this.handler.getIdentity(deletedItem)] = deletedItem;
				var parentItem = this.getParent(deletedItem);
				this._removeChildItem(parentItem, deletedItem);
				this.onTreeChange(deletedItem, parentItem);
				//this.getChildren(parentItem, dojo.hitch(this, "onChildrenChange", parentItem));
				this.onDelete(deletedItem);
			}
		},
		
		_onSet: function(/* Item */ item, /*String*/ attribute, /*Object | Array*/ oldValue, /*Object | Array*/ newValue) {
			// summary: Callback handler for the store attached to this tree model to call
			//		when an item is modified
			if(!this.listening) return;
			if(this.loadedInModel(item)) {
				switch(attribute) {
					case "parentId":
						newValue = this.resolver.byId(newValue);
					case "parent":
						this.pasteItem(item, this.handler.getValue("parent"), newValue, false, this.handler.getValue("next"));
						break;
					case "nextId":
						newValue = this.resolver.byId(newValue);
					case "next":
						var oldParent = this.handler.getValue("parent")
						this.pasteItem(item, oldParent, oldParent, false, newValue);
						break;
					default:
						this.onChange(item);
				}
			}
		},
		
		onDelete: function(/*dojo.data.Item*/ item) {
			// summary:
			//		Callback whenever an item has been deleted from this model.
		},
		
		// =======================================================================
		// Callbacks
		
		onChange: function(/*dojo.data.Item*/ item){
			// summary:
			//		Callback whenever an item has changed, so that Tree
			//		can update the label, icon, etc.   Note that changes
			//		to an item's children or parent(s) will trigger an
			//		onChildrenChange() so you can ignore those changes here.
			// tags:
			//		callback
		},
		
		onChildrenChange: function(/*dojo.data.Item*/ parent, /*dojo.data.Item[]*/ newChildrenList){
	        // summary: Callback to do notifications about new or updated items under a parent.  Deletes
	        //		are handled by the onDelete notification.
		},
		
		onTreeChange: function(/*Item*/ childItem, /*Item*/ oldParentItem, /*Item*/ newParentItem, /*Item*/ nextSiblingItem) {
			// summary: Called when the tree model is changed through one of three scenarios.
			// 		1) An item is moved in the tree model.  This can be called 
			//			when an item is reparented or reordered within the same parent.  In both
			//			cases the nextSiblingItem refers to the next sibling of childItem, sharing
			//			its same newParentItem.
			//		2) A new item is inserted into the tree at a given parent.  In this case,
			//			the oldParentItem is null.
			//		3) An item is removed from the tree at a given parent.  In this case, the
			//			newParentItem and the nextSiblingItem is null.
			// childItem: Item to move.
			// oldParentItem: Item old parent of the childItem.
			// newParentItem: Item new parent of the childItem.  If this is the same as the
			//		oldParentItem, it indicates that the childItem is being reordered in
			//		the list of children under the parent.
			// nextSiblingItem: Item that is becoming the next sibling of the moved child item.  
			// 		Null indicates moving to the end of the list of children. 
		},				
		toString: function() {
			return "[PocTreeModel of {" + this.handler + "}]";
		}
	}
);

}

if(!dojo._hasResource["com.ibm.data.resolver.tree.PocGlobalTreeModel"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.data.resolver.tree.PocGlobalTreeModel"] = true;
/*
 * @author Ben
 */ 
dojo.provide("com.ibm.data.resolver.tree.PocGlobalTreeModel");



dojo.declare("com.ibm.data.resolver.tree.PocGlobalTreeModel",
	com.ibm.data.resolver.tree.PocTreeModel,
	{
		scheme: "",
		refItem: null,
		
		getRoot: function(onItem, onError) {
			if(this.root) {
				onItem(this.root);
			}
			else {
				this.getAncestors(this.refItem, dojo.hitch(this, function(items){
					if(!this.root) {
						this.root = items[items.length - 1];
						this._allItems[this.getIdentity(this.root)] = this.root;
					}
					if(onItem) onItem(this.root);
				}), onError);
			}
		}
	}
);

}

if(!dojo._hasResource["com.ibm.data.resolver.tree.PocLMTreeModel"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.data.resolver.tree.PocLMTreeModel"] = true;
/*
 * @author Ben
 */ 
dojo.provide("com.ibm.data.resolver.tree.PocLMTreeModel");


/*
 * Instances of this tree model are specific to one page and cannot be shared amongst other pages.
 * This maintains this model as a tree model instead of a forest model with a fake root of all
 * layout models in a system.  A forest model of the system layout models would be useless and
 * would not perform well given the design of the models and their APIs.
 */

dojo.declare("com.ibm.data.resolver.tree.PocLMTreeModel",
	com.ibm.data.resolver.tree.PocTreeModel,
	{
		refItem: null,
		pageId: "",
		
		constructor: function() {
			this._rDfd = null;
			this._allItems = [];
		},
		
		getRoot: function(onItem, onError){
			// summary:
		    //            Calls onItem with the root item for the tree, possibly a fabricated item.
			//            Throws exception on error.
			if(this.root) {
				if(this.resolver.isItemLoaded(this.root)) {
					if(onItem) onItem(this.root);
				}
				else {
					this.resolver.loadItem({
						item: this.root,
						onItem: onItem,
						onError: onError
					});
				}
				return;
			}
			if(this.refItem && !this.getParent(this.refItem)) {
				var compId = this.handler._extractCompositeIds(this.getIdentity(this.refItem));
				if(compId.layoutId == compId.pageId) {
					return this.handler.getValue(this.refItem, "children")
						.addOnLoad(dojo.hitch(this, function(ch){
							this._allItems = ch;
							this.root = ch[0];
							if(onItem) onItem(this.root);
						}))
						.addOnError(onError);
				}
				else {
					this.root = this.refItem;	// in a layout model, the root node is unchangeable
					this._allItems.push(this.root);
					return this.getRoot(onItem, onError);
				}
			}
			if(this._rDfd) {
				this._rDfd.addCallbacks(onItem, onError);
			}
			else {
				this._rDfd = (new dojo.Deferred()).addBoth(dojo.hitch(this, function(){
	        		delete this._rDfd;	// cleanup
	        	})).addCallbacks(onItem, onError);
	        	
	        	if(this.refItem) {
					this.getAncestors(this.refItem, dojo.hitch(this, function(items){
							this._allItems = items;
							this._rDfd.callback(items[items.length - 1]);
						}), dojo.hitch(this, function(error){
							this._rDfd.errback(error);
						})
					);
	        	}
	        	else {
	        		this.resolver.fetch({
	        			query: {
	        				uri: "lm:oid:" + this.pageId
	        			},
        				onComplete: function(items) {
        					this._allItems = items;
        					for(var i = 0; i<items.length; i++) {
        						if(!this.getParent(items[i])) {
        							this.root = items[i];
        							this._rDfd.callback(this.root);
        							return;
        						}
        					}
        					this._rDfd.errback(new Error("lm:oid:" + this.pageId));
        				},
        				onError: function(err){
        					this._rDfd.errback(error);
        				},
        				scope: this
	        		});
	        	}
			}
		},
		getAll: function() {
			return this._allItems;
		},
		
		inModel: function(/*Item|String*/ obj) {
			if(!dojo.isString(obj)) {
				obj = this.getIdentity(obj);
			}
			
			var compId = this.handler._extractCompositeIds(obj);
			return this.pageId == compId.pageId;
		},
		toString: function() {
			return "[PocLMTreeModel of {" + this.handler + "} for page {" + this.pageId + "}]";
		}
	}
);

}

if(!dojo._hasResource["com.ibm.data.resolver.CMPocHandler"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.data.resolver.CMPocHandler"] = true;
/*
 * @author Ben
 */ 
dojo.provide("com.ibm.data.resolver.CMPocHandler");







dojo.declare("com.ibm.data.resolver.CMPocHandler",
	[com.ibm.data.resolver.OpenSearchPocHandler, com.ibm.data.resolver.tree.TreeModeledHandler],
	{		
		category: "content",
		
		_globalTreeModel: null,
		
		namespaces: dojo.mixin({}, 
			com.ibm.data.resolver.OpenSearchPocHandler.prototype.namespaces,
			com.ibm.data.resolver.ResolverQueryRules.namespaces),
		
		constructor: function() {
			this.customAttributes.treeModel.get = function(item, multiValued) {
				if(!this._globalTreeModel) {
					this._globalTreeModel = new com.ibm.data.resolver.tree.PocGlobalTreeModel({
						refItem: item,
						handler: this,
						resolver: this.resolver,
						scheme: this.definition.scheme
					});
				}
				return multiValued ? [this._globalTreeModel] : this._globalTreeModel;
			};
		},
		
		_createTemplates: function() {
			var nsDecl = [];
			for(var prefix in this.namespaces) {
				nsDecl.push('xmlns:', prefix, '="', this.namespaces[prefix], '" ');
			}
			dojo.mixin(this, {
				pageTemplate: {
					templateString:
						'<?xml version="1.0" encoding="UTF-8"?>'
						+'<atom:feed '
							+nsDecl.join('')
							+'>'
							+'<atom:author>'
								+'<atom:name>IBM WebSphere Portal/6.1</atom:name>'
							+'</atom:author>'
							+'<atom:title>IBM WebSphere Portal Model Feed</atom:title>'
							+'<atom:link href="." rel="self" type="application/atom+xml"/>'
							+'<atom:entry>'
								+'<atom:title>${title}</atom:title>'
								+'<atom:id>${id}</atom:id>'
								+'<atom:content type="application/xml">'
									+'<model:content-page>'
										+'<model:supported-markup>html</model:supported-markup>'
										+'<model:title>'
										+'<base:nls-string xml:lang="${locale}">${title}</base:nls-string>'
										+'</model:title>'
									+'</model:content-page>'
								+'</atom:content>'
								+'<thr:in-reply-to ext:uri="${parentId}" href="${parentId}" ref="${parentId}" type="application/atom+xml"/>'
							+'</atom:entry>'
						+'</atom:feed>',
					templateProps: {
						id: "",
						title: "",
						locale: dojo.local,
						parentId: ""
					}
				},
					
				internalURLTemplate: {
					templateString:
						 '<?xml version="1.0" encoding="UTF-8"?>'
						+'<atom:feed '
							+nsDecl.join('')
							+'>'
							+'<atom:author>'
								+'<atom:name>IBM WebSphere Portal/6.1</atom:name>'
							+'</atom:author>'
							+'<atom:title>IBM WebSphere Portal Model Feed</atom:title>'
							+'<atom:link href="." rel="self" type="application/atom+xml"/>'
							+'<atom:entry>'
								+'<atom:title>${title}</atom:title>'
								+'<atom:id>${id}</atom:id>'
								+'<atom:content type="application/xml">'
									+'<model:content-page>'
										+'<model:supported-markup>html</model:supported-markup>'
										+'<model:title>'
										+'<base:nls-string xml:lang="${locale}">${title}</base:nls-string>'
										+'</model:title>'
									+'</model:content-page>'
								+'</atom:content>'
								+'<thr:in-reply-to ext:uri="${parentId}" href="${parentId}" ref="${parentId}" type="application/atom+xml"/>'
							+'</atom:entry>'
						+'</atom:feed>',
					templateProps: {
						id: "",
						title: "",
						locale: dojo.local,
						parentId: ""
					}
				},
				
				externalURLTemplate: {
					templateString:
						'<?xml version="1.0" encoding="UTF-8"?>'
						+'<atom:feed '
							+nsDecl.join('')
							+'>'
							+'<atom:author>'
								+'<atom:name>IBM WebSphere Portal/6.1</atom:name>'
							+'</atom:author>'
							+'<atom:title>IBM WebSphere Portal Model Feed</atom:title>'
							+'<atom:link href="." rel="self" type="application/atom+xml"/>'
							+'<atom:entry>'
								+'<atom:title>${title}</atom:title>'
								+'<atom:id>${id}</atom:id>'
								+'<atom:content type="application/xml">'
									+'<model:content-page>'
										+'<model:supported-markup>html</model:supported-markup>'
										+'<model:title>'
										+'<base:nls-string xml:lang="${locale}">${title}</base:nls-string>'
										+'</model:title>'
									+'</model:content-page>'
								+'</atom:content>'
								+'<thr:in-reply-to ext:uri="${parentId}" href="${parentId}" ref="${parentId}" type="application/atom+xml"/>'
							+'</atom:entry>'
						+'</atom:feed>',
					templateProps: {
						id: "",
						title: "",
						locale: dojo.local,
						parentId: ""
					}
				}
			});
		},
		
		getSaveQuery: function(/*item*/ item) {
			var q = this.inherited(arguments);
			if(this.resolver.isCreated(item)) {
				// merge updates
				// empty representation.. performance-smart
				q.rep = "empty";
			}
			else {
				q.uri = this.getValue(item, "parentId");
			}
			return q;
		},
		
		modifyNewItemArgs: function(args, parentInfo) {
			this.inherited(arguments);
			if(args.isPrivate != null) {
				if(dojo.isString(args.isPrivate)) {
					args.isPrivate = args.isPrivate.toLowerCase();
					switch(args.isPrivate) {
						case "true":
						case "yes":
							args.isPrivate = "true";
						default:
							args.isPrivate = "false";
					}
				}
				else {
					if(args.isPrivate == true) args.isPrivate = "true";
					else args.isPrivate = "false";
				}
			}
			return args;
		},
		fillInProperties: function(newItem, template, keywordArgs, parentInfo) {
			if(keywordArgs.isPrivate != null) {
				this.engine.select("./atom:content/*", newItem.data, true).attr("creationcontext:private", keywordArgs.isPrivate);
			}
			delete keywordArgs.isPrivate;
			if(keywordArgs.metadata) {
				for(var key in keywordArgs.metadata) {
					keywordArgs["metadata[" + key + "]$"] = keywordArgs.metadata[key];
				}
				delete keywordArgs.metadata;
			}
			if(keywordArgs.friendlyName) {
				keywordArgs["metadata[com.ibm.portal.friendly.name]$"] = keywordArgs.friendlyName;
				delete keywordArgs.friendlyName;
			}
			return this.inherited(arguments);
		},
		getTemplate: function(args, parentInfo) {
			switch(args.type) {
				case "internalURL": 
					return this.internalURLTemplate;
				case "externalURL": 
					return this.externalURLTemplate;
				case "page": 
				default: 
					return this.pageTemplate;
			}
		},
		instantiateTemplate: function(template, args, parentInfo) {
			var xmlDoc = this.inherited(arguments);
			if(!args.parentId) {
				// we don't want the thr:in-reply-to element in the DOM data to send, so remove it
				this.engine.select("./thr:in-reply-to", xmlDoc).destroy();
			}
			return xmlDoc;
		},
		_makeModifiable: function(item) {
			// summary: Modifies the element of this item to become modifiable
			//		for writing back to the server.  Subclasses can override this
			//		to do things like prune an item to only include necessary information
			//		for updates and nothing more.  This is called by backup once after
			//		backing up the original element first.  After this returns,
			//		this item's element may have been modified.  Any queries against
			//		this item should now include logic to check the backup copy as well
			//		if a query doesn't return anything as it could have been deleted by
			//		this function.  Care should be taken to ensure that the query result
			//		specifically detects if nothing was found or if the actual value was
			//		null or an empty string.
			this.engine.select("atom:content/*/* | thr:in-reply-to | atom:link", item.data).destroy();
			
			this.inherited(arguments);
		}
	}
);

(function(){
	
	var r = com.ibm.data.resolver;
	var atomBase = r.ResolverQueryRules.atom;
	
	var r = com.ibm.data.resolver, 
		cmPoc = r.CMPocHandler, 
		prot = cmPoc.prototype, 
		def = prot.definition,
		atomBase = r.ResolverQueryRules.atom;
	
	def = dojo.mixin({}, def, {
		scheme: "cm"
	});
	
	def.features = dojo.mixin({}, def.features, {
		"TreeModeled": true
	});
	
	prot.definition = def;
	
	dojo.extend(cmPoc, {		
		queryRules: dojo.mixin({}, r.OpenSearchPocHandler.prototype.queryRules, 
					atomBase.threadExt,
					atomBase.treeExt, 
					atomBase.uniqueNameExt, 
					atomBase.L10nExt, 
					atomBase.acExt,  
					atomBase.modelExt,
					atomBase.operationsExt, 
					atomBase.contentExt,
					atomBase.metaExt, {
			//layout: {selector: "./atom:link[@ext:rel='layout']", field: "@ext:uri", type: "Item", readOnly: true},
			//layoutId: {selector: "./atom:link[@ext:rel='layout']", field: "@ext:uri", readOnly: true},
			shareable: {selector: "./atom:content/*[model:shareable]/model:shareable", field: "$textContent"},
			bookmarkable: {selector: "./atom:content/*[model:bookmarkable]/model:bookmarkable", field: "$textContent"},
			internalRef: {selector: "./atom:link[@ext:rel='internal-url']", type: "Item", field: "@ext:uri"},
			internalRefId: {selector: "./atom:link[@ext:rel='internal-url']", field: "@ext:uri"},
			internalURL: {selector: "./atom:link[@ext:rel='internal-url']", field: "@href"},
			externalURL: {selector: "./atom:link[@ext:rel='external-url']", field: "@href"}
		}),
		customAttributes: dojo.mixin({}, r.OpenSearchPocHandler.prototype.customAttributes, {
			navigationNode: {
				get: function(item, multiValued) {
					var nmId = "nm" + this.getIdentity(item).substr(2);
					var navItem = this.resolver.byId(nmId);
					if(!this.resolver.isItemLoaded(navItem)) {
						var seedArgs = {
							id: nmId,
							title: this.getLabel(item)
						};
						var parentId = this.etValue(item, "parentId");
						if(parentId) {
							seedArgs.parentId = parentId;
						}
						
						dojo.forEach(["theme", "nextId", "nextURI", "parentId", "parentURI", "uniqueName"], function(attr){
							var val = this.getValue(item, attr);
							if(val) {
								seedArgs[attr] = val;
							}
						}, this);
						navItem = this.resolver.seedStore(seedArgs);
					}
					return multiValued ? [navItem] : navItem;
				},
				set: function(item, value, multiValued) {
					// can't write to this attribute
					return false;
				}
			},
			layoutModel: {
				get: function(item, multiValued) {
					if(!item._cachedMeta.layoutModel) {
						item._cachedMeta.layoutModel = new com.ibm.data.resolver.tree.PocLMTreeModel({
							pageId: this.getIdentity(item).substr(7),
							handler: this,
							resolver: this.resolver
						});
					}
					return multiValued ? [item._cachedMeta.layoutModel] : item._cachedMeta.layoutModel;
				},
				set: function(item, value, multiValued) {
					// can't write to this attribute
					return false;
				}
			}
		})
	});
	
	var modelSpecificSetter = function(nodeName, data, rule, value){
		this.select("./atom:content/*", data, true).createFromJson({
			name: nodeName,
			children: [value]
		});
		return true;
	};
	
	prot.queryRules.shareable = dojo.partial(modelSpecificSetter, "model:shareable");
	prot.queryRules.bookmarkable = dojo.partial(modelSpecificSetter, "model:bookmarkable");
	
	com.ibm.strategy.Strategy.applyStrategy(cmPoc, new com.ibm.data.resolver.tree.AtomModelTreeStrategy());
	
	com.ibm.data.Resolver.register(def.scheme, cmPoc);
})();


}

if(!dojo._hasResource["com.ibm.data.resolver.NMPocHandler"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.data.resolver.NMPocHandler"] = true;
/*
 * @author Ben
 */ 
dojo.provide("com.ibm.data.resolver.NMPocHandler");






dojo.declare("com.ibm.data.resolver.NMPocHandler",
	[com.ibm.data.resolver.OpenSearchPocHandler, com.ibm.data.resolver.tree.TreeModeledHandler],
	{
		category: "navigation",
		
		_globalTreeModel: null,
		
		namespaces: dojo.mixin({}, 
			com.ibm.data.resolver.OpenSearchPocHandler.prototype.namespaces,
			com.ibm.data.resolver.ResolverQueryRules.namespaces),
		
		constructor: function() {
			this.customAttributes.treeModel.get = function(item, multiValued) {
				if(!this._globalTreeModel) {
					this._globalTreeModel = new com.ibm.data.resolver.tree.PocGlobalTreeModel({
						refItem: item,
						handler: this,
						resolver: this.resolver,
						scheme: this.definition.scheme
					});
				}
				return multiValued ? [this._globalTreeModel] : this._globalTreeModel;
			};
		},
		
		_createTemplates: function() {
			var nsDecl = [];
			for(var prefix in this.namespaces) {
				nsDecl.push('xmlns:', prefix, '="', this.namespaces[prefix], '" ');
			}
			dojo.mixin(this, {
				nodeTemplate: {
					templateString:
						'<?xml version="1.0" encoding="UTF-8"?>'
						+'<atom:feed '
							+nsDecl.join('')
							+'>'
							+'<atom:author>'
								+'<atom:name>IBM WebSphere Portal/6.1</atom:name>'
							+'</atom:author>'
							+'<atom:title>IBM WebSphere Portal Model Feed</atom:title>'
							+'<atom:link href="." rel="self" type="application/atom+xml"/>'
							+'<atom:entry>'
								+'<atom:title>${title}</atom:title>'
								+'<atom:id>${id}</atom:id>'
								+'<atom:content type="application/xml">'
									+'<model:navigation-node>'
										+'<model:title>'
										+'<base:nls-string xml:lang="${locale}">${title}</base:nls-string>'
										+'</model:title>'
									+'</model:navigation-node>'
								+'</atom:content>'
								+'<thr:in-reply-to ext:uri="${parentId}" href="${parentId}" ref="${parentId}" type="application/atom+xml"/>'
							+'</atom:entry>'
						+'</atom:feed>',
					templateProps: {
						id: "",
						title: "",
						locale: dojo.local,
						parentId: ""
					}
				}
			});
		},
		getSaveQuery: function(/*item*/ item) {
			var q = this.inherited(arguments);
			if(this.resolver.isCreated(item)) {
				// merge updates
				// empty representation.. performance-smart
				q.rep = "empty";
			}
			else {
				q.uri = this.getValue(item, "parentId");
			}
			return q;
		},
		fillInProperties: function(newItem, template, keywordArgs, parentInfo) {
			if(keywordArgs.metadata) {
				for(var key in keywordArgs.metadata) {
					keywordArgs["metadata[" + key + "]$"] = keywordArgs.metadata[key];
				}
				delete keywordArgs.metadata;
			}
			if(keywordArgs.friendlyName) {
				keywordArgs["metadata[com.ibm.portal.friendly.name]$"] = keywordArgs.friendlyName;
				delete keywordArgs.friendlyName;
			}
			return this.inherited(arguments);
		},
		getTemplate: function(args, parentInfo) {
			return this.nodeTemplate;
		},
		instantiateTemplate: function(template, args, parentInfo) {
			var xmlDoc = this.inherited(arguments);
			if(!args.parentId) {
				// we don't want the thr:in-reply-to element in the DOM data to send, so remove it
				this.engine.select("./thr:in-reply-to", xmlDoc).destroy();
			}
			return xmlDoc;
		},
		_makeModifiable: function(item) {
			// summary: Modifies the element of this item to become modifiable
			//		for writing back to the server.  Subclasses can override this
			//		to do things like prune an item to only include necessary information
			//		for updates and nothing more.  This is called by backup once after
			//		backing up the original element first.  After this returns,
			//		this item's element may have been modified.  Any queries against
			//		this item should now include logic to check the backup copy as well
			//		if a query doesn't return anything as it could have been deleted by
			//		this function.  Care should be taken to ensure that the query result
			//		specifically detects if nothing was found or if the actual value was
			//		null or an empty string.
			this.engine.select("atom:content/*/* | thr:in-reply-to | atom:link", item.data).destroy();
			
			this.inherited(arguments);
		}
	}
);

(function(){
	var r = com.ibm.data.resolver, 
		nmPoc = r.NMPocHandler, 
		prot = nmPoc.prototype, 
		def = prot.definition,
		atomBase = r.ResolverQueryRules.atom;
		
	def = dojo.mixin({}, def, {
		scheme: "nm"
	});
	
	def.features = dojo.mixin({}, def.features, {
		"TreeModeled": true
	});
	
	prot.definition = def;
	
	dojo.extend(nmPoc, {		
		queryRules: dojo.mixin({}, r.OpenSearchPocHandler.prototype.queryRules, 
					atomBase.threadExt,
					atomBase.treeExt, 
					atomBase.uniqueNameExt, 
					atomBase.L10nExt, 
					atomBase.acExt,  
					atomBase.modelExt,
					atomBase.operationsExt, 
					atomBase.contentExt,
					atomBase.metaExt, {
			contentNode: {selector: "./atom:link[@ext:class='content-node']", field: "@ext:uri", type: "Item"},
			contentNodeId: {selector: "./atom:link[@ext:class='content-node']", field: "@ext:uri"},
			contentNodeType: {selector: "./atom:link[@ext:class='content-node']", field: "@ext:rel"}
		})
	});
	
	var contentNodeSetter = function(data, rule, value){
		var attrs = {
			"ext:class": "content-node", 
			"type": "application/atom+xml"
		};
		attrs[rule.field.substr(1)] = value;
		this.createFromJson(data, {
			name: "atom:link",
			attributes: attrs
		});
		return true;
	};
	
	prot.queryRules.contentNode.setter = contentNodeSetter;
	prot.queryRules.contentNodeId.setter = contentNodeSetter;
	prot.queryRules.contentNodeType.setter = contentNodeSetter;
	
	com.ibm.strategy.Strategy.applyStrategy(nmPoc, new com.ibm.data.resolver.tree.AtomModelTreeStrategy());
	
	com.ibm.data.Resolver.register(def.scheme, nmPoc);
})();

}

if(!dojo._hasResource["com.ibm.data.resolver.PMPocHandler"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.data.resolver.PMPocHandler"] = true;
/*
 * @author Ben
 */ 
dojo.provide("com.ibm.data.resolver.PMPocHandler");




dojo.declare("com.ibm.data.resolver.PMPocHandler",
	com.ibm.data.resolver.OpenSearchPocHandler,
	{
		category: "content",
		
		namespaces: dojo.mixin({}, 
			com.ibm.data.resolver.OpenSearchPocHandler.prototype.namespaces,
			com.ibm.data.resolver.ResolverQueryRules.namespaces),

		_createTemplates: function() {
			var nsDecl = [];
			for(var prefix in this.namespaces) {
				nsDecl.push('xmlns:', prefix, '="', this.namespaces[prefix], '" ');
			}
			dojo.mixin(this, {
				entityTemplate: {
					templateString: 
						 '<?xml version="1.0" encoding="UTF-8"?>'
						+'<atom:feed '
							+nsDecl.join('')
							+'>'
							+'<atom:author>'
								+'<atom:name>IBM WebSphere Portal/6.1</atom:name>'
							+'</atom:author>'
							+'<atom:title>IBM WebSphere Portal Model Feed</atom:title>'
							+'<atom:link href="." rel="self" type="application/atom+xml"/>'
							+'<atom:entry>'
								+'<atom:title>${title}</atom:title>'
								+'<atom:id>${id}</atom:id>'
								+'<atom:content type="application/xml">'
									+'<model:portlet-entity/>'
								+'</atom:content>'
								+'<thr:in-reply-to ext:uri="${parentId}" href="${parentId}" ref="${parentId}" type="application/atom+xml"/>'
							+'</atom:entry>'
						+'</atom:feed>',
					templateProps: {
						id: "",
						title: "",
						parentId: ""
					}
				},
							
				definitionTemplate: {
					templateString: 
						 '<?xml version="1.0" encoding="UTF-8"?>'
						+'<atom:feed '
							+nsDecl.join('')
							+'>'
							+'<atom:author>'
								+'<atom:name>IBM WebSphere Portal/6.1</atom:name>'
							+'</atom:author>'
							+'<atom:title>IBM WebSphere Portal Model Feed</atom:title>'
							+'<atom:link href="." rel="self" type="application/atom+xml"/>'
							+'<atom:entry>'
								+'<atom:title>${title}</atom:title>'
								+'<atom:summary>${summary}</atom:summary>'
								+'<atom:id>${id}</atom:id>'
								+'<atom:content type="application/xml">'
									+'<model:portlet-definition/>'
								+'</atom:content>'
								+'<thr:in-reply-to ext:uri="${parentId}" href="${parentId}" ref="${parentId}" type="application/atom+xml"/>'
							+'</atom:entry>'
						+'</atom:feed>',
					templateProps: {
						id: "",
						title: "",
						summary: "",
						parentId: ""
					}
				},
				
				portletTemplate: {
					templateString:
						 '<?xml version="1.0" encoding="UTF-8"?>'
						+'<atom:feed '
							+nsDecl.join('')
							+'>'
							+'<atom:author>'
								+'<atom:name>IBM WebSphere Portal/6.1</atom:name>'
							+'</atom:author>'
							+'<atom:title>IBM WebSphere Portal Model Feed</atom:title>'
							+'<atom:link href="." rel="self" type="application/atom+xml"/>'
							+'<atom:entry>'
								+'<atom:title>${title}</atom:title>'
								+'<atom:id>${id}</atom:id>'
								+'<atom:content type="application/xml">'
									+'<model:portlet/>'
								+'</atom:content>'
								+'<thr:in-reply-to ext:uri="${parentId}" href="${parentId}" ref="${parentId}" type="application/atom+xml"/>'
							+'</atom:entry>'
						+'</atom:feed>',
					templateProps: {
						id: "",
						title: "",
						parentId: ""
					}
				}
			});
		},
		
		getTemplate: function(args, parentInfo) {
			switch(args.type) {
				case "portlet": 
					return this.portletTemplate;
				case "portlet-definition": 
					return this.definitionTemplate;
				case "portlet-entity": 
				default: 
					return this.entityTemplate;
			}
		},
		getSaveQuery: function(/*item*/ item) {
			var q = this.inherited(arguments);
			if(this.resolver.isCreated(item)) {
				// merge updates
				// empty representation.. performance-smart
				q.rep = "empty";
			}
			else {
				q.uri = this.getValue(item, "parentId");
			}
			
			switch(this.getValue(item, "modelNodeType", "")) {
				// portlet-entity and portlet-definition items should save in "replace" mode instead of "merge" mode
				// so that preferences are replaced correctly
				case "portlet-definition":
				case "portlet-entity":
					q.mode = "replace";
				default:
			}
			
			return q;
		},
		
		_makeModifiable: function(item) {
			// summary: Modifies the element of this item to become modifiable
			//		for writing back to the server.  Subclasses can override this
			//		to do things like prune an item to only include necessary information
			//		for updates and nothing more.  This is called by backup once after
			//		backing up the original element first.  After this returns,
			//		this item's element may have been modified.  Any queries against
			//		this item should now include logic to check the backup copy as well
			//		if a query doesn't return anything as it could have been deleted by
			//		this function.  Care should be taken to ensure that the query result
			//		specifically detects if nothing was found or if the actual value was
			//		null or an empty string.			
			this.inherited(arguments);
		}
	}
);

(function(){
	var r = com.ibm.data.resolver, 
		pmPoc = r.PMPocHandler, 
		prot = pmPoc.prototype, 
		def = prot.definition,
		atomBase = r.ResolverQueryRules.atom;
	
	def = dojo.mixin({}, def, {
		scheme: "pm"
	});
	
	prot.definition = def;
	
	// relationship model:
	//		portlet-window -> [private portlet-entity ->] shared portlet-entity -> 
	// 		portlet-definition -> portlet -> web-application
	// 
	// private portlet-entity is not there by default but can be created as a child
	// of the shared portlet-entity
	
	dojo.extend(pmPoc, {		
		queryRules: dojo.mixin({}, r.OpenSearchPocHandler.prototype.queryRules, 
				atomBase.threadExt,
				atomBase.uniqueNameExt, 
				atomBase.L10nExt,  
				atomBase.modelExt, {
			initParameters: {selector: "./atom:content/model:portlet/model:initparameters", field: "$textContent", readOnly: true},
			supportedModes: {selector: "./atom:content/model:portlet/model:supports/model:portlet-mode", field: "$textContent", readOnly: true},
			supportedMarkups: {selector: "./atom:content/model:portlet/model:supports/model:mime-type", field: "$textContent", readOnly: true},
			contextRoot: {selector: "./atom:content/model:web-application/model:context-root", field: "$textContent", readOnly: true},
			
			// the most common attribute for this store, provides read/write operations for portlet preferences on items
			// that support it
			preferenceValue$: {selector: "./atom:content/*[model:portletpreferences]/model:portletpreferences[@name='${0}']/base:value", field: "@value", key: "${0}", deferSet: true, setter: 
				function(data, rule, value, multiValued) {
					var valueDef = {
						name: "base:value",
						attributes: {
							"xsi:type": "base:String"
						}
					};
					
					var modelNode = this.select("./atom:content/*", data, true);
					var type = modelNode.prop("localName")[0];
					// only create preferences on portlet-entity and portlet-definition items
					if(type != "portlet-entity" && type != "portlet-definition") return false;
					
					var prefNode = modelNode.select("model:portletpreferences[@name='" + rule.key + "']", true);
					if(prefNode.length == 0) {
						modelNode.createFromJson({
							name: "model:portletpreferences",
							attributes: {
								"name": rule.key,
								"read-only": "false"
							}
						});
						prefNode = modelNode.select("model:portletpreferences[@name='" + rule.key + "']", true);
					}
					else {
						if(prefNode.attr("read-only")[0] == "true") {
							throw new Error(this.resolver.fmt("errorReadOnlyPrefs", [rule.key]));
						}
					}
					
					prefNode.select("*").destroy();	// clear existing values
					if(!multiValued) {
						value = [value];
					}
					
					dojo.forEach(value, function(singleValue){
						valueDef.attributes.value = singleValue;
						prefNode.createFromJson(valueDef);
					}, this);
					
					return true;
				}
			},
			preferenceReadOnly$: {selector: "./atom:content/*[model:portletpreferences]/model:portletpreferences[name=${0}]", field: "@read-only", key: "${0}", readOnly: true}
			
			// provide a read-only construct for easily accessing all the portlet preferences on the current item
			//,preferences: {selector: "./atom:content/*[model:portletpreferences]/model:portletpreferences", field: "PortletPreferenceConstruct", type: "Node", readOnly: true}
		}),
		
		customAttributes: dojo.mixin({}, prot.customAttributes, {
			portletWindowChain: {
				get: function(item, multiValued) {
					if(this.getValue(item, "modelNodeType", "portlet-window") != "portlet-window") return;
					return new com.ibm.data.resolver.PMWindowChain({
						store: this.resolver,
						windowId: this.getIdentity(item)
					});
				},
				set: function(item, value, multiValued) {
					// can't write to this attribute as it is a composite object derived from others
					return false;
				}
			}
		})
	});
	
	com.ibm.data.Resolver.register(def.scheme, pmPoc);	
})();

dojo.declare("com.ibm.data.resolver.PMWindowChain",
	com.ibm.data.ItemsLoader,
	{
		windowId: "",
		constructor: function() {
			this.query = {
				uri: this.windowId,
				levels: "-all"
			};
		},
		filter: function(items) {
			if(!items.pw) {	// only if not filtered yet
				var store = this.store;
				items = dojo.mixin(items, {
					getWindow: function() {
						return this.pw;
					},
					getPrivateEntity: function() {
						return this.ppe;
					},
					getSharedEntity: function() {
						return this.spe;
					},
					getDefinition: function() {
						return this.pd;
					},
					getPortlet: function() {
						return this.p;
					},
					getApplication: function() {
						return this.wa;
					},
					createPrivateEntity: function() {
						// summary: TODO
					},
					getPreferences: function(/*String?*/ layer) {
						// summary: Gets the preferences object for a PMPOD, which is rooted at a Window object.
						//		Allows getting preferences on various layers via the optional layer argument.
						// layer: String indicating which layer to set the preference value on.  Supports the following layers:
						//	 		"Config" - Refers to administrator preferences from Config mode
						// 			"Shared" - Refers to default shared preferences from Edit Defaults mode 
						// 			"Private" - Refers to personalized preferences from Edit, View, or Help modes.
						//		The default layer, if one isn't provided, is set to "Private" if a private entity exists.  Otherwise
						//		it's set to "Shared".
						var ppe = this.getPrivateEntity();
						if(!layer) {
							if(!ppe) layer = "Shared";
							else layer = "Private";
						}
						var item = null;
						switch(layer) {
							case "Private":
								item = ppe;
								break;
							case "Shared":
								item = this.getSharedEntity();
								break;
							case "Config":
								item = this.getDefinition();
								break;
							default: 
								item = ppe ? ppe : this.getSharedEntity();
						}
						return new com.ibm.data.resolver.PMPreferences({
							item: item,
							root: item.data,
							layer: layer,
							dataStore: store
						});
					}
				});
				var copy = items.slice();
				items.pw = copy.shift();
				items.spe = copy.shift();
				if(store.getValue(items[0], "modelNodeType") == "portlet-entity") {
					items.ppe = this._items.spe;
					items.spe = copy.shift();
				}
				items.pd = copy.shift();
				items.p = copy.shift();
				items.wa = copy.shift();
			}
			return items;
		}
	}
);

dojo.declare("com.ibm.data.resolver.PMPreferences",
	com.ibm.xml.SimpleXmlAccessor,
	{
		namespaces: com.ibm.data.resolver.ResolverQueryRules.namespaces,
		dataStore: null,
		
		constructor: function(args) {
			dojo.mixin(this, args);
		},
		getMap: function() {
			if(!this._map) {
				this._map = {};
				var prefs = this.select("./model:portletpreferences", this.root);
				if(prefs && prefs.length > 0) {
					dojo.forEach(prefs, function(prefNode){
						var name = this.attr(prefNode, "name"); 
						this._map[name] = {
							"readonly": this.attr(prefNode, "read-only"),
							"values": dojo.map(this.select("./base:value", prefNode), function(valueNode){
								return this.attr(valueNode, "value");
							}, this)
						};
					}, this);
				}
			}
			return this._map;
		},
		getNames: function() {
			var map = this.getMap();
			var names = [];
			for(var name in map) {
				names.push(name);
			}
			return names;
		},
		_getPrefNode: function(/*String*/ key) {
			if(!key) {
				throw new Error(this.dataStore.fmt("errorNullPrefsKey"));
			}
			var prefNode = this.select("./model:portletpreferences[name='" + key + "']", this.root);
			if(prefNode && prefNode.length > 0) return prefNode[0];
			return null;
		},
		isReadOnly: function(/*String*/ key) {
			var prefNode = this._getPrefNode(key);
			return prefNode && prefNode.length > 0 ? this.attr(prefNode, "read-only") == "true" : false;
		},
		reset: function(/*String*/ key) {
			var prefNode = this._getPrefNode(key);
			if(prefNode) {
				prefNode.parentNode.removeChild(prefNode);
				prefNode = null;
			}
		},
		store: function(args) {
			// summary: Store changes made to these preferences back to the server
			// args: Object specifying callbacks to be called on server response, supporting these properties:
			//		onComplete: Function called with zero arguments indicating success
			//		onError: Function called with one error object argument
			//		scope: Object scope to call the callbacks in, defaulting to the global scope
			this.dataStore.saveItems([this.item], args);
		},
		getValue: function(/*String*/ key, /*String*/ defaultValue) {
			return this.dataStore.getValue(this.item, "preferenceValue[" + key + "]$", defaultValue);
		},
		getValues: function(/*String*/ key, /*String[]*/ defaultValues) {
			return this.dataStore.getValues(this.item, "preferenceValue[" + key + "]$", defaultValues);
		},
		setValue: function(/*String*/ key, /*String*/ value) {
			this.setValues(key, [value]);
		},
		setValues: function(/*String*/ key, /*String[]*/ values) {
			if(values === undefined) values = [];
			this.dataStore.setValues(this.item, "preferenceValue[" + key + "]$", values);
			if(this._map) {
				// update the map
				if(this._map[key]) {
					this._map[key].values = values.slice();
				}
				else {
					this._map[key] = {
						"readonly": false,
						"values": values.slice()
					}
				}
			}
		}
	}
);


}

if(!dojo._hasResource["com.ibm.data.resolver.LMPocHandler"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.data.resolver.LMPocHandler"] = true;
/*
 * @author Ben
 */ 
dojo.provide("com.ibm.data.resolver.LMPocHandler");

		// for linking across handlers





dojo.declare("com.ibm.data.resolver.LMPocHandler",
	[com.ibm.data.resolver.OpenSearchPocHandler, com.ibm.data.resolver.tree.TreeModeledHandler],
	{
		category: "content",
		
		parentMgmtStrategy: "com.ibm.data.resolver.LMParentDependencyStrategy",
		
		namespaces: dojo.mixin({}, 
			com.ibm.data.resolver.OpenSearchPocHandler.prototype.namespaces,
			com.ibm.data.resolver.ResolverQueryRules.namespaces),
				
		constructor: function() {
			this._treeModels = {};
			this.customAttributes.treeModel.get = function(item, multiValued) {
				// "this" is the handler
				var id = this.getIdentity(item);
				var pageId = this._extractCompositeIds(id).pageId;
				if(!this._treeModels[pageId]) {
					this._treeModels[pageId] = new com.ibm.data.resolver.tree.PocLMTreeModel({
						pageId: pageId,
						refItem: item,
						handler: this,
						resolver: this.resolver
					});
				}
				return multiValued ? [this._treeModels[pageId]] : this._treeModels[pageId];
			};
		},
		
		_createTemplates: function() {
			var nsDecl = [];
			for(var prefix in this.namespaces) {
				nsDecl.push('xmlns:', prefix, '="', this.namespaces[prefix], '" ');
			}
			dojo.mixin(this, {
				containerTemplate: {
					templateString: 
						 '<?xml version="1.0" encoding="UTF-8"?>'
						+'<atom:feed '
							+nsDecl.join('')
							+'>'
							+'<atom:author>'
								+'<atom:name>IBM WebSphere Portal/6.1</atom:name>'
							+'</atom:author>'
							+'<atom:title>IBM WebSphere Portal Model Feed</atom:title>'
							+'<atom:link href="." rel="self" type="application/atom+xml"/>'
							+'<atom:entry>'
								+'<atom:title>${title}</atom:title>'
								+'<atom:id>${id}</atom:id>'
								+'<atom:content type="application/xml">'
									+'<model:layout-container/>'
								+'</atom:content>'
								+'<thr:in-reply-to ext:uri="${parentId}" href="${parentId}" ref="${parentId}" type="application/atom+xml"/>'
							+'</atom:entry>'
						+'</atom:feed>',
					templateProps: {
						id: "",
						title: "",
						parentId: ""
					}
				},
				
				controlTemplate: {
					templateString:
						 '<?xml version="1.0" encoding="UTF-8"?>'
						+'<atom:feed '
							+nsDecl.join('')
							+'>'
							+'<atom:author>'
								+'<atom:name>IBM WebSphere Portal/6.1</atom:name>'
							+'</atom:author>'
							+'<atom:title>IBM WebSphere Portal Model Feed</atom:title>'
							+'<atom:link href="." rel="self" type="application/atom+xml"/>'
							+'<atom:entry>'
								+'<atom:title>${title}</atom:title>'
								+'<atom:id>${id}</atom:id>'
								+'<atom:content type="application/xml">'
									+'<model:layout-control creationcontext:portlet-definition="${portletDefinitionId}">'
										+'<model:deletable>true</model:deletable>' 
						                +'<model:deletableFlag>true</model:deletableFlag>'
						                +'<model:modifiable>true</model:modifiable>' 
						                +'<model:modifiableFlag>true</model:modifiableFlag>'
									+'</model:layout-control>'
								+'</atom:content>'
								+'<thr:in-reply-to ext:uri="${parentId}" href="${parentId}" ref="${parentId}" type="application/atom+xml"/>'
							+'</atom:entry>'
						+'</atom:feed>',
					templateProps: {
						id: "",
						title: "",
						parentId: "",
						portletDefinitionId: ""
					}
				}
			});
		},
		
		processFetch: function(/*DOMDoc*/ xmlDoc, /*Request*/ request) {
			// summary: Extension point for descendants or consumers of this store to handle
			//		responses from server requests for data.  Most subclasses can leave this
			// 		function as-is, but if special handling is required that cannot be done
			// 		with other extension points, this can be overridden as well.
			// 		Must call onBegin, onItem, and onComplete callbacks correctly as 
			// 		specified by dojo.data.api.Read.  The onError callback is handled elsewhere.
			// xmlDoc: DOMDoc of the response from an IO request
			// request: Request used to fetch the result
			var composite = this.inherited(arguments);
			var id = this.engine.getByRule(composite.meta.root, this.queryRules["id"]).value;
			var compId = this._extractCompositeIds(id);
			
			composite.meta.allAllowedPortlet = this.engine.getByRule(composite.meta.root, this.bodyQueryRules["allAllowedPortlet"], true).value;
			composite.meta.allPortletsAllowed = this.engine.getByRule(composite.meta.root, this.bodyQueryRules["allPortletsAllowed"]).value;
			composite.meta.wmURI = this.engine.getByRule(composite.meta.root, this.bodyQueryRules["wmURI"]).value;
			return composite;
		},
		
		getSaveQuery: function(/*item*/ item) {
			var q = this.inherited(arguments);
			if(this.resolver.isCreated(item)) {
				// merge updates
				// empty representation.. performance-smart
				q.rep = "empty";
			}
			else {
				// lm templates store the creation URI in the title block
				q.uri = this.getLabel(item);
			}
			return q;
		},
		updateReferences: function(item) {
			this.inherited(arguments);
			var isCreated = this.resolver.isCreated(item);
			var parentId = this.getValue(item, "parentId", this.getValue(item, "title"));
			if(parentId) {
				var pageItem = this._getPage(item);
				if(pageItem) {
					var layoutId = this._extractCompositeIds(this.getIdentity(item)).layoutId,
						pageId = this._extractCompositeIds(this.resolver.getIdentity(pageItem)).pageId,
						prefix = isCreated ? "lm:oid:" : "lm:cid:";
					this.setValue(item, "id", prefix + layoutId + "@oid:" + pageId);
				}
				var parentItem = this.resolver.byId(parentId);
				if(parentItem) {
					var compParts = this._extractCompositeIds(this.resolver.getIdentity(parentItem));
					if(compParts.layoutId && compParts.layoutId != compParts.pageId) {
						this.setValue(item, "title", "lm:oid:" + compParts.layoutId + "@oid:" + compParts.pageId);
						this.setValue(item, "parentId", "lm:oid:" + compParts.layoutId + "@oid:" + compParts.pageId);
					}
					else {
						this.setValue(item, "title", "lm:oid:" + compParts.pageId + "@oid:" + compParts.pageId);
					}
				}
			}
		},
		_getPage: function(item) {
			var compId = this._extractCompositeIds(this.getIdentity(item));
			if(compId.pageId) {
				var pageItem = this.resolver.byCId("cm:cid:" + compId.pageId);
				if(!pageItem) pageItem = this.resolver.byId("cm:oid:" + compId.pageId);
				return pageItem;
			}
			return null;
		},
		_extractCompositeIds: function(/*String*/ compositeId) {
			// summary: Extracts the parts from a composite id consisting of a layout part and a page part.
			if(compositeId.indexOf("lm:") == 0) {
				var sepIndex = compositeId.indexOf("@oid:"),
					lid, pageId;
				if(sepIndex > -1) {
					lid = compositeId.substring(7, sepIndex);
					pageId = compositeId.substring(sepIndex + 5);
				}
				else {
					lid = compositeId.substr(7);
					pageId = lid;
				}
				
				return {layoutId: lid, pageId: pageId};
			}
			else if(compositeId.indexOf("cm:") == 0) {
				return {layoutId: null, pageId: compositeId.substring(compositeId.lastIndexOf(":") + 1)};
			}
			else {
				return {layoutId: null, pageId: compositeId};
			}
		},
		modifyNewItemArgs: function(args, parentInfo) {
			this.inherited(arguments);
			var compParts = this._extractCompositeIds(args.parentId);
			if(compParts.pageId) {
				args.pageId = compParts.pageId;
				args.id += "@oid:" + args.pageId;
			}
			if(compParts.layoutId && compParts.layoutId != compParts.pageId) {
				// the parent is a layout node
				args.layoutId = compParts.layoutId;
				args.title = args.parentId;
			}
			else {
				// the parent is the page itself, so we're creating a root layout node
				args.title = args.parentId;
				delete args.parentId;
			}
			
			if(args.portletDefinitionId) {
				args.portletDefinitionId = args.portletDefinitionId.replace(/\s/g, "%20");
			}
		},
		fillInProperties: function(newItem, template, keywordArgs, parentInfo) {
			if(keywordArgs.preferences && this.getValue(newItem, "modelNodeType") == "layout-control") {
				// an interesting way of doing something after an item we're creating here is created
				// on the server
				var delayDfd = new dojo.Deferred();
				this.resolver.addBeforeOnCreate(delayDfd);
				
				var conn = dojo.connect(this.resolver, "onNew", dojo.hitch(this, function(prefsMap, item, parentInfo){
					if(item == newItem) {
						this.resolver.addOnCreate(item, dojo.hitch(this, function(item){
							var windowChain = this.resolver.getValue(this.resolver.getValue(item, "portlet"), "portletWindowChain");
							windowChain.addOnLoad(dojo.hitch(this, function(chain){
								var prefs = chain.getPreferences();
								for(var key in prefsMap) {
									var val = prefsMap[key];
									prefs[dojo.isArray(val) ? "setValues" : "setValue"](key, val);
								}
								prefs.store();
							}));
						}));
						dojo.disconnect(conn);
					}
				}, keywordArgs.preferences));
			}
			delete keywordArgs.preferences;
			return this.inherited(arguments);
		},
		getTemplate: function(args, parentInfo) {
			switch(args.type) {
				case "control": 
				case "portlet":
					return this.controlTemplate;
				case "container": 
				default: 
					return this.containerTemplate;
			}
		},
		instantiateTemplate: function(template, args, parentInfo) {
			var xmlDoc = this.inherited(arguments);
			if(!args.parentId) {
				// we don't want the thr:in-reply-to element in the DOM data to send, so remove it
				this.engine.select("./thr:in-reply-to", xmlDoc).destroy();
			}
			return xmlDoc;
		},
			
		_makeModifiable: function(item) {
			// summary: Modifies the element of this item to become modifiable
			//		for writing back to the server.  Subclasses can override this
			//		to do things like prune an item to only include necessary information
			//		for updates and nothing more.  This is called by backup once after
			//		backing up the original element first.  After this returns,
			//		this item's element may have been modified.  Any queries against
			//		this item should now include logic to check the backup copy as well
			//		if a query doesn't return anything as it could have been deleted by
			//		this function.  Care should be taken to ensure that the query result
			//		specifically detects if nothing was found or if the actual value was
			//		null or an empty string.
			this.engine.select("atom:content/*/* | thr:in-reply-to | atom:link", item.data).destroy();
			
			this.inherited(arguments);
		}
	}
);

dojo.declare("com.ibm.data.resolver.LMParentDependencyStrategy",
	com.ibm.data.resolver.tree.ParentDependencyStrategy,
	{
		
		extensionsMap: dojo.mixin({}, 
			com.ibm.data.resolver.tree.ParentDependencyStrategy.prototype.extensionsMap,
			{
				"newItem": "newItem"
			}
		),
		
		newItem: function(/* Object? */ keywordArgs, /*Object?*/ parentInfo) {
			var item = this.proceed(arguments);
			var pId = this.handler.getLabel(item);
			if(pId) {
				this._changeDependencies(this.handler.getIdentity(item), pId);
			}
			return item;
		}	
	}
);

dojo.declare("com.ibm.data.resolver.LMAtomModelTreeStrategy",
	com.ibm.data.resolver.tree.AtomModelTreeStrategy,
	{
		// summary: Provides layout model specific semantics for processing
		//		fetched data chunks with regards to children and their parents
		//		due to special cases in layout model data and the handler's
		//		request processing.
		
		processFetch: function(/*DOMDoc*/ xmlDoc, /*Request*/ request) {
			var map = this.proceed(arguments);
			var compId = this.handler._extractCompositeIds(request.query.uri);
			if(compId.layoutId == compId.pageId && map.items.length > 0) {
				this.processChildren(map, "all", this.handler.getIdentity(map.items[0]));
			}
			else {
				var levels = request.query.levels;
				if(dojo.isString(levels)) levels = levels.toLowerCase();
				this.processChildren(map, levels, request.query.uri);
			}
			return map;
		}	
	}
);

(function(){
	var r = com.ibm.data.resolver, 
		lmPoc = r.LMPocHandler, 
		prot = lmPoc.prototype, 
		def = prot.definition,
		atomBase = r.ResolverQueryRules.atom;
	
	def = dojo.mixin({}, def, {
		scheme: "lm"
	});
	
	def.features = dojo.mixin({}, def.features, {
		"TreeModeled": true
	});
	
	prot.definition = def;
	
	var bodyExtRules = {
		allPortletsAllowed: {selector: "./model:allPortletsAllowed", field: "$textContent"},
		allAllowedPortlet: {selector: "./atom:link[@portal:rel='allAllowedPortlet']", field: "@portal:uri"},
		wmURI: {selector: "./atom:link[@rel='related']", field: "@href"}
	};
	
	dojo.extend(lmPoc, {
		bodyQueryRules: dojo.mixin({}, com.ibm.data.resolver.OpenSearchPocHandler.prototype.bodyQueryRules, 
			bodyExtRules),
		
		queryRules: dojo.mixin({}, r.OpenSearchPocHandler.prototype.queryRules, 
					atomBase.threadExt,
					atomBase.treeExt,
					atomBase.uniqueNameExt, 
					atomBase.modelExt, 
					atomBase.operationsExt, {
			skin: {selector: "./atom:link[@ext:rel='skin']", field: "@ext:uri", setter: 
				function(data, rule, value){
					this.createFromJson(data, {
						name: "atom:link",
						attributes: {
							"ext:rel": "skin",
							"ext:uri": value
						}
					});
					return true;
				}
			},
			skinUniqueName: {selector: "./atom:link[@ext:rel='skin']", field: "@ext:uniquename", readOnly: true},
			portlet: {selector: "./atom:link[@ext:rel='portlet']", field: "@ext:uri", type: "Item", readOnly: true},
			portletId: {selector: "./atom:link[@ext:rel='portlet']", field: "@ext:uri", readOnly: true},
			portletURI: {selector: "./atom:link[@ext:rel='portlet']", field: "@href", readOnly: true},
			portletDefinition: {selector: "./atom:link[@ext:rel='portlet-definition']", field: "@ext:uri", type: "Item", readOnly: true},
			portletDefinitionURI: {selector: "./atom:link[@ext:rel='portlet-definition']", field: "@href", readOnly: true},
			templateName: {selector: "./atom:content/*[model:templateName]/model:templateName", field: "$textContent", readOnly: true},
			modifiable: {selector: "./atom:content/*[model:modifiable]/model:modifiable", field: "$textContent"},
			modifiableFlag: {selector: "./atom:content/*[model:modifiableFlag]/model:modifiableFlag", field: "$textContent"},
			deletable: {selector: "./atom:content/*[model:deletable]/model:deletable", field: "$textContent"},
			deletableFlag: {selector: "./atom:content/*[model:deletableFlag]/model:deletableFlag", field: "$textContent"},
			containerChild: {selector: "./atom:content/*[model:containerChild]/model:containerChild", field: "$textContent", readOnly: true},
			controlChild: {selector: "./atom:content/*[model:controlChild]/model:controlChild", field: "$textContent", readOnly: true}
		}),
		
		customAttributes: dojo.mixin({}, r.OpenSearchPocHandler.prototype.customAttributes, {
			portletWindowChain: {
				get: function(item, multiValued) {
					if(this.getValue(item, "modelNodeType") != "layout-control") return null;
					if(!this.resolver.isCreated(item)) {
						// the window chain is a mockup... keep track of changes and merge on create
						
					}
					else {
						return new com.ibm.data.resolver.PMWindowChain({
							store: this.resolver,
							windowId: this.getValue(item, "portletId")
						});
					}
				},
				set: function(item, value, multiValued) {
					// can't write to this attribute as it is a composite object derived from others
					return false;
				}
			},
			allPortletsAllowed: {
				get: function(item, multiValued) {
					return dojo.getObject("_cachedMeta.requestMeta.allPortletsAllowed");
				},
				set: function(item, value, multiValued) {
					return false;
				}
			},
			allAllowedPortlet: {
				get: function(item, multiValued) {
					return dojo.getObject("_cachedMeta.requestMeta.allAllowedPortlet");
				},
				set: function(item, value, multiValued) {
					return false;
				}
			},
			wmURI: {
				get: function(item, multiValued) {
					return dojo.getObject("_cachedMeta.requestMeta.wmURI");
				},
				set: function(item, value, multiValued) {
					return false;
				}
			}
		})
	});
	
	com.ibm.strategy.Strategy.applyStrategy(lmPoc, new com.ibm.data.resolver.LMAtomModelTreeStrategy());
	
	com.ibm.data.Resolver.register(def.scheme, lmPoc);
})();

}

if(!dojo._hasResource["com.ibm.data.resolver.tree.ResolverTreePreloadingStrategy"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.data.resolver.tree.ResolverTreePreloadingStrategy"] = true;
dojo.provide("com.ibm.data.resolver.tree.ResolverTreePreloadingStrategy");



dojo.declare("com.ibm.data.resolver.tree.ResolverTreePreloadingStrategy",
	com.ibm.strategy.Strategy,
	{
		// summary: This strategy can be applied to widgets which mix in the com.ibm.widgets.TreeModeled
		//		module to provide tree-modeled data backed widget support.  This strategy is used
		//		to seed data from a preloaded TreeModeled widget back into the resolver store
		//		by assuming that the model backing the TreeModeled widget is an instance of a PocTreeModel.
		//		As with any strategy, it can be applied to a widget constructor module, effectively
		//		applying it to the prototype for all instances of that widget.
		
		// extensions: Array
		//		Array of strings indicating which functions in this strategy should be used
		//		to wrap functions of the same name in the object this strategy is applied to.
		//		Extensions cannot be named "strategyInit", "around", or "proceed", as these
		//		reserved words for strategy management.
		extensions: ["seedPreloadedData"],
		
		seedPreloadedData: function() {
			var me = this.getStrategyContext().instance;
			if(me.preloaded) {
        		var st = me.model.resolver;
        		me.item = this.propToItem(me.item, st);
				var children = dojo.mixin([], {loaded: true, preloaded: true});
				dojo.forEach(me.getChildren(), function(wij){
					wij.item = this.propToItem(wij.item, st, {parent: me.item});
					children.push(wij.item);
				}, this);
				
				st.setValues(me.item, "children", children);

				return true;
			}
			return false;
		},
		
		propToItem: function(prop, st, parentInfo) {
			if(dojo.isString(prop)) {
    			prop = dojo.fromJson(com.ibm.domUtilities.decodeXML(prop));
    		}
			if(!st.isItem(prop)) {
				prop = st.seedStore(prop, parentInfo);
			}
			return prop;
		}
	}
);

}

if(!dojo._hasResource["com.ibm.data.resolver.tree.HiddenNodesFilterStrategy"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.data.resolver.tree.HiddenNodesFilterStrategy"] = true;
/*
 * @author Ben
 */ 
dojo.provide("com.ibm.data.resolver.tree.HiddenNodesFilterStrategy");



dojo.declare("com.ibm.data.resolver.tree.HiddenNodesFilterStrategy",
	com.ibm.strategy.Strategy,
	{
		extensions: ["modifyFetchQuery", "filterChildren"],
		
		modifyFetchQuery: function(query) {
			if(!query.mdname) query.mdname = [];
			query.mdname.push("com.ibm.portal.Hidden");
			return this.proceed(arguments);
		},
		
		filterChildren: function(parentItem, items) {
			items = this.proceed(arguments);
			var me = this.getStrategyContext().instance, id = me.getIdentity(parentItem);
			var loaded = items.loaded;
			items = dojo.filter(items, function(item){
				var isHidden = this.resolver.getValue(item, "metadata[com.ibm.portal.Hidden]$", "").toLowerCase();
				if(isHidden == "yes" || isHidden == "true") {
					return false;
				}
				else return true;
			}, me);
			items.loaded = loaded;
			return items;
		}
	}
);

}

if(!dojo._hasResource["com.ibm.data.resolver.strategy.AspectsStrategy"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.data.resolver.strategy.AspectsStrategy"] = true;
/*
 * @author Ben
 */ 
dojo.provide("com.ibm.data.resolver.strategy.AspectsStrategy");



dojo.declare("com.ibm.data.resolver.strategy.AspectsStrategy",
	com.ibm.data.resolver.strategy.PocHandlerStrategy,
	{
		// summary: Advises a POC handler to modify all fetch queries
		//		targeted at the server-side handler registered at the
		//		same scheme with additional aspect parameters for
		//		requesting aspects for the fetched resources in addition
		// 		to whatever default aspects are returned from the request.
		//		It specifically uses the "aspect" query parameter.
		//		The constructor for this module takes a single argument
		//		array of strings, indicating all the aspects to be requested.
		
		extensions: ["modifyFetchQuery"],
		
		constructor: function(/*Array*/ aspects) {
			this._aspects = aspects || [];
		},
		
		modifyFetchQuery: function(query) {
			if(!query.aspect) query.aspect = [];
			query.aspect = query.aspect.concat(this._aspects);
			return this.proceed(arguments);
		}
	}
);

}

if(!dojo._hasResource["com.ibm.data.resolver.strategy.MetadataStrategy"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.ibm.data.resolver.strategy.MetadataStrategy"] = true;
/*
 * @author Ben
 */ 
dojo.provide("com.ibm.data.resolver.strategy.MetadataStrategy");



dojo.declare("com.ibm.data.resolver.strategy.MetadataStrategy",
	com.ibm.data.resolver.strategy.PocHandlerStrategy,
	{
		// summary: Advises a POC handler to modify all fetch queries
		//		targeted at the server-side handler registered at the
		//		same scheme with additional metadata parameters for
		//		requesting metadata for the fetched resources in addition
		// 		to whatever default metadata is returned from the request.
		//		It specifically uses the "mdname" query parameter.
		//		The constructor for this module takes a single argument
		//		array of strings, indicating all the metadata keys
		//		to be requested.
		
		extensions: ["modifyFetchQuery"],
		
		constructor: function(/*Array*/ keys) {
			this._keys = keys || [];
		},
		
		modifyFetchQuery: function(query) {
			if(!query.mdname) query.mdname = [];
			else if(!dojo.isArray(query.mdname)) query.mdname = [query.mdname];
			query.mdname = query.mdname.concat(this._keys);
			return this.proceed(arguments);
		}
	}
);

}


dojo.i18n._preloadLocalizations("com.nls.ibmPortalEnhancedTheme", ["ROOT","aa","aa-dj","aa-er","aa-et","af","af-za","am","am-et","ar","ar-dz","ar-jo","ar-lb","ar-ma","ar-qa","ar-sa","ar-sy","ar-tn","ar-ye","as","as-in","az","be","be-by","bg","bg-bg","bn","bn-bd","bn-in","bs","byn","byn-er","ca","ca-es","cs","cs-cz","cy","cy-gb","da","da-dk","de","de-at","de-be","de-ch","de-de","de-li","de-lu","dv","dz","dz-bt","el","el-cy","el-gr","el-polytoni","en","en-as","en-au","en-be","en-bw","en-ca","en-gb","en-gu","en-hk","en-ie","en-in","en-mh","en-mp","en-mt","en-nz","en-ph","en-pk","en-sg","en-um","en-us","en-us-posix","en-vi","en-za","en-zw","eo","es","es-ar","es-bo","es-cl","es-co","es-cr","es-do","es-ec","es-es","es-gt","es-hn","es-mx","es-ni","es-pa","es-pr","es-py","es-sv","es-us","es-uy","es-ve","et","et-ee","eu","eu-es","fa","fa-af","fi","fi-fi","fo","fo-fo","fr","fr-be","fr-ca","fr-ch","fr-lu","fur","ga","ga-ie","gez","gez-er","gez-et","gl","gl-es","gu","gu-in","gv","gv-gb","haw","haw-us","he","he-il","hi","hi-in","hr","hu","hu-hu","hy","hy-am","hy-am-revised","ia","id","id-id","is","is-is","it","it-ch","it-it","ja","ja-jp","ka","kk","kk-kz","kl","kl-gl","km","km-kh","kn","kn-in","ko","ko-kr","kok","kok-in","kw","kw-gb","ky","ln","lo","lo-la","lt","lt-lt","lv","lv-lv","mk","mk-mk","ml","ml-in","mn","mr","mr-in","ms","ms-bn","ms-my","mt","mt-mt","nb","nb-no","ne","nl","nl-be","nl-nl","nn","nn-no","om","om-et","om-ke","or","or-in","pa","pa-arab","pa-in","pl","pl-pl","ps","ps-af","pt","pt-br","pt-pt","ro","ro-ro","ru","ru-ua","rw","sa","se","sh","sh-ba","sid","sid-et","sk","sk-sk","sl","sl-si","so","so-dj","so-et","so-ke","so-so","sq","sq-al","sr","sr-ba","sr-cyrl","sr-cyrl-ba","sr-latn","sr-latn-ba","sv","sv-fi","sv-se","sw","sw-ke","sw-tz","syr","syr-sy","ta","ta-in","te","te-in","th","th-th","ti","ti-er","ti-et","tig","tig-er","tr","tt","tt-ru","uk","uk-ua","uz","uz-arab","vi","wal","wal-et","xh","xx","zh","zh-cn","zh-hans","zh-hans-cn","zh-hans-sg","zh-hant","zh-hant-hk","zh-hant-mo","zh-hant-tw","zh-hk","zh-mo","zh-sg","zh-tw","zu"]);

 
delete djConfig.baseUrl;

 

ibmPortalPortletContextMenus = {};
ibmPortalPortletContextMenuDirtyItems = [];
function ibmPortalPortletMenuSave(callback){
	ibmPortalConfig.resolver.saveItems(ibmPortalPortletContextMenuDirtyItems,{onComplete:callback,onError:callback});
	ibmPortalPortletContextMenuDirtyItems = [];
}
function ibmPortalCreatePortletMenu(id,url,arrowImg,altText,emptyMenuText,errorMsg,labelU,labelD,labelL,labelR,del){
	ibmPortalPortletContextMenus[id] = new com.ibm.widgets.LazyLoadingDropdown({
		url: com.ibm.utilities.withBaseUrl(url),
        arrowImg: arrowImg,
        btnClass: "lotusIcon lotusActionMenu",
        altText: altText,
        emptyMenuText: emptyMenuText,
		errorMsg: errorMsg,
        onOpenMenu: dojo.hitch(this,function(){ibmPortalCreatePortletMoveActions(id,labelU,labelD,labelL,labelR,del)}),
        self: "ibmPortalPortletContextMenus[id]"
    },"menu_"+id);
}
function ibmPortalMovePortlet(store,item,parentId,siblingId,domNode,oldParentDomNode,newParentDomNode,nextDomNode,sync){
	if(!store) return;

	store.setValue(item, "position", {
		parentId: parentId,
		nextId: (siblingId ? "lm:"+siblingId : null)
	});        
	oldParentDomNode.removeChild(domNode);
	newParentDomNode.insertBefore(domNode,nextDomNode);
	if(sync) com.ibm.portal.dnd.PORTLET_MEDIATOR.dndContainers[newParentDomNode.id].sync();
	ibmPortalPortletContextMenuDirtyItems.push(item);
}
function ibmPortalCreatePortletMoveActions(id,labelU,labelD,labelL,labelR,del){
	if(ibmPortalConfig.inEditMode && ibmPortalConfig.canMovePortlets){
		var me = dojo.query("[controlId~="+id+"]")[0];
		var next = me.nextSibling;
		while(next != null && !dojo.hasClass(next,"ibmPortalControlContainer")) next = next.nextSibling;
		var prev = me.previousSibling; 
		while(prev != null && !dojo.hasClass(prev,"ibmPortalControlContainer")) prev = prev.previousSibling;
		var parent = me.parentNode;
		var directions = dojo.eval("("+me.parentNode.getAttribute("directions")+")") || {};
		var orientation = me.parentNode.getAttribute("orientation");
		var suffix = "@oid:"+ibmPortalConfig.contentNodeOID;
		
		var addDirectionMenuItem = function(label,newParent,nextDom,sync){
			var menuItem = new dijit.MenuItem({
				 label: label,
				 onClick: function(){
					if (!newParent) {
						return;
					}
					var nextSibling = nextDom ? nextDom.getAttribute("controlId")+suffix : null;
					var store = ibmPortalConfig.resolver;
					var item = store.byId("lm:"+id+suffix);
					var setAttributes = dojo.hitch(this,function(item){
						ibmPortalMovePortlet(store,item,"lm:"+newParent.id+suffix,nextSibling,me,parent,newParent,nextDom,sync);
					});
					if(store.isItemLoaded(item)){
						setAttributes(item);
					} else {
						store.loadItem({
							item: item,
							onItem: setAttributes
						});
					}
				 }
			});
			ibmPortalPortletContextMenus[id].insertChild(menuItem,true);
		}
		
		if(ibmPortalConfig.isRTL){
			var temp = labelL;
			labelL = labelR;
			labelR = temp;
		}
		
		if(prev){
			var label = (orientation == "V") ? labelU : labelL;
			addDirectionMenuItem(label,parent,prev,false);
		}
		if(next){
			var label = (orientation == "V") ? labelD : labelR;
			var nextNext = next.nextSibling;
			while(nextNext != null && !dojo.hasClass(nextNext,"ibmPortalControlContainer")) nextNext = nextNext.nextSibling;
			addDirectionMenuItem(label,parent,nextNext,false);
		}
		if(directions.up && (!prev || orientation == "H")){
			var container = dojo.query("[ordinal~="+directions.up+"]")[0];
			addDirectionMenuItem(labelU,container,null,true);
		}
		if (directions.down && (!next || orientation == "H")){
			var container = dojo.query("[ordinal~="+directions.down+"]")[0];
			addDirectionMenuItem(labelD,container,null,true);
		}
		if(directions.left && (!prev || orientation == "V")){
			var container = dojo.query("[ordinal~="+directions.left+"]")[0];
			addDirectionMenuItem(labelL,container,null,true);
		}
		if (directions.right && (!next || orientation == "V")){
			var container = dojo.query("[ordinal~="+directions.right+"]")[0];
			addDirectionMenuItem(labelR,container,null,true);
		}
		var deleteItem = new dijit.MenuItem({
			 label: del,
			 onClick: function(){
				var store = ibmPortalConfig.resolver;
				var item = store.byId("lm:"+id+suffix);
				store.deleteItem(item);
				me.parentNode.removeChild(me);
				
				//start changes for PM23202
				//clear any items with the same ID before pushing the new one:
				for(var i = 0; i < ibmPortalPortletContextMenuDirtyItems.length; i++) {
				   if(ibmPortalPortletContextMenuDirtyItems[i].id == item.id) {
					     ibmPortalPortletContextMenuDirtyItems.splice(i--, 1);
				   }
				}
				//End Changes for PM23202
				
				ibmPortalPortletContextMenuDirtyItems.push(item);
				ibmPortalMovePortlet();
			 }
		});
		ibmPortalPortletContextMenus[id].insertChild(deleteItem,true);
	}
}
function ibmPortalCreateThinSkinHoverIE6(id){
	var control = dojo.byId("control_"+id);
	var titlebar = dojo.byId("titlebar_"+id);
	control.onmouseover = function(){ titlebar.className = "wpsThinSkinVisible" };
	control.onmouseout = function(){ titlebar.className = "wpsThinSkinInvisible" };
}
function ibmPortalCreateAccessiblePortletMenu(id){
	
	var titlebar = dojo.byId("titlebar_"+id);
	var skipLink = dojo.byId("skipportlet."+id);
	
	skipLink.onfocus = function(){ titlebar.className = "wpsThinSkinVisible" };
}

function themeInit() {

}
/* Initialize resolver model store */
function initializeResolverStore(){
	com.ibm.strategy.Strategy.applyStrategy(com.ibm.widgets.NavigationWidget, new com.ibm.data.resolver.tree.ResolverTreePreloadingStrategy());
	var res = ibmPortalConfig.resolver = com.ibm.data.Resolver.getStore({
		url: ibmPortalConfig.contentHandlerURI,
		namespaces: { 
			"ext": "http://www.ibm.com/xmlns/prod/websphere/portal/v6.0.1/portal-model", 
			"creationcontext": "http://www.ibm.com/xmlns/prod/websphere/portal/v6.1.0/portal-creation-context", 
			"base": "http://www.ibm.com/xmlns/prod/websphere/portal/v6.0/ibm-portal-composite-base", 
			"model": "http://www.ibm.com/xmlns/prod/websphere/portal/v6.0.1/portal-model-elements" 
		},
		tunnel: ibmPortalConfig.xMethodOverride
	});
	res.applyHandlerStrategy("cm", new com.ibm.data.resolver.strategy.AspectsStrategy(["ac"]));
	res.applyHandlerStrategy("nm", new com.ibm.data.resolver.strategy.AspectsStrategy(["ac"]));
	res.applyHandlerStrategy("cm", new com.ibm.data.resolver.tree.HiddenNodesFilterStrategy());
	res.applyHandlerStrategy("nm", new com.ibm.data.resolver.tree.HiddenNodesFilterStrategy());
	ibmPortalConfig.currentPage = res.byId("nm:oid:" + ibmPortalConfig.currentPageOID);
	ibmPortalConfig.navModel = res.getValue(ibmPortalConfig.currentPage, "treeModel");
	ibmPortalConfig.navModel.newItem = function(args, parent) {
		var cArgs = {
			pocType: "cm",
			type: "page",
			title: args.title,
			metadata: {
				"layout": ibmPortalConfig.defaultPageLayout,
				"com.ibm.portal.remote-cache-expiry": ibmPortalConfig.defaultPageCache
			}
		};
		if(args.friendlyURL) cArgs.metadata["com.ibm.portal.friendly.name"] = args.friendlyURL;
		if(args["private"] == true || args["private"] == "on") cArgs.isPrivate = true;
		parent = this.resolver.byId("cm" + this.getIdentity(parent).substr(2));
		var newPage = this.resolver.newItem(cArgs, {parent: parent});
		var layoutRoot = this.resolver.newItem({
			pocType: "lm",
			type: "container"
		}, {parent: newPage});
		var lastLayoutContainer, pendingItems = [newPage, layoutRoot];
		for(var i=0; i<ibmPortalConfig.defaultPageLayoutContainers; i++) {
			lastLayoutContainer = this.resolver.newItem({
				pocType: "lm",
				type: "container"
			}, {parent: layoutRoot});
			pendingItems.push(lastLayoutContainer);
		}
		this.resolver.addOnCreate(lastLayoutContainer, function() {
			if(args.onComplete) args.onComplete.call(args.scope ? args.scope : dojo.global);
			if(ibmPortalConfig.autoNavigateToNewPages) ibmPortalConfig.selectionModel.changeSelection(newPage);
		});
		this.resolver.saveItems(pendingItems,{});
		return newPage;
	};
}
function initializeSelectionPath(selectionPath) {
	ibmPortalConfig.selectionPath = selectionPath.reverse();
	ibmPortalConfig.selectionModel = new com.ibm.data.SelectionModel({treeModel:ibmPortalConfig.navModel,selectionPath:selectionPath,
		changeSelection: function(newSelection) {
			if(newSelection) {
				var url = com.ibm.utilities.baseUrl();
				top.location.assign(url + "?uri=" + this.treeModel.getIdentity(newSelection));
			}
		}
	});
	ibmPortalConfig.contentNodeOID = ibmPortalConfig.resolver.getValue(ibmPortalConfig.currentPage, "contentNodeId", "").substr(7);
}
function ibmPortalSetupBreadcrumbs() {
	var breadcrumb = new com.ibm.widgets.Breadcrumbs({
		model: ibmPortalConfig.selectionModel,
		startLevel: ibmPortalConfig.isApplication ? 3 : 2,
		renderSiblings: false,
		siblingSeparator: "",
		allowNew: false,
		listDOM: "span",
		itemDOM: "span",
		listClass: "lotusBreadcrumbs",
		containerClass: "ibmPortalBreadcrumbs lotusLeft"
	}, "navSelectionCrumbs");
	breadcrumb.startup();
}
/* Customize shelf initialization */
/*2010 10 06 Sue*/
function ibmPortalSetupCustomizeShelf (kind){
	var cNode = ibmPortalConfig.resolver.getValue(ibmPortalConfig.currentPage, "contentNode");
	dojo.extend(com.ibm.customize.AddContentPaletteContainer, com.ibm.customize.AddContentController); /* extension added here so a different extension can be added in Mashup pages */
	dojo.extend(com.ibm.customize.ChangeStylePaletteContainer, com.ibm.customize.ChangeStyleController); /* extension added here so a different extension can be added in Mashup pages */
	var customizeTabs = [], addContent, changeStyle, changeLayout;

	if(strLangImgPath == "kor") {
		var addContentJSON = ibmPortalConfig.isWcmPresent ? ibmPortalConfig.themeRootURI + "/system/addContent_wcm.json":ibmPortalConfig.themeRootURI + "/system/kor/addContent.json" ;
		if(kind=="PF"){
			addContentJSON = ibmPortalConfig.isWcmPresent ? ibmPortalConfig.themeRootURI + "/system/addContent_wcm.json":ibmPortalConfig.themeRootURI + "/system/kor/addContentPF.json" ;
		}else if(kind=="ST"|| kind=="GD"){
			addContentJSON = ibmPortalConfig.isWcmPresent ? ibmPortalConfig.themeRootURI + "/system/addContent_wcm.json":ibmPortalConfig.themeRootURI + "/system/kor/addContentST.json" ;
		}else if(kind=="EM"){
			addContentJSON = ibmPortalConfig.isWcmPresent ? ibmPortalConfig.themeRootURI + "/system/addContent_wcm.json":ibmPortalConfig.themeRootURI + "/system/kor/addContentEM.json" ;
		}
	} else {
		var addContentJSON = ibmPortalConfig.isWcmPresent ? ibmPortalConfig.themeRootURI + "/system/addContent_wcm.json":ibmPortalConfig.themeRootURI + "/system/eng/addContent.json" ;
		if(kind=="PF"){
			addContentJSON = ibmPortalConfig.isWcmPresent ? ibmPortalConfig.themeRootURI + "/system/addContent_wcm.json":ibmPortalConfig.themeRootURI + "/system/eng/addContentPF.json" ;
		}else if(kind=="ST"|| kind=="GD"){
			addContentJSON = ibmPortalConfig.isWcmPresent ? ibmPortalConfig.themeRootURI + "/system/addContent_wcm.json":ibmPortalConfig.themeRootURI + "/system/eng/addContentST.json" ;
		}else if(kind=="EM"){
			addContentJSON = ibmPortalConfig.isWcmPresent ? ibmPortalConfig.themeRootURI + "/system/addContent_wcm.json":ibmPortalConfig.themeRootURI + "/system/eng/addContentEM.json" ;
		}
	}

	if (!ibmPortalConfig.isStatic && !ibmPortalConfig.isPortletMaximized && ibmPortalConfig.hasEditorRoleOnContentNode) {
		addContent = new com.ibm.customize.AddContentPaletteContainer({store:ibmPortalConfig.resolver,item:cNode,maxLabelLength:20,iconInfo:ibmPortalConfig.themeRootURI+"/css/images/iconInfo.gif",smallWidget:true,legacy:!ibmPortalConfig.hasPageLayout,pageId:ibmPortalConfig.contentNodeOID,jsonFile:addContentJSON,imagePath:ibmPortalConfig.themeRootURI+"/css/images"},document.createElement("div"));
		changeStyle = new com.ibm.customize.ChangeStylePaletteContainer({store:ibmPortalConfig.resolver,item:cNode,baseCssPath:ibmPortalConfig.themeRootURI+"/css/",imagePath: ibmPortalConfig.themeRootURI+"/css/images",set:ibmPortalConfig.colorPalette,jsonFile:ibmPortalConfig.themeRootURI+"/system/changeStyle.json"},document.createElement("div"));
		changeLayout = new com.ibm.customize.ChangeLayoutPaletteContainer({store:ibmPortalConfig.resolver,item:cNode,imagePath: ibmPortalConfig.themeRootURI+"/css/images",set:ibmPortalConfig.currentPageLayout,jsonFile:ibmPortalConfig.themeRootURI+"/system/changeLayout.json"},document.createElement("div"));
		customizeTabs = [{controller:addContent},{controller:changeStyle},{controller:changeLayout}];
	} else if (!ibmPortalConfig.isStatic && !ibmPortalConfig.isPortletMaximized && !ibmPortalConfig.hasEditorRoleOnContentNode && ibmPortalConfig.hasPrivRoleOnContentNode && ibmPortalConfig.hasPageLayout) {
		addContent = new com.ibm.customize.AddContentPaletteContainer({store:ibmPortalConfig.resolver,item:cNode,maxLabelLength:20,iconInfo:ibmPortalConfig.themeRootURI+"/css/images/iconInfo.gif",smallWidget:true,legacy:!ibmPortalConfig.hasPageLayout,pageId:ibmPortalConfig.contentNodeOID,jsonFile:addContentJSON,imagePath:ibmPortalConfig.themeRootURI+"/css/images"},document.createElement("div"));
		customizeTabs = [{controller:addContent}];
	} else if (ibmPortalConfig.isPortletMaximized || (ibmPortalConfig.isStatic && ibmPortalConfig.hasEditorRoleOnContentNode)){
		changeStyle = new com.ibm.customize.ChangeStylePaletteContainer({store:ibmPortalConfig.resolver,item:cNode,baseCssPath:ibmPortalConfig.themeRootURI+"/css/",imagePath: ibmPortalConfig.themeRootURI+"/css/images",set:ibmPortalConfig.colorPalette,jsonFile:ibmPortalConfig.themeRootURI+"/system/changeStyle.json"},document.createElement("div"));
		customizeTabs = [{controller:changeStyle}];
	}

	//console.log("customizeTabs:\n" + customizeTabs);

	if(customizeTabs.length > 0) {
		var tabbedController = new com.ibm.customize.TabbedController({
			imagePath: ibmPortalConfig.themeRootURI+"/css/images",
			pageId:ibmPortalConfig.contentNodeOID,
			children:customizeTabs,
			link:"customizeShelfButton",
			onFirstOpen: function(){
				this.fillTabs();
			}
		},"ibmPortalCustomizeShelf");
		// ------------------------------------------------------------------------------------
		//  by cbh
		//document.all.ibmPortalCustomizeShelf.style.display = "none";
		//document.all.layoutContainers.style.display = "none";
		// ------------------------------------------------------------------------------------
		 tabbedController.connectButton();
		 ibmPortalConfig.savePageManager.register({save:dojo.hitch(this,function(c){tabbedController.portalSave(c)}),beforeSave:dojo.hitch(this,function(c){tabbedController.portalBeforeSave(c)}),dirty:"makeDirty",scope:tabbedController});
	}
}
/* Share menu initialization */
function ibmPortalCreateShareMenu(args){
	if(!ibmPortalConfig.isApplication){
		dojo.require("com.ibm.widgets.LazyLoadingDropdown");
		var menu = new com.ibm.widgets.LazyLoadingDropdown({
			label: ibmPortalConfig.uiStrings.theme_share,
			arrowImg: ibmPortalConfig.themeRootURI+"/css/images/btnDropDown2.png",
			btnClass: "lotusBtn",
			emptyMenuText:ibmPortalConfig.uiStrings.emptyMenuText,
			errorMsg: ibmPortalConfig.uiStrings.errorMsg
		},"ibmPortalSharePageMenu");
		if (ibmPortalConfig.canShare){
			var share = new dijit.MenuItem({
				 label: ibmPortalConfig.uiStrings.theme_share_page,
				 onClick: function(){
					function sharePage() {
						var es = com.ibm.mashups.iwidget.services.ServiceManager.getService(com.ibm.mashups.iwidget.services.EventService.SERVICE_NAME);
						var dialogParam = {
							hasRightBottomResizer: false,
							nodeWidth: "774px",
							title: ibmPortalConfig.uiStrings.theme_share_page
						};
						var payload = {
							widgetTypeId: "sharePage",
							eventName:  "com.ibm.mashups.builder.sharePage",
							eventPayload:  ibmPortalConfig.currentPageOID,
							dialogParam:  dialogParam,
							requestRefresh: true
						};
						es.broadcastEvent("com.ibm.mashups.builder.displayInMashupDialog",payload);
						if(!ibmPortalConfig.isShareStrategySet){
							com.ibm.strategy.Strategy.applyStrategy(com.ibm.mm.builder.accessControl, new com.ibm.strategy.ShareNotificationStrategy(function(newNode) {
								window.location.replace(top.location.href);
							}));
						}
					}
					ibmPortalConfig.savePageManager.leavePage(sharePage);
				}
			});
			menu.insertChild(share);
		}
		var disableAddSharedPages = false;
		try {disableAddSharedPages = com.ibm.mashups.enabler.model.Factory.getNavigationModel().findDefaultAcceptParent() == null;}
		catch(err) {/*console.error(err);*/setTimeout(function(){throw err;}, 1);}
		var more = new dijit.MenuItem({
			disabled: disableAddSharedPages,
			 "label": ibmPortalConfig.uiStrings.theme_add_pages_shared,
			 onClick: function(){	
			var es = com.ibm.mashups.iwidget.services.ServiceManager.getService(com.ibm.mashups.iwidget.services.EventService.SERVICE_NAME);
			var dialogParam = {
				nodeWidth: "600px",
				containerBackgroundColor: "white",
				hasLeftBottomResizer: false,
				hasRightBottomResizer: false,
				title: ibmPortalConfig.uiStrings.theme_add_pages_shared
			};
			var payload = {
				widgetTypeId: "viewMorePage",
				eventName:  "com.ibm.mashups.builder.viewMorePage",
				eventPayload:  "",
				dialogParam:  dialogParam,
				requestRefresh: true 
			};
			es.broadcastEvent("com.ibm.mashups.builder.displayInMashupDialog",payload);
			if(!ibmPortalConfig.isPageAddedStrategySet){
				com.ibm.strategy.Strategy.applyStrategy(com.ibm.mm.builder.viewMorePage, new com.ibm.strategy.PageAddedNotificationStrategy(null, function() {
					dijit.byId("navTabs").reload();
				}));
				ibmPortalConfig.isPageAddedStrategySet = true;
			}
		}
	});
	menu.insertChild(more);
	}
}
/* MORE ACTIONS PAGE MENU initialization*/
function ibmPortalCreatePageMenu(){
	dojo.require("com.ibm.widgets.LazyLoadingDropdown");
	new com.ibm.widgets.LazyLoadingDropdown({
		 label: ibmPortalConfig.uiStrings.theme_more_actions,
		 url: com.ibm.utilities.withBaseUrl(ibmPortalConfig.moreActionsUrl),
		 arrowImg: ibmPortalConfig.themeRootURI+"/css/images/btnDropDown2.png",
		 btnClass: "lotusBtn",
		 emptyMenuText: ibmPortalConfig.uiStrings.emptyMenuText,
		errorMsg: ibmPortalConfig.uiStrings.errorMsg
	},"ibmPortalPageMenuButton");
}
/* STATUSBAR initialization */	
function ibmPortalSetupStatusBar(clear,print,showDetails,hideDetails,warning,error,info,statusError,messagesAvailable,itemsAvailable) {
	var v3themeProperties = { 
		"clear": clear, 
		"print": print,
		"showDetails": showDetails, 
		"hideDetails": hideDetails,
		"warning": warning, 
		"error": error,
		"info": info, 
		"statusError": statusError,
		"messagesAvailable": messagesAvailable, 
		"itemsAvailable": itemsAvailable
	};
	dojo._loadedModules["com.ibm.portal.nls.v3theme"] = {"ROOT": v3themeProperties, "${wp.preferredLocale}": v3themeProperties };
	var statusBar = new com.ibm.widgets.StatusBar({
		uid: "ibmPortalStatusBox",
		locale: ibmPortalConfig.locale,
		errorGifPath: ibmPortalConfig.themeRootURI+"/images/statusBar/error.gif",
		warningGifPath: ibmPortalConfig.themeRootURI+"/images/statusBar/warning.gif",
		infoGifPath: ibmPortalConfig.themeRootURI+"/images/statusBar/info.gif",
        multipleMessagesGifPath: ibmPortalConfig.themeRootURI+"/images/statusBar/info.gif"
	},"ibmPortalStatusBarContainer");
	statusBar.startup();
}
/* SAVE PAGE MANAGER initialization */
function ibmPortalCreateSavePageManager(){
	dojo.require("com.ibm.customize.SavePageManager");
	ibmPortalConfig.savePageManager = new com.ibm.customize.SavePageManager({},"savePageButton");
	ibmPortalConfig.savePageManager.register({save:dojo.hitch(this,function(c){ibmPortalConfig.navModel.save({onComplete: c, onError: function(saveList){
		dojo.forEach(saveList.getErrors(), function(error) {
            var message = error.name;
            var details = error.message;
            var statusMessage = new com.ibm.widgets.StatusMessage("error", message, details);
            dojo.publish("/portal/status", [{message: statusMessage, uid: 'ibmPortalStatusBox'}]);
        });
        c();
    }})}),dirty:"pasteItem",scope:ibmPortalConfig.navModel});
}
/* set authentication handler for ESM and session timeout handling */
com.ibm.ajax.auth.setAuthenticationHandler( function () { 
    //console.debug( "Illegal response content-type detected or Portal 401 !" );
	var fullPageRefreshURL = ibmPortalConfig.portalContext +"/mypoc/!ut/p/cm/oid:" + ibmPortalConfig.currentPageOID+"?mode=view";
		
	//Fire the redirect event so any necessary clean up can occur.
	com.ibm.portal.EVENT_BROKER.redirect.fire( { url: fullPageRefreshURL } ); 
	top.location.href = fullPageRefreshURL;
});
/* begin MODE TOGGLE code */
function ibmPortalToggleMode(){
	var bundle = dojo.i18n.getLocalization("com.ibm.bundles", "Theme");
	var icon = dojo.byId("ibmPortalModeToggle");
	var customizeBar = dojo.byId("ibmPortalCustomizeBar");
	var layoutContainers = com.ibm.portal.dnd.PORTLET_MEDIATOR.dndContainers;
	var tabContainer = dijit.byId("navTabs");

	//-- image width ( ) Start
	var btnPortalWidth = "";

	if(strLangImgPath == "eng") {
		btnPortalWidth = "103px";
	}
	else {
		btnPortalWidth = "74px";
	}
	//-- image width ( ) End

	if (ibmPortalConfig.inEditMode){
		ibmPortalGoToViewMode(icon,customizeBar,layoutContainers,tabContainer,bundle["theme_go_to_edit"]);

		//2010 09 15 Sue
		document.getElementById("edit_text_id").innerHTML= '<img src="/wps/images/kut/' + strLangImgPath + '/pt/btn_ptexpand.gif " width="' + btnPortalWidth + '" style="padding:0 0 0 2px;" height="20"  alt="\ud3ec\ud0c8\uc124\uc815"/>';
	} else {
		ibmPortalGoToEditMode(icon,customizeBar,layoutContainers,tabContainer,bundle["theme_go_to_view"]);
		//2010 09 15 Sue
		document.getElementById("edit_text_id").innerHTML = '<img src="/wps/images/kut/' + strLangImgPath + '/pt/btn_ptcollapse.gif "  width="' + btnPortalWidth + '" style="padding:0 0 0 2px;" height="20" alt="\uc124\uc815\uc885\ub8cc"/>';
	}
}
dojo.require("dojo.io.script");
function ibmPortalGoToEditMode(icon,customizeBar,layoutContainers,tabContainer,goToView){
	if(!ibmPortalConfig.editModeInitialized){
		dojo.addClass(dojo.body(), "ibmPortalEditModeLoading");
		com.ibm.portal.dnd.PORTLET_MEDIATOR.init();
		
		//console.log("step 1");

		dojo.io.iframe.send({ 
			handleAs: "javascript", 
			url: com.ibm.utilities.withBaseUrl(ibmPortalConfig.mmiLogicUrl), 
			method: "GET", 
			load: function(res) {
				// open and close the iframe document to force the browser to
				// think it has stopped loading, which it has
						//console.log("step 2");
				try {
					// Firefox fix to prevent constant loading.
					dojo.io.iframe._frame.contentDocument.open();
					dojo.io.iframe._frame.contentDocument.close();
				} catch (catchthis) {
					// IE fix as it ignores the try.
				}
						//console.log("step 3");
                var auth=dojo.getObject("com.ibm.ajax.auth");
                if(ibmConfig.user=='null' && auth) {
							//console.log("step 4 in if");
                    auth.authenticationHandler();
                    return;                
                }
				dojo.io.script.get({
					checkString: "mmiLoaded",
					url: ibmPortalConfig.themeRootURI + "/js/mmi_js.jsp",
					handle: function(response) {
								//console.log("step 5");
						dojo.io.script.get({
							checkString: "ibm.stateManager",
							url: "/mmtheme/themes/html/MashupTheme/js.jsp",
							handle: function(response) {
										//console.log("step 6");
								initExtensionRegistry();
								livetextService.init();
								if(!ibmPortalConfig.isMinimalTheme) {
									if(ibmPortalConfig.canCustomize) ibmPortalSetupCustomizeShelf(UserKind);/* enable customize shelf */
									//if(ibmPortalConfig.canCustomize) ibmPortalSetupCustomizeShelf();/* enable customize shelf */ 
									ibmPortalCreateShareMenu();/* enable share menu */
									ibmPortalCreatePageMenu();/* enable page menu */
									
								}
								dojo.removeClass(dojo.body(), "ibmPortalEditModeLoading");
								postEditModeBootstrap(icon,tabContainer,customizeBar,goToView);
								//console.log("step 8");
							}
						});
						//console.log("step 9");
					}
				});
				//console.log("step 10");
			},
			error: function(err) {
				/*console.error(err);*/
				dojo.removeClass(dojo.body(), "ibmPortalEditModeLoading");
				postEditModeBootstrap(icon,tabContainer,customizeBar,goToView);
			}
		});
		ibmPortalConfig.editModeInitialized = true;
		//console.log("step 12");
	} else {
		for(var i in layoutContainers) layoutContainers[i].isSource = true;
		postEditModeBootstrap(icon,tabContainer,customizeBar,goToView);
	}
}
function initExtensionRegistry() { /* this was in mmi_js, but it wasn't getting called in the handle fn above from there, so its here for now. */
	var enablerCfg = ibmConfig;
	if ( enablerCfg && enablerCfg.extensions && enablerCfg.extensions.length > 0 ) {
		var configVar = {};
		function forInLoop ( obj, work ) {
			for ( prop in obj ) {
				if ( obj.hasOwnProperty( prop ) ) {
					work( prop, obj[prop] );
				}	
			}	
		}
		for ( var i = 0; i < enablerCfg.extensions.length; i++ ) {
			forInLoop( enablerCfg.extensions[i], function ( name, value ) {
				configVar[name] = value;
			});
		}
		var mappingFn = enablerCfg[ "mappingFunction" ]; 
		var extReg = new ExtensionRegistry( mappingFn );
		extReg.process( enablerCfg.extensions );
	}
}
function postEditModeBootstrap(icon,tabContainer,customizeBar,goToView) {
	dojo.fx.wipeIn({node:customizeBar}).play();
	icon.src = "./icons/Accept.gif";
	icon.title = icon.firstChild.innerHTML = goToView;
	dojo.addClass(dojo.body(),"ibmPortalEditMode");
    // ------------------------------------------------------------------------------------
	//  by cbh
	if(tabContainer != "undefined") {
		tabContainer.setupDnd();
	} else {
		alert("undefined");
	}
	// ------------------------------------------------------------------------------------
	ibmPortalConfig.savePageManager.register({save:com.ibm.portal.dnd.PORTLET_MEDIATOR.saveMoves,dirty:"sendMoveRequest",scope:com.ibm.portal.dnd.PORTLET_MEDIATOR});
	ibmPortalConfig.savePageManager.register({save:ibmPortalPortletMenuSave,dirty:"ibmPortalMovePortlet"});
   ibmPortalConfig.inEditMode = true;
}
function ibmPortalGoToViewMode(icon,customizeBar,layoutContainers,tabContainer,goToEdit){
	var go = dojo.hitch(this,function(){
		dojo.removeClass(document.getElementsByTagName('body')[0],"ibmPortalEditMode");
		var customizeShelf = dijit.byId("ibmPortalCustomizeShelf");
		if(customizeShelf && customizeShelf.displayState == "open") customizeShelf.toggleDisplay();
		dojo.fx.wipeOut({node:customizeBar}).play();
		icon.src = "./icons/Edit.gif";
		icon.title = icon.firstChild.innerHTML = goToEdit;
		for(var i in layoutContainers) layoutContainers[i].isSource = false;
		tabContainer.disableDnd();
		ibmPortalConfig.inEditMode = false;
	});
	ibmPortalConfig.savePageManager.leavePage(go,true);
}
/* end MODE TOGGLE code */
/* Toggle edit mode for pages with no portlets */
function newPageLoadEdit() {
	if(ibmPortalConfig.hasPageLayout && dojo.query('.ibmPortalControlContainer', dojo.byId('layoutContainers')).length == 0) {
		//ibmPortalToggleMode();
		/**     2010 10 06**/
	}
}
if (!ibmPortalConfig.isMinimalTheme && ibmPortalConfig.canEditPage) {
	dojo.addOnLoad(function(){
		var timeout = 100;
		if (dojo.isIE){ timeout = 3000; }
		setTimeout("newPageLoadEdit()", timeout);
	});
}
,H!<Ez      UHUH;/"UO)W   K:http://portal.koreatech.ac.kr/EnhancedTheme/themes/html/Enhanced/js/js.jsp necko:classified 1 request-method GET response-head HTTP/1.1 200 OK
Date: Tue, 05 May 2015 09:48:07 GMT
Server: IBM_HTTP_Server
Cache-Control: public, max-age=432000, post-check=172000, max-age=3600
Expires: Tue, 05 May 2015 10:48:07 GMT
Content-Type: text/javascript;charset=ISO-8859-1
Content-Language: en-US
 uncompressed-len 0  ;